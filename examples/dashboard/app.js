(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Adapted from https://github.com/Flet/prettier-bytes/
// Changing 1000 bytes to 1024, so we can keep uppercase KB vs kB
// ISC License (c) Dan Flettre https://github.com/Flet/prettier-bytes/blob/master/LICENSE
module.exports = function prettierBytes (num) {
  if (typeof num !== 'number' || isNaN(num)) {
    throw new TypeError('Expected a number, got ' + typeof num)
  }

  var neg = num < 0
  var units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']

  if (neg) {
    num = -num
  }

  if (num < 1) {
    return (neg ? '-' : '') + num + ' B'
  }

  var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1)
  num = Number(num / Math.pow(1024, exponent))
  var unit = units[exponent]

  if (num >= 10 || num % 1 === 0) {
    // Do not show decimals when the number is two-digit, or if the number has no
    // decimal component.
    return (neg ? '-' : '') + num.toFixed(0) + ' ' + unit
  } else {
    return (neg ? '-' : '') + num.toFixed(1) + ' ' + unit
  }
}

},{}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],3:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":2,"buffer":3,"ieee754":7}],4:[function(require,module,exports){
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],5:[function(require,module,exports){
/*!
 * Cropper.js v1.5.7
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2020-05-23T05:23:00.081Z
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Cropper = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
  var WINDOW = IS_BROWSER ? window : {};
  var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;
  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
  var NAMESPACE = 'cropper'; // Actions

  var ACTION_ALL = 'all';
  var ACTION_CROP = 'crop';
  var ACTION_MOVE = 'move';
  var ACTION_ZOOM = 'zoom';
  var ACTION_EAST = 'e';
  var ACTION_WEST = 'w';
  var ACTION_SOUTH = 's';
  var ACTION_NORTH = 'n';
  var ACTION_NORTH_EAST = 'ne';
  var ACTION_NORTH_WEST = 'nw';
  var ACTION_SOUTH_EAST = 'se';
  var ACTION_SOUTH_WEST = 'sw'; // Classes

  var CLASS_CROP = "".concat(NAMESPACE, "-crop");
  var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
  var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
  var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
  var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
  var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
  var CLASS_MOVE = "".concat(NAMESPACE, "-move"); // Data keys

  var DATA_ACTION = "".concat(NAMESPACE, "Action");
  var DATA_PREVIEW = "".concat(NAMESPACE, "Preview"); // Drag modes

  var DRAG_MODE_CROP = 'crop';
  var DRAG_MODE_MOVE = 'move';
  var DRAG_MODE_NONE = 'none'; // Events

  var EVENT_CROP = 'crop';
  var EVENT_CROP_END = 'cropend';
  var EVENT_CROP_MOVE = 'cropmove';
  var EVENT_CROP_START = 'cropstart';
  var EVENT_DBLCLICK = 'dblclick';
  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
  var EVENT_READY = 'ready';
  var EVENT_RESIZE = 'resize';
  var EVENT_WHEEL = 'wheel';
  var EVENT_ZOOM = 'zoom'; // Mime types

  var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps

  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
  var REGEXP_DATA_URL = /^data:/;
  var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
  var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc

  var DEFAULTS = {
    // Define the view mode of the cropper
    viewMode: 0,
    // 0, 1, 2, 3
    // Define the dragging mode of the cropper
    dragMode: DRAG_MODE_CROP,
    // 'crop', 'move' or 'none'
    // Define the initial aspect ratio of the crop box
    initialAspectRatio: NaN,
    // Define the aspect ratio of the crop box
    aspectRatio: NaN,
    // An object with the previous cropping result data
    data: null,
    // A selector for adding extra containers to preview
    preview: '',
    // Re-render the cropper when resize the window
    responsive: true,
    // Restore the cropped area after resize the window
    restore: true,
    // Check if the current image is a cross-origin image
    checkCrossOrigin: true,
    // Check the current image's Exif Orientation information
    checkOrientation: true,
    // Show the black modal
    modal: true,
    // Show the dashed lines for guiding
    guides: true,
    // Show the center indicator for guiding
    center: true,
    // Show the white modal to highlight the crop box
    highlight: true,
    // Show the grid background
    background: true,
    // Enable to crop the image automatically when initialize
    autoCrop: true,
    // Define the percentage of automatic cropping area when initializes
    autoCropArea: 0.8,
    // Enable to move the image
    movable: true,
    // Enable to rotate the image
    rotatable: true,
    // Enable to scale the image
    scalable: true,
    // Enable to zoom the image
    zoomable: true,
    // Enable to zoom the image by dragging touch
    zoomOnTouch: true,
    // Enable to zoom the image by wheeling mouse
    zoomOnWheel: true,
    // Define zoom ratio when zoom the image by wheeling mouse
    wheelZoomRatio: 0.1,
    // Enable to move the crop box
    cropBoxMovable: true,
    // Enable to resize the crop box
    cropBoxResizable: true,
    // Toggle drag mode between "crop" and "move" when click twice on the cropper
    toggleDragModeOnDblclick: true,
    // Size limitation
    minCanvasWidth: 0,
    minCanvasHeight: 0,
    minCropBoxWidth: 0,
    minCropBoxHeight: 0,
    minContainerWidth: 200,
    minContainerHeight: 100,
    // Shortcuts of events
    ready: null,
    cropstart: null,
    cropmove: null,
    cropend: null,
    crop: null,
    zoom: null
  };

  var TEMPLATE = '<div class="cropper-container" touch-action="none">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-cropper-action="e"></span>' + '<span class="cropper-line line-n" data-cropper-action="n"></span>' + '<span class="cropper-line line-w" data-cropper-action="w"></span>' + '<span class="cropper-line line-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-e" data-cropper-action="e"></span>' + '<span class="cropper-point point-n" data-cropper-action="n"></span>' + '<span class="cropper-point point-w" data-cropper-action="w"></span>' + '<span class="cropper-point point-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-ne" data-cropper-action="ne"></span>' + '<span class="cropper-point point-nw" data-cropper-action="nw"></span>' + '<span class="cropper-point point-sw" data-cropper-action="sw"></span>' + '<span class="cropper-point point-se" data-cropper-action="se"></span>' + '</div>' + '</div>';

  /**
   * Check if the given value is not a number.
   */

  var isNaN = Number.isNaN || WINDOW.isNaN;
  /**
   * Check if the given value is a number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a number, else `false`.
   */

  function isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
  }
  /**
   * Check if the given value is a positive number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.
   */

  var isPositiveNumber = function isPositiveNumber(value) {
    return value > 0 && value < Infinity;
  };
  /**
   * Check if the given value is undefined.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
   */

  function isUndefined(value) {
    return typeof value === 'undefined';
  }
  /**
   * Check if the given value is an object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is an object, else `false`.
   */

  function isObject(value) {
    return _typeof(value) === 'object' && value !== null;
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * Check if the given value is a plain object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
   */

  function isPlainObject(value) {
    if (!isObject(value)) {
      return false;
    }

    try {
      var _constructor = value.constructor;
      var prototype = _constructor.prototype;
      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
    } catch (error) {
      return false;
    }
  }
  /**
   * Check if the given value is a function.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a function, else `false`.
   */

  function isFunction(value) {
    return typeof value === 'function';
  }
  var slice = Array.prototype.slice;
  /**
   * Convert array-like or iterable object to an array.
   * @param {*} value - The value to convert.
   * @returns {Array} Returns a new array.
   */

  function toArray(value) {
    return Array.from ? Array.from(value) : slice.call(value);
  }
  /**
   * Iterate the given data.
   * @param {*} data - The data to iterate.
   * @param {Function} callback - The process function for each element.
   * @returns {*} The original data.
   */

  function forEach(data, callback) {
    if (data && isFunction(callback)) {
      if (Array.isArray(data) || isNumber(data.length)
      /* array-like */
      ) {
          toArray(data).forEach(function (value, key) {
            callback.call(data, value, key, data);
          });
        } else if (isObject(data)) {
        Object.keys(data).forEach(function (key) {
          callback.call(data, data[key], key, data);
        });
      }
    }

    return data;
  }
  /**
   * Extend the given object.
   * @param {*} target - The target object to extend.
   * @param {*} args - The rest objects for merging to the target object.
   * @returns {Object} The extended object.
   */

  var assign = Object.assign || function assign(target) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (isObject(target) && args.length > 0) {
      args.forEach(function (arg) {
        if (isObject(arg)) {
          Object.keys(arg).forEach(function (key) {
            target[key] = arg[key];
          });
        }
      });
    }

    return target;
  };
  var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
  /**
   * Normalize decimal number.
   * Check out {@link https://0.30000000000000004.com/}
   * @param {number} value - The value to normalize.
   * @param {number} [times=100000000000] - The times for normalizing.
   * @returns {number} Returns the normalized number.
   */

  function normalizeDecimalNumber(value) {
    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;
    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
  }
  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
  /**
   * Apply styles to the given element.
   * @param {Element} element - The target element.
   * @param {Object} styles - The styles for applying.
   */

  function setStyle(element, styles) {
    var style = element.style;
    forEach(styles, function (value, property) {
      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
        value = "".concat(value, "px");
      }

      style[property] = value;
    });
  }
  /**
   * Check if the given element has a special class.
   * @param {Element} element - The element to check.
   * @param {string} value - The class to search.
   * @returns {boolean} Returns `true` if the special class was found.
   */

  function hasClass(element, value) {
    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
  }
  /**
   * Add classes to the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be added.
   */

  function addClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        addClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.add(value);
      return;
    }

    var className = element.className.trim();

    if (!className) {
      element.className = value;
    } else if (className.indexOf(value) < 0) {
      element.className = "".concat(className, " ").concat(value);
    }
  }
  /**
   * Remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be removed.
   */

  function removeClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        removeClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.remove(value);
      return;
    }

    if (element.className.indexOf(value) >= 0) {
      element.className = element.className.replace(value, '');
    }
  }
  /**
   * Add or remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be toggled.
   * @param {boolean} added - Add only.
   */

  function toggleClass(element, value, added) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        toggleClass(elem, value, added);
      });
      return;
    } // IE10-11 doesn't support the second parameter of `classList.toggle`


    if (added) {
      addClass(element, value);
    } else {
      removeClass(element, value);
    }
  }
  var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
  /**
   * Transform the given string from camelCase to kebab-case
   * @param {string} value - The value to transform.
   * @returns {string} The transformed value.
   */

  function toParamCase(value) {
    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();
  }
  /**
   * Get data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to get.
   * @returns {string} The data value.
   */

  function getData(element, name) {
    if (isObject(element[name])) {
      return element[name];
    }

    if (element.dataset) {
      return element.dataset[name];
    }

    return element.getAttribute("data-".concat(toParamCase(name)));
  }
  /**
   * Set data to the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to set.
   * @param {string} data - The data value.
   */

  function setData(element, name, data) {
    if (isObject(data)) {
      element[name] = data;
    } else if (element.dataset) {
      element.dataset[name] = data;
    } else {
      element.setAttribute("data-".concat(toParamCase(name)), data);
    }
  }
  /**
   * Remove data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to remove.
   */

  function removeData(element, name) {
    if (isObject(element[name])) {
      try {
        delete element[name];
      } catch (error) {
        element[name] = undefined;
      }
    } else if (element.dataset) {
      // #128 Safari not allows to delete dataset property
      try {
        delete element.dataset[name];
      } catch (error) {
        element.dataset[name] = undefined;
      }
    } else {
      element.removeAttribute("data-".concat(toParamCase(name)));
    }
  }
  var REGEXP_SPACES = /\s\s*/;

  var onceSupported = function () {
    var supported = false;

    if (IS_BROWSER) {
      var once = false;

      var listener = function listener() {};

      var options = Object.defineProperty({}, 'once', {
        get: function get() {
          supported = true;
          return once;
        },

        /**
         * This setter can fix a `TypeError` in strict mode
         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
         * @param {boolean} value - The value to set
         */
        set: function set(value) {
          once = value;
        }
      });
      WINDOW.addEventListener('test', listener, options);
      WINDOW.removeEventListener('test', listener, options);
    }

    return supported;
  }();
  /**
   * Remove event listener from the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */


  function removeListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (!onceSupported) {
        var listeners = element.listeners;

        if (listeners && listeners[event] && listeners[event][listener]) {
          handler = listeners[event][listener];
          delete listeners[event][listener];

          if (Object.keys(listeners[event]).length === 0) {
            delete listeners[event];
          }

          if (Object.keys(listeners).length === 0) {
            delete element.listeners;
          }
        }
      }

      element.removeEventListener(event, handler, options);
    });
  }
  /**
   * Add event listener to the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */

  function addListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var _handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (options.once && !onceSupported) {
        var _element$listeners = element.listeners,
            listeners = _element$listeners === void 0 ? {} : _element$listeners;

        _handler = function handler() {
          delete listeners[event][listener];
          element.removeEventListener(event, _handler, options);

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          listener.apply(element, args);
        };

        if (!listeners[event]) {
          listeners[event] = {};
        }

        if (listeners[event][listener]) {
          element.removeEventListener(event, listeners[event][listener], options);
        }

        listeners[event][listener] = _handler;
        element.listeners = listeners;
      }

      element.addEventListener(event, _handler, options);
    });
  }
  /**
   * Dispatch event on the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Object} data - The additional event data.
   * @returns {boolean} Indicate if the event is default prevented or not.
   */

  function dispatchEvent(element, type, data) {
    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors

    if (isFunction(Event) && isFunction(CustomEvent)) {
      event = new CustomEvent(type, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } else {
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(type, true, true, data);
    }

    return element.dispatchEvent(event);
  }
  /**
   * Get the offset base on the document.
   * @param {Element} element - The target element.
   * @returns {Object} The offset data.
   */

  function getOffset(element) {
    var box = element.getBoundingClientRect();
    return {
      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
      top: box.top + (window.pageYOffset - document.documentElement.clientTop)
    };
  }
  var location = WINDOW.location;
  var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
  /**
   * Check if the given URL is a cross origin URL.
   * @param {string} url - The target URL.
   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
   */

  function isCrossOriginURL(url) {
    var parts = url.match(REGEXP_ORIGINS);
    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
  }
  /**
   * Add timestamp to the given URL.
   * @param {string} url - The target URL.
   * @returns {string} The result URL.
   */

  function addTimestamp(url) {
    var timestamp = "timestamp=".concat(new Date().getTime());
    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
  }
  /**
   * Get transforms base on the given object.
   * @param {Object} obj - The target object.
   * @returns {string} A string contains transform values.
   */

  function getTransforms(_ref) {
    var rotate = _ref.rotate,
        scaleX = _ref.scaleX,
        scaleY = _ref.scaleY,
        translateX = _ref.translateX,
        translateY = _ref.translateY;
    var values = [];

    if (isNumber(translateX) && translateX !== 0) {
      values.push("translateX(".concat(translateX, "px)"));
    }

    if (isNumber(translateY) && translateY !== 0) {
      values.push("translateY(".concat(translateY, "px)"));
    } // Rotate should come first before scale to match orientation transform


    if (isNumber(rotate) && rotate !== 0) {
      values.push("rotate(".concat(rotate, "deg)"));
    }

    if (isNumber(scaleX) && scaleX !== 1) {
      values.push("scaleX(".concat(scaleX, ")"));
    }

    if (isNumber(scaleY) && scaleY !== 1) {
      values.push("scaleY(".concat(scaleY, ")"));
    }

    var transform = values.length ? values.join(' ') : 'none';
    return {
      WebkitTransform: transform,
      msTransform: transform,
      transform: transform
    };
  }
  /**
   * Get the max ratio of a group of pointers.
   * @param {string} pointers - The target pointers.
   * @returns {number} The result ratio.
   */

  function getMaxZoomRatio(pointers) {
    var pointers2 = _objectSpread2({}, pointers);

    var ratios = [];
    forEach(pointers, function (pointer, pointerId) {
      delete pointers2[pointerId];
      forEach(pointers2, function (pointer2) {
        var x1 = Math.abs(pointer.startX - pointer2.startX);
        var y1 = Math.abs(pointer.startY - pointer2.startY);
        var x2 = Math.abs(pointer.endX - pointer2.endX);
        var y2 = Math.abs(pointer.endY - pointer2.endY);
        var z1 = Math.sqrt(x1 * x1 + y1 * y1);
        var z2 = Math.sqrt(x2 * x2 + y2 * y2);
        var ratio = (z2 - z1) / z1;
        ratios.push(ratio);
      });
    });
    ratios.sort(function (a, b) {
      return Math.abs(a) < Math.abs(b);
    });
    return ratios[0];
  }
  /**
   * Get a pointer from an event object.
   * @param {Object} event - The target event object.
   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
   * @returns {Object} The result pointer contains start and/or end point coordinates.
   */

  function getPointer(_ref2, endOnly) {
    var pageX = _ref2.pageX,
        pageY = _ref2.pageY;
    var end = {
      endX: pageX,
      endY: pageY
    };
    return endOnly ? end : _objectSpread2({
      startX: pageX,
      startY: pageY
    }, end);
  }
  /**
   * Get the center point coordinate of a group of pointers.
   * @param {Object} pointers - The target pointers.
   * @returns {Object} The center point coordinate.
   */

  function getPointersCenter(pointers) {
    var pageX = 0;
    var pageY = 0;
    var count = 0;
    forEach(pointers, function (_ref3) {
      var startX = _ref3.startX,
          startY = _ref3.startY;
      pageX += startX;
      pageY += startY;
      count += 1;
    });
    pageX /= count;
    pageY /= count;
    return {
      pageX: pageX,
      pageY: pageY
    };
  }
  /**
   * Get the max sizes in a rectangle under the given aspect ratio.
   * @param {Object} data - The original sizes.
   * @param {string} [type='contain'] - The adjust type.
   * @returns {Object} The result sizes.
   */

  function getAdjustedSizes(_ref4) // or 'cover'
  {
    var aspectRatio = _ref4.aspectRatio,
        height = _ref4.height,
        width = _ref4.width;
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';
    var isValidWidth = isPositiveNumber(width);
    var isValidHeight = isPositiveNumber(height);

    if (isValidWidth && isValidHeight) {
      var adjustedWidth = height * aspectRatio;

      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {
        height = width / aspectRatio;
      } else {
        width = height * aspectRatio;
      }
    } else if (isValidWidth) {
      height = width / aspectRatio;
    } else if (isValidHeight) {
      width = height * aspectRatio;
    }

    return {
      width: width,
      height: height
    };
  }
  /**
   * Get the new sizes of a rectangle after rotated.
   * @param {Object} data - The original sizes.
   * @returns {Object} The result sizes.
   */

  function getRotatedSizes(_ref5) {
    var width = _ref5.width,
        height = _ref5.height,
        degree = _ref5.degree;
    degree = Math.abs(degree) % 180;

    if (degree === 90) {
      return {
        width: height,
        height: width
      };
    }

    var arc = degree % 90 * Math.PI / 180;
    var sinArc = Math.sin(arc);
    var cosArc = Math.cos(arc);
    var newWidth = width * cosArc + height * sinArc;
    var newHeight = width * sinArc + height * cosArc;
    return degree > 90 ? {
      width: newHeight,
      height: newWidth
    } : {
      width: newWidth,
      height: newHeight
    };
  }
  /**
   * Get a canvas which drew the given image.
   * @param {HTMLImageElement} image - The image for drawing.
   * @param {Object} imageData - The image data.
   * @param {Object} canvasData - The canvas data.
   * @param {Object} options - The options.
   * @returns {HTMLCanvasElement} The result canvas.
   */

  function getSourceCanvas(image, _ref6, _ref7, _ref8) {
    var imageAspectRatio = _ref6.aspectRatio,
        imageNaturalWidth = _ref6.naturalWidth,
        imageNaturalHeight = _ref6.naturalHeight,
        _ref6$rotate = _ref6.rotate,
        rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
        _ref6$scaleX = _ref6.scaleX,
        scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,
        _ref6$scaleY = _ref6.scaleY,
        scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
    var aspectRatio = _ref7.aspectRatio,
        naturalWidth = _ref7.naturalWidth,
        naturalHeight = _ref7.naturalHeight;
    var _ref8$fillColor = _ref8.fillColor,
        fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,
        _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
        imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,
        _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
        imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,
        _ref8$maxWidth = _ref8.maxWidth,
        maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,
        _ref8$maxHeight = _ref8.maxHeight,
        maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,
        _ref8$minWidth = _ref8.minWidth,
        minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,
        _ref8$minHeight = _ref8.minHeight,
        minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var maxSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var minSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as
    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90

    var destMaxSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var destMinSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);
    context.fillStyle = fillColor;
    context.fillRect(0, 0, width, height);
    context.save();
    context.translate(width / 2, height / 2);
    context.rotate(rotate * Math.PI / 180);
    context.scale(scaleX, scaleY);
    context.imageSmoothingEnabled = imageSmoothingEnabled;
    context.imageSmoothingQuality = imageSmoothingQuality;
    context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {
      return Math.floor(normalizeDecimalNumber(param));
    }))));
    context.restore();
    return canvas;
  }
  var fromCharCode = String.fromCharCode;
  /**
   * Get string from char code in data view.
   * @param {DataView} dataView - The data view for read.
   * @param {number} start - The start index.
   * @param {number} length - The read length.
   * @returns {string} The read result.
   */

  function getStringFromCharCode(dataView, start, length) {
    var str = '';
    length += start;

    for (var i = start; i < length; i += 1) {
      str += fromCharCode(dataView.getUint8(i));
    }

    return str;
  }
  var REGEXP_DATA_URL_HEAD = /^data:.*,/;
  /**
   * Transform Data URL to array buffer.
   * @param {string} dataURL - The Data URL to transform.
   * @returns {ArrayBuffer} The result array buffer.
   */

  function dataURLToArrayBuffer(dataURL) {
    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
    var binary = atob(base64);
    var arrayBuffer = new ArrayBuffer(binary.length);
    var uint8 = new Uint8Array(arrayBuffer);
    forEach(uint8, function (value, i) {
      uint8[i] = binary.charCodeAt(i);
    });
    return arrayBuffer;
  }
  /**
   * Transform array buffer to Data URL.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
   * @param {string} mimeType - The mime type of the Data URL.
   * @returns {string} The result Data URL.
   */

  function arrayBufferToDataURL(arrayBuffer, mimeType) {
    var chunks = []; // Chunk Typed Array for better performance (#435)

    var chunkSize = 8192;
    var uint8 = new Uint8Array(arrayBuffer);

    while (uint8.length > 0) {
      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9
      // eslint-disable-next-line prefer-spread
      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
      uint8 = uint8.subarray(chunkSize);
    }

    return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join('')));
  }
  /**
   * Get orientation value from given array buffer.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
   * @returns {number} The read orientation value.
   */

  function resetAndGetOrientation(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var orientation; // Ignores range error when the image does not have correct Exif information

    try {
      var littleEndian;
      var app1Start;
      var ifdStart; // Only handle JPEG image (start by 0xFFD8)

      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
        var length = dataView.byteLength;
        var offset = 2;

        while (offset + 1 < length) {
          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
            app1Start = offset;
            break;
          }

          offset += 1;
        }
      }

      if (app1Start) {
        var exifIDCode = app1Start + 4;
        var tiffOffset = app1Start + 10;

        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
          var endianness = dataView.getUint16(tiffOffset);
          littleEndian = endianness === 0x4949;

          if (littleEndian || endianness === 0x4D4D
          /* bigEndian */
          ) {
              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

                if (firstIFDOffset >= 0x00000008) {
                  ifdStart = tiffOffset + firstIFDOffset;
                }
              }
            }
        }
      }

      if (ifdStart) {
        var _length = dataView.getUint16(ifdStart, littleEndian);

        var _offset;

        var i;

        for (i = 0; i < _length; i += 1) {
          _offset = ifdStart + i * 12 + 2;

          if (dataView.getUint16(_offset, littleEndian) === 0x0112
          /* Orientation */
          ) {
              // 8 is the offset of the current tag's value
              _offset += 8; // Get the original orientation value

              orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value

              dataView.setUint16(_offset, 1, littleEndian);
              break;
            }
        }
      }
    } catch (error) {
      orientation = 1;
    }

    return orientation;
  }
  /**
   * Parse Exif Orientation value.
   * @param {number} orientation - The orientation to parse.
   * @returns {Object} The parsed result.
   */

  function parseOrientation(orientation) {
    var rotate = 0;
    var scaleX = 1;
    var scaleY = 1;

    switch (orientation) {
      // Flip horizontal
      case 2:
        scaleX = -1;
        break;
      // Rotate left 180

      case 3:
        rotate = -180;
        break;
      // Flip vertical

      case 4:
        scaleY = -1;
        break;
      // Flip vertical and rotate right 90

      case 5:
        rotate = 90;
        scaleY = -1;
        break;
      // Rotate right 90

      case 6:
        rotate = 90;
        break;
      // Flip horizontal and rotate right 90

      case 7:
        rotate = 90;
        scaleX = -1;
        break;
      // Rotate left 90

      case 8:
        rotate = -90;
        break;
    }

    return {
      rotate: rotate,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var render = {
    render: function render() {
      this.initContainer();
      this.initCanvas();
      this.initCropBox();
      this.renderCanvas();

      if (this.cropped) {
        this.renderCropBox();
      }
    },
    initContainer: function initContainer() {
      var element = this.element,
          options = this.options,
          container = this.container,
          cropper = this.cropper;
      addClass(cropper, CLASS_HIDDEN);
      removeClass(element, CLASS_HIDDEN);
      var containerData = {
        width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),
        height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)
      };
      this.containerData = containerData;
      setStyle(cropper, {
        width: containerData.width,
        height: containerData.height
      });
      addClass(element, CLASS_HIDDEN);
      removeClass(cropper, CLASS_HIDDEN);
    },
    // Canvas (image wrapper)
    initCanvas: function initCanvas() {
      var containerData = this.containerData,
          imageData = this.imageData;
      var viewMode = this.options.viewMode;
      var rotated = Math.abs(imageData.rotate) % 180 === 90;
      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
      var aspectRatio = naturalWidth / naturalHeight;
      var canvasWidth = containerData.width;
      var canvasHeight = containerData.height;

      if (containerData.height * aspectRatio > containerData.width) {
        if (viewMode === 3) {
          canvasWidth = containerData.height * aspectRatio;
        } else {
          canvasHeight = containerData.width / aspectRatio;
        }
      } else if (viewMode === 3) {
        canvasHeight = containerData.width / aspectRatio;
      } else {
        canvasWidth = containerData.height * aspectRatio;
      }

      var canvasData = {
        aspectRatio: aspectRatio,
        naturalWidth: naturalWidth,
        naturalHeight: naturalHeight,
        width: canvasWidth,
        height: canvasHeight
      };
      canvasData.left = (containerData.width - canvasWidth) / 2;
      canvasData.top = (containerData.height - canvasHeight) / 2;
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      this.canvasData = canvasData;
      this.limited = viewMode === 1 || viewMode === 2;
      this.limitCanvas(true, true);
      this.initialImageData = assign({}, imageData);
      this.initialCanvasData = assign({}, canvasData);
    },
    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var viewMode = options.viewMode;
      var aspectRatio = canvasData.aspectRatio;
      var cropped = this.cropped && cropBoxData;

      if (sizeLimited) {
        var minCanvasWidth = Number(options.minCanvasWidth) || 0;
        var minCanvasHeight = Number(options.minCanvasHeight) || 0;

        if (viewMode > 1) {
          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

          if (viewMode === 3) {
            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        } else if (viewMode > 0) {
          if (minCanvasWidth) {
            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
          } else if (minCanvasHeight) {
            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
          } else if (cropped) {
            minCanvasWidth = cropBoxData.width;
            minCanvasHeight = cropBoxData.height;

            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        }

        var _getAdjustedSizes = getAdjustedSizes({
          aspectRatio: aspectRatio,
          width: minCanvasWidth,
          height: minCanvasHeight
        });

        minCanvasWidth = _getAdjustedSizes.width;
        minCanvasHeight = _getAdjustedSizes.height;
        canvasData.minWidth = minCanvasWidth;
        canvasData.minHeight = minCanvasHeight;
        canvasData.maxWidth = Infinity;
        canvasData.maxHeight = Infinity;
      }

      if (positionLimited) {
        if (viewMode > (cropped ? 0 : 1)) {
          var newCanvasLeft = containerData.width - canvasData.width;
          var newCanvasTop = containerData.height - canvasData.height;
          canvasData.minLeft = Math.min(0, newCanvasLeft);
          canvasData.minTop = Math.min(0, newCanvasTop);
          canvasData.maxLeft = Math.max(0, newCanvasLeft);
          canvasData.maxTop = Math.max(0, newCanvasTop);

          if (cropped && this.limited) {
            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
            canvasData.maxLeft = cropBoxData.left;
            canvasData.maxTop = cropBoxData.top;

            if (viewMode === 2) {
              if (canvasData.width >= containerData.width) {
                canvasData.minLeft = Math.min(0, newCanvasLeft);
                canvasData.maxLeft = Math.max(0, newCanvasLeft);
              }

              if (canvasData.height >= containerData.height) {
                canvasData.minTop = Math.min(0, newCanvasTop);
                canvasData.maxTop = Math.max(0, newCanvasTop);
              }
            }
          }
        } else {
          canvasData.minLeft = -canvasData.width;
          canvasData.minTop = -canvasData.height;
          canvasData.maxLeft = containerData.width;
          canvasData.maxTop = containerData.height;
        }
      }
    },
    renderCanvas: function renderCanvas(changed, transformed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;

      if (transformed) {
        var _getRotatedSizes = getRotatedSizes({
          width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
          height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
          degree: imageData.rotate || 0
        }),
            naturalWidth = _getRotatedSizes.width,
            naturalHeight = _getRotatedSizes.height;

        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
        canvasData.left -= (width - canvasData.width) / 2;
        canvasData.top -= (height - canvasData.height) / 2;
        canvasData.width = width;
        canvasData.height = height;
        canvasData.aspectRatio = naturalWidth / naturalHeight;
        canvasData.naturalWidth = naturalWidth;
        canvasData.naturalHeight = naturalHeight;
        this.limitCanvas(true, false);
      }

      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
        canvasData.left = canvasData.oldLeft;
      }

      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
        canvasData.top = canvasData.oldTop;
      }

      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
      this.limitCanvas(false, true);
      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      setStyle(this.canvas, assign({
        width: canvasData.width,
        height: canvasData.height
      }, getTransforms({
        translateX: canvasData.left,
        translateY: canvasData.top
      })));
      this.renderImage(changed);

      if (this.cropped && this.limited) {
        this.limitCropBox(true, true);
      }
    },
    renderImage: function renderImage(changed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;
      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
      assign(imageData, {
        width: width,
        height: height,
        left: (canvasData.width - width) / 2,
        top: (canvasData.height - height) / 2
      });
      setStyle(this.image, assign({
        width: imageData.width,
        height: imageData.height
      }, getTransforms(assign({
        translateX: imageData.left,
        translateY: imageData.top
      }, imageData))));

      if (changed) {
        this.output();
      }
    },
    initCropBox: function initCropBox() {
      var options = this.options,
          canvasData = this.canvasData;
      var aspectRatio = options.aspectRatio || options.initialAspectRatio;
      var autoCropArea = Number(options.autoCropArea) || 0.8;
      var cropBoxData = {
        width: canvasData.width,
        height: canvasData.height
      };

      if (aspectRatio) {
        if (canvasData.height * aspectRatio > canvasData.width) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      this.cropBoxData = cropBoxData;
      this.limitCropBox(true, true); // Initialize auto crop area

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than "minWidth/Height"

      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;
      this.initialCropBoxData = assign({}, cropBoxData);
    },
    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData,
          limited = this.limited;
      var aspectRatio = options.aspectRatio;

      if (sizeLimited) {
        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height

        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

        if (aspectRatio) {
          if (minCropBoxWidth && minCropBoxHeight) {
            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
          } else if (minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else if (minCropBoxHeight) {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }

          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
          } else {
            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
          }
        } // The minWidth/Height must be less than maxWidth/Height


        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
        cropBoxData.maxWidth = maxCropBoxWidth;
        cropBoxData.maxHeight = maxCropBoxHeight;
      }

      if (positionLimited) {
        if (limited) {
          cropBoxData.minLeft = Math.max(0, canvasData.left);
          cropBoxData.minTop = Math.max(0, canvasData.top);
          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
        } else {
          cropBoxData.minLeft = 0;
          cropBoxData.minTop = 0;
          cropBoxData.maxLeft = containerData.width - cropBoxData.width;
          cropBoxData.maxTop = containerData.height - cropBoxData.height;
        }
      }
    },
    renderCropBox: function renderCropBox() {
      var options = this.options,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData;

      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
        cropBoxData.left = cropBoxData.oldLeft;
      }

      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
        cropBoxData.top = cropBoxData.oldTop;
      }

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
      this.limitCropBox(false, true);
      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;

      if (options.movable && options.cropBoxMovable) {
        // Turn to move the canvas when the crop box is equal to the container
        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
      }

      setStyle(this.cropBox, assign({
        width: cropBoxData.width,
        height: cropBoxData.height
      }, getTransforms({
        translateX: cropBoxData.left,
        translateY: cropBoxData.top
      })));

      if (this.cropped && this.limited) {
        this.limitCanvas(true, true);
      }

      if (!this.disabled) {
        this.output();
      }
    },
    output: function output() {
      this.preview();
      dispatchEvent(this.element, EVENT_CROP, this.getData());
    }
  };

  var preview = {
    initPreview: function initPreview() {
      var element = this.element,
          crossOrigin = this.crossOrigin;
      var preview = this.options.preview;
      var url = crossOrigin ? this.crossOriginUrl : this.url;
      var alt = element.alt || 'The image to preview';
      var image = document.createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = url;
      image.alt = alt;
      this.viewBox.appendChild(image);
      this.viewBoxImage = image;

      if (!preview) {
        return;
      }

      var previews = preview;

      if (typeof preview === 'string') {
        previews = element.ownerDocument.querySelectorAll(preview);
      } else if (preview.querySelector) {
        previews = [preview];
      }

      this.previews = previews;
      forEach(previews, function (el) {
        var img = document.createElement('img'); // Save the original size for recover

        setData(el, DATA_PREVIEW, {
          width: el.offsetWidth,
          height: el.offsetHeight,
          html: el.innerHTML
        });

        if (crossOrigin) {
          img.crossOrigin = crossOrigin;
        }

        img.src = url;
        img.alt = alt;
        /**
         * Override img element styles
         * Add `display:block` to avoid margin top issue
         * Add `height:auto` to override `height` attribute on IE8
         * (Occur only when margin-top <= -height)
         */

        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';
        el.innerHTML = '';
        el.appendChild(img);
      });
    },
    resetPreview: function resetPreview() {
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        setStyle(element, {
          width: data.width,
          height: data.height
        });
        element.innerHTML = data.html;
        removeData(element, DATA_PREVIEW);
      });
    },
    preview: function preview() {
      var imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var cropBoxWidth = cropBoxData.width,
          cropBoxHeight = cropBoxData.height;
      var width = imageData.width,
          height = imageData.height;
      var left = cropBoxData.left - canvasData.left - imageData.left;
      var top = cropBoxData.top - canvasData.top - imageData.top;

      if (!this.cropped || this.disabled) {
        return;
      }

      setStyle(this.viewBoxImage, assign({
        width: width,
        height: height
      }, getTransforms(assign({
        translateX: -left,
        translateY: -top
      }, imageData))));
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        var originalWidth = data.width;
        var originalHeight = data.height;
        var newWidth = originalWidth;
        var newHeight = originalHeight;
        var ratio = 1;

        if (cropBoxWidth) {
          ratio = originalWidth / cropBoxWidth;
          newHeight = cropBoxHeight * ratio;
        }

        if (cropBoxHeight && newHeight > originalHeight) {
          ratio = originalHeight / cropBoxHeight;
          newWidth = cropBoxWidth * ratio;
          newHeight = originalHeight;
        }

        setStyle(element, {
          width: newWidth,
          height: newHeight
        });
        setStyle(element.getElementsByTagName('img')[0], assign({
          width: width * ratio,
          height: height * ratio
        }, getTransforms(assign({
          translateX: -left * ratio,
          translateY: -top * ratio
        }, imageData))));
      });
    }
  };

  var events = {
    bind: function bind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        addListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        addListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        addListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        addListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        addListener(element, EVENT_ZOOM, options.zoom);
      }

      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));

      if (options.zoomable && options.zoomOnWheel) {
        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
      }

      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));

      if (options.responsive) {
        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
      }
    },
    unbind: function unbind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        removeListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        removeListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        removeListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        removeListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        removeListener(element, EVENT_ZOOM, options.zoom);
      }

      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);

      if (options.zoomable && options.zoomOnWheel) {
        removeListener(cropper, EVENT_WHEEL, this.onWheel, {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
      }

      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);

      if (options.responsive) {
        removeListener(window, EVENT_RESIZE, this.onResize);
      }
    }
  };

  var handlers = {
    resize: function resize() {
      if (this.disabled) {
        return;
      }

      var options = this.options,
          container = this.container,
          containerData = this.containerData;
      var ratio = container.offsetWidth / containerData.width; // Resize when width changed or height changed

      if (ratio !== 1 || container.offsetHeight !== containerData.height) {
        var canvasData;
        var cropBoxData;

        if (options.restore) {
          canvasData = this.getCanvasData();
          cropBoxData = this.getCropBoxData();
        }

        this.render();

        if (options.restore) {
          this.setCanvasData(forEach(canvasData, function (n, i) {
            canvasData[i] = n * ratio;
          }));
          this.setCropBoxData(forEach(cropBoxData, function (n, i) {
            cropBoxData[i] = n * ratio;
          }));
        }
      }
    },
    dblclick: function dblclick() {
      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
        return;
      }

      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
    },
    wheel: function wheel(event) {
      var _this = this;

      var ratio = Number(this.options.wheelZoomRatio) || 0.1;
      var delta = 1;

      if (this.disabled) {
        return;
      }

      event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)

      if (this.wheeling) {
        return;
      }

      this.wheeling = true;
      setTimeout(function () {
        _this.wheeling = false;
      }, 50);

      if (event.deltaY) {
        delta = event.deltaY > 0 ? 1 : -1;
      } else if (event.wheelDelta) {
        delta = -event.wheelDelta / 120;
      } else if (event.detail) {
        delta = event.detail > 0 ? 1 : -1;
      }

      this.zoom(-delta * ratio, event);
    },
    cropStart: function cropStart(event) {
      var buttons = event.buttons,
          button = event.button;

      if (this.disabled // Handle mouse event and pointer event and ignore touch event
      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)
      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu
      || event.ctrlKey)) {
        return;
      }

      var options = this.options,
          pointers = this.pointers;
      var action;

      if (event.changedTouches) {
        // Handle touch event
        forEach(event.changedTouches, function (touch) {
          pointers[touch.identifier] = getPointer(touch);
        });
      } else {
        // Handle mouse event and pointer event
        pointers[event.pointerId || 0] = getPointer(event);
      }

      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
        action = ACTION_ZOOM;
      } else {
        action = getData(event.target, DATA_ACTION);
      }

      if (!REGEXP_ACTIONS.test(action)) {
        return;
      }

      if (dispatchEvent(this.element, EVENT_CROP_START, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      } // This line is required for preventing page zooming in iOS browsers


      event.preventDefault();
      this.action = action;
      this.cropping = false;

      if (action === ACTION_CROP) {
        this.cropping = true;
        addClass(this.dragBox, CLASS_MODAL);
      }
    },
    cropMove: function cropMove(event) {
      var action = this.action;

      if (this.disabled || !action) {
        return;
      }

      var pointers = this.pointers;
      event.preventDefault();

      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      }

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          // The first parameter should not be undefined (#432)
          assign(pointers[touch.identifier] || {}, getPointer(touch, true));
        });
      } else {
        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
      }

      this.change(event);
    },
    cropEnd: function cropEnd(event) {
      if (this.disabled) {
        return;
      }

      var action = this.action,
          pointers = this.pointers;

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          delete pointers[touch.identifier];
        });
      } else {
        delete pointers[event.pointerId || 0];
      }

      if (!action) {
        return;
      }

      event.preventDefault();

      if (!Object.keys(pointers).length) {
        this.action = '';
      }

      if (this.cropping) {
        this.cropping = false;
        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
      }

      dispatchEvent(this.element, EVENT_CROP_END, {
        originalEvent: event,
        action: action
      });
    }
  };

  var change = {
    change: function change(event) {
      var options = this.options,
          canvasData = this.canvasData,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData,
          pointers = this.pointers;
      var action = this.action;
      var aspectRatio = options.aspectRatio;
      var left = cropBoxData.left,
          top = cropBoxData.top,
          width = cropBoxData.width,
          height = cropBoxData.height;
      var right = left + width;
      var bottom = top + height;
      var minLeft = 0;
      var minTop = 0;
      var maxWidth = containerData.width;
      var maxHeight = containerData.height;
      var renderable = true;
      var offset; // Locking aspect ratio in "free mode" by holding shift key

      if (!aspectRatio && event.shiftKey) {
        aspectRatio = width && height ? width / height : 1;
      }

      if (this.limited) {
        minLeft = cropBoxData.minLeft;
        minTop = cropBoxData.minTop;
        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
      }

      var pointer = pointers[Object.keys(pointers)[0]];
      var range = {
        x: pointer.endX - pointer.startX,
        y: pointer.endY - pointer.startY
      };

      var check = function check(side) {
        switch (side) {
          case ACTION_EAST:
            if (right + range.x > maxWidth) {
              range.x = maxWidth - right;
            }

            break;

          case ACTION_WEST:
            if (left + range.x < minLeft) {
              range.x = minLeft - left;
            }

            break;

          case ACTION_NORTH:
            if (top + range.y < minTop) {
              range.y = minTop - top;
            }

            break;

          case ACTION_SOUTH:
            if (bottom + range.y > maxHeight) {
              range.y = maxHeight - bottom;
            }

            break;
        }
      };

      switch (action) {
        // Move crop box
        case ACTION_ALL:
          left += range.x;
          top += range.y;
          break;
        // Resize crop box

        case ACTION_EAST:
          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_EAST);
          width += range.x;

          if (width < 0) {
            action = ACTION_WEST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_NORTH:
          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;

          if (height < 0) {
            action = ACTION_SOUTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_WEST:
          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_WEST);
          width -= range.x;
          left += range.x;

          if (width < 0) {
            action = ACTION_EAST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_SOUTH:
          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_SOUTH);
          height += range.y;

          if (height < 0) {
            action = ACTION_NORTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_NORTH_EAST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
          } else {
            check(ACTION_NORTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_NORTH_WEST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
            left += cropBoxData.width - width;
          } else {
            check(ACTION_NORTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_WEST:
          if (aspectRatio) {
            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_WEST);
            width -= range.x;
            left += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_EAST:
          if (aspectRatio) {
            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_EAST);
            width += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            top -= height;
          }

          break;
        // Move canvas

        case ACTION_MOVE:
          this.move(range.x, range.y);
          renderable = false;
          break;
        // Zoom canvas

        case ACTION_ZOOM:
          this.zoom(getMaxZoomRatio(pointers), event);
          renderable = false;
          break;
        // Create crop box

        case ACTION_CROP:
          if (!range.x || !range.y) {
            renderable = false;
            break;
          }

          offset = getOffset(this.cropper);
          left = pointer.startX - offset.left;
          top = pointer.startY - offset.top;
          width = cropBoxData.minWidth;
          height = cropBoxData.minHeight;

          if (range.x > 0) {
            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
          } else if (range.x < 0) {
            left -= width;
            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
          }

          if (range.y < 0) {
            top -= height;
          } // Show the crop box if is hidden


          if (!this.cropped) {
            removeClass(this.cropBox, CLASS_HIDDEN);
            this.cropped = true;

            if (this.limited) {
              this.limitCropBox(true, true);
            }
          }

          break;
      }

      if (renderable) {
        cropBoxData.width = width;
        cropBoxData.height = height;
        cropBoxData.left = left;
        cropBoxData.top = top;
        this.action = action;
        this.renderCropBox();
      } // Override


      forEach(pointers, function (p) {
        p.startX = p.endX;
        p.startY = p.endY;
      });
    }
  };

  var methods = {
    // Show the crop box manually
    crop: function crop() {
      if (this.ready && !this.cropped && !this.disabled) {
        this.cropped = true;
        this.limitCropBox(true, true);

        if (this.options.modal) {
          addClass(this.dragBox, CLASS_MODAL);
        }

        removeClass(this.cropBox, CLASS_HIDDEN);
        this.setCropBoxData(this.initialCropBoxData);
      }

      return this;
    },
    // Reset the image and crop box to their initial states
    reset: function reset() {
      if (this.ready && !this.disabled) {
        this.imageData = assign({}, this.initialImageData);
        this.canvasData = assign({}, this.initialCanvasData);
        this.cropBoxData = assign({}, this.initialCropBoxData);
        this.renderCanvas();

        if (this.cropped) {
          this.renderCropBox();
        }
      }

      return this;
    },
    // Clear the crop box
    clear: function clear() {
      if (this.cropped && !this.disabled) {
        assign(this.cropBoxData, {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        });
        this.cropped = false;
        this.renderCropBox();
        this.limitCanvas(true, true); // Render canvas after crop box rendered

        this.renderCanvas();
        removeClass(this.dragBox, CLASS_MODAL);
        addClass(this.cropBox, CLASS_HIDDEN);
      }

      return this;
    },

    /**
     * Replace the image's src and rebuild the cropper
     * @param {string} url - The new URL.
     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
     * @returns {Cropper} this
     */
    replace: function replace(url) {
      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.disabled && url) {
        if (this.isImg) {
          this.element.src = url;
        }

        if (hasSameSize) {
          this.url = url;
          this.image.src = url;

          if (this.ready) {
            this.viewBoxImage.src = url;
            forEach(this.previews, function (element) {
              element.getElementsByTagName('img')[0].src = url;
            });
          }
        } else {
          if (this.isImg) {
            this.replaced = true;
          }

          this.options.data = null;
          this.uncreate();
          this.load(url);
        }
      }

      return this;
    },
    // Enable (unfreeze) the cropper
    enable: function enable() {
      if (this.ready && this.disabled) {
        this.disabled = false;
        removeClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },
    // Disable (freeze) the cropper
    disable: function disable() {
      if (this.ready && !this.disabled) {
        this.disabled = true;
        addClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },

    /**
     * Destroy the cropper and remove the instance from the image
     * @returns {Cropper} this
     */
    destroy: function destroy() {
      var element = this.element;

      if (!element[NAMESPACE]) {
        return this;
      }

      element[NAMESPACE] = undefined;

      if (this.isImg && this.replaced) {
        element.src = this.originalUrl;
      }

      this.uncreate();
      return this;
    },

    /**
     * Move the canvas with relative offsets
     * @param {number} offsetX - The relative offset distance on the x-axis.
     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
     * @returns {Cropper} this
     */
    move: function move(offsetX) {
      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;
      var _this$canvasData = this.canvasData,
          left = _this$canvasData.left,
          top = _this$canvasData.top;
      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
    },

    /**
     * Move the canvas to an absolute point
     * @param {number} x - The x-axis coordinate.
     * @param {number} [y=x] - The y-axis coordinate.
     * @returns {Cropper} this
     */
    moveTo: function moveTo(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var canvasData = this.canvasData;
      var changed = false;
      x = Number(x);
      y = Number(y);

      if (this.ready && !this.disabled && this.options.movable) {
        if (isNumber(x)) {
          canvasData.left = x;
          changed = true;
        }

        if (isNumber(y)) {
          canvasData.top = y;
          changed = true;
        }

        if (changed) {
          this.renderCanvas(true);
        }
      }

      return this;
    },

    /**
     * Zoom the canvas with a relative ratio
     * @param {number} ratio - The target ratio.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoom: function zoom(ratio, _originalEvent) {
      var canvasData = this.canvasData;
      ratio = Number(ratio);

      if (ratio < 0) {
        ratio = 1 / (1 - ratio);
      } else {
        ratio = 1 + ratio;
      }

      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
    },

    /**
     * Zoom the canvas to an absolute ratio
     * @param {number} ratio - The target ratio.
     * @param {Object} pivot - The zoom pivot point coordinate.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
      var options = this.options,
          canvasData = this.canvasData;
      var width = canvasData.width,
          height = canvasData.height,
          naturalWidth = canvasData.naturalWidth,
          naturalHeight = canvasData.naturalHeight;
      ratio = Number(ratio);

      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
        var newWidth = naturalWidth * ratio;
        var newHeight = naturalHeight * ratio;

        if (dispatchEvent(this.element, EVENT_ZOOM, {
          ratio: ratio,
          oldRatio: width / naturalWidth,
          originalEvent: _originalEvent
        }) === false) {
          return this;
        }

        if (_originalEvent) {
          var pointers = this.pointers;
          var offset = getOffset(this.cropper);
          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
            pageX: _originalEvent.pageX,
            pageY: _originalEvent.pageY
          }; // Zoom from the triggering point of the event

          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
        } else {
          // Zoom from the center of the canvas
          canvasData.left -= (newWidth - width) / 2;
          canvasData.top -= (newHeight - height) / 2;
        }

        canvasData.width = newWidth;
        canvasData.height = newHeight;
        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Rotate the canvas with a relative degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotate: function rotate(degree) {
      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
    },

    /**
     * Rotate the canvas to an absolute degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotateTo: function rotateTo(degree) {
      degree = Number(degree);

      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
        this.imageData.rotate = degree % 360;
        this.renderCanvas(true, true);
      }

      return this;
    },

    /**
     * Scale the image on the x-axis.
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @returns {Cropper} this
     */
    scaleX: function scaleX(_scaleX) {
      var scaleY = this.imageData.scaleY;
      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
    },

    /**
     * Scale the image on the y-axis.
     * @param {number} scaleY - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scaleY: function scaleY(_scaleY) {
      var scaleX = this.imageData.scaleX;
      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
    },

    /**
     * Scale the image
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scale: function scale(scaleX) {
      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
      var imageData = this.imageData;
      var transformed = false;
      scaleX = Number(scaleX);
      scaleY = Number(scaleY);

      if (this.ready && !this.disabled && this.options.scalable) {
        if (isNumber(scaleX)) {
          imageData.scaleX = scaleX;
          transformed = true;
        }

        if (isNumber(scaleY)) {
          imageData.scaleY = scaleY;
          transformed = true;
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }
      }

      return this;
    },

    /**
     * Get the cropped area position and size data (base on the original image)
     * @param {boolean} [rounded=false] - Indicate if round the data values or not.
     * @returns {Object} The result cropped data.
     */
    getData: function getData() {
      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          x: cropBoxData.left - canvasData.left,
          y: cropBoxData.top - canvasData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
        var ratio = imageData.width / imageData.naturalWidth;
        forEach(data, function (n, i) {
          data[i] = n / ratio;
        });

        if (rounded) {
          // In case rounding off leads to extra 1px in right or bottom border
          // we should round the top-left corner and the dimension (#343).
          var bottom = Math.round(data.y + data.height);
          var right = Math.round(data.x + data.width);
          data.x = Math.round(data.x);
          data.y = Math.round(data.y);
          data.width = right - data.x;
          data.height = bottom - data.y;
        }
      } else {
        data = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      if (options.rotatable) {
        data.rotate = imageData.rotate || 0;
      }

      if (options.scalable) {
        data.scaleX = imageData.scaleX || 1;
        data.scaleY = imageData.scaleY || 1;
      }

      return data;
    },

    /**
     * Set the cropped area position and size with new data
     * @param {Object} data - The new data.
     * @returns {Cropper} this
     */
    setData: function setData(data) {
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData;
      var cropBoxData = {};

      if (this.ready && !this.disabled && isPlainObject(data)) {
        var transformed = false;

        if (options.rotatable) {
          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
            imageData.rotate = data.rotate;
            transformed = true;
          }
        }

        if (options.scalable) {
          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
            imageData.scaleX = data.scaleX;
            transformed = true;
          }

          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
            imageData.scaleY = data.scaleY;
            transformed = true;
          }
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }

        var ratio = imageData.width / imageData.naturalWidth;

        if (isNumber(data.x)) {
          cropBoxData.left = data.x * ratio + canvasData.left;
        }

        if (isNumber(data.y)) {
          cropBoxData.top = data.y * ratio + canvasData.top;
        }

        if (isNumber(data.width)) {
          cropBoxData.width = data.width * ratio;
        }

        if (isNumber(data.height)) {
          cropBoxData.height = data.height * ratio;
        }

        this.setCropBoxData(cropBoxData);
      }

      return this;
    },

    /**
     * Get the container size data.
     * @returns {Object} The result container data.
     */
    getContainerData: function getContainerData() {
      return this.ready ? assign({}, this.containerData) : {};
    },

    /**
     * Get the image position and size data.
     * @returns {Object} The result image data.
     */
    getImageData: function getImageData() {
      return this.sized ? assign({}, this.imageData) : {};
    },

    /**
     * Get the canvas position and size data.
     * @returns {Object} The result canvas data.
     */
    getCanvasData: function getCanvasData() {
      var canvasData = this.canvasData;
      var data = {};

      if (this.ready) {
        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
          data[n] = canvasData[n];
        });
      }

      return data;
    },

    /**
     * Set the canvas position and size with new data.
     * @param {Object} data - The new canvas data.
     * @returns {Cropper} this
     */
    setCanvasData: function setCanvasData(data) {
      var canvasData = this.canvasData;
      var aspectRatio = canvasData.aspectRatio;

      if (this.ready && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          canvasData.left = data.left;
        }

        if (isNumber(data.top)) {
          canvasData.top = data.top;
        }

        if (isNumber(data.width)) {
          canvasData.width = data.width;
          canvasData.height = data.width / aspectRatio;
        } else if (isNumber(data.height)) {
          canvasData.height = data.height;
          canvasData.width = data.height * aspectRatio;
        }

        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Get the crop box position and size data.
     * @returns {Object} The result crop box data.
     */
    getCropBoxData: function getCropBoxData() {
      var cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          left: cropBoxData.left,
          top: cropBoxData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
      }

      return data || {};
    },

    /**
     * Set the crop box position and size with new data.
     * @param {Object} data - The new crop box data.
     * @returns {Cropper} this
     */
    setCropBoxData: function setCropBoxData(data) {
      var cropBoxData = this.cropBoxData;
      var aspectRatio = this.options.aspectRatio;
      var widthChanged;
      var heightChanged;

      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          cropBoxData.left = data.left;
        }

        if (isNumber(data.top)) {
          cropBoxData.top = data.top;
        }

        if (isNumber(data.width) && data.width !== cropBoxData.width) {
          widthChanged = true;
          cropBoxData.width = data.width;
        }

        if (isNumber(data.height) && data.height !== cropBoxData.height) {
          heightChanged = true;
          cropBoxData.height = data.height;
        }

        if (aspectRatio) {
          if (widthChanged) {
            cropBoxData.height = cropBoxData.width / aspectRatio;
          } else if (heightChanged) {
            cropBoxData.width = cropBoxData.height * aspectRatio;
          }
        }

        this.renderCropBox();
      }

      return this;
    },

    /**
     * Get a canvas drawn the cropped image.
     * @param {Object} [options={}] - The config options.
     * @returns {HTMLCanvasElement} - The result canvas.
     */
    getCroppedCanvas: function getCroppedCanvas() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.ready || !window.HTMLCanvasElement) {
        return null;
      }

      var canvasData = this.canvasData;
      var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.

      if (!this.cropped) {
        return source;
      }

      var _this$getData = this.getData(),
          initialX = _this$getData.x,
          initialY = _this$getData.y,
          initialWidth = _this$getData.width,
          initialHeight = _this$getData.height;

      var ratio = source.width / Math.floor(canvasData.naturalWidth);

      if (ratio !== 1) {
        initialX *= ratio;
        initialY *= ratio;
        initialWidth *= ratio;
        initialHeight *= ratio;
      }

      var aspectRatio = initialWidth / initialHeight;
      var maxSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.maxWidth || Infinity,
        height: options.maxHeight || Infinity
      });
      var minSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.minWidth || 0,
        height: options.minHeight || 0
      }, 'cover');

      var _getAdjustedSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.width || (ratio !== 1 ? source.width : initialWidth),
        height: options.height || (ratio !== 1 ? source.height : initialHeight)
      }),
          width = _getAdjustedSizes.width,
          height = _getAdjustedSizes.height;

      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.width = normalizeDecimalNumber(width);
      canvas.height = normalizeDecimalNumber(height);
      context.fillStyle = options.fillColor || 'transparent';
      context.fillRect(0, 0, width, height);
      var _options$imageSmoothi = options.imageSmoothingEnabled,
          imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,
          imageSmoothingQuality = options.imageSmoothingQuality;
      context.imageSmoothingEnabled = imageSmoothingEnabled;

      if (imageSmoothingQuality) {
        context.imageSmoothingQuality = imageSmoothingQuality;
      } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage


      var sourceWidth = source.width;
      var sourceHeight = source.height; // Source canvas parameters

      var srcX = initialX;
      var srcY = initialY;
      var srcWidth;
      var srcHeight; // Destination canvas parameters

      var dstX;
      var dstY;
      var dstWidth;
      var dstHeight;

      if (srcX <= -initialWidth || srcX > sourceWidth) {
        srcX = 0;
        srcWidth = 0;
        dstX = 0;
        dstWidth = 0;
      } else if (srcX <= 0) {
        dstX = -srcX;
        srcX = 0;
        srcWidth = Math.min(sourceWidth, initialWidth + srcX);
        dstWidth = srcWidth;
      } else if (srcX <= sourceWidth) {
        dstX = 0;
        srcWidth = Math.min(initialWidth, sourceWidth - srcX);
        dstWidth = srcWidth;
      }

      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
        srcY = 0;
        srcHeight = 0;
        dstY = 0;
        dstHeight = 0;
      } else if (srcY <= 0) {
        dstY = -srcY;
        srcY = 0;
        srcHeight = Math.min(sourceHeight, initialHeight + srcY);
        dstHeight = srcHeight;
      } else if (srcY <= sourceHeight) {
        dstY = 0;
        srcHeight = Math.min(initialHeight, sourceHeight - srcY);
        dstHeight = srcHeight;
      }

      var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid "IndexSizeError"

      if (dstWidth > 0 && dstHeight > 0) {
        var scale = width / initialWidth;
        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
      } // All the numerical parameters should be integer for `drawImage`
      // https://github.com/fengyuanchen/cropper/issues/476


      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {
        return Math.floor(normalizeDecimalNumber(param));
      }))));
      return canvas;
    },

    /**
     * Change the aspect ratio of the crop box.
     * @param {number} aspectRatio - The new aspect ratio.
     * @returns {Cropper} this
     */
    setAspectRatio: function setAspectRatio(aspectRatio) {
      var options = this.options;

      if (!this.disabled && !isUndefined(aspectRatio)) {
        // 0 -> NaN
        options.aspectRatio = Math.max(0, aspectRatio) || NaN;

        if (this.ready) {
          this.initCropBox();

          if (this.cropped) {
            this.renderCropBox();
          }
        }
      }

      return this;
    },

    /**
     * Change the drag mode.
     * @param {string} mode - The new drag mode.
     * @returns {Cropper} this
     */
    setDragMode: function setDragMode(mode) {
      var options = this.options,
          dragBox = this.dragBox,
          face = this.face;

      if (this.ready && !this.disabled) {
        var croppable = mode === DRAG_MODE_CROP;
        var movable = options.movable && mode === DRAG_MODE_MOVE;
        mode = croppable || movable ? mode : DRAG_MODE_NONE;
        options.dragMode = mode;
        setData(dragBox, DATA_ACTION, mode);
        toggleClass(dragBox, CLASS_CROP, croppable);
        toggleClass(dragBox, CLASS_MOVE, movable);

        if (!options.cropBoxMovable) {
          // Sync drag mode to crop box when it is not movable
          setData(face, DATA_ACTION, mode);
          toggleClass(face, CLASS_CROP, croppable);
          toggleClass(face, CLASS_MOVE, movable);
        }
      }

      return this;
    }
  };

  var AnotherCropper = WINDOW.Cropper;

  var Cropper = /*#__PURE__*/function () {
    /**
     * Create a new Cropper.
     * @param {Element} element - The target element for cropping.
     * @param {Object} [options={}] - The configuration options.
     */
    function Cropper(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Cropper);

      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
        throw new Error('The first argument is required and must be an <img> or <canvas> element.');
      }

      this.element = element;
      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
      this.cropped = false;
      this.disabled = false;
      this.pointers = {};
      this.ready = false;
      this.reloading = false;
      this.replaced = false;
      this.sized = false;
      this.sizing = false;
      this.init();
    }

    _createClass(Cropper, [{
      key: "init",
      value: function init() {
        var element = this.element;
        var tagName = element.tagName.toLowerCase();
        var url;

        if (element[NAMESPACE]) {
          return;
        }

        element[NAMESPACE] = this;

        if (tagName === 'img') {
          this.isImg = true; // e.g.: "img/picture.jpg"

          url = element.getAttribute('src') || '';
          this.originalUrl = url; // Stop when it's a blank image

          if (!url) {
            return;
          } // e.g.: "https://example.com/img/picture.jpg"


          url = element.src;
        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
          url = element.toDataURL();
        }

        this.load(url);
      }
    }, {
      key: "load",
      value: function load(url) {
        var _this = this;

        if (!url) {
          return;
        }

        this.url = url;
        this.imageData = {};
        var element = this.element,
            options = this.options;

        if (!options.rotatable && !options.scalable) {
          options.checkOrientation = false;
        } // Only IE10+ supports Typed Arrays


        if (!options.checkOrientation || !window.ArrayBuffer) {
          this.clone();
          return;
        } // Detect the mime type of the image directly if it is a Data URL


        if (REGEXP_DATA_URL.test(url)) {
          // Read ArrayBuffer from Data URL of JPEG images directly for better performance
          if (REGEXP_DATA_URL_JPEG.test(url)) {
            this.read(dataURLToArrayBuffer(url));
          } else {
            // Only a JPEG image may contains Exif Orientation information,
            // the rest types of Data URLs are not necessary to check orientation at all.
            this.clone();
          }

          return;
        } // 1. Detect the mime type of the image by a XMLHttpRequest.
        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.


        var xhr = new XMLHttpRequest();
        var clone = this.clone.bind(this);
        this.reloading = true;
        this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:
        // http, https, data, chrome, chrome-extension.
        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy
        // in some browsers as IE11 and Safari.

        xhr.onabort = clone;
        xhr.onerror = clone;
        xhr.ontimeout = clone;

        xhr.onprogress = function () {
          // Abort the request directly if it not a JPEG image for better performance
          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {
            xhr.abort();
          }
        };

        xhr.onload = function () {
          _this.read(xhr.response);
        };

        xhr.onloadend = function () {
          _this.reloading = false;
          _this.xhr = null;
        }; // Bust cache when there is a "crossOrigin" property to avoid browser cache error


        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
          url = addTimestamp(url);
        }

        xhr.open('GET', url);
        xhr.responseType = 'arraybuffer';
        xhr.withCredentials = element.crossOrigin === 'use-credentials';
        xhr.send();
      }
    }, {
      key: "read",
      value: function read(arrayBuffer) {
        var options = this.options,
            imageData = this.imageData; // Reset the orientation value to its default value 1
        // as some iOS browsers will render image with its orientation

        var orientation = resetAndGetOrientation(arrayBuffer);
        var rotate = 0;
        var scaleX = 1;
        var scaleY = 1;

        if (orientation > 1) {
          // Generate a new URL which has the default orientation value
          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);

          var _parseOrientation = parseOrientation(orientation);

          rotate = _parseOrientation.rotate;
          scaleX = _parseOrientation.scaleX;
          scaleY = _parseOrientation.scaleY;
        }

        if (options.rotatable) {
          imageData.rotate = rotate;
        }

        if (options.scalable) {
          imageData.scaleX = scaleX;
          imageData.scaleY = scaleY;
        }

        this.clone();
      }
    }, {
      key: "clone",
      value: function clone() {
        var element = this.element,
            url = this.url;
        var crossOrigin = element.crossOrigin;
        var crossOriginUrl = url;

        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
          if (!crossOrigin) {
            crossOrigin = 'anonymous';
          } // Bust cache when there is not a "crossOrigin" property (#519)


          crossOriginUrl = addTimestamp(url);
        }

        this.crossOrigin = crossOrigin;
        this.crossOriginUrl = crossOriginUrl;
        var image = document.createElement('img');

        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }

        image.src = crossOriginUrl || url;
        image.alt = element.alt || 'The image to crop';
        this.image = image;
        image.onload = this.start.bind(this);
        image.onerror = this.stop.bind(this);
        addClass(image, CLASS_HIDE);
        element.parentNode.insertBefore(image, element.nextSibling);
      }
    }, {
      key: "start",
      value: function start() {
        var _this2 = this;

        var image = this.image;
        image.onload = null;
        image.onerror = null;
        this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,
        // such as Safari for iOS, Chrome for iOS, and in-app browsers.

        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);

        var done = function done(naturalWidth, naturalHeight) {
          assign(_this2.imageData, {
            naturalWidth: naturalWidth,
            naturalHeight: naturalHeight,
            aspectRatio: naturalWidth / naturalHeight
          });
          _this2.sizing = false;
          _this2.sized = true;

          _this2.build();
        }; // Most modern browsers (excepts iOS WebKit)


        if (image.naturalWidth && !isIOSWebKit) {
          done(image.naturalWidth, image.naturalHeight);
          return;
        }

        var sizingImage = document.createElement('img');
        var body = document.body || document.documentElement;
        this.sizingImage = sizingImage;

        sizingImage.onload = function () {
          done(sizingImage.width, sizingImage.height);

          if (!isIOSWebKit) {
            body.removeChild(sizingImage);
          }
        };

        sizingImage.src = image.src; // iOS WebKit will convert the image automatically
        // with its orientation once append it into DOM (#279)

        if (!isIOSWebKit) {
          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
          body.appendChild(sizingImage);
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        var image = this.image;
        image.onload = null;
        image.onerror = null;
        image.parentNode.removeChild(image);
        this.image = null;
      }
    }, {
      key: "build",
      value: function build() {
        if (!this.sized || this.ready) {
          return;
        }

        var element = this.element,
            options = this.options,
            image = this.image; // Create cropper elements

        var container = element.parentNode;
        var template = document.createElement('div');
        template.innerHTML = TEMPLATE;
        var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
        var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
        var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
        var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
        var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
        this.container = container;
        this.cropper = cropper;
        this.canvas = canvas;
        this.dragBox = dragBox;
        this.cropBox = cropBox;
        this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
        this.face = face;
        canvas.appendChild(image); // Hide the original image

        addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image

        container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden

        if (!this.isImg) {
          removeClass(image, CLASS_HIDE);
        }

        this.initPreview();
        this.bind();
        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
        addClass(cropBox, CLASS_HIDDEN);

        if (!options.guides) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
        }

        if (!options.center) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
        }

        if (options.background) {
          addClass(cropper, "".concat(NAMESPACE, "-bg"));
        }

        if (!options.highlight) {
          addClass(face, CLASS_INVISIBLE);
        }

        if (options.cropBoxMovable) {
          addClass(face, CLASS_MOVE);
          setData(face, DATA_ACTION, ACTION_ALL);
        }

        if (!options.cropBoxResizable) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
        }

        this.render();
        this.ready = true;
        this.setDragMode(options.dragMode);

        if (options.autoCrop) {
          this.crop();
        }

        this.setData(options.data);

        if (isFunction(options.ready)) {
          addListener(element, EVENT_READY, options.ready, {
            once: true
          });
        }

        dispatchEvent(element, EVENT_READY);
      }
    }, {
      key: "unbuild",
      value: function unbuild() {
        if (!this.ready) {
          return;
        }

        this.ready = false;
        this.unbind();
        this.resetPreview();
        this.cropper.parentNode.removeChild(this.cropper);
        removeClass(this.element, CLASS_HIDDEN);
      }
    }, {
      key: "uncreate",
      value: function uncreate() {
        if (this.ready) {
          this.unbuild();
          this.ready = false;
          this.cropped = false;
        } else if (this.sizing) {
          this.sizingImage.onload = null;
          this.sizing = false;
          this.sized = false;
        } else if (this.reloading) {
          this.xhr.onabort = null;
          this.xhr.abort();
        } else if (this.image) {
          this.stop();
        }
      }
      /**
       * Get the no conflict cropper class.
       * @returns {Cropper} The cropper class.
       */

    }], [{
      key: "noConflict",
      value: function noConflict() {
        window.Cropper = AnotherCropper;
        return Cropper;
      }
      /**
       * Change the default options.
       * @param {Object} options - The new default options.
       */

    }, {
      key: "setDefaults",
      value: function setDefaults(options) {
        assign(DEFAULTS, isPlainObject(options) && options);
      }
    }]);

    return Cropper;
  }();

  assign(Cropper.prototype, render, preview, events, handlers, change, methods);

  return Cropper;

})));

},{}],6:[function(require,module,exports){
(function (process,global,Buffer){(function (){
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define("exifr",["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).exifr={})}(this,(function(e){"use strict";function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}});var n=["prototype","__proto__","caller","arguments","length","name"];Object.getOwnPropertyNames(t).forEach((function(r){-1===n.indexOf(r)&&e[r]!==t[r]&&(e[r]=t[r])})),t&&u(e,t)}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function o(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function f(e,t,n){return(f=o()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&u(i,n.prototype),i}).apply(null,arguments)}function c(e){var t="function"==typeof Map?new Map:void 0;return(c=function(e){if(null===e||(n=e,-1===Function.toString.call(n).indexOf("[native code]")))return e;var n;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return f(e,arguments,s(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),u(r,e)})(e)}function h(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function l(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?h(e):t}function d(e){var t=o();return function(){var n,r=s(e);if(t){var i=s(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return l(this,n)}}function v(e,t,n){return(v="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=s(e)););return e}(e,t);if(r){var i=Object.getOwnPropertyDescriptor(r,t);return i.get?i.get.call(n):i.value}})(e,t,n||e)}var p=Object.values||function(e){var t=[];for(var n in e)t.push(e[n]);return t},y=Object.entries||function(e){var t=[];for(var n in e)t.push([n,e[n]]);return t},g=Object.assign||function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return n.forEach((function(t){for(var n in t)e[n]=t[n]})),e},k=Object.fromEntries||function(e){var t={};return m(e).forEach((function(e){var n=e[0],r=e[1];t[n]=r})),t},m=Array.from||function(e){if(e instanceof P){var t=[];return e.forEach((function(e,n){return t.push([n,e])})),t}return Array.prototype.slice.call(e)};function b(e){return-1!==this.indexOf(e)}Array.prototype.includes||(Array.prototype.includes=b),String.prototype.includes||(String.prototype.includes=b),String.prototype.startsWith||(String.prototype.startsWith=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.substring(t,t+e.length)===e}),String.prototype.endsWith||(String.prototype.endsWith=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.length;return this.substring(t-e.length,t)===e});var A="undefined"!=typeof self?self:global,w=A.fetch||function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new Promise((function(n,r){var i=new XMLHttpRequest;if(i.open("get",e,!0),i.responseType="arraybuffer",i.onerror=r,t.headers)for(var a in t.headers)i.setRequestHeader(a,t.headers[a]);i.onload=function(){n({ok:i.status>=200&&i.status<300,status:i.status,arrayBuffer:function(){return Promise.resolve(i.response)}})},i.send(null)}))},O=function(e){var t=[];if(Object.defineProperties(t,{size:{get:function(){return this.length}},has:{value:function(e){return-1!==this.indexOf(e)}},add:{value:function(e){this.has(e)||this.push(e)}},delete:{value:function(e){if(this.has(e)){var t=this.indexOf(e);this.splice(t,1)}}}}),Array.isArray(e))for(var n=0;n<e.length;n++)t.add(e[n]);return t},S=function(e){return new P(e)},P=void 0!==A.Map&&void 0!==A.Map.prototype.keys?A.Map:function(){function e(n){if(t(this,e),this.clear(),n)for(var r=0;r<n.length;r++)this.set(n[r][0],n[r][1])}return r(e,[{key:"clear",value:function(){this._map={},this._keys=[]}},{key:"size",get:function(){return this._keys.length}},{key:"get",value:function(e){return this._map["map_"+e]}},{key:"set",value:function(e,t){return this._map["map_"+e]=t,this._keys.indexOf(e)<0&&this._keys.push(e),this}},{key:"has",value:function(e){return this._keys.indexOf(e)>=0}},{key:"delete",value:function(e){var t=this._keys.indexOf(e);return!(t<0)&&(delete this._map["map_"+e],this._keys.splice(t,1),!0)}},{key:"keys",value:function(){return this._keys.slice(0)}},{key:"values",value:function(){var e=this;return this._keys.map((function(t){return e.get(t)}))}},{key:"entries",value:function(){var e=this;return this._keys.map((function(t){return[t,e.get(t)]}))}},{key:"forEach",value:function(e,t){for(var n=0;n<this._keys.length;n++)e.call(t,this._map["map_"+this._keys[n]],this._keys[n],this)}}]),e}(),U="undefined"!=typeof self?self:global,x="undefined"!=typeof navigator,C=x&&"undefined"==typeof HTMLImageElement,B=!("undefined"==typeof global||"undefined"==typeof process||!process.versions||!process.versions.node),j=U.Buffer,_=!!j;var V=function(e){return void 0!==e};function I(e){return void 0===e||(e instanceof P?0===e.size:0===p(e).filter(V).length)}function L(e){var t=new Error(e);throw delete t.stack,t}function T(e){var t=function(e){var t=0;return e.ifd0.enabled&&(t+=1024),e.exif.enabled&&(t+=2048),e.makerNote&&(t+=2048),e.userComment&&(t+=1024),e.gps.enabled&&(t+=512),e.interop.enabled&&(t+=100),e.ifd1.enabled&&(t+=1024),t+2048}(e);return e.jfif.enabled&&(t+=50),e.xmp.enabled&&(t+=2e4),e.iptc.enabled&&(t+=14e3),e.icc.enabled&&(t+=6e3),t}var z=function(e){return String.fromCharCode.apply(null,e)},F="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):void 0;function E(e){return F?F.decode(e):_?Buffer.from(e).toString("utf8"):decodeURIComponent(escape(z(e)))}var D=function(){function e(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(t(this,e),"boolean"==typeof a&&(this.le=a),Array.isArray(n)&&(n=new Uint8Array(n)),0===n)this.byteOffset=0,this.byteLength=0;else if(n instanceof ArrayBuffer){void 0===i&&(i=n.byteLength-r);var s=new DataView(n,r,i);this._swapDataView(s)}else if(n instanceof Uint8Array||n instanceof DataView||n instanceof e){void 0===i&&(i=n.byteLength-r),(r+=n.byteOffset)+i>n.byteOffset+n.byteLength&&L("Creating view outside of available memory in ArrayBuffer");var u=new DataView(n.buffer,r,i);this._swapDataView(u)}else if("number"==typeof n){var o=new DataView(new ArrayBuffer(n));this._swapDataView(o)}else L("Invalid input argument for BufferView: "+n)}return r(e,[{key:"_swapArrayBuffer",value:function(e){this._swapDataView(new DataView(e))}},{key:"_swapBuffer",value:function(e){this._swapDataView(new DataView(e.buffer,e.byteOffset,e.byteLength))}},{key:"_swapDataView",value:function(e){this.dataView=e,this.buffer=e.buffer,this.byteOffset=e.byteOffset,this.byteLength=e.byteLength}},{key:"_lengthToEnd",value:function(e){return this.byteLength-e}},{key:"set",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;t instanceof DataView||t instanceof e?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer&&(t=new Uint8Array(t)),t instanceof Uint8Array||L("BufferView.set(): Invalid data argument.");var i=this.toUint8();return i.set(t,n),new r(this,n,t.byteLength)}},{key:"subarray",value:function(t,n){return new e(this,t,n=n||this._lengthToEnd(t))}},{key:"toUint8",value:function(){return new Uint8Array(this.buffer,this.byteOffset,this.byteLength)}},{key:"getUint8Array",value:function(e,t){return new Uint8Array(this.buffer,this.byteOffset+e,t)}},{key:"getString",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=this.getUint8Array(e,t);return E(n)}},{key:"getLatin1String",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=this.getUint8Array(e,t);return z(n)}},{key:"getUnicodeString",value:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=[],r=0;r<t&&e+r<this.byteLength;r+=2)n.push(this.getUint16(e+r));return z(n)}},{key:"getInt8",value:function(e){return this.dataView.getInt8(e)}},{key:"getUint8",value:function(e){return this.dataView.getUint8(e)}},{key:"getInt16",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getInt16(e,t)}},{key:"getInt32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getInt32(e,t)}},{key:"getUint16",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getUint16(e,t)}},{key:"getUint32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getUint32(e,t)}},{key:"getFloat32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat32(e,t)}},{key:"getFloat64",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat64(e,t)}},{key:"getFloat",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat32(e,t)}},{key:"getDouble",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat64(e,t)}},{key:"getUintBytes",value:function(e,t,n){switch(t){case 1:return this.getUint8(e,n);case 2:return this.getUint16(e,n);case 4:return this.getUint32(e,n);case 8:return this.getUint64&&this.getUint64(e,n)}}},{key:"getUint",value:function(e,t,n){switch(t){case 8:return this.getUint8(e,n);case 16:return this.getUint16(e,n);case 32:return this.getUint32(e,n);case 64:return this.getUint64&&this.getUint64(e,n)}}},{key:"toString",value:function(e){return this.dataView.toString(e,this.constructor.name)}},{key:"ensureChunk",value:function(){}}],[{key:"from",value:function(t,n){return t instanceof this&&t.le===n?t:new e(t,void 0,void 0,n)}}]),e}();function R(e,t){L("".concat(e," '").concat(t,"' was not loaded, try using full build of exifr."))}var N=function(e){a(i,e);var n=d(i);function i(e){var r;return t(this,i),(r=n.call(this)).kind=e,r}return r(i,[{key:"get",value:function(e,t){return this.has(e)||R(this.kind,e),t&&(e in t||function(e,t){L("Unknown ".concat(e," '").concat(t,"'."))}(this.kind,e),t[e].enabled||R(this.kind,e)),v(s(i.prototype),"get",this).call(this,e)}},{key:"keyList",value:function(){return m(this.keys())}}]),i}(c(P)),M=new N("file parser"),W=new N("segment parser"),K=new N("file reader");function H(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}function X(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var Y=H((function(e){return new Promise((function(t,n){var r=new FileReader;r.onloadend=function(){return t(r.result||new ArrayBuffer)},r.onerror=n,r.readAsArrayBuffer(e)}))})),G=H((function(e){return w(e).then((function(e){return e.arrayBuffer()}))})),J=H((function(e,t){return X(t(e),(function(e){return new D(e)}))})),q=H((function(e,t,n){var r=new(K.get(n))(e,t);return X(r.read(),(function(){return r}))})),Q=H((function(e,t,n,r){return K.has(n)?q(e,t,n):r?J(e,r):(L("Parser ".concat(n," is not loaded")),X())})),Z="Invalid input argument";function $(e,t){return(n=e).startsWith("data:")||n.length>1e4?q(e,t,"base64"):x?Q(e,t,"url",G):B?q(e,t,"fs"):void L(Z);var n}var ee=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"tagKeys",get:function(){return this.allKeys||(this.allKeys=m(this.keys())),this.allKeys}},{key:"tagValues",get:function(){return this.allValues||(this.allValues=m(this.values())),this.allValues}}]),i}(c(P));function te(e,t,n){var r=new ee,i=n;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){var s=i[a],u=s[0],o=s[1];r.set(u,o)}if(Array.isArray(t)){var f=t;Array.isArray(f)||("function"==typeof f.entries&&(f=f.entries()),f=m(f));for(var c=0;c<f.length;c++){var h=f[c];e.set(h,r)}}else e.set(t,r);return r}function ne(e,t,n){var r,i=e.get(t),a=n;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)r=a[s],i.set(r[0],r[1])}var re=S(),ie=S(),ae=S(),se=37500,ue=37510,oe=33723,fe=34675,ce=34665,he=34853,le=40965,de=["chunked","firstChunkSize","firstChunkSizeNode","firstChunkSizeBrowser","chunkSize","chunkLimit"],ve=["jfif","xmp","icc","iptc","ihdr"],pe=["tiff"].concat(ve),ye=["ifd0","ifd1","exif","gps","interop"],ge=[].concat(pe,ye),ke=["makerNote","userComment"],me=["translateKeys","translateValues","reviveValues","multiSegment"],be=[].concat(me,["sanitize","mergeOutput","silentErrors"]),Ae=function(){function e(){t(this,e)}return r(e,[{key:"translate",get:function(){return this.translateKeys||this.translateValues||this.reviveValues}}]),e}(),we=function(e){a(s,e);var n=d(s);function s(e,r,a,u){var o;if(t(this,s),i(h(o=n.call(this)),"enabled",!1),i(h(o),"skip",O()),i(h(o),"pick",O()),i(h(o),"deps",O()),i(h(o),"translateKeys",!1),i(h(o),"translateValues",!1),i(h(o),"reviveValues",!1),o.key=e,o.enabled=r,o.parse=o.enabled,o.applyInheritables(u),o.canBeFiltered=ye.includes(e),o.canBeFiltered&&(o.dict=re.get(e)),void 0!==a)if(Array.isArray(a))o.parse=o.enabled=!0,o.canBeFiltered&&a.length>0&&o.translateTagSet(a,o.pick);else if("object"==typeof a){if(o.enabled=!0,o.parse=!1!==a.parse,o.canBeFiltered){var f=a.pick,c=a.skip;f&&f.length>0&&o.translateTagSet(f,o.pick),c&&c.length>0&&o.translateTagSet(c,o.skip)}o.applyInheritables(a)}else!0===a||!1===a?o.parse=o.enabled=a:L("Invalid options argument: ".concat(a));return o}return r(s,[{key:"needed",get:function(){return this.enabled||this.deps.size>0}},{key:"applyInheritables",value:function(e){var t,n,r=me;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)void 0!==(n=e[t=r[i]])&&(this[t]=n)}},{key:"translateTagSet",value:function(e,t){if(this.dict){var n,r,i=this.dict,a=i.tagKeys,s=i.tagValues,u=e;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)"string"==typeof(n=u[o])?(-1===(r=s.indexOf(n))&&(r=a.indexOf(Number(n))),-1!==r&&t.add(Number(a[r]))):t.add(n)}else{var f=e;Array.isArray(f)||("function"==typeof f.entries&&(f=f.entries()),f=m(f));for(var c=0;c<f.length;c++){var h=f[c];t.add(h)}}}},{key:"finalizeFilters",value:function(){!this.enabled&&this.deps.size>0?(this.enabled=!0,Ce(this.pick,this.deps)):this.enabled&&this.pick.size>0&&Ce(this.pick,this.deps)}}]),s}(Ae),Oe={jfif:!1,tiff:!0,xmp:!1,icc:!1,iptc:!1,ifd0:!0,ifd1:!1,exif:!0,gps:!0,interop:!1,ihdr:void 0,makerNote:!1,userComment:!1,multiSegment:!1,skip:[],pick:[],translateKeys:!0,translateValues:!0,reviveValues:!0,sanitize:!0,mergeOutput:!0,silentErrors:!0,chunked:!0,firstChunkSize:void 0,firstChunkSizeNode:512,firstChunkSizeBrowser:65536,chunkSize:65536,chunkLimit:5},Se=S(),Pe=function(e){a(i,e);var n=d(i);function i(e){var r;return t(this,i),r=n.call(this),!0===e?r.setupFromTrue():void 0===e?r.setupFromUndefined():Array.isArray(e)?r.setupFromArray(e):"object"==typeof e?r.setupFromObject(e):L("Invalid options argument ".concat(e)),void 0===r.firstChunkSize&&(r.firstChunkSize=x?r.firstChunkSizeBrowser:r.firstChunkSizeNode),r.mergeOutput&&(r.ifd1.enabled=!1),r.filterNestedSegmentTags(),r.traverseTiffDependencyTree(),r.checkLoadedPlugins(),r}return r(i,[{key:"setupFromUndefined",value:function(){var e,t=de;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++)this[e=t[n]]=Oe[e];var r=be;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)this[e=r[i]]=Oe[e];var a=ke;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)this[e=a[s]]=Oe[e];var u=ge;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)this[e=u[o]]=new we(e,Oe[e],void 0,this)}},{key:"setupFromTrue",value:function(){var e,t=de;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++)this[e=t[n]]=Oe[e];var r=be;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)this[e=r[i]]=Oe[e];var a=ke;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)this[e=a[s]]=!0;var u=ge;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)this[e=u[o]]=new we(e,!0,void 0,this)}},{key:"setupFromArray",value:function(e){var t,n=de;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++)this[t=n[r]]=Oe[t];var i=be;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)this[t=i[a]]=Oe[t];var s=ke;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++)this[t=s[u]]=Oe[t];var o=ge;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)this[t=o[f]]=new we(t,!1,void 0,this);this.setupGlobalFilters(e,void 0,ye)}},{key:"setupFromObject",value:function(e){var t;ye.ifd0=ye.ifd0||ye.image,ye.ifd1=ye.ifd1||ye.thumbnail,g(this,e);var n=de;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++)this[t=n[r]]=xe(e[t],Oe[t]);var i=be;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)this[t=i[a]]=xe(e[t],Oe[t]);var s=ke;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++)this[t=s[u]]=xe(e[t],Oe[t]);var o=pe;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)this[t=o[f]]=new we(t,Oe[t],e[t],this);var c=ye;Array.isArray(c)||("function"==typeof c.entries&&(c=c.entries()),c=m(c));for(var h=0;h<c.length;h++)this[t=c[h]]=new we(t,Oe[t],e[t],this.tiff);this.setupGlobalFilters(e.pick,e.skip,ye,ge),!0===e.tiff?this.batchEnableWithBool(ye,!0):!1===e.tiff?this.batchEnableWithUserValue(ye,e):Array.isArray(e.tiff)?this.setupGlobalFilters(e.tiff,void 0,ye):"object"==typeof e.tiff&&this.setupGlobalFilters(e.tiff.pick,e.tiff.skip,ye)}},{key:"batchEnableWithBool",value:function(e,t){var n=e;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){this[n[r]].enabled=t}}},{key:"batchEnableWithUserValue",value:function(e,t){var n=e;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=t[i];this[i].enabled=!1!==a&&void 0!==a}}},{key:"setupGlobalFilters",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;if(e&&e.length){var i=r;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){var s=i[a];this[s].enabled=!1}var u=Ue(e,n),o=u;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++){var c=o[f],h=c[0],l=c[1];Ce(this[h].pick,l),this[h].enabled=!0}}else if(t&&t.length){var d=Ue(t,n),v=d;Array.isArray(v)||("function"==typeof v.entries&&(v=v.entries()),v=m(v));for(var p=0;p<v.length;p++){var y=v[p],g=y[0],k=y[1];Ce(this[g].skip,k)}}}},{key:"filterNestedSegmentTags",value:function(){var e=this.ifd0,t=this.exif,n=this.xmp,r=this.iptc,i=this.icc;this.makerNote?t.deps.add(se):t.skip.add(se),this.userComment?t.deps.add(ue):t.skip.add(ue),n.enabled||e.skip.add(700),r.enabled||e.skip.add(oe),i.enabled||e.skip.add(fe)}},{key:"traverseTiffDependencyTree",value:function(){var e=this,t=this.ifd0,n=this.exif,r=this.gps;this.interop.needed&&(n.deps.add(le),t.deps.add(le)),n.needed&&t.deps.add(ce),r.needed&&t.deps.add(he),this.tiff.enabled=ye.some((function(t){return!0===e[t].enabled}))||this.makerNote||this.userComment;var i=ye;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){this[i[a]].finalizeFilters()}}},{key:"onlyTiff",get:function(){var e=this;return!ve.map((function(t){return e[t].enabled})).some((function(e){return!0===e}))&&this.tiff.enabled}},{key:"checkLoadedPlugins",value:function(){var e=pe;Array.isArray(e)||("function"==typeof e.entries&&(e=e.entries()),e=m(e));for(var t=0;t<e.length;t++){var n=e[t];this[n].enabled&&!W.has(n)&&R("segment parser",n)}}}],[{key:"useCached",value:function(e){var t=Se.get(e);return void 0!==t||(t=new this(e),Se.set(e,t)),t}}]),i}(Ae);function Ue(e,t){var n,r,i,a=[],s=t;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++){r=s[u],n=[];var o=re.get(r);Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)i=o[f],(e.includes(i[0])||e.includes(i[1]))&&n.push(i[0]);n.length&&a.push([r,n])}return a}function xe(e,t){return void 0!==e?e:void 0!==t?t:void 0}function Ce(e,t){var n=t;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r];e.add(i)}}function Be(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}function je(){}function _e(e,t){if(!t)return e&&e.then?e.then(je):Promise.resolve()}function Ve(e,t){var n=e();return n&&n.then?n.then(t):t(n)}i(Pe,"default",Oe);var Ie=function(){function e(n){t(this,e),i(this,"parsers",{}),this.options=Pe.useCached(n)}return r(e,[{key:"setup",value:function(){if(!this.fileParser){var e=this.file,t=e.getUint16(0),n=M;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=i[0],s=i[1];if(s.canHandle(e,t))return this.fileParser=new s(this.options,this.file,this.parsers),e[a]=!0}L("Unknown file format")}}},{key:"read",value:function(e){try{var t=this;return Be(function(e,t){return"string"==typeof e?$(e,t):x&&!C&&e instanceof HTMLImageElement?$(e.src,t):e instanceof Uint8Array||e instanceof ArrayBuffer||e instanceof DataView?new D(e):x&&e instanceof Blob?Q(e,t,"blob",Y):void L(Z)}(e,t.options),(function(e){t.file=e}))}catch(e){return Promise.reject(e)}}},{key:"parse",value:function(){try{var e=this;e.setup();var t={},n=[];return Ve((function(){return e.options.silentErrors?Be(e.doParse(t,n).catch((function(e){return n.push(e)})),(function(){n.push.apply(n,e.fileParser.errors)})):_e(e.doParse(t,n))}),(function(){return e.file.close&&e.file.close(),e.options.silentErrors&&n.length>0&&(t.errors=n),I(r=t)?void 0:r;var r}))}catch(e){return Promise.reject(e)}}},{key:"doParse",value:function(e,t){try{var n=this;return Be(n.fileParser.parse(),(function(){var r,i=p(n.parsers).map((r=function(t){return Be(t.parse(),(function(n){t.assignToOutput(e,n)}))},function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];try{return Promise.resolve(r.apply(this,e))}catch(e){return Promise.reject(e)}}));if(n.options.silentErrors){var a=function(e){return t.push(e)};i=i.map((function(e){return e.catch(a)}))}return _e(Promise.all(i))}))}catch(e){return Promise.reject(e)}}},{key:"extractThumbnail",value:function(){try{var e=this;e.setup();var t,n=e.options,r=e.file,i=W.get("tiff",n);return Ve((function(){if(!r.tiff)return function(e){var t=e();if(t&&t.then)return t.then(je)}((function(){if(r.jpeg)return Be(e.fileParser.getOrFindSegment("tiff"),(function(e){t=e}))}));t={start:0,type:"tiff"}}),(function(){if(void 0!==t)return Be(e.fileParser.ensureSegmentChunk(t),(function(t){return Be((e.parsers.tiff=new i(t,n,r)).extractThumbnail(),(function(e){return r.close&&r.close(),e}))}))}))}catch(e){return Promise.reject(e)}}}]),e}();var Le,Te=(Le=function(e,t){var n,r,i,a=new Ie(t);return n=a.read(e),r=function(){return a.parse()},i?r?r(n):n:(n&&n.then||(n=Promise.resolve(n)),r?n.then(r):n)},function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];try{return Promise.resolve(Le.apply(this,e))}catch(e){return Promise.reject(e)}}),ze=Object.freeze({__proto__:null,parse:Te,Exifr:Ie,fileParsers:M,segmentParsers:W,fileReaders:K,tagKeys:re,tagValues:ie,tagRevivers:ae,createDictionary:te,extendDictionary:ne,fetchUrlAsArrayBuffer:G,readBlobAsArrayBuffer:Y,chunkedProps:de,otherSegments:ve,segments:pe,tiffBlocks:ye,segmentsAndBlocks:ge,tiffExtractables:ke,inheritables:me,allFormatters:be,Options:Pe});function Fe(){}var Ee=function(){function e(n,r,a){var s=this;t(this,e),i(this,"errors",[]),i(this,"ensureSegmentChunk",function(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}((function(e){var t,n,r,i=e.start,a=e.size||65536;return t=function(){if(s.file.chunked)return function(e){var t=e();if(t&&t.then)return t.then(Fe)}((function(){if(!s.file.available(i,a))return function(e){if(e&&e.then)return e.then(Fe)}(function(e,t){try{var n=e()}catch(e){return t(e)}return n&&n.then?n.then(void 0,t):n}((function(){return t=s.file.readChunk(i,a),n=function(t){e.chunk=t},r?n?n(t):t:(t&&t.then||(t=Promise.resolve(t)),n?t.then(n):t);var t,n,r}),(function(t){L("Couldn't read segment: ".concat(JSON.stringify(e),". ").concat(t.message))})));e.chunk=s.file.subarray(i,a)}));s.file.byteLength>i+a?e.chunk=s.file.subarray(i,a):void 0===e.size?e.chunk=s.file.subarray(i):L("Segment unreachable: "+JSON.stringify(e))},n=function(){return e.chunk},(r=t())&&r.then?r.then(n):n(r)}))),this.extendOptions&&this.extendOptions(n),this.options=n,this.file=r,this.parsers=a}return r(e,[{key:"injectSegment",value:function(e,t){this.options[e].enabled&&this.createParser(e,t)}},{key:"createParser",value:function(e,t){var n=new(W.get(e))(t,this.options,this.file);return this.parsers[e]=n}},{key:"createParsers",value:function(e){var t=e;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++){var r=t[n],i=r.type,a=r.chunk,s=this.options[i];if(s&&s.enabled){var u=this.parsers[i];u&&u.append||u||this.createParser(i,a)}}}},{key:"readSegments",value:function(e){try{var t=e.map(this.ensureSegmentChunk);return function(e,t){if(!t)return e&&e.then?e.then(Fe):Promise.resolve()}(Promise.all(t))}catch(e){return Promise.reject(e)}}}]),e}(),De=function(){function e(n){var r=this,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=arguments.length>2?arguments[2]:void 0;t(this,e),i(this,"errors",[]),i(this,"raw",S()),i(this,"handleError",(function(e){if(!r.options.silentErrors)throw e;r.errors.push(e.message)})),this.chunk=this.normalizeInput(n),this.file=s,this.type=this.constructor.type,this.globalOptions=this.options=a,this.localOptions=a[this.type],this.canTranslate=this.localOptions&&this.localOptions.translate}return r(e,[{key:"normalizeInput",value:function(e){return e instanceof D?e:new D(e)}},{key:"translate",value:function(){this.canTranslate&&(this.translated=this.translateBlock(this.raw,this.type))}},{key:"output",get:function(){return this.translated?this.translated:this.raw?k(this.raw):void 0}},{key:"translateBlock",value:function(e,t){var n=ae.get(t),r=ie.get(t),i=re.get(t),a=this.options[t],s=a.reviveValues&&!!n,u=a.translateValues&&!!r,o=a.translateKeys&&!!i,f={},c=e;Array.isArray(c)||("function"==typeof c.entries&&(c=c.entries()),c=m(c));for(var h=0;h<c.length;h++){var l=c[h],d=l[0],v=l[1];s&&n.has(d)?v=n.get(d)(v):u&&r.has(d)&&(v=this.translateValue(v,r.get(d))),o&&i.has(d)&&(d=i.get(d)||d),f[d]=v}return f}},{key:"translateValue",value:function(e,t){return t[e]||t.DEFAULT||e}},{key:"assignToOutput",value:function(e,t){this.assignObjectToOutput(e,this.constructor.type,t)}},{key:"assignObjectToOutput",value:function(e,t,n){if(this.globalOptions.mergeOutput)return g(e,n);e[t]?g(e[t],n):e[t]=n}}],[{key:"findPosition",value:function(e,t){var n=e.getUint16(t+2)+2,r="function"==typeof this.headerLength?this.headerLength(e,t,n):this.headerLength,i=t+r,a=n-r;return{offset:t,length:n,headerLength:r,start:i,size:a,end:i+a}}},{key:"parse",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=new Pe(i({},this.type,t)),r=new this(e,n);return r.parse()}}]),e}();function Re(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}i(De,"headerLength",4),i(De,"type",void 0),i(De,"multiSegment",!1),i(De,"canHandle",(function(){return!1}));function Ne(){}function Me(e,t){if(!t)return e&&e.then?e.then(Ne):Promise.resolve()}function We(e){var t=e();if(t&&t.then)return t.then(Ne)}function Ke(e,t){var n=e();return n&&n.then?n.then(t):t(n)}function He(e,t,n){if(!e.s){if(n instanceof Xe){if(!n.s)return void(n.o=He.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(He.bind(null,e,t),He.bind(null,e,2));e.s=t,e.v=n;var r=e.o;r&&r(e)}}var Xe=function(){function e(){}return e.prototype.then=function(t,n){var r=new e,i=this.s;if(i){var a=1&i?t:n;if(a){try{He(r,1,a(this.v))}catch(e){He(r,2,e)}return r}return this}return this.o=function(e){try{var i=e.v;1&e.s?He(r,1,t?t(i):i):n?He(r,1,n(i)):He(r,2,i)}catch(e){He(r,2,e)}},r},e}();function Ye(e){return e instanceof Xe&&1&e.s}function Ge(e,t,n){for(var r;;){var i=e();if(Ye(i)&&(i=i.v),!i)return a;if(i.then){r=0;break}var a=n();if(a&&a.then){if(!Ye(a)){r=1;break}a=a.s}if(t){var s=t();if(s&&s.then&&!Ye(s)){r=2;break}}}var u=new Xe,o=He.bind(null,u,2);return(0===r?i.then(c):1===r?a.then(f):s.then(h)).then(void 0,o),u;function f(r){a=r;do{if(t&&(s=t())&&s.then&&!Ye(s))return void s.then(h).then(void 0,o);if(!(i=e())||Ye(i)&&!i.v)return void He(u,1,a);if(i.then)return void i.then(c).then(void 0,o);Ye(a=n())&&(a=a.v)}while(!a||!a.then);a.then(f).then(void 0,o)}function c(e){e?(a=n())&&a.then?a.then(f).then(void 0,o):f(a):He(u,1,a)}function h(){(i=e())?i.then?i.then(c).then(void 0,o):c(i):He(u,1,a)}}function Je(e){return 192===e||194===e||196===e||219===e||221===e||218===e||254===e}function qe(e){return e>=224&&e<=239}function Qe(e,t,n){var r=W;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++){var a=r[i],s=a[0];if(a[1].canHandle(e,t,n))return s}}var Ze=function(e){a(s,e);var n=d(s);function s(){var e;t(this,s);for(var r=arguments.length,a=new Array(r),u=0;u<r;u++)a[u]=arguments[u];return i(h(e=n.call.apply(n,[this].concat(a))),"appSegments",[]),i(h(e),"jpegSegments",[]),i(h(e),"unknownSegments",[]),e}return r(s,[{key:"parse",value:function(){try{var e=this;return Re(e.findAppSegments(),(function(){return Re(e.readSegments(e.appSegments),(function(){e.mergeMultiSegments(),e.createParsers(e.mergedAppSegments||e.appSegments)}))}))}catch(e){return Promise.reject(e)}}},{key:"setupSegmentFinderArgs",value:function(e){var t=this;!0===e?(this.findAll=!0,this.wanted=O(W.keyList())):(e=void 0===e?W.keyList().filter((function(e){return t.options[e].enabled})):e.filter((function(e){return t.options[e].enabled&&W.has(e)})),this.findAll=!1,this.remaining=O(e),this.wanted=O(e)),this.unfinishedMultiSegment=!1}},{key:"findAppSegments",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;try{var n=this;n.setupSegmentFinderArgs(t);var r=n.file,i=n.findAll,a=n.wanted,s=n.remaining;return Ke((function(){if(!i&&n.file.chunked)return i=m(a).some((function(e){var t=W.get(e),r=n.options[e];return t.multiSegment&&r.multiSegment})),We((function(){if(i)return Me(n.file.readWhole())}))}),(function(){var t=!1;if(e=n.findAppSegmentsInRange(e,r.byteLength),!n.options.onlyTiff)return function(){if(r.chunked){var i=!1;return Ge((function(){return!t&&s.size>0&&!i&&(!!r.canReadNextChunk||!!n.unfinishedMultiSegment)}),void 0,(function(){var a=r.nextChunkOffset,s=n.appSegments.some((function(e){return!n.file.available(e.offset||e.start,e.length||e.size)}));return Ke((function(){return e>a&&!s?Re(r.readNextChunk(e),(function(e){i=!e})):Re(r.readNextChunk(a),(function(e){i=!e}))}),(function(){void 0===(e=n.findAppSegmentsInRange(e,r.byteLength))&&(t=!0)}))}))}}()}))}catch(e){return Promise.reject(e)}}},{key:"findAppSegmentsInRange",value:function(e,t){t-=2;for(var n,r,i,a,s,u,o=this.file,f=this.findAll,c=this.wanted,h=this.remaining,l=this.options;e<t;e++)if(255===o.getUint8(e))if(qe(n=o.getUint8(e+1))){if(r=o.getUint16(e+2),(i=Qe(o,e,r))&&c.has(i)&&(s=(a=W.get(i)).findPosition(o,e),u=l[i],s.type=i,this.appSegments.push(s),!f&&(a.multiSegment&&u.multiSegment?(this.unfinishedMultiSegment=s.chunkNumber<s.chunkCount,this.unfinishedMultiSegment||h.delete(i)):h.delete(i),0===h.size)))break;l.recordUnknownSegments&&((s=De.findPosition(o,e)).marker=n,this.unknownSegments.push(s)),e+=r+1}else if(Je(n)){if(r=o.getUint16(e+2),218===n&&!1!==l.stopAfterSos)return;l.recordJpegSegments&&this.jpegSegments.push({offset:e,length:r,marker:n}),e+=r+1}return e}},{key:"mergeMultiSegments",value:function(){var e=this;if(this.appSegments.some((function(e){return e.multiSegment}))){var t=function(e,t){for(var n,r,i,a=S(),s=0;s<e.length;s++)r=(n=e[s])[t],a.has(r)?i=a.get(r):a.set(r,i=[]),i.push(n);return m(a)}(this.appSegments,"type");this.mergedAppSegments=t.map((function(t){var n=t[0],r=t[1],i=W.get(n,e.options);return i.handleMultiSegments?{type:n,chunk:i.handleMultiSegments(r)}:r[0]}))}}},{key:"getSegment",value:function(e){return this.appSegments.find((function(t){return t.type===e}))}},{key:"getOrFindSegment",value:function(e){try{var t=this,n=t.getSegment(e);return Ke((function(){if(void 0===n)return Re(t.findAppSegments(0,[e]),(function(){n=t.getSegment(e)}))}),(function(){return n}))}catch(e){return Promise.reject(e)}}}],[{key:"canHandle",value:function(e,t){return 65496===t}}]),s}(Ee);function $e(){}i(Ze,"type","jpeg"),M.set("jpeg",Ze);function et(e,t){if(!t)return e&&e.then?e.then($e):Promise.resolve()}function tt(e,t){var n=e();return n&&n.then?n.then(t):t(n)}var nt=[void 0,1,1,2,4,8,1,1,2,4,8,4,8,4];var rt=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"parse",value:function(){try{var e=this;e.parseHeader();var t=e.options;return tt((function(){if(t.ifd0.enabled)return et(e.parseIfd0Block())}),(function(){return tt((function(){if(t.exif.enabled)return et(e.safeParse("parseExifBlock"))}),(function(){return tt((function(){if(t.gps.enabled)return et(e.safeParse("parseGpsBlock"))}),(function(){return tt((function(){if(t.interop.enabled)return et(e.safeParse("parseInteropBlock"))}),(function(){return tt((function(){if(t.ifd1.enabled)return et(e.safeParse("parseThumbnailBlock"))}),(function(){return e.createOutput()}))}))}))}))}))}catch(e){return Promise.reject(e)}}},{key:"safeParse",value:function(e){var t=this[e]();return void 0!==t.catch&&(t=t.catch(this.handleError)),t}},{key:"findIfd0Offset",value:function(){void 0===this.ifd0Offset&&(this.ifd0Offset=this.chunk.getUint32(4))}},{key:"findIfd1Offset",value:function(){if(void 0===this.ifd1Offset){this.findIfd0Offset();var e=this.chunk.getUint16(this.ifd0Offset),t=this.ifd0Offset+2+12*e;this.ifd1Offset=this.chunk.getUint32(t)}}},{key:"parseBlock",value:function(e,t){var n=S();return this[t]=n,this.parseTags(e,t,n),n}},{key:"parseIfd0Block",value:function(){try{var e=this;if(e.ifd0)return;var t=e.file;return e.findIfd0Offset(),e.ifd0Offset<8&&L("Malformed EXIF data"),!t.chunked&&e.ifd0Offset>t.byteLength&&L("IFD0 offset points to outside of file.\nthis.ifd0Offset: ".concat(e.ifd0Offset,", file.byteLength: ").concat(t.byteLength)),tt((function(){if(t.tiff)return et(t.ensureChunk(e.ifd0Offset,T(e.options)))}),(function(){var t=e.parseBlock(e.ifd0Offset,"ifd0");if(0!==t.size)return e.exifOffset=t.get(ce),e.interopOffset=t.get(le),e.gpsOffset=t.get(he),e.xmp=t.get(700),e.iptc=t.get(oe),e.icc=t.get(fe),e.options.sanitize&&(t.delete(ce),t.delete(le),t.delete(he),t.delete(700),t.delete(oe),t.delete(fe)),t}))}catch(e){return Promise.reject(e)}}},{key:"parseExifBlock",value:function(){try{var e=this;if(e.exif)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){if(void 0!==e.exifOffset)return tt((function(){if(e.file.tiff)return et(e.file.ensureChunk(e.exifOffset,T(e.options)))}),(function(){var t=e.parseBlock(e.exifOffset,"exif");return e.interopOffset||(e.interopOffset=t.get(le)),e.makerNote=t.get(se),e.userComment=t.get(ue),e.options.sanitize&&(t.delete(le),t.delete(se),t.delete(ue)),e.unpack(t,41728),e.unpack(t,41729),t}))}))}catch(e){return Promise.reject(e)}}},{key:"unpack",value:function(e,t){var n=e.get(t);n&&1===n.length&&e.set(t,n[0])}},{key:"parseGpsBlock",value:function(){try{var e=this;if(e.gps)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){if(void 0!==e.gpsOffset){var t=e.parseBlock(e.gpsOffset,"gps");return t&&t.has(2)&&t.has(4)&&(t.set("latitude",it.apply(void 0,t.get(2).concat([t.get(1)]))),t.set("longitude",it.apply(void 0,t.get(4).concat([t.get(3)])))),t}}))}catch(e){return Promise.reject(e)}}},{key:"parseInteropBlock",value:function(){try{var e=this;if(e.interop)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){return tt((function(){if(void 0===e.interopOffset&&!e.exif)return et(e.parseExifBlock())}),(function(){if(void 0!==e.interopOffset)return e.parseBlock(e.interopOffset,"interop")}))}))}catch(e){return Promise.reject(e)}}},{key:"parseThumbnailBlock",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];try{var t=this;if(t.ifd1||t.ifd1Parsed)return;if(t.options.mergeOutput&&!e)return;return t.findIfd1Offset(),t.ifd1Offset>0&&(t.parseBlock(t.ifd1Offset,"ifd1"),t.ifd1Parsed=!0),t.ifd1}catch(e){return Promise.reject(e)}}},{key:"extractThumbnail",value:function(){try{var e=this;return e.headerParsed||e.parseHeader(),tt((function(){if(!e.ifd1Parsed)return et(e.parseThumbnailBlock(!0))}),(function(){if(void 0!==e.ifd1){var t=e.ifd1.get(513),n=e.ifd1.get(514);return e.chunk.getUint8Array(t,n)}}))}catch(e){return Promise.reject(e)}}},{key:"image",get:function(){return this.ifd0}},{key:"thumbnail",get:function(){return this.ifd1}},{key:"createOutput",value:function(){var e,t,n,r={},i=ye;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)if(!I(e=this[t=i[a]]))if(n=this.canTranslate?this.translateBlock(e,t):k(e),this.options.mergeOutput){if("ifd1"===t)continue;g(r,n)}else r[t]=n;return this.makerNote&&(r.makerNote=this.makerNote),this.userComment&&(r.userComment=this.userComment),r}},{key:"assignToOutput",value:function(e,t){if(this.globalOptions.mergeOutput)g(e,t);else{var n=y(t);Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=i[0],s=i[1];this.assignObjectToOutput(e,a,s)}}}}],[{key:"canHandle",value:function(e,t){return 225===e.getUint8(t+1)&&1165519206===e.getUint32(t+4)&&0===e.getUint16(t+8)}}]),i}(function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"parseHeader",value:function(){var e=this.chunk.getUint16();18761===e?this.le=!0:19789===e&&(this.le=!1),this.chunk.le=this.le,this.headerParsed=!0}},{key:"parseTags",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:S(),r=this.options[t],i=r.pick,a=r.skip,s=(i=O(i)).size>0,u=0===a.size,o=this.chunk.getUint16(e);e+=2;for(var f=0;f<o;f++){var c=this.chunk.getUint16(e);if(s){if(i.has(c)&&(n.set(c,this.parseTag(e,c,t)),i.delete(c),0===i.size))break}else!u&&a.has(c)||n.set(c,this.parseTag(e,c,t));e+=12}return n}},{key:"parseTag",value:function(e,t,n){var r,i=this.chunk,a=i.getUint16(e+2),s=i.getUint32(e+4),u=nt[a];if(u*s<=4?e+=8:e=i.getUint32(e+8),(a<1||a>13)&&L("Invalid TIFF value type. block: ".concat(n.toUpperCase(),", tag: ").concat(t.toString(16),", type: ").concat(a,", offset ").concat(e)),e>i.byteLength&&L("Invalid TIFF value offset. block: ".concat(n.toUpperCase(),", tag: ").concat(t.toString(16),", type: ").concat(a,", offset ").concat(e," is outside of chunk size ").concat(i.byteLength)),1===a)return i.getUint8Array(e,s);if(2===a)return""===(r=function(e){for(;e.endsWith("\0");)e=e.slice(0,-1);return e}(r=i.getString(e,s)).trim())?void 0:r;if(7===a)return i.getUint8Array(e,s);if(1===s)return this.parseTagValue(a,e);for(var o=new(function(e){switch(e){case 1:return Uint8Array;case 3:return Uint16Array;case 4:return Uint32Array;case 5:return Array;case 6:return Int8Array;case 8:return Int16Array;case 9:return Int32Array;case 10:return Array;case 11:return Float32Array;case 12:return Float64Array;default:return Array}}(a))(s),f=u,c=0;c<s;c++)o[c]=this.parseTagValue(a,e),e+=f;return o}},{key:"parseTagValue",value:function(e,t){var n=this.chunk;switch(e){case 1:return n.getUint8(t);case 3:return n.getUint16(t);case 4:return n.getUint32(t);case 5:return n.getUint32(t)/n.getUint32(t+4);case 6:return n.getInt8(t);case 8:return n.getInt16(t);case 9:return n.getInt32(t);case 10:return n.getInt32(t)/n.getInt32(t+4);case 11:return n.getFloat(t);case 12:return n.getDouble(t);case 13:return n.getUint32(t);default:L("Invalid tiff type ".concat(e))}}}]),i}(De));function it(e,t,n,r){var i=e+t/60+n/3600;return"S"!==r&&"W"!==r||(i*=-1),i}i(rt,"type","tiff"),i(rt,"headerLength",10),W.set("tiff",rt);var at=Object.freeze({__proto__:null,default:ze,Exifr:Ie,fileParsers:M,segmentParsers:W,fileReaders:K,tagKeys:re,tagValues:ie,tagRevivers:ae,createDictionary:te,extendDictionary:ne,fetchUrlAsArrayBuffer:G,readBlobAsArrayBuffer:Y,chunkedProps:de,otherSegments:ve,segments:pe,tiffBlocks:ye,segmentsAndBlocks:ge,tiffExtractables:ke,inheritables:me,allFormatters:be,Options:Pe,parse:Te});function st(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}function ut(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}var ot=ut((function(e){var t=new Ie(vt);return st(t.read(e),(function(){return st(t.parse(),(function(e){if(e&&e.ifd0)return e.ifd0[274]}))}))})),ft=ut((function(e){var t=new Ie(dt);return st(t.read(e),(function(){return st(t.parse(),(function(e){if(e&&e.gps){var t=e.gps;return{latitude:t.latitude,longitude:t.longitude}}}))}))})),ct=ut((function(e){return st(this.thumbnail(e),(function(e){if(void 0!==e){var t=new Blob([e]);return URL.createObjectURL(t)}}))})),ht=ut((function(e){var t=new Ie(pt);return st(t.read(e),(function(){return st(t.extractThumbnail(),(function(e){return e&&_?j.from(e):e}))}))})),lt={ifd0:!1,ifd1:!1,exif:!1,gps:!1,interop:!1,sanitize:!1,reviveValues:!0,translateKeys:!1,translateValues:!1,mergeOutput:!1},dt=g({},lt,{firstChunkSize:4e4,gps:[1,2,3,4]}),vt=g({},lt,{firstChunkSize:4e4,ifd0:[274]}),pt=g({},lt,{tiff:!1,ifd1:!0,mergeOutput:!1}),yt=Object.freeze({1:{dimensionSwapped:!1,scaleX:1,scaleY:1,deg:0,rad:0},2:{dimensionSwapped:!1,scaleX:-1,scaleY:1,deg:0,rad:0},3:{dimensionSwapped:!1,scaleX:1,scaleY:1,deg:180,rad:180*Math.PI/180},4:{dimensionSwapped:!1,scaleX:-1,scaleY:1,deg:180,rad:180*Math.PI/180},5:{dimensionSwapped:!0,scaleX:1,scaleY:-1,deg:90,rad:90*Math.PI/180},6:{dimensionSwapped:!0,scaleX:1,scaleY:1,deg:90,rad:90*Math.PI/180},7:{dimensionSwapped:!0,scaleX:1,scaleY:-1,deg:270,rad:270*Math.PI/180},8:{dimensionSwapped:!0,scaleX:1,scaleY:1,deg:270,rad:270*Math.PI/180}});if(e.rotateCanvas=!0,e.rotateCss=!0,"object"==typeof navigator){var gt=navigator.userAgent;if(gt.includes("iPad")||gt.includes("iPhone")){var kt=gt.match(/OS (\d+)_(\d+)/);if(kt){var mt=kt[1],bt=kt[2],At=Number(mt)+.1*Number(bt);e.rotateCanvas=At<13.4,e.rotateCss=!1}}else if(gt.includes("OS X 10")){var wt=gt.match(/OS X 10[_.](\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(wt)<15}if(gt.includes("Chrome/")){var Ot=gt.match(/Chrome\/(\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(Ot)<81}else if(gt.includes("Firefox/")){var St=gt.match(/Firefox\/(\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(St)<77}}function Pt(){}var Ut=function(e){a(u,e);var n=d(u);function u(){var e;t(this,u);for(var r=arguments.length,a=new Array(r),s=0;s<r;s++)a[s]=arguments[s];return i(h(e=n.call.apply(n,[this].concat(a))),"ranges",new xt),0!==e.byteLength&&e.ranges.add(0,e.byteLength),e}return r(u,[{key:"_tryExtend",value:function(e,t,n){if(0===e&&0===this.byteLength&&n){var r=new DataView(n.buffer||n,n.byteOffset,n.byteLength);this._swapDataView(r)}else{var i=e+t;if(i>this.byteLength){var a=this._extend(i).dataView;this._swapDataView(a)}}}},{key:"_extend",value:function(e){var t;t=_?j.allocUnsafe(e):new Uint8Array(e);var n=new DataView(t.buffer,t.byteOffset,t.byteLength);return t.set(new Uint8Array(this.buffer,this.byteOffset,this.byteLength),0),{uintView:t,dataView:n}}},{key:"subarray",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t=t||this._lengthToEnd(e),n&&this._tryExtend(e,t),this.ranges.add(e,t),v(s(u.prototype),"subarray",this).call(this,e,t)}},{key:"set",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n&&this._tryExtend(t,e.byteLength,e);var r=v(s(u.prototype),"set",this).call(this,e,t);return this.ranges.add(t,r.byteLength),r}},{key:"ensureChunk",value:function(e,t){try{var n=this;if(!n.chunked)return;if(n.ranges.available(e,t))return;return function(e,t){if(!t)return e&&e.then?e.then(Pt):Promise.resolve()}(n.readChunk(e,t))}catch(e){return Promise.reject(e)}}},{key:"available",value:function(e,t){return this.ranges.available(e,t)}}]),u}(D),xt=function(){function e(){t(this,e),i(this,"list",[])}return r(e,[{key:"length",get:function(){return this.list.length}},{key:"add",value:function(e,t){var n=e+t,r=this.list.filter((function(t){return Ct(e,t.offset,n)||Ct(e,t.end,n)}));if(r.length>0){e=Math.min.apply(Math,[e].concat(r.map((function(e){return e.offset})))),t=(n=Math.max.apply(Math,[n].concat(r.map((function(e){return e.end})))))-e;var i=r.shift();i.offset=e,i.length=t,i.end=n,this.list=this.list.filter((function(e){return!r.includes(e)}))}else this.list.push({offset:e,length:t,end:n})}},{key:"available",value:function(e,t){var n=e+t;return this.list.some((function(t){return t.offset<=e&&n<=t.end}))}}]),e}();function Ct(e,t,n){return e<=t&&t<=n}function Bt(){}function jt(e,t){if(!t)return e&&e.then?e.then(Bt):Promise.resolve()}function _t(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var Vt=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"readWhole",value:function(){try{var e=this;return e.chunked=!1,_t(Y(e.input),(function(t){e._swapArrayBuffer(t)}))}catch(e){return Promise.reject(e)}}},{key:"readChunked",value:function(){return this.chunked=!0,this.size=this.input.size,v(s(i.prototype),"readChunked",this).call(this)}},{key:"_readChunk",value:function(e,t){try{var n=this,r=t?e+t:void 0,i=n.input.slice(e,r);return _t(Y(i),(function(t){return n.set(t,e,!0)}))}catch(e){return Promise.reject(e)}}}]),i}(function(e){a(s,e);var n=d(s);function s(e,r){var a;return t(this,s),i(h(a=n.call(this,0)),"chunksRead",0),a.input=e,a.options=r,a}return r(s,[{key:"readWhole",value:function(){try{var e=this;return e.chunked=!1,jt(e.readChunk(e.nextChunkOffset))}catch(e){return Promise.reject(e)}}},{key:"readChunked",value:function(){try{var e=this;return e.chunked=!0,jt(e.readChunk(0,e.options.firstChunkSize))}catch(e){return Promise.reject(e)}}},{key:"readNextChunk",value:function(e){try{var t=this;if(void 0===e&&(e=t.nextChunkOffset),t.fullyRead)return t.chunksRead++,!1;var n=t.options.chunkSize;return r=t.readChunk(e,n),i=function(e){return!!e&&e.byteLength===n},a?i?i(r):r:(r&&r.then||(r=Promise.resolve(r)),i?r.then(i):r)}catch(e){return Promise.reject(e)}var r,i,a}},{key:"readChunk",value:function(e,t){try{var n=this;if(n.chunksRead++,0===(t=n.safeWrapAddress(e,t)))return;return n._readChunk(e,t)}catch(e){return Promise.reject(e)}}},{key:"safeWrapAddress",value:function(e,t){return void 0!==this.size&&e+t>this.size?Math.max(0,this.size-e):t}},{key:"nextChunkOffset",get:function(){if(0!==this.ranges.list.length)return this.ranges.list[0].length}},{key:"canReadNextChunk",get:function(){return this.chunksRead<this.options.chunkLimit}},{key:"fullyRead",get:function(){return void 0!==this.size&&this.nextChunkOffset===this.size}},{key:"read",value:function(){return this.options.chunked?this.readChunked():this.readWhole()}},{key:"close",value:function(){}}]),s}(Ut));K.set("blob",Vt),e.Exifr=Ie,e.Options=Pe,e.allFormatters=be,e.chunkedProps=de,e.createDictionary=te,e.default=at,e.disableAllOptions=lt,e.extendDictionary=ne,e.fetchUrlAsArrayBuffer=G,e.fileParsers=M,e.fileReaders=K,e.gps=ft,e.gpsOnlyOptions=dt,e.inheritables=me,e.orientation=ot,e.orientationOnlyOptions=vt,e.otherSegments=ve,e.parse=Te,e.readBlobAsArrayBuffer=Y,e.rotation=function(t){return st(ot(t),(function(t){return g({canvas:e.rotateCanvas,css:e.rotateCss},yt[t])}))},e.rotations=yt,e.segmentParsers=W,e.segments=pe,e.segmentsAndBlocks=ge,e.tagKeys=re,e.tagRevivers=ae,e.tagValues=ie,e.thumbnail=ht,e.thumbnailOnlyOptions=pt,e.thumbnailUrl=ct,e.tiffBlocks=ye,e.tiffExtractables=ke,Object.defineProperty(e,"__esModule",{value:!0})}));

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":19,"buffer":3}],7:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(require,module,exports){
module.exports = function isShallowEqual (a, b) {
  if (a === b) return true
  for (var i in a) if (!(i in b)) return false
  for (var i in b) if (a[i] !== b[i]) return false
  return true
}

},{}],9:[function(require,module,exports){
(function (global){(function (){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.6.4";
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa && typeof global.btoa == 'function'
        ? function(b){ return global.btoa(b) } : function(b) {
        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
            'The string contains invalid characters.'
        );
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(String(u)));
    };
    var mkUriSafe = function (b64) {
        return b64.replace(/[+\/]/g, function(m0) {
            return m0 == '+' ? '-' : '_';
        }).replace(/=/g, '');
    };
    var encode = function(u, urisafe) {
        return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
    };
    var encodeURI = function(u) { return encode(u, true) };
    var fromUint8Array;
    if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
        // return btoa(fromCharCode.apply(null, a));
        var b64 = '';
        for (var i = 0, l = a.length; i < l; i += 3) {
            var a0 = a[i], a1 = a[i+1], a2 = a[i+2];
            var ord = a0 << 16 | a1 << 8 | a2;
            b64 +=    b64chars.charAt( ord >>> 18)
                +     b64chars.charAt((ord >>> 12) & 63)
                + ( typeof a1 != 'undefined'
                    ? b64chars.charAt((ord >>>  6) & 63) : '=')
                + ( typeof a2 != 'undefined'
                    ? b64chars.charAt( ord         & 63) : '=');
        }
        return urisafe ? mkUriSafe(b64) : b64;
    };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob && typeof global.atob == 'function'
        ? function(a){ return global.atob(a) } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = function(a) { return btou(_atob(a)) };
    var _fromURI = function(a) {
        return String(a).replace(/[-_]/g, function(m0) {
            return m0 == '-' ? '+' : '/'
        }).replace(/[^A-Za-z0-9\+\/]/g, '');
    };
    var decode = function(a){
        return _decode(_fromURI(a));
    };
    var toUint8Array;
    if (global.Uint8Array) toUint8Array = function(a) {
        return Uint8Array.from(atob(_fromURI(a)), function(c) {
            return c.charCodeAt(0);
        });
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],10:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],11:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = throttle;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],12:[function(require,module,exports){
'use strict';

var safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
        return typeof value === 'number' && value !== value;
    };
function isEqual(first, second) {
    if (first === second) {
        return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
    }
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

module.exports = memoizeOne;

},{}],13:[function(require,module,exports){
var wildcard = require('wildcard');
var reMimePartSplit = /[\/\+\.]/;

/**
  # mime-match

  A simple function to checker whether a target mime type matches a mime-type
  pattern (e.g. image/jpeg matches image/jpeg OR image/*).

  ## Example Usage

  <<< example.js

**/
module.exports = function(target, pattern) {
  function test(pattern) {
    var result = wildcard(pattern, target, reMimePartSplit);

    // ensure that we have a valid mime type (should have two parts)
    return result && result.length >= 2;
  }

  return pattern ? test(pattern.split(';')[0]) : test;
};

},{"wildcard":14}],14:[function(require,module,exports){
/* jshint node: true */
'use strict';

/**
  # wildcard

  Very simple wildcard matching, which is designed to provide the same
  functionality that is found in the
  [eve](https://github.com/adobe-webplatform/eve) eventing library.

  ## Usage

  It works with strings:

  <<< examples/strings.js

  Arrays:

  <<< examples/arrays.js

  Objects (matching against keys):

  <<< examples/objects.js

  While the library works in Node, if you are are looking for file-based
  wildcard matching then you should have a look at:

  <https://github.com/isaacs/node-glob>
**/

function WildcardMatcher(text, separator) {
  this.text = text = text || '';
  this.hasWild = ~text.indexOf('*');
  this.separator = separator;
  this.parts = text.split(separator);
}

WildcardMatcher.prototype.match = function(input) {
  var matches = true;
  var parts = this.parts;
  var ii;
  var partsCount = parts.length;
  var testParts;

  if (typeof input == 'string' || input instanceof String) {
    if (!this.hasWild && this.text != input) {
      matches = false;
    } else {
      testParts = (input || '').split(this.separator);
      for (ii = 0; matches && ii < partsCount; ii++) {
        if (parts[ii] === '*')  {
          continue;
        } else if (ii < testParts.length) {
          matches = parts[ii] === testParts[ii];
        } else {
          matches = false;
        }
      }

      // If matches, then return the component parts
      matches = matches && testParts;
    }
  }
  else if (typeof input.splice == 'function') {
    matches = [];

    for (ii = input.length; ii--; ) {
      if (this.match(input[ii])) {
        matches[matches.length] = input[ii];
      }
    }
  }
  else if (typeof input == 'object') {
    matches = {};

    for (var key in input) {
      if (this.match(key)) {
        matches[key] = input[key];
      }
    }
  }

  return matches;
};

module.exports = function(text, test, separator) {
  var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
  if (typeof test != 'undefined') {
    return matcher.match(test);
  }

  return matcher;
};

},{}],15:[function(require,module,exports){
/**
* Create an event emitter with namespaces
* @name createNamespaceEmitter
* @example
* var emitter = require('./index')()
*
* emitter.on('*', function () {
*   console.log('all events emitted', this.event)
* })
*
* emitter.on('example', function () {
*   console.log('example event emitted')
* })
*/
module.exports = function createNamespaceEmitter () {
  var emitter = {}
  var _fns = emitter._fns = {}

  /**
  * Emit an event. Optionally namespace the event. Handlers are fired in the order in which they were added with exact matches taking precedence. Separate the namespace and event with a `:`
  * @name emit
  * @param {String} event  the name of the event, with optional namespace
  * @param {...*} data  up to 6 arguments that are passed to the event listener
  * @example
  * emitter.emit('example')
  * emitter.emit('demo:test')
  * emitter.emit('data', { example: true}, 'a string', 1)
  */
  emitter.emit = function emit (event, arg1, arg2, arg3, arg4, arg5, arg6) {
    var toEmit = getListeners(event)

    if (toEmit.length) {
      emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6])
    }
  }

  /**
  * Create en event listener.
  * @name on
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.on('example', function () {})
  * emitter.on('demo', function () {})
  */
  emitter.on = function on (event, fn) {
    if (!_fns[event]) {
      _fns[event] = []
    }

    _fns[event].push(fn)
  }

  /**
  * Create en event listener that fires once.
  * @name once
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.once('example', function () {})
  * emitter.once('demo', function () {})
  */
  emitter.once = function once (event, fn) {
    function one () {
      fn.apply(this, arguments)
      emitter.off(event, one)
    }
    this.on(event, one)
  }

  /**
  * Stop listening to an event. Stop all listeners on an event by only passing the event name. Stop a single listener by passing that event handler as a callback.
  * You must be explicit about what will be unsubscribed: `emitter.off('demo')` will unsubscribe an `emitter.on('demo')` listener,
  * `emitter.off('demo:example')` will unsubscribe an `emitter.on('demo:example')` listener
  * @name off
  * @param {String} event
  * @param {Function} [fn]  the specific handler
  * @example
  * emitter.off('example')
  * emitter.off('demo', function () {})
  */
  emitter.off = function off (event, fn) {
    var keep = []

    if (event && fn) {
      var fns = this._fns[event]
      var i = 0
      var l = fns ? fns.length : 0

      for (i; i < l; i++) {
        if (fns[i] !== fn) {
          keep.push(fns[i])
        }
      }
    }

    keep.length ? this._fns[event] = keep : delete this._fns[event]
  }

  function getListeners (e) {
    var out = _fns[e] ? _fns[e] : []
    var idx = e.indexOf(':')
    var args = (idx === -1) ? [e] : [e.substring(0, idx), e.substring(idx + 1)]

    var keys = Object.keys(_fns)
    var i = 0
    var l = keys.length

    for (i; i < l; i++) {
      var key = keys[i]
      if (key === '*') {
        out = out.concat(_fns[key])
      }

      if (args.length === 2 && args[0] === key) {
        out = out.concat(_fns[key])
        break
      }
    }

    return out
  }

  function emitAll (e, fns, args) {
    var i = 0
    var l = fns.length

    for (i; i < l; i++) {
      if (!fns[i]) break
      fns[i].event = e
      fns[i].apply(fns[i], args)
    }
  }

  return emitter
}

},{}],16:[function(require,module,exports){
(function (process){(function (){
let { urlAlphabet } = require('./url-alphabet/index.cjs')
if (process.env.NODE_ENV !== 'production') {
  if (
    typeof navigator !== 'undefined' &&
    navigator.product === 'ReactNative' &&
    typeof crypto === 'undefined'
  ) {
    throw new Error(
      'React Native does not have a built-in secure random generator. ' +
        'If you dont need unpredictable IDs use `nanoid/non-secure`. ' +
        'For secure IDs, import `react-native-get-random-values` ' +
        'before Nano ID.'
    )
  }
  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {
    throw new Error(
      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +
        ' before importing Nano ID to fix IE 11 support'
    )
  }
  if (typeof crypto === 'undefined') {
    throw new Error(
      'Your browser does not have secure random generator. ' +
        'If you dont need unpredictable IDs, you can use nanoid/non-secure.'
    )
  }
}
let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, size, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * size) / alphabet.length)
  return () => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)
let nanoid = (size = 21) => {
  let id = ''
  let bytes = crypto.getRandomValues(new Uint8Array(size))
  while (size--) {
    let byte = bytes[size] & 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte < 63) {
      id += '_'
    } else {
      id += '-'
    }
  }
  return id
}
module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

}).call(this)}).call(this,require('_process'))

},{"./url-alphabet/index.cjs":17,"_process":19}],17:[function(require,module,exports){
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
module.exports = { urlAlphabet }

},{}],18:[function(require,module,exports){
var n,l,u,t,i,r,o,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function v(n){var l=n.parentNode;l&&l.removeChild(n)}function h(l,u,t){var i,r,o,f={};for(o in u)"key"==o?i=u[o]:"ref"==o?r=u[o]:f[o]=u[o];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),"function"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)void 0===f[o]&&(f[o]=l.defaultProps[o]);return p(l,f,i,r,null)}function p(n,t,i,r,o){var f={type:n,props:t,key:i,ref:r,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++u:o};return null==o&&null!=l.vnode&&l.vnode(f),f}function y(n){return n.children}function d(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function k(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k(n)}}function x(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!b.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(b)}function b(){for(var n;b.__r=i.length;)n=i.sort(function(n,l){return n.__v.__b-l.__v.__b}),i=[],n.some(function(n){var l,u,t,i,r,o;n.__d&&(r=(i=(l=n).__v).__e,(o=l.__P)&&(u=[],(t=a({},i)).__v=i.__v+1,I(o,i,t,l.__n,void 0!==o.ownerSVGElement,null!=i.__h?[r]:null,u,null==r?_(i):r,i.__h),T(u,i),i.__e!=r&&k(i)))})}function m(n,l,u,t,i,r,o,f,s,a){var v,h,d,k,x,b,m,A=t&&t.__k||c,P=A.length;for(u.__k=[],v=0;v<l.length;v++)if(null!=(k=u.__k[v]=null==(k=l[v])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?p(null,k,null,null,k):Array.isArray(k)?p(y,{children:k},null,null,null):k.__b>0?p(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(d=A[v])||d&&k.key==d.key&&k.type===d.type)A[v]=void 0;else for(h=0;h<P;h++){if((d=A[h])&&k.key==d.key&&k.type===d.type){A[h]=void 0;break}d=null}I(n,k,d=d||e,i,r,o,f,s,a),x=k.__e,(h=k.ref)&&d.ref!=h&&(m||(m=[]),d.ref&&m.push(d.ref,null,k),m.push(h,k.__c||x,k)),null!=x?(null==b&&(b=x),"function"==typeof k.type&&k.__k===d.__k?k.__d=s=g(k,s,n):s=w(n,k,d,A,x,s),"function"==typeof u.type&&(u.__d=s)):s&&d.__e==s&&s.parentNode!=n&&(s=_(d))}for(u.__e=b,v=P;v--;)null!=A[v]&&("function"==typeof u.type&&null!=A[v].__e&&A[v].__e==u.__d&&(u.__d=_(t,v+1)),L(A[v],A[v]));if(m)for(v=0;v<m.length;v++)z(m[v],m[++v],m[++v])}function g(n,l,u){for(var t,i=n.__k,r=0;i&&r<i.length;r++)(t=i[r])&&(t.__=n,l="function"==typeof t.type?g(t,l,u):w(u,t,t,i,t.__e,l));return l}function w(n,l,u,t,i,r){var o,f,e;if(void 0!==l.__d)o=l.__d,l.__d=void 0;else if(null==u||i!=r||null==i.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(i),o=null;else{for(f=r,e=0;(f=f.nextSibling)&&e<t.length;e+=2)if(f==i)break n;n.insertBefore(i,r),o=r}return void 0!==o?o:i.nextSibling}function A(n,l,u,t,i){var r;for(r in u)"children"===r||"key"===r||r in l||C(n,r,null,u[r],t);for(r in l)i&&"function"!=typeof l[r]||"children"===r||"key"===r||"value"===r||"checked"===r||u[r]===l[r]||C(n,r,l[r],u[r],t)}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||s.test(l)?u:u+"px"}function C(n,l,u,t,i){var r;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||P(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||P(n.style,l,u[l])}else if("o"===l[0]&&"n"===l[1])r=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?t||n.addEventListener(l,r?H:$,r):n.removeEventListener(l,r?H:$,r);else if("dangerouslySetInnerHTML"!==l){if(i)l=l.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function $(n){this.l[n.type+!1](l.event?l.event(n):n)}function H(n){this.l[n.type+!0](l.event?l.event(n):n)}function I(n,u,t,i,r,o,f,e,c){var s,v,h,p,_,k,x,b,g,w,A,P=u.type;if(void 0!==u.constructor)return null;null!=t.__h&&(c=t.__h,e=u.__e=t.__e,u.__h=null,o=[e]),(s=l.__b)&&s(u);try{n:if("function"==typeof P){if(b=u.props,g=(s=P.contextType)&&i[s.__c],w=s?g?g.props.value:s.__:i,t.__c?x=(v=u.__c=t.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(b,w):(u.__c=v=new d(b,w),v.constructor=P,v.render=M),g&&g.sub(v),v.props=b,v.state||(v.state={}),v.context=w,v.__n=i,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=a({},v.__s)),a(v.__s,P.getDerivedStateFromProps(b,v.__s))),p=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&b!==p&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(b,w),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(b,v.__s,w)||u.__v===t.__v){v.props=b,v.state=v.__s,u.__v!==t.__v&&(v.__d=!1),v.__v=u,u.__e=t.__e,u.__k=t.__k,u.__k.forEach(function(n){n&&(n.__=u)}),v.__h.length&&f.push(v);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(b,v.__s,w),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(p,_,k)})}v.context=w,v.props=b,v.state=v.__s,(s=l.__r)&&s(u),v.__d=!1,v.__v=u,v.__P=n,s=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(i=a(a({},i),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(k=v.getSnapshotBeforeUpdate(p,_)),A=null!=s&&s.type===y&&null==s.key?s.props.children:s,m(n,Array.isArray(A)?A:[A],u,t,i,r,o,f,e,c),v.base=u.__e,u.__h=null,v.__h.length&&f.push(v),x&&(v.__E=v.__=null),v.__e=!1}else null==o&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=j(t.__e,u,t,i,r,o,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=o)&&(u.__e=e,u.__h=!!c,o[o.indexOf(e)]=null),l.__e(n,u,t)}}function T(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function j(l,u,t,i,r,o,f,c){var s,a,h,p=t.props,y=u.props,d=u.type,k=0;if("svg"===d&&(r=!0),null!=o)for(;k<o.length;k++)if((s=o[k])&&(s===l||(d?s.localName==d:3==s.nodeType))){l=s,o[k]=null;break}if(null==l){if(null===d)return document.createTextNode(y);l=r?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,y.is&&y),o=null,c=!1}if(null===d)p===y||c&&l.data===y||(l.data=y);else{if(o=o&&n.call(l.childNodes),a=(p=t.props||e).dangerouslySetInnerHTML,h=y.dangerouslySetInnerHTML,!c){if(null!=o)for(p={},k=0;k<l.attributes.length;k++)p[l.attributes[k].name]=l.attributes[k].value;(h||a)&&(h&&(a&&h.__html==a.__html||h.__html===l.innerHTML)||(l.innerHTML=h&&h.__html||""))}if(A(l,y,p,r,c),h)u.__k=[];else if(k=u.props.children,m(l,Array.isArray(k)?k:[k],u,t,i,r&&"foreignObject"!==d,o,f,o?o[0]:t.__k&&_(t,0),c),null!=o)for(k=o.length;k--;)null!=o[k]&&v(o[k]);c||("value"in y&&void 0!==(k=y.value)&&(k!==l.value||"progress"===d&&!k)&&C(l,"value",k,p.value,!1),"checked"in y&&void 0!==(k=y.checked)&&k!==l.checked&&C(l,"checked",k,p.checked,!1))}return l}function z(n,u,t){try{"function"==typeof n?n(u):n.current=u}catch(n){l.__e(n,t)}}function L(n,u,t){var i,r;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||z(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(r=0;r<i.length;r++)i[r]&&L(i[r],u,"function"!=typeof n.type);t||null==n.__e||v(n.__e),n.__e=n.__d=void 0}function M(n,l,u){return this.constructor(n,u)}function N(u,t,i){var r,o,f;l.__&&l.__(u,t),o=(r="function"==typeof i)?null:i&&i.__k||t.__k,f=[],I(t,u=(!r&&i||t).__k=h(y,null,[u]),o||e,e,void 0!==t.ownerSVGElement,!r&&i?[i]:o?null:t.firstChild?n.call(t.childNodes):null,f,!r&&i?i:o?o.__e:t.firstChild,r),T(f,u)}n=c.slice,l={__e:function(n,l){for(var u,t,i;l=l.__;)if((u=l.__c)&&!u.__)try{if((t=u.constructor)&&null!=t.getDerivedStateFromError&&(u.setState(t.getDerivedStateFromError(n)),i=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),i=u.__d),i)return u.__E=u}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&void 0===n.constructor},d.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),"function"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),x(this))},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),x(this))},d.prototype.render=y,i=[],r="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,b.__r=0,f=0,exports.render=N,exports.hydrate=function n(l,u){N(l,u,n)},exports.createElement=h,exports.h=h,exports.Fragment=y,exports.createRef=function(){return{current:null}},exports.isValidElement=t,exports.Component=d,exports.cloneElement=function(l,u,t){var i,r,o,f=a({},l.props);for(o in u)"key"==o?i=u[o]:"ref"==o?r=u[o]:f[o]=u[o];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),p(l.type,f,i||l.key,r||l.ref,null)},exports.createContext=function(n,l){var u={__c:l="__cC"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(x)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u},exports.toChildArray=function n(l,u){return u=u||[],null==l||"boolean"==typeof l||(Array.isArray(l)?l.some(function(l){n(l,u)}):u.push(l)),u},exports.options=l;


},{}],19:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],20:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],21:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova.default)()) {
        return (0, _readAsByteArray.default)(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader, chunkSize) {
    _classCallCheck(this, StreamSource);

    this._chunkSize = chunkSize;
    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error('Unknown data type');
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative.default)() && input && typeof input.uri !== 'undefined') {
        return (0, _uriToBlob.default)(input.uri).then(function (blob) {
          return new FileSource(blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. ".concat(err));
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === 'function' && typeof input.size !== 'undefined') {
        return Promise.resolve(new FileSource(input));
      }

      if (typeof input.read === 'function') {
        chunkSize = +chunkSize;

        if (!isFinite(chunkSize)) {
          return Promise.reject(new Error('cannot create source for stream without a finite value for the `chunkSize` option'));
        }

        return Promise.resolve(new StreamSource(input, chunkSize));
      }

      return Promise.reject(new Error('source object may only be an instance of File, Blob, or Reader in this environment'));
    }
  }]);

  return FileReader;
}();

exports.default = FileReader;
},{"./isCordova":26,"./isReactNative":27,"./readAsByteArray":28,"./uriToBlob":29}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */
function fingerprint(file, options) {
  if ((0, _isReactNative.default)()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(['tus-br', file.name, file.type, file.size, file.lastModified, options.endpoint].join('-'));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : 'noexif';
  return ['tus-rn', file.name || 'noname', file.size || 'nosize', exifHash, options.endpoint].join('/');
}

function hashCode(str) {
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash &= hash; // Convert to 32bit integer
  }

  return hash;
}
},{"./isReactNative":27}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return 'XHRHttpStack';
    }
  }]);

  return XHRHttpStack;
}();

exports.default = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!('upload' in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();
},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function () {
    return _logger.enableDebugLog;
  }
});
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function () {
    return _urlStorage.canStoreURLs;
  }
});
Object.defineProperty(exports, "HttpStack", {
  enumerable: true,
  get: function () {
    return _httpStack.default;
  }
});
exports.isSupported = exports.defaultOptions = exports.Upload = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/* global window */


var defaultOptions = _objectSpread({}, _upload.default.defaultOptions, {
  httpStack: new _httpStack.default(),
  fileReader: new _fileReader.default(),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage.default(),
  fingerprint: _fingerprint.default
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread({}, defaultOptions, {}, options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      options = _objectSpread({}, defaultOptions, {}, options);
      return _upload.default.terminate(url, options, cb);
    }
  }]);

  return Upload;
}(_upload.default);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === 'function';
exports.isSupported = isSupported;
},{"../logger":32,"../noopUrlStorage":33,"../upload":34,"./fileReader":22,"./fingerprint":23,"./httpStack":24,"./urlStorage":30}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isCordova = function isCordova() {
  return typeof window != 'undefined' && (typeof window.PhoneGap != 'undefined' || typeof window.Cordova != 'undefined' || typeof window.cordova != 'undefined');
};

var _default = isCordova;
exports.default = _default;
},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
};

var _default = isReactNative;
exports.default = _default;
},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = readAsByteArray;

/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */
function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}
},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uriToBlob;

/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */
function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = 'blob';

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open('GET', uri);
    xhr.send();
  });
}
},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebStorageUrlStorage = exports.canStoreURLs = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window, localStorage */


var hasStorage = false;

try {
  hasStorage = 'localStorage' in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = 'tusSupport';
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries('tus::');

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;
},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader('X-Request-ID') || 'n/a';
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : 'n/a';
      var body = res ? res.getBody() || '' : 'n/a';
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return DetailedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports.default = _default;
},{}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;

/* eslint no-console: "off" */
var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}
},{}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports.default = NoopUrlStorage;
},{}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _error = _interopRequireDefault(require("./error"));

var _logger = require("./logger");

var _uuid = _interopRequireDefault(require("./uuid"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  onShouldRetry: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ('resume' in options) {
      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.'); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error('tus: no file or stream to upload provided'));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {
        this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        ['uploadUrl', 'uploadSize', 'uploadLengthDeferred'].forEach(function (optionName) {
          if (_this2.options[optionName]) {
            _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
          }
        });
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.');
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        }

        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
      }).then(function (source) {
        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.

        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this3 = this;

      var totalSize = this._size = this._source.size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs

      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective
      // upload is completed.

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread({}, _this3.options, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread({}, _this3.options.headers, {
                'Upload-Concat': 'partial'
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;

                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return !!u;
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options);
            upload.start(); // Store the upload in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest('POST', _this3.options.endpoint);
        req.setHeader('Upload-Concat', "final;".concat(_this3._parallelUploadUrls.join(' '))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== '') {
          req.setHeader('Upload-Metadata', metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, 'tus: unexpected response while creating upload');

          return;
        }

        var location = res.getHeader('Location');

        if (location == null) {
          _this3._emitHttpError(req, res, 'tus: invalid or missing Location header');

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = +this.options.uploadSize;

        if (isNaN(this._size)) {
          this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'));

          return;
        }
      } else {
        this._size = this._source.size;

        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option"));

          return;
        }
      } // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.


      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.url));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)('Creating a new upload');

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate) {
      var _this4 = this; // Count the number of arguments to see if a callback is being provided in the old style required by tus-js-client 1.x, then throw an error if it is.
      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.


      if (arguments.length > 1 && typeof arguments[1] === 'function') {
        throw new Error('tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead');
      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort();

        this._source.close();
      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error.default(message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === 'function') {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === 'function') {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === 'function') {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === 'function') {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error('tus: unable to create upload because no endpoint is provided'));

        return;
      }

      var req = this._openRequest('POST', this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader('Upload-Defer-Length', 1);
      } else {
        req.setHeader('Upload-Length', this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== '') {
        req.setHeader('Upload-Metadata', metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, 'tus: unexpected response while creating upload');

          return;
        }

        var location = res.getHeader('Location');

        if (location == null) {
          _this6._emitHttpError(req, res, 'tus: invalid or missing Location header');

          return;
        }

        _this6.url = resolveUrl(_this6.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === 'function') {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess();

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage();

        if (_this6.options.uploadDataDuringCreation) {
          _this6._handleUploadResponse(req, res);
        } else {
          _this6._offset = 0;

          _this6._performUpload();
        }
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, 'tus: failed to create upload', err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest('HEAD', this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          } // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.


          if (status === 423) {
            _this7._emitHttpError(req, res, 'tus: upload is currently locked; retry later');

            return;
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)');

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader('Upload-Offset'), 10);

        if (isNaN(offset)) {
          _this7._emitHttpError(req, res, 'tus: invalid or missing offset value');

          return;
        }

        var length = parseInt(res.getHeader('Upload-Length'), 10);

        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, 'tus: invalid or missing length value');

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === 'function') {
          _this7.options._onUploadUrlAvailable();
        } // Upload has already been completed and we do not need to send additional
        // data to the server


        if (offset === length) {
          _this7._emitProgress(length, length);

          _this7._emitSuccess();

          return;
        }

        _this7._offset = offset;

        _this7._performUpload();
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, 'tus: failed to resume upload', err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest('POST', this.url);
        req.setHeader('X-HTTP-Method-Override', 'PATCH');
      } else {
        req = this._openRequest('PATCH', this.url);
      }

      req.setHeader('Upload-Offset', this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, 'tus: unexpected response while uploading chunk');

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset ".concat(_this8._offset), err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader('Content-Type', 'application/offset+octet-stream'); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader('Upload-Length', _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        }

        _this9._emitProgress(_this9._offset, _this9._size);

        return _this9._sendRequest(req, value);
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader('Upload-Offset'), 10);

      if (isNaN(offset)) {
        this._emitHttpError(req, res, 'tus: invalid or missing offset value');

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset == this._size) {
        // Yay, finally done :)
        this._emitSuccess();

        this._source.close();

        return;
      }

      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this10._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.


      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {
        return;
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        return _this11._urlStorageKey = urlStorageKey;
      })["catch"](function (err) {
        _this11._emitError(err);
      });
    }
    /**
     * Send a request with the provided body.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return sendRequest(req, body, this.options);
    }
  }], [{
    key: "terminate",
    value: function terminate(url, options) {
      // Count the number of arguments to see if a callback is being provided as the last
      // argument in the old style required by tus-js-client 1.x, then throw an error if it is.
      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.
      if (arguments.length > 1 && typeof arguments[arguments.length - 1] === 'function') {
        throw new Error('tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead');
      } // Note that in order for the trick above to work, a default value cannot be set for `options`,
      // so the check below replaces the old default `{}`.


      if (options === undefined) {
        options = {};
      }

      var req = openRequest('DELETE', url, options);
      return sendRequest(req, null, options).then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error.default('tus: unexpected response while terminating upload', null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error.default)) {
          err = new _error.default('tus: failed to terminate upload', err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread({}, options, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  var encoded = [];

  for (var key in metadata) {
    encoded.push("".concat(key, " ").concat(_jsBase.Base64.encode(metadata[key])));
  }

  return encoded.join(',');
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader('Tus-Resumable', '1.0.0');
  var headers = options.headers || {};

  for (var name in headers) {
    req.setHeader(name, headers[name]);
  }

  if (options.addRequestId) {
    var requestId = (0, _uuid.default)();
    req.setHeader('X-Request-ID', requestId);
  }

  return req;
}
/**
 * Send a request with the provided body while invoking the onBeforeRequest
 * and onAfterResponse callbacks.
 *
 * @api private
 */


function sendRequest(req, body, options) {
  var onBeforeRequestPromise = typeof options.onBeforeRequest === 'function' ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();
  return onBeforeRequestPromise.then(function () {
    return req.send(body).then(function (res) {
      var onAfterResponsePromise = typeof options.onAfterResponse === 'function' ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();
      return onAfterResponsePromise.then(function () {
        return res;
      });
    });
  });
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== 'undefined' && 'navigator' in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or
  // a onShouldRetry is specified and returns true
  // - the browser does not indicate that we are offline
  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {
    return false;
  }

  if (options && typeof options.onShouldRetry === 'function') {
    return options.onShouldRetry(err, retryAttempt, options);
  }

  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse.default(link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @param {string[]} previousUrls The upload URLs for previous parts.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount, previousUrls) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.

  if (previousUrls) {
    parts.forEach(function (part, index) {
      part.uploadUrl = previousUrls[index] || null;
    });
  }

  return parts;
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports.default = _default;
},{"./error":31,"./logger":32,"./uuid":35,"js-base64":9,"url-parse":36}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uuid;

/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
},{}],36:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":20,"requires-port":21}],37:[function(require,module,exports){
'use strict';

class AuthError extends Error {
  constructor() {
    super('Authorization required');
    this.name = 'AuthError';
    this.isAuthError = true;
  }

}

module.exports = AuthError;

},{}],38:[function(require,module,exports){
'use strict';

const RequestClient = require('./RequestClient');

const tokenStorage = require('./tokenStorage');

const getName = id => {
  return id.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');
};

module.exports = class Provider extends RequestClient {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.provider = opts.provider;
    this.id = this.provider;
    this.name = this.opts.name || getName(this.id);
    this.pluginId = this.opts.pluginId;
    this.tokenKey = `companion-${this.pluginId}-auth-token`;
    this.companionKeysParams = this.opts.companionKeysParams;
    this.preAuthToken = null;
  }

  headers() {
    return Promise.all([super.headers(), this.getAuthToken()]).then(([headers, token]) => {
      const authHeaders = {};

      if (token) {
        authHeaders['uppy-auth-token'] = token;
      }

      if (this.companionKeysParams) {
        authHeaders['uppy-credentials-params'] = btoa(JSON.stringify({
          params: this.companionKeysParams
        }));
      }

      return { ...headers,
        ...authHeaders
      };
    });
  }

  onReceiveResponse(response) {
    response = super.onReceiveResponse(response);
    const plugin = this.uppy.getPlugin(this.pluginId);
    const oldAuthenticated = plugin.getPluginState().authenticated;
    const authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
    plugin.setPluginState({
      authenticated
    });
    return response;
  }

  setAuthToken(token) {
    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
  }

  getAuthToken() {
    return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
  }

  authUrl(queries = {}) {
    if (this.preAuthToken) {
      queries.uppyPreAuthToken = this.preAuthToken;
    }

    return `${this.hostname}/${this.id}/connect?${new URLSearchParams(queries)}`;
  }

  fileUrl(id) {
    return `${this.hostname}/${this.id}/get/${id}`;
  }

  fetchPreAuthToken() {
    if (!this.companionKeysParams) {
      return Promise.resolve();
    }

    return this.post(`${this.id}/preauth/`, {
      params: this.companionKeysParams
    }).then(res => {
      this.preAuthToken = res.token;
    }).catch(err => {
      this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${err}`, 'warning');
    });
  }

  list(directory) {
    return this.get(`${this.id}/list/${directory || ''}`);
  }

  logout() {
    return this.get(`${this.id}/logout`).then(response => Promise.all([response, this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey)])).then(([response]) => response);
  }

  static initPlugin(plugin, opts, defaultOpts) {
    plugin.type = 'acquirer';
    plugin.files = [];

    if (defaultOpts) {
      plugin.opts = { ...defaultOpts,
        ...opts
      };
    }

    if (opts.serverUrl || opts.serverPattern) {
      throw new Error('`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`');
    }

    if (opts.companionAllowedHosts) {
      const pattern = opts.companionAllowedHosts; // validate companionAllowedHosts param

      if (typeof pattern !== 'string' && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
        throw new TypeError(`${plugin.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);
      }

      plugin.opts.companionAllowedHosts = pattern;
    } else if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
      // does not start with https://
      plugin.opts.companionAllowedHosts = `https://${opts.companionUrl.replace(/^\/\//, '')}`;
    } else {
      plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
    }

    plugin.storage = plugin.opts.storage || tokenStorage;
  }

};

},{"./RequestClient":39,"./tokenStorage":43}],39:[function(require,module,exports){
'use strict';

var _class, _getPostResponseFunc, _getUrl, _errorHandler, _temp;

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const fetchWithNetworkError = require('./../../utils/lib/fetchWithNetworkError');

const AuthError = require('./AuthError'); // Remove the trailing slash so we can always safely append /xyz.


function stripSlash(url) {
  return url.replace(/\/$/, '');
}

async function handleJSONResponse(res) {
  if (res.status === 401) {
    throw new AuthError();
  }

  const jsonPromise = res.json();

  if (res.status < 200 || res.status > 300) {
    let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;

    try {
      const errData = await jsonPromise;
      errMsg = errData.message ? `${errMsg} message: ${errData.message}` : errMsg;
      errMsg = errData.requestId ? `${errMsg} request-Id: ${errData.requestId}` : errMsg;
    } finally {
      // eslint-disable-next-line no-unsafe-finally
      throw new Error(errMsg);
    }
  }

  return jsonPromise;
}

module.exports = (_temp = (_getPostResponseFunc = /*#__PURE__*/_classPrivateFieldLooseKey("getPostResponseFunc"), _getUrl = /*#__PURE__*/_classPrivateFieldLooseKey("getUrl"), _errorHandler = /*#__PURE__*/_classPrivateFieldLooseKey("errorHandler"), _class = class RequestClient {
  // eslint-disable-next-line global-require
  constructor(uppy, opts) {
    Object.defineProperty(this, _errorHandler, {
      value: _errorHandler2
    });
    Object.defineProperty(this, _getUrl, {
      value: _getUrl2
    });
    Object.defineProperty(this, _getPostResponseFunc, {
      writable: true,
      value: skip => response => skip ? response : this.onReceiveResponse(response)
    });
    this.uppy = uppy;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    this.allowedHeaders = ['accept', 'content-type', 'uppy-auth-token'];
    this.preflightDone = false;
  }

  get hostname() {
    const {
      companion
    } = this.uppy.getState();
    const host = this.opts.companionUrl;
    return stripSlash(companion && companion[host] ? companion[host] : host);
  }

  headers() {
    const userHeaders = this.opts.companionHeaders || {};
    return Promise.resolve({ ...RequestClient.defaultHeaders,
      ...userHeaders
    });
  }

  onReceiveResponse(response) {
    const state = this.uppy.getState();
    const companion = state.companion || {};
    const host = this.opts.companionUrl;
    const {
      headers
    } = response; // Store the self-identified domain name for the Companion instance we just hit.

    if (headers.has('i-am') && headers.get('i-am') !== companion[host]) {
      this.uppy.setState({
        companion: { ...companion,
          [host]: headers.get('i-am')
        }
      });
    }

    return response;
  }

  preflight(path) {
    if (this.preflightDone) {
      return Promise.resolve(this.allowedHeaders.slice());
    }

    return fetch(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
      method: 'OPTIONS'
    }).then(response => {
      if (response.headers.has('access-control-allow-headers')) {
        this.allowedHeaders = response.headers.get('access-control-allow-headers').split(',').map(headerName => headerName.trim().toLowerCase());
      }

      this.preflightDone = true;
      return this.allowedHeaders.slice();
    }).catch(err => {
      this.uppy.log(`[CompanionClient] unable to make preflight request ${err}`, 'warning');
      this.preflightDone = true;
      return this.allowedHeaders.slice();
    });
  }

  preflightAndHeaders(path) {
    return Promise.all([this.preflight(path), this.headers()]).then(([allowedHeaders, headers]) => {
      // filter to keep only allowed Headers
      Object.keys(headers).forEach(header => {
        if (!allowedHeaders.includes(header.toLowerCase())) {
          this.uppy.log(`[CompanionClient] excluding disallowed header ${header}`);
          delete headers[header]; // eslint-disable-line no-param-reassign
        }
      });
      return headers;
    });
  }

  get(path, skipPostResponse) {
    const method = 'get';
    return this.preflightAndHeaders(path).then(headers => fetchWithNetworkError(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || 'same-origin'
    })).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
  }

  post(path, data, skipPostResponse) {
    const method = 'post';
    return this.preflightAndHeaders(path).then(headers => fetchWithNetworkError(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || 'same-origin',
      body: JSON.stringify(data)
    })).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
  }

  delete(path, data, skipPostResponse) {
    const method = 'delete';
    return this.preflightAndHeaders(path).then(headers => fetchWithNetworkError(`${this.hostname}/${path}`, {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || 'same-origin',
      body: data ? JSON.stringify(data) : null
    })).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
  }

}), _class.VERSION = "2.0.3", _class.defaultHeaders = {
  Accept: 'application/json',
  'Content-Type': 'application/json',
  'Uppy-Versions': `@uppy/companion-client=${_class.VERSION}`
}, _temp);

function _getUrl2(url) {
  if (/^(https?:|)\/\//.test(url)) {
    return url;
  }

  return `${this.hostname}/${url}`;
}

function _errorHandler2(method, path) {
  return err => {
    var _err;

    if (!((_err = err) != null && _err.isAuthError)) {
      const error = new Error(`Could not ${method} ${_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path)}`);
      error.cause = err;
      err = error; // eslint-disable-line no-param-reassign
    }

    return Promise.reject(err);
  };
}

},{"./../../utils/lib/fetchWithNetworkError":152,"./AuthError":37}],40:[function(require,module,exports){
'use strict';

const RequestClient = require('./RequestClient');

const getName = id => {
  return id.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');
};

module.exports = class SearchProvider extends RequestClient {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.provider = opts.provider;
    this.id = this.provider;
    this.name = this.opts.name || getName(this.id);
    this.pluginId = this.opts.pluginId;
  }

  fileUrl(id) {
    return `${this.hostname}/search/${this.id}/get/${id}`;
  }

  search(text, queries) {
    queries = queries ? `&${queries}` : '';
    return this.get(`search/${this.id}/list?q=${encodeURIComponent(text)}${queries}`);
  }

};

},{"./RequestClient":39}],41:[function(require,module,exports){
"use strict";

var _queued, _emitter, _isOpen, _socket, _handleMessage;

let _Symbol$for, _Symbol$for2;

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const ee = require('namespace-emitter');

module.exports = (_queued = /*#__PURE__*/_classPrivateFieldLooseKey("queued"), _emitter = /*#__PURE__*/_classPrivateFieldLooseKey("emitter"), _isOpen = /*#__PURE__*/_classPrivateFieldLooseKey("isOpen"), _socket = /*#__PURE__*/_classPrivateFieldLooseKey("socket"), _handleMessage = /*#__PURE__*/_classPrivateFieldLooseKey("handleMessage"), _Symbol$for = Symbol.for('uppy test: getSocket'), _Symbol$for2 = Symbol.for('uppy test: getQueued'), class UppySocket {
  constructor(opts) {
    Object.defineProperty(this, _queued, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _emitter, {
      writable: true,
      value: ee()
    });
    Object.defineProperty(this, _isOpen, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _socket, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handleMessage, {
      writable: true,
      value: e => {
        try {
          const message = JSON.parse(e.data);
          this.emit(message.action, message.payload);
        } catch (err) {
          // TODO: use a more robust error handler.
          console.log(err); // eslint-disable-line no-console
        }
      }
    });
    this.opts = opts;

    if (!opts || opts.autoOpen !== false) {
      this.open();
    }
  }

  get isOpen() {
    return _classPrivateFieldLooseBase(this, _isOpen)[_isOpen];
  }

  [_Symbol$for]() {
    return _classPrivateFieldLooseBase(this, _socket)[_socket];
  }

  [_Symbol$for2]() {
    return _classPrivateFieldLooseBase(this, _queued)[_queued];
  }

  open() {
    _classPrivateFieldLooseBase(this, _socket)[_socket] = new WebSocket(this.opts.target);

    _classPrivateFieldLooseBase(this, _socket)[_socket].onopen = () => {
      _classPrivateFieldLooseBase(this, _isOpen)[_isOpen] = true;

      while (_classPrivateFieldLooseBase(this, _queued)[_queued].length > 0 && _classPrivateFieldLooseBase(this, _isOpen)[_isOpen]) {
        const first = _classPrivateFieldLooseBase(this, _queued)[_queued].shift();

        this.send(first.action, first.payload);
      }
    };

    _classPrivateFieldLooseBase(this, _socket)[_socket].onclose = () => {
      _classPrivateFieldLooseBase(this, _isOpen)[_isOpen] = false;
    };

    _classPrivateFieldLooseBase(this, _socket)[_socket].onmessage = _classPrivateFieldLooseBase(this, _handleMessage)[_handleMessage];
  }

  close() {
    var _classPrivateFieldLoo;

    (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _socket)[_socket]) == null ? void 0 : _classPrivateFieldLoo.close();
  }

  send(action, payload) {
    // attach uuid
    if (!_classPrivateFieldLooseBase(this, _isOpen)[_isOpen]) {
      _classPrivateFieldLooseBase(this, _queued)[_queued].push({
        action,
        payload
      });

      return;
    }

    _classPrivateFieldLooseBase(this, _socket)[_socket].send(JSON.stringify({
      action,
      payload
    }));
  }

  on(action, handler) {
    _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(action, handler);
  }

  emit(action, payload) {
    _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(action, payload);
  }

  once(action, handler) {
    _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(action, handler);
  }

});

},{"namespace-emitter":15}],42:[function(require,module,exports){
'use strict';
/**
 * Manages communications with Companion
 */

const RequestClient = require('./RequestClient');

const Provider = require('./Provider');

const SearchProvider = require('./SearchProvider');

const Socket = require('./Socket');

module.exports = {
  RequestClient,
  Provider,
  SearchProvider,
  Socket
};

},{"./Provider":38,"./RequestClient":39,"./SearchProvider":40,"./Socket":41}],43:[function(require,module,exports){
'use strict';
/**
 * This module serves as an Async wrapper for LocalStorage
 */

module.exports.setItem = (key, value) => {
  return new Promise(resolve => {
    localStorage.setItem(key, value);
    resolve();
  });
};

module.exports.getItem = key => {
  return Promise.resolve(localStorage.getItem(key));
};

module.exports.removeItem = key => {
  return new Promise(resolve => {
    localStorage.removeItem(key);
    resolve();
  });
};

},{}],44:[function(require,module,exports){
"use strict";

/**
 * Core plugin logic that all plugins share.
 *
 * BasePlugin does not contain DOM rendering so it can be used for plugins
 * without a user interface.
 *
 * See `Plugin` for the extended version with Preact rendering for interfaces.
 */
const Translator = require('./../../utils/lib/Translator');

module.exports = class BasePlugin {
  constructor(uppy, opts = {}) {
    this.uppy = uppy;
    this.opts = opts;
  }

  getPluginState() {
    const {
      plugins
    } = this.uppy.getState();
    return plugins[this.id] || {};
  }

  setPluginState(update) {
    const {
      plugins
    } = this.uppy.getState();
    this.uppy.setState({
      plugins: { ...plugins,
        [this.id]: { ...plugins[this.id],
          ...update
        }
      }
    });
  }

  setOptions(newOpts) {
    this.opts = { ...this.opts,
      ...newOpts
    };
    this.setPluginState(); // so that UI re-renders with new options

    this.i18nInit();
  }

  i18nInit() {
    const translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = translator.translate.bind(translator);
    this.i18nArray = translator.translateArray.bind(translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  }
  /**
   * Extendable methods
   * ==================
   * These methods are here to serve as an overview of the extendable methods as well as
   * making them not conditional in use, such as `if (this.afterUpdate)`.
   */
  // eslint-disable-next-line class-methods-use-this


  addTarget() {
    throw new Error('Extend the addTarget method to add your plugin to another plugin\'s target');
  } // eslint-disable-next-line class-methods-use-this


  install() {} // eslint-disable-next-line class-methods-use-this


  uninstall() {}
  /**
   * Called when plugin is mounted, whether in DOM or into another plugin.
   * Needed because sometimes plugins are mounted separately/after `install`,
   * so this.el and this.parent might not be available in `install`.
   * This is the case with @uppy/react plugins, for example.
   */


  render() {
    throw new Error('Extend the render method to add your plugin to a DOM element');
  } // eslint-disable-next-line class-methods-use-this


  update() {} // Called after every state update, after everything's mounted. Debounced.
  // eslint-disable-next-line class-methods-use-this


  afterUpdate() {}

};

},{"./../../utils/lib/Translator":148}],45:[function(require,module,exports){
"use strict";

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const {
  render
} = require('preact');

const findDOMElement = require('./../../utils/lib/findDOMElement');

const BasePlugin = require('./BasePlugin');
/**
 * Defer a frequent call to the microtask queue.
 *
 * @param {() => T} fn
 * @returns {Promise<T>}
 */


function debounce(fn) {
  let calling = null;
  let latestArgs = null;
  return (...args) => {
    latestArgs = args;

    if (!calling) {
      calling = Promise.resolve().then(() => {
        calling = null; // At this point `args` may be different from the most
        // recent state, if multiple calls happened since this task
        // was queued. So we use the `latestArgs`, which definitely
        // is the most recent call.

        return fn(...latestArgs);
      });
    }

    return calling;
  };
}
/**
 * UIPlugin is the extended version of BasePlugin to incorporate rendering with Preact.
 * Use this for plugins that need a user interface.
 *
 * For plugins without an user interface, see BasePlugin.
 */


var _updateUI = /*#__PURE__*/_classPrivateFieldLooseKey("updateUI");

class UIPlugin extends BasePlugin {
  constructor(...args) {
    super(...args);
    Object.defineProperty(this, _updateUI, {
      writable: true,
      value: void 0
    });
  }

  /**
   * Check if supplied `target` is a DOM element or an `object`.
   * If its an object  target is a plugin, and we search `plugins`
   * for a plugin with same name and return its target.
   */
  mount(target, plugin) {
    const callerPluginName = plugin.id;
    const targetElement = findDOMElement(target);

    if (targetElement) {
      this.isTargetDOMEl = true; // When target is <body> with a single <div> element,
      // Preact thinks its the Uppy root element in there when doing a diff,
      // and destroys it. So we are creating a fragment (could be empty div)

      const uppyRootElement = document.createDocumentFragment(); // API for plugins that require a synchronous rerender.

      _classPrivateFieldLooseBase(this, _updateUI)[_updateUI] = debounce(state => {
        // plugin could be removed, but this.rerender is debounced below,
        // so it could still be called even after uppy.removePlugin or uppy.close
        // hence the check
        if (!this.uppy.getPlugin(this.id)) return;
        render(this.render(state), uppyRootElement);
        this.afterUpdate();
      });
      this.uppy.log(`Installing ${callerPluginName} to a DOM element '${target}'`);

      if (this.opts.replaceTargetContent) {
        // Doing render(h(null), targetElement), which should have been
        // a better way, since because the component might need to do additional cleanup when it is removed,
        // stopped working  Preact just adds null into target, not replacing
        targetElement.innerHTML = '';
      }

      render(this.render(this.uppy.getState()), uppyRootElement);
      this.el = uppyRootElement.firstElementChild;
      targetElement.appendChild(uppyRootElement);
      this.onMount();
      return this.el;
    }

    let targetPlugin;

    if (typeof target === 'object' && target instanceof UIPlugin) {
      // Targeting a plugin *instance*
      targetPlugin = target;
    } else if (typeof target === 'function') {
      // Targeting a plugin type
      const Target = target; // Find the target plugin instance.

      this.uppy.iteratePlugins(p => {
        if (p instanceof Target) {
          targetPlugin = p;
          return false;
        }
      });
    }

    if (targetPlugin) {
      this.uppy.log(`Installing ${callerPluginName} to ${targetPlugin.id}`);
      this.parent = targetPlugin;
      this.el = targetPlugin.addTarget(plugin);
      this.onMount();
      return this.el;
    }

    this.uppy.log(`Not installing ${callerPluginName}`);
    let message = `Invalid target option given to ${callerPluginName}.`;

    if (typeof target === 'function') {
      message += ' The given target is not a Plugin class. ' + 'Please check that you\'re not specifying a React Component instead of a plugin. ' + 'If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: ' + 'run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.';
    } else {
      message += 'If you meant to target an HTML element, please make sure that the element exists. ' + 'Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. ' + '(see https://github.com/transloadit/uppy/issues/1042)\n\n' + 'If you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.';
    }

    throw new Error(message);
  }

  update(state) {
    if (this.el != null) {
      var _classPrivateFieldLoo, _classPrivateFieldLoo2;

      (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _updateUI))[_updateUI]) == null ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2, state);
    }
  }

  unmount() {
    if (this.isTargetDOMEl) {
      var _this$el;

      (_this$el = this.el) == null ? void 0 : _this$el.remove();
    }

    this.onUnmount();
  } // eslint-disable-next-line class-methods-use-this


  onMount() {} // eslint-disable-next-line class-methods-use-this


  onUnmount() {}

}

module.exports = UIPlugin;

},{"./../../utils/lib/findDOMElement":154,"./BasePlugin":44,"preact":18}],46:[function(require,module,exports){
/* global AggregateError */
'use strict';

let _Symbol$for, _Symbol$for2;

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const Translator = require('./../../utils/lib/Translator');

const ee = require('namespace-emitter');

const {
  nanoid
} = require('nanoid');

const throttle = require('lodash.throttle');

const prettierBytes = require('@transloadit/prettier-bytes');

const match = require('mime-match');

const DefaultStore = require('./../../store-default');

const getFileType = require('./../../utils/lib/getFileType');

const getFileNameAndExtension = require('./../../utils/lib/getFileNameAndExtension');

const generateFileID = require('./../../utils/lib/generateFileID');

const supportsUploadProgress = require('./supportsUploadProgress');

const getFileName = require('./getFileName');

const {
  justErrorsLogger,
  debugLogger
} = require('./loggers');

const locale = require('./locale'); // Exported from here.


class RestrictionError extends Error {
  constructor(...args) {
    super(...args);
    this.isRestriction = true;
  }

}

if (typeof AggregateError === 'undefined') {
  // eslint-disable-next-line no-global-assign
  globalThis.AggregateError = class AggregateError extends Error {
    constructor(errors, message) {
      super(message);
      this.errors = errors;
    }

  };
}

class AggregateRestrictionError extends AggregateError {
  constructor(...args) {
    super(...args);
    this.isRestriction = true;
  }

}
/**
 * Uppy Core module.
 * Manages plugins, state updates, acts as an event bus,
 * adds/removes files and metadata.
 */


var _plugins = /*#__PURE__*/_classPrivateFieldLooseKey("plugins");

var _storeUnsubscribe = /*#__PURE__*/_classPrivateFieldLooseKey("storeUnsubscribe");

var _emitter = /*#__PURE__*/_classPrivateFieldLooseKey("emitter");

var _preProcessors = /*#__PURE__*/_classPrivateFieldLooseKey("preProcessors");

var _uploaders = /*#__PURE__*/_classPrivateFieldLooseKey("uploaders");

var _postProcessors = /*#__PURE__*/_classPrivateFieldLooseKey("postProcessors");

var _checkRestrictions = /*#__PURE__*/_classPrivateFieldLooseKey("checkRestrictions");

var _checkMinNumberOfFiles = /*#__PURE__*/_classPrivateFieldLooseKey("checkMinNumberOfFiles");

var _checkRequiredMetaFieldsOnFile = /*#__PURE__*/_classPrivateFieldLooseKey("checkRequiredMetaFieldsOnFile");

var _checkRequiredMetaFields = /*#__PURE__*/_classPrivateFieldLooseKey("checkRequiredMetaFields");

var _showOrLogErrorAndThrow = /*#__PURE__*/_classPrivateFieldLooseKey("showOrLogErrorAndThrow");

var _assertNewUploadAllowed = /*#__PURE__*/_classPrivateFieldLooseKey("assertNewUploadAllowed");

var _checkAndCreateFileStateObject = /*#__PURE__*/_classPrivateFieldLooseKey("checkAndCreateFileStateObject");

var _startIfAutoProceed = /*#__PURE__*/_classPrivateFieldLooseKey("startIfAutoProceed");

var _addListeners = /*#__PURE__*/_classPrivateFieldLooseKey("addListeners");

var _updateOnlineStatus = /*#__PURE__*/_classPrivateFieldLooseKey("updateOnlineStatus");

var _createUpload = /*#__PURE__*/_classPrivateFieldLooseKey("createUpload");

var _getUpload = /*#__PURE__*/_classPrivateFieldLooseKey("getUpload");

var _removeUpload = /*#__PURE__*/_classPrivateFieldLooseKey("removeUpload");

var _runUpload = /*#__PURE__*/_classPrivateFieldLooseKey("runUpload");

_Symbol$for = Symbol.for('uppy test: getPlugins');
_Symbol$for2 = Symbol.for('uppy test: createUpload');

class Uppy {
  // eslint-disable-next-line global-require

  /** @type {Record<string, BasePlugin[]>} */

  /**
   * Instantiate Uppy
   *
   * @param {object} opts  Uppy options
   */
  constructor(_opts) {
    Object.defineProperty(this, _runUpload, {
      value: _runUpload2
    });
    Object.defineProperty(this, _removeUpload, {
      value: _removeUpload2
    });
    Object.defineProperty(this, _getUpload, {
      value: _getUpload2
    });
    Object.defineProperty(this, _createUpload, {
      value: _createUpload2
    });
    Object.defineProperty(this, _addListeners, {
      value: _addListeners2
    });
    Object.defineProperty(this, _startIfAutoProceed, {
      value: _startIfAutoProceed2
    });
    Object.defineProperty(this, _checkAndCreateFileStateObject, {
      value: _checkAndCreateFileStateObject2
    });
    Object.defineProperty(this, _assertNewUploadAllowed, {
      value: _assertNewUploadAllowed2
    });
    Object.defineProperty(this, _showOrLogErrorAndThrow, {
      value: _showOrLogErrorAndThrow2
    });
    Object.defineProperty(this, _checkRequiredMetaFields, {
      value: _checkRequiredMetaFields2
    });
    Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {
      value: _checkRequiredMetaFieldsOnFile2
    });
    Object.defineProperty(this, _checkMinNumberOfFiles, {
      value: _checkMinNumberOfFiles2
    });
    Object.defineProperty(this, _checkRestrictions, {
      value: _checkRestrictions2
    });
    Object.defineProperty(this, _plugins, {
      writable: true,
      value: Object.create(null)
    });
    Object.defineProperty(this, _storeUnsubscribe, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _emitter, {
      writable: true,
      value: ee()
    });
    Object.defineProperty(this, _preProcessors, {
      writable: true,
      value: new Set()
    });
    Object.defineProperty(this, _uploaders, {
      writable: true,
      value: new Set()
    });
    Object.defineProperty(this, _postProcessors, {
      writable: true,
      value: new Set()
    });
    Object.defineProperty(this, _updateOnlineStatus, {
      writable: true,
      value: this.updateOnlineStatus.bind(this)
    });
    this.defaultLocale = locale;
    const defaultOptions = {
      id: 'uppy',
      autoProceed: false,

      /**
       * @deprecated The method should not be used
       */
      allowMultipleUploads: true,
      allowMultipleUploadBatches: true,
      debug: false,
      restrictions: {
        maxFileSize: null,
        minFileSize: null,
        maxTotalFileSize: null,
        maxNumberOfFiles: null,
        minNumberOfFiles: null,
        allowedFileTypes: null,
        requiredMetaFields: []
      },
      meta: {},
      onBeforeFileAdded: currentFile => currentFile,
      onBeforeUpload: files => files,
      store: DefaultStore(),
      logger: justErrorsLogger,
      infoTimeout: 5000
    }; // Merge default options with the ones set by user,
    // making sure to merge restrictions too

    this.opts = { ...defaultOptions,
      ..._opts,
      restrictions: { ...defaultOptions.restrictions,
        ...(_opts && _opts.restrictions)
      }
    }; // Support debug: true for backwards-compatability, unless logger is set in opts
    // opts instead of this.opts to avoid comparing objects  we set logger: justErrorsLogger in defaultOptions

    if (_opts && _opts.logger && _opts.debug) {
      this.log('You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.', 'warning');
    } else if (_opts && _opts.debug) {
      this.opts.logger = debugLogger;
    }

    this.log(`Using Core v${this.constructor.VERSION}`);

    if (this.opts.restrictions.allowedFileTypes && this.opts.restrictions.allowedFileTypes !== null && !Array.isArray(this.opts.restrictions.allowedFileTypes)) {
      throw new TypeError('`restrictions.allowedFileTypes` must be an array');
    }

    this.i18nInit(); // ___Why throttle at 500ms?
    //    - We must throttle at >250ms for superfocus in Dashboard to work well
    //    (because animation takes 0.25s, and we want to wait for all animations to be over before refocusing).
    //    [Practical Check]: if thottle is at 100ms, then if you are uploading a file,
    //    and click 'ADD MORE FILES', - focus won't activate in Firefox.
    //    - We must throttle at around >500ms to avoid performance lags.
    //    [Practical Check] Firefox, try to upload a big file for a prolonged period of time. Laptop will start to heat up.

    this.calculateProgress = throttle(this.calculateProgress.bind(this), 500, {
      leading: true,
      trailing: true
    });
    this.store = this.opts.store;
    this.setState({
      plugins: {},
      files: {},
      currentUploads: {},
      allowNewUpload: true,
      capabilities: {
        uploadProgress: supportsUploadProgress(),
        individualCancellation: true,
        resumableUploads: false
      },
      totalProgress: 0,
      meta: { ...this.opts.meta
      },
      info: [],
      recoveredState: null
    });
    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe((prevState, nextState, patch) => {
      this.emit('state-update', prevState, nextState, patch);
      this.updateAll(nextState);
    }); // Exposing uppy object on window for debugging and testing

    if (this.opts.debug && typeof window !== 'undefined') {
      window[this.opts.id] = this;
    }

    _classPrivateFieldLooseBase(this, _addListeners)[_addListeners]();
  }

  emit(event, ...args) {
    _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(event, ...args);
  }

  on(event, callback) {
    _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event, callback);

    return this;
  }

  once(event, callback) {
    _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(event, callback);

    return this;
  }

  off(event, callback) {
    _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event, callback);

    return this;
  }
  /**
   * Iterate on all plugins and run `update` on them.
   * Called each time state changes.
   *
   */


  updateAll(state) {
    this.iteratePlugins(plugin => {
      plugin.update(state);
    });
  }
  /**
   * Updates state with a patch
   *
   * @param {object} patch {foo: 'bar'}
   */


  setState(patch) {
    this.store.setState(patch);
  }
  /**
   * Returns current state.
   *
   * @returns {object}
   */


  getState() {
    return this.store.getState();
  }
  /**
   * Back compat for when uppy.state is used instead of uppy.getState().
   *
   * @deprecated
   */


  get state() {
    // Here, state is a non-enumerable property.
    return this.getState();
  }
  /**
   * Shorthand to set state for a specific file.
   */


  setFileState(fileID, state) {
    if (!this.getState().files[fileID]) {
      throw new Error(`Cant set state for ${fileID} (the file could have been removed)`);
    }

    this.setState({
      files: { ...this.getState().files,
        [fileID]: { ...this.getState().files[fileID],
          ...state
        }
      }
    });
  }

  i18nInit() {
    const translator = new Translator([this.defaultLocale, this.opts.locale]);
    this.i18n = translator.translate.bind(translator);
    this.i18nArray = translator.translateArray.bind(translator);
    this.locale = translator.locale;
  }

  setOptions(newOpts) {
    this.opts = { ...this.opts,
      ...newOpts,
      restrictions: { ...this.opts.restrictions,
        ...(newOpts && newOpts.restrictions)
      }
    };

    if (newOpts.meta) {
      this.setMeta(newOpts.meta);
    }

    this.i18nInit();

    if (newOpts.locale) {
      this.iteratePlugins(plugin => {
        plugin.setOptions();
      });
    } // Note: this is not the preact `setState`, it's an internal function that has the same name.


    this.setState(); // so that UI re-renders with new options
  }

  resetProgress() {
    const defaultProgress = {
      percentage: 0,
      bytesUploaded: 0,
      uploadComplete: false,
      uploadStarted: null
    };
    const files = { ...this.getState().files
    };
    const updatedFiles = {};
    Object.keys(files).forEach(fileID => {
      const updatedFile = { ...files[fileID]
      };
      updatedFile.progress = { ...updatedFile.progress,
        ...defaultProgress
      };
      updatedFiles[fileID] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      totalProgress: 0
    });
    this.emit('reset-progress');
  }

  addPreProcessor(fn) {
    _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].add(fn);
  }

  removePreProcessor(fn) {
    return _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].delete(fn);
  }

  addPostProcessor(fn) {
    _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].add(fn);
  }

  removePostProcessor(fn) {
    return _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].delete(fn);
  }

  addUploader(fn) {
    _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].add(fn);
  }

  removeUploader(fn) {
    return _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].delete(fn);
  }

  setMeta(data) {
    const updatedMeta = { ...this.getState().meta,
      ...data
    };
    const updatedFiles = { ...this.getState().files
    };
    Object.keys(updatedFiles).forEach(fileID => {
      updatedFiles[fileID] = { ...updatedFiles[fileID],
        meta: { ...updatedFiles[fileID].meta,
          ...data
        }
      };
    });
    this.log('Adding metadata:');
    this.log(data);
    this.setState({
      meta: updatedMeta,
      files: updatedFiles
    });
  }

  setFileMeta(fileID, data) {
    const updatedFiles = { ...this.getState().files
    };

    if (!updatedFiles[fileID]) {
      this.log('Was trying to set metadata for a file that has been removed: ', fileID);
      return;
    }

    const newMeta = { ...updatedFiles[fileID].meta,
      ...data
    };
    updatedFiles[fileID] = { ...updatedFiles[fileID],
      meta: newMeta
    };
    this.setState({
      files: updatedFiles
    });
  }
  /**
   * Get a file object.
   *
   * @param {string} fileID The ID of the file object to return.
   */


  getFile(fileID) {
    return this.getState().files[fileID];
  }
  /**
   * Get all files in an array.
   */


  getFiles() {
    const {
      files
    } = this.getState();
    return Object.values(files);
  }

  getObjectOfFilesPerState() {
    const {
      files: filesObject,
      totalProgress,
      error
    } = this.getState();
    const files = Object.values(filesObject);
    const inProgressFiles = files.filter(({
      progress
    }) => !progress.uploadComplete && progress.uploadStarted);
    const newFiles = files.filter(file => !file.progress.uploadStarted);
    const startedFiles = files.filter(file => file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess);
    const uploadStartedFiles = files.filter(file => file.progress.uploadStarted);
    const pausedFiles = files.filter(file => file.isPaused);
    const completeFiles = files.filter(file => file.progress.uploadComplete);
    const erroredFiles = files.filter(file => file.error);
    const inProgressNotPausedFiles = inProgressFiles.filter(file => !file.isPaused);
    const processingFiles = files.filter(file => file.progress.preprocess || file.progress.postprocess);
    return {
      newFiles,
      startedFiles,
      uploadStartedFiles,
      pausedFiles,
      completeFiles,
      erroredFiles,
      inProgressFiles,
      inProgressNotPausedFiles,
      processingFiles,
      isUploadStarted: uploadStartedFiles.length > 0,
      isAllComplete: totalProgress === 100 && completeFiles.length === files.length && processingFiles.length === 0,
      isAllErrored: !!error && erroredFiles.length === files.length,
      isAllPaused: inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length,
      isUploadInProgress: inProgressFiles.length > 0,
      isSomeGhost: files.some(file => file.isGhost)
    };
  }
  /**
   * A public wrapper for _checkRestrictions  checks if a file passes a set of restrictions.
   * For use in UI pluigins (like Providers), to disallow selecting files that wont pass restrictions.
   *
   * @param {object} file object to check
   * @param {Array} [files] array to check maxNumberOfFiles and maxTotalFileSize
   * @returns {object} { result: true/false, reason: why file didnt pass restrictions }
   */


  validateRestrictions(file, files) {
    try {
      _classPrivateFieldLooseBase(this, _checkRestrictions)[_checkRestrictions](file, files);

      return {
        result: true
      };
    } catch (err) {
      return {
        result: false,
        reason: err.message
      };
    }
  }
  /**
   * Check if file passes a set of restrictions set in options: maxFileSize, minFileSize,
   * maxNumberOfFiles and allowedFileTypes.
   *
   * @param {object} file object to check
   * @param {Array} [files] array to check maxNumberOfFiles and maxTotalFileSize
   * @private
   */


  checkIfFileAlreadyExists(fileID) {
    const {
      files
    } = this.getState();

    if (files[fileID] && !files[fileID].isGhost) {
      return true;
    }

    return false;
  }
  /**
   * Create a file state object based on user-provided `addFile()` options.
   *
   * Note this is extremely side-effectful and should only be done when a file state object
   * will be added to state immediately afterward!
   *
   * The `files` value is passed in because it may be updated by the caller without updating the store.
   */


  /**
   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,
   * try to guess file type in a clever way, check file against restrictions,
   * and start an upload if `autoProceed === true`.
   *
   * @param {object} file object to add
   * @returns {string} id for the added file
   */
  addFile(file) {
    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);

    const {
      files
    } = this.getState();

    let newFile = _classPrivateFieldLooseBase(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, file); // Users are asked to re-select recovered files without data,
    // and to keep the progress, meta and everthing else, we only replace said data


    if (files[newFile.id] && files[newFile.id].isGhost) {
      newFile = { ...files[newFile.id],
        data: file.data,
        isGhost: false
      };
      this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);
    }

    this.setState({
      files: { ...files,
        [newFile.id]: newFile
      }
    });
    this.emit('file-added', newFile);
    this.emit('files-added', [newFile]);
    this.log(`Added file: ${newFile.name}, ${newFile.id}, mime type: ${newFile.type}`);

    _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();

    return newFile.id;
  }
  /**
   * Add multiple files to `state.files`. See the `addFile()` documentation.
   *
   * If an error occurs while adding a file, it is logged and the user is notified.
   * This is good for UI plugins, but not for programmatic use.
   * Programmatic users should usually still use `addFile()` on individual files.
   */


  addFiles(fileDescriptors) {
    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](); // create a copy of the files object only once


    const files = { ...this.getState().files
    };
    const newFiles = [];
    const errors = [];

    for (let i = 0; i < fileDescriptors.length; i++) {
      try {
        let newFile = _classPrivateFieldLooseBase(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, fileDescriptors[i]); // Users are asked to re-select recovered files without data,
        // and to keep the progress, meta and everthing else, we only replace said data


        if (files[newFile.id] && files[newFile.id].isGhost) {
          newFile = { ...files[newFile.id],
            data: fileDescriptors[i].data,
            isGhost: false
          };
          this.log(`Replaced blob in a ghost file: ${newFile.name}, ${newFile.id}`);
        }

        files[newFile.id] = newFile;
        newFiles.push(newFile);
      } catch (err) {
        if (!err.isRestriction) {
          errors.push(err);
        }
      }
    }

    this.setState({
      files
    });
    newFiles.forEach(newFile => {
      this.emit('file-added', newFile);
    });
    this.emit('files-added', newFiles);

    if (newFiles.length > 5) {
      this.log(`Added batch of ${newFiles.length} files`);
    } else {
      Object.keys(newFiles).forEach(fileID => {
        this.log(`Added file: ${newFiles[fileID].name}\n id: ${newFiles[fileID].id}\n type: ${newFiles[fileID].type}`);
      });
    }

    if (newFiles.length > 0) {
      _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();
    }

    if (errors.length > 0) {
      let message = 'Multiple errors occurred while adding files:\n';
      errors.forEach(subError => {
        message += `\n * ${subError.message}`;
      });
      this.info({
        message: this.i18n('addBulkFilesFailed', {
          smart_count: errors.length
        }),
        details: message
      }, 'error', this.opts.infoTimeout);

      if (typeof AggregateError === 'function') {
        throw new AggregateError(errors, message);
      } else {
        const err = new Error(message);
        err.errors = errors;
        throw err;
      }
    }
  }

  removeFiles(fileIDs, reason) {
    const {
      files,
      currentUploads
    } = this.getState();
    const updatedFiles = { ...files
    };
    const updatedUploads = { ...currentUploads
    };
    const removedFiles = Object.create(null);
    fileIDs.forEach(fileID => {
      if (files[fileID]) {
        removedFiles[fileID] = files[fileID];
        delete updatedFiles[fileID];
      }
    }); // Remove files from the `fileIDs` list in each upload.

    function fileIsNotRemoved(uploadFileID) {
      return removedFiles[uploadFileID] === undefined;
    }

    Object.keys(updatedUploads).forEach(uploadID => {
      const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved); // Remove the upload if no files are associated with it anymore.

      if (newFileIDs.length === 0) {
        delete updatedUploads[uploadID];
        return;
      }

      updatedUploads[uploadID] = { ...currentUploads[uploadID],
        fileIDs: newFileIDs
      };
    });
    const stateUpdate = {
      currentUploads: updatedUploads,
      files: updatedFiles
    }; // If all files were removed - allow new uploads,
    // and clear recoveredState

    if (Object.keys(updatedFiles).length === 0) {
      stateUpdate.allowNewUpload = true;
      stateUpdate.error = null;
      stateUpdate.recoveredState = null;
    }

    this.setState(stateUpdate);
    this.calculateTotalProgress();
    const removedFileIDs = Object.keys(removedFiles);
    removedFileIDs.forEach(fileID => {
      this.emit('file-removed', removedFiles[fileID], reason);
    });

    if (removedFileIDs.length > 5) {
      this.log(`Removed ${removedFileIDs.length} files`);
    } else {
      this.log(`Removed files: ${removedFileIDs.join(', ')}`);
    }
  }

  removeFile(fileID, reason = null) {
    this.removeFiles([fileID], reason);
  }

  pauseResume(fileID) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
      return undefined;
    }

    const wasPaused = this.getFile(fileID).isPaused || false;
    const isPaused = !wasPaused;
    this.setFileState(fileID, {
      isPaused
    });
    this.emit('upload-pause', fileID, isPaused);
    return isPaused;
  }

  pauseAll() {
    const updatedFiles = { ...this.getState().files
    };
    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter(file => {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(file => {
      const updatedFile = { ...updatedFiles[file],
        isPaused: true
      };
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('pause-all');
  }

  resumeAll() {
    const updatedFiles = { ...this.getState().files
    };
    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter(file => {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(file => {
      const updatedFile = { ...updatedFiles[file],
        isPaused: false,
        error: null
      };
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('resume-all');
  }

  retryAll() {
    const updatedFiles = { ...this.getState().files
    };
    const filesToRetry = Object.keys(updatedFiles).filter(file => {
      return updatedFiles[file].error;
    });
    filesToRetry.forEach(file => {
      const updatedFile = { ...updatedFiles[file],
        isPaused: false,
        error: null
      };
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      error: null
    });
    this.emit('retry-all', filesToRetry);

    if (filesToRetry.length === 0) {
      return Promise.resolve({
        successful: [],
        failed: []
      });
    }

    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](filesToRetry, {
      forceAllowNewUpload: true // create new upload even if allowNewUpload: false

    });

    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
  }

  cancelAll() {
    this.emit('cancel-all');
    const {
      files
    } = this.getState();
    const fileIDs = Object.keys(files);

    if (fileIDs.length) {
      this.removeFiles(fileIDs, 'cancel-all');
    }

    this.setState({
      totalProgress: 0,
      error: null,
      recoveredState: null
    });
  }

  retryUpload(fileID) {
    this.setFileState(fileID, {
      error: null,
      isPaused: false
    });
    this.emit('upload-retry', fileID);

    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload]([fileID], {
      forceAllowNewUpload: true // create new upload even if allowNewUpload: false

    });

    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
  }

  reset() {
    this.cancelAll();
  }

  logout() {
    this.iteratePlugins(plugin => {
      if (plugin.provider && plugin.provider.logout) {
        plugin.provider.logout();
      }
    });
  }

  calculateProgress(file, data) {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    } // bytesTotal may be null or zero; in that case we can't divide by it


    const canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;
    this.setFileState(file.id, {
      progress: { ...this.getFile(file.id).progress,
        bytesUploaded: data.bytesUploaded,
        bytesTotal: data.bytesTotal,
        percentage: canHavePercentage ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
      }
    });
    this.calculateTotalProgress();
  }

  calculateTotalProgress() {
    // calculate total progress, using the number of files currently uploading,
    // multiplied by 100 and the summ of individual progress of each file
    const files = this.getFiles();
    const inProgress = files.filter(file => {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });

    if (inProgress.length === 0) {
      this.emit('progress', 0);
      this.setState({
        totalProgress: 0
      });
      return;
    }

    const sizedFiles = inProgress.filter(file => file.progress.bytesTotal != null);
    const unsizedFiles = inProgress.filter(file => file.progress.bytesTotal == null);

    if (sizedFiles.length === 0) {
      const progressMax = inProgress.length * 100;
      const currentProgress = unsizedFiles.reduce((acc, file) => {
        return acc + file.progress.percentage;
      }, 0);
      const totalProgress = Math.round(currentProgress / progressMax * 100);
      this.setState({
        totalProgress
      });
      return;
    }

    let totalSize = sizedFiles.reduce((acc, file) => {
      return acc + file.progress.bytesTotal;
    }, 0);
    const averageSize = totalSize / sizedFiles.length;
    totalSize += averageSize * unsizedFiles.length;
    let uploadedSize = 0;
    sizedFiles.forEach(file => {
      uploadedSize += file.progress.bytesUploaded;
    });
    unsizedFiles.forEach(file => {
      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
    });
    let totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100); // hot fix, because:
    // uploadedSize ended up larger than totalSize, resulting in 1325% total

    if (totalProgress > 100) {
      totalProgress = 100;
    }

    this.setState({
      totalProgress
    });
    this.emit('progress', totalProgress);
  }
  /**
   * Registers listeners for all global actions, like:
   * `error`, `file-removed`, `upload-progress`
   */


  updateOnlineStatus() {
    const online = typeof window.navigator.onLine !== 'undefined' ? window.navigator.onLine : true;

    if (!online) {
      this.emit('is-offline');
      this.info(this.i18n('noInternetConnection'), 'error', 0);
      this.wasOffline = true;
    } else {
      this.emit('is-online');

      if (this.wasOffline) {
        this.emit('back-online');
        this.info(this.i18n('connectedToInternet'), 'success', 3000);
        this.wasOffline = false;
      }
    }
  }

  getID() {
    return this.opts.id;
  }
  /**
   * Registers a plugin with Core.
   *
   * @param {object} Plugin object
   * @param {object} [opts] object with options to be passed to Plugin
   * @returns {object} self for chaining
   */
  // eslint-disable-next-line no-shadow


  use(Plugin, opts) {
    if (typeof Plugin !== 'function') {
      const msg = `Expected a plugin class, but got ${Plugin === null ? 'null' : typeof Plugin}.` + ' Please verify that the plugin was imported and spelled correctly.';
      throw new TypeError(msg);
    } // Instantiate


    const plugin = new Plugin(this, opts);
    const pluginId = plugin.id;

    if (!pluginId) {
      throw new Error('Your plugin must have an id');
    }

    if (!plugin.type) {
      throw new Error('Your plugin must have a type');
    }

    const existsPluginAlready = this.getPlugin(pluginId);

    if (existsPluginAlready) {
      const msg = `Already found a plugin named '${existsPluginAlready.id}'. ` + `Tried to use: '${pluginId}'.\n` + 'Uppy plugins must have unique `id` options. See https://uppy.io/docs/plugins/#id.';
      throw new Error(msg);
    }

    if (Plugin.VERSION) {
      this.log(`Using ${pluginId} v${Plugin.VERSION}`);
    }

    if (plugin.type in _classPrivateFieldLooseBase(this, _plugins)[_plugins]) {
      _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type].push(plugin);
    } else {
      _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type] = [plugin];
    }

    plugin.install();
    return this;
  }
  /**
   * Find one Plugin by name.
   *
   * @param {string} id plugin id
   * @returns {BasePlugin|undefined}
   */


  getPlugin(id) {
    for (const plugins of Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins])) {
      const foundPlugin = plugins.find(plugin => plugin.id === id);
      if (foundPlugin != null) return foundPlugin;
    }

    return undefined;
  }

  [_Symbol$for](type) {
    return _classPrivateFieldLooseBase(this, _plugins)[_plugins][type];
  }
  /**
   * Iterate through all `use`d plugins.
   *
   * @param {Function} method that will be run on each plugin
   */


  iteratePlugins(method) {
    Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins]).flat(1).forEach(method);
  }
  /**
   * Uninstall and remove a plugin.
   *
   * @param {object} instance The plugin instance to remove.
   */


  removePlugin(instance) {
    this.log(`Removing plugin ${instance.id}`);
    this.emit('plugin-remove', instance);

    if (instance.uninstall) {
      instance.uninstall();
    }

    const list = _classPrivateFieldLooseBase(this, _plugins)[_plugins][instance.type]; // list.indexOf failed here, because Vue3 converted the plugin instance
    // to a Proxy object, which failed the strict comparison test:
    // obj !== objProxy


    const index = list.findIndex(item => item.id === instance.id);

    if (index !== -1) {
      list.splice(index, 1);
    }

    const state = this.getState();
    const updatedState = {
      plugins: { ...state.plugins,
        [instance.id]: undefined
      }
    };
    this.setState(updatedState);
  }
  /**
   * Uninstall all plugins and close down this Uppy instance.
   */


  close() {
    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);
    this.reset();

    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe]();

    this.iteratePlugins(plugin => {
      this.removePlugin(plugin);
    });

    if (typeof window !== 'undefined' && window.removeEventListener) {
      window.removeEventListener('online', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
      window.removeEventListener('offline', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
    }
  }

  hideInfo() {
    const {
      info
    } = this.getState();
    this.setState({
      info: info.slice(1)
    });
    this.emit('info-hidden');
  }
  /**
   * Set info message in `state.info`, so that UI plugins like `Informer`
   * can display the message.
   *
   * @param {string | object} message Message to be displayed by the informer
   * @param {string} [type]
   * @param {number} [duration]
   */


  info(message, type = 'info', duration = 3000) {
    const isComplexMessage = typeof message === 'object';
    this.setState({
      info: [...this.getState().info, {
        type,
        message: isComplexMessage ? message.message : message,
        details: isComplexMessage ? message.details : null
      }]
    });
    setTimeout(() => this.hideInfo(), duration);
    this.emit('info-visible');
  }
  /**
   * Passes messages to a function, provided in `opts.logger`.
   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.
   *
   * @param {string|object} message to log
   * @param {string} [type] optional `error` or `warning`
   */


  log(message, type) {
    const {
      logger
    } = this.opts;

    switch (type) {
      case 'error':
        logger.error(message);
        break;

      case 'warning':
        logger.warn(message);
        break;

      default:
        logger.debug(message);
        break;
    }
  }
  /**
   * Restore an upload by its ID.
   */


  restore(uploadID) {
    this.log(`Core: attempting to restore upload "${uploadID}"`);

    if (!this.getState().currentUploads[uploadID]) {
      _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);

      return Promise.reject(new Error('Nonexistent upload'));
    }

    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
  }
  /**
   * Create an upload for a bunch of files.
   *
   * @param {Array<string>} fileIDs File IDs to include in this upload.
   * @returns {string} ID of this upload.
   */


  [_Symbol$for2](...args) {
    return _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](...args);
  }

  /**
   * Add data to an upload's result object.
   *
   * @param {string} uploadID The ID of the upload.
   * @param {object} data Data properties to add to the result object.
   */
  addResultData(uploadID, data) {
    if (!_classPrivateFieldLooseBase(this, _getUpload)[_getUpload](uploadID)) {
      this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
      return;
    }

    const {
      currentUploads
    } = this.getState();
    const currentUpload = { ...currentUploads[uploadID],
      result: { ...currentUploads[uploadID].result,
        ...data
      }
    };
    this.setState({
      currentUploads: { ...currentUploads,
        [uploadID]: currentUpload
      }
    });
  }
  /**
   * Remove an upload, eg. if it has been canceled or completed.
   *
   * @param {string} uploadID The ID of the upload.
   */


  /**
   * Start an upload for all the files that are not currently being uploaded.
   *
   * @returns {Promise}
   */
  upload() {
    var _classPrivateFieldLoo;

    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _plugins)[_plugins].uploader) != null && _classPrivateFieldLoo.length)) {
      this.log('No uploader type plugins are used', 'warning');
    }

    let {
      files
    } = this.getState();
    const onBeforeUploadResult = this.opts.onBeforeUpload(files);

    if (onBeforeUploadResult === false) {
      return Promise.reject(new Error('Not starting the upload because onBeforeUpload returned false'));
    }

    if (onBeforeUploadResult && typeof onBeforeUploadResult === 'object') {
      files = onBeforeUploadResult; // Updating files in state, because uploader plugins receive file IDs,
      // and then fetch the actual file object from state

      this.setState({
        files
      });
    }

    return Promise.resolve().then(() => {
      _classPrivateFieldLooseBase(this, _checkMinNumberOfFiles)[_checkMinNumberOfFiles](files);

      _classPrivateFieldLooseBase(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files);
    }).catch(err => {
      _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err);
    }).then(() => {
      const {
        currentUploads
      } = this.getState(); // get a list of files that are currently assigned to uploads

      const currentlyUploadingFiles = Object.values(currentUploads).flatMap(curr => curr.fileIDs);
      const waitingFileIDs = [];
      Object.keys(files).forEach(fileID => {
        const file = this.getFile(fileID); // if the file hasn't started uploading and hasn't already been assigned to an upload..

        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
          waitingFileIDs.push(file.id);
        }
      });

      const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](waitingFileIDs);

      return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
    }).catch(err => {
      _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err, {
        showInformer: false
      });
    });
  }

}

function _checkRestrictions2(file, files = this.getFiles()) {
  const {
    maxFileSize,
    minFileSize,
    maxTotalFileSize,
    maxNumberOfFiles,
    allowedFileTypes
  } = this.opts.restrictions;

  if (maxNumberOfFiles) {
    if (files.length + 1 > maxNumberOfFiles) {
      throw new RestrictionError(`${this.i18n('youCanOnlyUploadX', {
        smart_count: maxNumberOfFiles
      })}`);
    }
  }

  if (allowedFileTypes) {
    const isCorrectFileType = allowedFileTypes.some(type => {
      // check if this is a mime-type
      if (type.indexOf('/') > -1) {
        if (!file.type) return false;
        return match(file.type.replace(/;.*?$/, ''), type);
      } // otherwise this is likely an extension


      if (type[0] === '.' && file.extension) {
        return file.extension.toLowerCase() === type.substr(1).toLowerCase();
      }

      return false;
    });

    if (!isCorrectFileType) {
      const allowedFileTypesString = allowedFileTypes.join(', ');
      throw new RestrictionError(this.i18n('youCanOnlyUploadFileTypes', {
        types: allowedFileTypesString
      }));
    }
  } // We can't check maxTotalFileSize if the size is unknown.


  if (maxTotalFileSize && file.size != null) {
    let totalFilesSize = 0;
    totalFilesSize += file.size;
    files.forEach(f => {
      totalFilesSize += f.size;
    });

    if (totalFilesSize > maxTotalFileSize) {
      throw new RestrictionError(this.i18n('exceedsSize', {
        size: prettierBytes(maxTotalFileSize),
        file: file.name
      }));
    }
  } // We can't check maxFileSize if the size is unknown.


  if (maxFileSize && file.size != null) {
    if (file.size > maxFileSize) {
      throw new RestrictionError(this.i18n('exceedsSize', {
        size: prettierBytes(maxFileSize),
        file: file.name
      }));
    }
  } // We can't check minFileSize if the size is unknown.


  if (minFileSize && file.size != null) {
    if (file.size < minFileSize) {
      throw new RestrictionError(this.i18n('inferiorSize', {
        size: prettierBytes(minFileSize)
      }));
    }
  }
}

function _checkMinNumberOfFiles2(files) {
  const {
    minNumberOfFiles
  } = this.opts.restrictions;

  if (Object.keys(files).length < minNumberOfFiles) {
    throw new RestrictionError(`${this.i18n('youHaveToAtLeastSelectX', {
      smart_count: minNumberOfFiles
    })}`);
  }
}

function _checkRequiredMetaFieldsOnFile2(file) {
  const {
    requiredMetaFields
  } = this.opts.restrictions;
  const {
    hasOwnProperty
  } = Object.prototype;
  const errors = [];
  const missingFields = [];

  for (let i = 0; i < requiredMetaFields.length; i++) {
    if (!hasOwnProperty.call(file.meta, requiredMetaFields[i]) || file.meta[requiredMetaFields[i]] === '') {
      const err = new RestrictionError(`${this.i18n('missingRequiredMetaFieldOnFile', {
        fileName: file.name
      })}`);
      errors.push(err);
      missingFields.push(requiredMetaFields[i]);

      _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err, {
        file,
        showInformer: false,
        throwErr: false
      });
    }
  }

  this.setFileState(file.id, {
    missingRequiredMetaFields: missingFields
  });
  return errors;
}

function _checkRequiredMetaFields2(files) {
  const errors = Object.keys(files).flatMap(fileID => {
    const file = this.getFile(fileID);
    return _classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
  });

  if (errors.length) {
    throw new AggregateRestrictionError(errors, `${this.i18n('missingRequiredMetaField')}`);
  }
}

function _showOrLogErrorAndThrow2(err, {
  showInformer = true,
  file = null,
  throwErr = true
} = {}) {
  const message = typeof err === 'object' ? err.message : err;
  const details = typeof err === 'object' && err.details ? err.details : ''; // Restriction errors should be logged, but not as errors,
  // as they are expected and shown in the UI.

  let logMessageWithDetails = message;

  if (details) {
    logMessageWithDetails += ` ${details}`;
  }

  if (err.isRestriction) {
    this.log(logMessageWithDetails);
    this.emit('restriction-failed', file, err);
  } else {
    this.log(logMessageWithDetails, 'error');
  } // Sometimes informer has to be shown manually by the developer,
  // for example, in `onBeforeFileAdded`.


  if (showInformer) {
    this.info({
      message,
      details
    }, 'error', this.opts.infoTimeout);
  }

  if (throwErr) {
    throw typeof err === 'object' ? err : new Error(err);
  }
}

function _assertNewUploadAllowed2(file) {
  const {
    allowNewUpload
  } = this.getState();

  if (allowNewUpload === false) {
    _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](new RestrictionError(this.i18n('noMoreFilesAllowed')), {
      file
    });
  }
}

function _checkAndCreateFileStateObject2(files, fileDescriptor) {
  const fileType = getFileType(fileDescriptor);
  const fileName = getFileName(fileType, fileDescriptor);
  const fileExtension = getFileNameAndExtension(fileName).extension;
  const isRemote = Boolean(fileDescriptor.isRemote);
  const fileID = generateFileID({ ...fileDescriptor,
    type: fileType
  });

  if (this.checkIfFileAlreadyExists(fileID)) {
    const error = new RestrictionError(this.i18n('noDuplicates', {
      fileName
    }));

    _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](error, {
      file: fileDescriptor
    });
  }

  const meta = fileDescriptor.meta || {};
  meta.name = fileName;
  meta.type = fileType; // `null` means the size is unknown.

  const size = Number.isFinite(fileDescriptor.data.size) ? fileDescriptor.data.size : null;
  let newFile = {
    source: fileDescriptor.source || '',
    id: fileID,
    name: fileName,
    extension: fileExtension || '',
    meta: { ...this.getState().meta,
      ...meta
    },
    type: fileType,
    data: fileDescriptor.data,
    progress: {
      percentage: 0,
      bytesUploaded: 0,
      bytesTotal: size,
      uploadComplete: false,
      uploadStarted: null
    },
    size,
    isRemote,
    remote: fileDescriptor.remote || '',
    preview: fileDescriptor.preview
  };
  const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, files);

  if (onBeforeFileAddedResult === false) {
    // Dont show UI info for this error, as it should be done by the developer
    _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](new RestrictionError('Cannot add the file because onBeforeFileAdded returned false.'), {
      showInformer: false,
      fileDescriptor
    });
  } else if (typeof onBeforeFileAddedResult === 'object' && onBeforeFileAddedResult !== null) {
    newFile = onBeforeFileAddedResult;
  }

  try {
    const filesArray = Object.keys(files).map(i => files[i]);

    _classPrivateFieldLooseBase(this, _checkRestrictions)[_checkRestrictions](newFile, filesArray);
  } catch (err) {
    _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err, {
      file: newFile
    });
  }

  return newFile;
}

function _startIfAutoProceed2() {
  if (this.opts.autoProceed && !this.scheduledAutoProceed) {
    this.scheduledAutoProceed = setTimeout(() => {
      this.scheduledAutoProceed = null;
      this.upload().catch(err => {
        if (!err.isRestriction) {
          this.log(err.stack || err.message || err);
        }
      });
    }, 4);
  }
}

function _addListeners2() {
  /**
   * @param {Error} error
   * @param {object} [file]
   * @param {object} [response]
   */
  const errorHandler = (error, file, response) => {
    let errorMsg = error.message || 'Unknown error';

    if (error.details) {
      errorMsg += ` ${error.details}`;
    }

    this.setState({
      error: errorMsg
    });

    if (file != null && file.id in this.getState().files) {
      this.setFileState(file.id, {
        error: errorMsg,
        response
      });
    }
  };

  this.on('error', errorHandler);
  this.on('upload-error', (file, error, response) => {
    errorHandler(error, file, response);

    if (typeof error === 'object' && error.message) {
      const newError = new Error(error.message);
      newError.details = error.message;

      if (error.details) {
        newError.details += ` ${error.details}`;
      }

      newError.message = this.i18n('failedToUpload', {
        file: file.name
      });

      _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](newError, {
        throwErr: false
      });
    } else {
      _classPrivateFieldLooseBase(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](error, {
        throwErr: false
      });
    }
  });
  this.on('upload', () => {
    this.setState({
      error: null
    });
  });
  this.on('upload-started', file => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }

    this.setFileState(file.id, {
      progress: {
        uploadStarted: Date.now(),
        uploadComplete: false,
        percentage: 0,
        bytesUploaded: 0,
        bytesTotal: file.size
      }
    });
  });
  this.on('upload-progress', this.calculateProgress);
  this.on('upload-success', (file, uploadResp) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }

    const currentProgress = this.getFile(file.id).progress;
    this.setFileState(file.id, {
      progress: { ...currentProgress,
        postprocess: _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].size > 0 ? {
          mode: 'indeterminate'
        } : null,
        uploadComplete: true,
        percentage: 100,
        bytesUploaded: currentProgress.bytesTotal
      },
      response: uploadResp,
      uploadURL: uploadResp.uploadURL,
      isPaused: false
    }); // Remote providers sometimes don't tell us the file size,
    // but we can know how many bytes we uploaded once the upload is complete.

    if (file.size == null) {
      this.setFileState(file.id, {
        size: uploadResp.bytesUploaded || currentProgress.bytesTotal
      });
    }

    this.calculateTotalProgress();
  });
  this.on('preprocess-progress', (file, progress) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }

    this.setFileState(file.id, {
      progress: { ...this.getFile(file.id).progress,
        preprocess: progress
      }
    });
  });
  this.on('preprocess-complete', file => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }

    const files = { ...this.getState().files
    };
    files[file.id] = { ...files[file.id],
      progress: { ...files[file.id].progress
      }
    };
    delete files[file.id].progress.preprocess;
    this.setState({
      files
    });
  });
  this.on('postprocess-progress', (file, progress) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }

    this.setFileState(file.id, {
      progress: { ...this.getState().files[file.id].progress,
        postprocess: progress
      }
    });
  });
  this.on('postprocess-complete', file => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }

    const files = { ...this.getState().files
    };
    files[file.id] = { ...files[file.id],
      progress: { ...files[file.id].progress
      }
    };
    delete files[file.id].progress.postprocess;
    this.setState({
      files
    });
  });
  this.on('restored', () => {
    // Files may have changed--ensure progress is still accurate.
    this.calculateTotalProgress();
  });
  this.on('dashboard:file-edit-complete', file => {
    if (file) {
      _classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
    }
  }); // show informer if offline

  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('online', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
    window.addEventListener('offline', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
    setTimeout(_classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus], 3000);
  }
}

function _createUpload2(fileIDs, opts = {}) {
  // uppy.retryAll sets this to true  when retrying we want to ignore `allowNewUpload: false`
  const {
    forceAllowNewUpload = false
  } = opts;
  const {
    allowNewUpload,
    currentUploads
  } = this.getState();

  if (!allowNewUpload && !forceAllowNewUpload) {
    throw new Error('Cannot create a new upload: already uploading.');
  }

  const uploadID = nanoid();
  this.emit('upload', {
    id: uploadID,
    fileIDs
  });
  this.setState({
    allowNewUpload: this.opts.allowMultipleUploadBatches !== false && this.opts.allowMultipleUploads !== false,
    currentUploads: { ...currentUploads,
      [uploadID]: {
        fileIDs,
        step: 0,
        result: {}
      }
    }
  });
  return uploadID;
}

function _getUpload2(uploadID) {
  const {
    currentUploads
  } = this.getState();
  return currentUploads[uploadID];
}

function _removeUpload2(uploadID) {
  const currentUploads = { ...this.getState().currentUploads
  };
  delete currentUploads[uploadID];
  this.setState({
    currentUploads
  });
}

async function _runUpload2(uploadID) {
  let {
    currentUploads
  } = this.getState();
  let currentUpload = currentUploads[uploadID];
  const restoreStep = currentUpload.step || 0;
  const steps = [...Array.from(_classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors]), ...Array.from(_classPrivateFieldLooseBase(this, _uploaders)[_uploaders]), ...Array.from(_classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors])];

  try {
    for (let step = restoreStep; step < steps.length; step++) {
      if (!currentUpload) {
        break;
      }

      const fn = steps[step];
      const updatedUpload = { ...currentUpload,
        step
      };
      this.setState({
        currentUploads: { ...currentUploads,
          [uploadID]: updatedUpload
        }
      }); // TODO give this the `updatedUpload` object as its only parameter maybe?
      // Otherwise when more metadata may be added to the upload this would keep getting more parameters

      await fn(updatedUpload.fileIDs, uploadID); // Update currentUpload value in case it was modified asynchronously.

      currentUploads = this.getState().currentUploads;
      currentUpload = currentUploads[uploadID];
    }
  } catch (err) {
    this.emit('error', err);

    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);

    throw err;
  } // Set result data.


  if (currentUpload) {
    // Mark postprocessing step as complete if necessary; this addresses a case where we might get
    // stuck in the postprocessing UI while the upload is fully complete.
    // If the postprocessing steps do not do any work, they may not emit postprocessing events at
    // all, and never mark the postprocessing as complete. This is fine on its own but we
    // introduced code in the @uppy/core upload-success handler to prepare postprocessing progress
    // state if any postprocessors are registered. That is to avoid a "flash of completed state"
    // before the postprocessing plugins can emit events.
    //
    // So, just in case an upload with postprocessing plugins *has* completed *without* emitting
    // postprocessing completion, we do it instead.
    currentUpload.fileIDs.forEach(fileID => {
      const file = this.getFile(fileID);

      if (file && file.progress.postprocess) {
        this.emit('postprocess-complete', file);
      }
    });
    const files = currentUpload.fileIDs.map(fileID => this.getFile(fileID));
    const successful = files.filter(file => !file.error);
    const failed = files.filter(file => file.error);
    await this.addResultData(uploadID, {
      successful,
      failed,
      uploadID
    }); // Update currentUpload value in case it was modified asynchronously.

    currentUploads = this.getState().currentUploads;
    currentUpload = currentUploads[uploadID];
  } // Emit completion events.
  // This is in a separate function so that the `currentUploads` variable
  // always refers to the latest state. In the handler right above it refers
  // to an outdated object without the `.result` property.


  let result;

  if (currentUpload) {
    result = currentUpload.result;
    this.emit('complete', result);

    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);
  }

  if (result == null) {
    this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
  }

  return result;
}

Uppy.VERSION = "2.1.2";
module.exports = Uppy;

},{"./../../store-default":135,"./../../utils/lib/Translator":148,"./../../utils/lib/generateFileID":155,"./../../utils/lib/getFileNameAndExtension":162,"./../../utils/lib/getFileType":163,"./getFileName":47,"./locale":49,"./loggers":50,"./supportsUploadProgress":51,"@transloadit/prettier-bytes":1,"lodash.throttle":11,"mime-match":13,"namespace-emitter":15,"nanoid":16}],47:[function(require,module,exports){
"use strict";

module.exports = function getFileName(fileType, fileDescriptor) {
  if (fileDescriptor.name) {
    return fileDescriptor.name;
  }

  if (fileType.split('/')[0] === 'image') {
    return `${fileType.split('/')[0]}.${fileType.split('/')[1]}`;
  }

  return 'noname';
};

},{}],48:[function(require,module,exports){
'use strict';

const Uppy = require('./Uppy');

const UIPlugin = require('./UIPlugin');

const BasePlugin = require('./BasePlugin');

const {
  debugLogger
} = require('./loggers');

module.exports = Uppy;
module.exports.Uppy = Uppy;
module.exports.UIPlugin = UIPlugin;
module.exports.BasePlugin = BasePlugin;
module.exports.debugLogger = debugLogger;

},{"./BasePlugin":44,"./UIPlugin":45,"./Uppy":46,"./loggers":50}],49:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    addBulkFilesFailed: {
      0: 'Failed to add %{smart_count} file due to an internal error',
      1: 'Failed to add %{smart_count} files due to internal errors'
    },
    youCanOnlyUploadX: {
      0: 'You can only upload %{smart_count} file',
      1: 'You can only upload %{smart_count} files'
    },
    youHaveToAtLeastSelectX: {
      0: 'You have to select at least %{smart_count} file',
      1: 'You have to select at least %{smart_count} files'
    },
    exceedsSize: '%{file} exceeds maximum allowed size of %{size}',
    missingRequiredMetaField: 'Missing required meta fields',
    missingRequiredMetaFieldOnFile: 'Missing required meta fields in %{fileName}',
    inferiorSize: 'This file is smaller than the allowed size of %{size}',
    youCanOnlyUploadFileTypes: 'You can only upload: %{types}',
    noMoreFilesAllowed: 'Cannot add more files',
    noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists",
    companionError: 'Connection with Companion failed',
    authAborted: 'Authentication aborted',
    companionUnauthorizeHint: 'To unauthorize to your %{provider} account, please go to %{url}',
    failedToUpload: 'Failed to upload %{file}',
    noInternetConnection: 'No Internet connection',
    connectedToInternet: 'Connected to the Internet',
    // Strings for remote providers
    noFilesFound: 'You have no files or folders here',
    selectX: {
      0: 'Select %{smart_count}',
      1: 'Select %{smart_count}'
    },
    allFilesFromFolderNamed: 'All files from folder %{name}',
    openFolderNamed: 'Open folder %{name}',
    cancel: 'Cancel',
    logOut: 'Log out',
    filter: 'Filter',
    resetFilter: 'Reset filter',
    loading: 'Loading...',
    authenticateWithTitle: 'Please authenticate with %{pluginName} to select files',
    authenticateWith: 'Connect to %{pluginName}',
    signInWithGoogle: 'Sign in with Google',
    searchImages: 'Search for images',
    enterTextToSearch: 'Enter text to search for images',
    backToSearch: 'Back to Search',
    emptyFolderAdded: 'No files were added from empty folder',
    folderAlreadyAdded: 'The folder "%{folder}" was already added',
    folderAdded: {
      0: 'Added %{smart_count} file from %{folder}',
      1: 'Added %{smart_count} files from %{folder}'
    }
  }
};

},{}],50:[function(require,module,exports){
"use strict";

/* eslint-disable no-console */
const getTimeStamp = require('./../../utils/lib/getTimeStamp'); // Swallow all logs, except errors.
// default if logger is not set or debug: false


const justErrorsLogger = {
  debug: () => {},
  warn: () => {},
  error: (...args) => console.error(`[Uppy] [${getTimeStamp()}]`, ...args)
}; // Print logs to console with namespace + timestamp,
// set by logger: Uppy.debugLogger or debug: true

const debugLogger = {
  debug: (...args) => console.debug(`[Uppy] [${getTimeStamp()}]`, ...args),
  warn: (...args) => console.warn(`[Uppy] [${getTimeStamp()}]`, ...args),
  error: (...args) => console.error(`[Uppy] [${getTimeStamp()}]`, ...args)
};
module.exports = {
  justErrorsLogger,
  debugLogger
};

},{"./../../utils/lib/getTimeStamp":168}],51:[function(require,module,exports){
"use strict";

// Edge 15.x does not fire 'progress' events on uploads.
// See https://github.com/transloadit/uppy/issues/945
// And https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12224510/
module.exports = function supportsUploadProgress(userAgent) {
  // Allow passing in userAgent for tests
  if (userAgent == null) {
    userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : null;
  } // Assume it works because basically everything supports progress events.


  if (!userAgent) return true;
  const m = /Edge\/(\d+\.\d+)/.exec(userAgent);
  if (!m) return true;
  const edgeVersion = m[1];
  let [major, minor] = edgeVersion.split('.');
  major = parseInt(major, 10);
  minor = parseInt(minor, 10); // Worked before:
  // Edge 40.15063.0.0
  // Microsoft EdgeHTML 15.15063

  if (major < 15 || major === 15 && minor < 15063) {
    return true;
  } // Fixed in:
  // Microsoft EdgeHTML 18.18218


  if (major > 18 || major === 18 && minor >= 18218) {
    return true;
  } // other versions don't work.


  return false;
};

},{}],52:[function(require,module,exports){
"use strict";

let _Symbol$for;

const {
  h,
  Component
} = require('preact');

_Symbol$for = Symbol.for('uppy test: disable unused locale key warning');

class AddFiles extends Component {
  constructor(...args) {
    super(...args);

    this.triggerFileInputClick = () => {
      this.fileInput.click();
    };

    this.triggerFolderInputClick = () => {
      this.folderInput.click();
    };

    this.onFileInputChange = event => {
      this.props.handleInputChange(event); // We clear the input after a file is selected, because otherwise
      // change event is not fired in Chrome and Safari when a file
      // with the same name is selected.
      // ___Why not use value="" on <input/> instead?
      //    Because if we use that method of clearing the input,
      //    Chrome will not trigger change if we drop the same file twice (Issue #768).

      event.target.value = null;
    };

    this.renderHiddenInput = (isFolder, refCallback) => {
      return h("input", {
        className: "uppy-Dashboard-input",
        hidden: true,
        "aria-hidden": "true",
        tabIndex: -1,
        webkitdirectory: isFolder,
        type: "file",
        name: "files[]",
        multiple: this.props.maxNumberOfFiles !== 1,
        onChange: this.onFileInputChange,
        accept: this.props.allowedFileTypes,
        ref: refCallback
      });
    };

    this.renderMyDeviceAcquirer = () => {
      return h("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": "MyDevice"
      }, h("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "data-uppy-super-focusable": true,
        onClick: this.triggerFileInputClick
      }, h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#2275D7"
      }), h("path", {
        d: "M21.973 21.152H9.863l-1.108-5.087h14.464l-1.246 5.087zM9.935 11.37h3.958l.886 1.444a.673.673 0 0 0 .585.316h6.506v1.37H9.935v-3.13zm14.898 3.44a.793.793 0 0 0-.616-.31h-.978v-2.126c0-.379-.275-.613-.653-.613H15.75l-.886-1.445a.673.673 0 0 0-.585-.316H9.232c-.378 0-.667.209-.667.587V14.5h-.782a.793.793 0 0 0-.61.303.795.795 0 0 0-.155.663l1.45 6.633c.078.36.396.618.764.618h13.354c.36 0 .674-.246.76-.595l1.631-6.636a.795.795 0 0 0-.144-.675z",
        fill: "#FFF"
      }))), h("div", {
        className: "uppy-DashboardTab-name"
      }, this.props.i18n('myDevice'))));
    };

    this.renderBrowseButton = (text, onClickFn) => {
      const numberOfAcquirers = this.props.acquirers.length;
      return h("button", {
        type: "button",
        className: "uppy-u-reset uppy-Dashboard-browse",
        onClick: onClickFn,
        "data-uppy-super-focusable": numberOfAcquirers === 0
      }, text);
    };

    this.renderDropPasteBrowseTagline = () => {
      const numberOfAcquirers = this.props.acquirers.length;
      const browseFiles = this.renderBrowseButton(this.props.i18n('browseFiles'), this.triggerFileInputClick);
      const browseFolders = this.renderBrowseButton(this.props.i18n('browseFolders'), this.triggerFolderInputClick); // in order to keep the i18n CamelCase and options lower (as are defaults) we will want to transform a lower
      // to Camel

      const lowerFMSelectionType = this.props.fileManagerSelectionType;
      const camelFMSelectionType = lowerFMSelectionType.charAt(0).toUpperCase() + lowerFMSelectionType.slice(1);
      return h("div", {
        class: "uppy-Dashboard-AddFiles-title"
      }, // eslint-disable-next-line no-nested-ternary
      this.props.disableLocalFiles ? this.props.i18n('importFiles') : numberOfAcquirers > 0 ? this.props.i18nArray(`dropPasteImport${camelFMSelectionType}`, {
        browseFiles,
        browseFolders,
        browse: browseFiles
      }) : this.props.i18nArray(`dropPaste${camelFMSelectionType}`, {
        browseFiles,
        browseFolders,
        browse: browseFiles
      }));
    };

    this.renderAcquirer = acquirer => {
      return h("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": acquirer.id
      }, h("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "aria-controls": `uppy-DashboardContent-panel--${acquirer.id}`,
        "aria-selected": this.props.activePickerPanel.id === acquirer.id,
        "data-uppy-super-focusable": true,
        onClick: () => this.props.showPanel(acquirer.id)
      }, acquirer.icon(), h("div", {
        className: "uppy-DashboardTab-name"
      }, acquirer.name)));
    };

    this.renderAcquirers = (acquirers, disableLocalFiles) => {
      // Group last two buttons, so we dont end up with
      // just one button on a new line
      const acquirersWithoutLastTwo = [...acquirers];
      const lastTwoAcquirers = acquirersWithoutLastTwo.splice(acquirers.length - 2, acquirers.length);
      return h("div", {
        className: "uppy-Dashboard-AddFiles-list",
        role: "tablist"
      }, !disableLocalFiles && this.renderMyDeviceAcquirer(), acquirersWithoutLastTwo.map(acquirer => this.renderAcquirer(acquirer)), h("span", {
        role: "presentation",
        style: {
          'white-space': 'nowrap'
        }
      }, lastTwoAcquirers.map(acquirer => this.renderAcquirer(acquirer))));
    };
  }

  [_Symbol$for]() {
    // Those are actually used in `renderDropPasteBrowseTagline` method.
    this.props.i18nArray('dropPasteBoth');
    this.props.i18nArray('dropPasteFiles');
    this.props.i18nArray('dropPasteFolders');
    this.props.i18nArray('dropPasteImportBoth');
    this.props.i18nArray('dropPasteImportFiles');
    this.props.i18nArray('dropPasteImportFolders');
  }

  renderPoweredByUppy() {
    const {
      i18nArray
    } = this.props;
    const uppyBranding = h("span", null, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-poweredByIcon",
      width: "11",
      height: "11",
      viewBox: "0 0 11 11"
    }, h("path", {
      d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
      fillRule: "evenodd"
    })), h("span", {
      className: "uppy-Dashboard-poweredByUppy"
    }, "Uppy"));
    const linkText = i18nArray('poweredBy', {
      uppy: uppyBranding
    });
    return h("a", {
      tabIndex: "-1",
      href: "https://uppy.io",
      rel: "noreferrer noopener",
      target: "_blank",
      className: "uppy-Dashboard-poweredBy"
    }, linkText);
  }

  render() {
    return h("div", {
      className: "uppy-Dashboard-AddFiles"
    }, this.renderHiddenInput(false, ref => {
      this.fileInput = ref;
    }), this.renderHiddenInput(true, ref => {
      this.folderInput = ref;
    }), this.renderDropPasteBrowseTagline(), this.props.acquirers.length > 0 && this.renderAcquirers(this.props.acquirers, this.props.disableLocalFiles), h("div", {
      className: "uppy-Dashboard-AddFiles-info"
    }, this.props.note && h("div", {
      className: "uppy-Dashboard-note"
    }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props)));
  }

}

module.exports = AddFiles;

},{"preact":18}],53:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const classNames = require('classnames');

const AddFiles = require('./AddFiles');

const AddFilesPanel = props => {
  return h("div", {
    className: classNames('uppy-Dashboard-AddFilesPanel', props.className),
    "data-uppy-panelType": "AddFiles",
    "aria-hidden": props.showAddFilesPanel
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n('addingMoreFiles')), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: () => props.toggleAddFilesPanel(false)
  }, props.i18n('back'))), h(AddFiles, props));
};

module.exports = AddFilesPanel;

},{"./AddFiles":52,"classnames":4,"preact":18}],54:[function(require,module,exports){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const {
  h
} = require('preact');

const classNames = require('classnames');

const isDragDropSupported = require('./../../../utils/lib/isDragDropSupported');

const FileList = require('./FileList');

const AddFiles = require('./AddFiles');

const AddFilesPanel = require('./AddFilesPanel');

const PickerPanelContent = require('./PickerPanelContent');

const EditorPanel = require('./EditorPanel');

const PanelTopBar = require('./PickerPanelTopBar');

const FileCard = require('./FileCard');

const Slide = require('./Slide'); // http://dev.edenspiekermann.com/2016/02/11/introducing-accessible-modal-dialog
// https://github.com/ghosh/micromodal


const WIDTH_XL = 900;
const WIDTH_LG = 700;
const WIDTH_MD = 576;
const HEIGHT_MD = 400;

module.exports = function Dashboard(props) {
  const noFiles = props.totalFileCount === 0;
  const isSizeMD = props.containerWidth > WIDTH_MD;
  const wrapperClassName = classNames({
    'uppy-Root': props.isTargetDOMEl
  });
  const dashboardClassName = classNames({
    'uppy-Dashboard': true,
    'uppy-Dashboard--isDisabled': props.disabled,
    'uppy-Dashboard--animateOpenClose': props.animateOpenClose,
    'uppy-Dashboard--isClosing': props.isClosing,
    'uppy-Dashboard--isDraggingOver': props.isDraggingOver,
    'uppy-Dashboard--modal': !props.inline,
    'uppy-size--md': props.containerWidth > WIDTH_MD,
    'uppy-size--lg': props.containerWidth > WIDTH_LG,
    'uppy-size--xl': props.containerWidth > WIDTH_XL,
    'uppy-size--height-md': props.containerHeight > HEIGHT_MD,
    'uppy-Dashboard--isAddFilesPanelVisible': props.showAddFilesPanel,
    'uppy-Dashboard--isInnerWrapVisible': props.areInsidesReadyToBeVisible
  }); // Important: keep these in sync with the percent width values in `src/components/FileItem/index.scss`.

  let itemsPerRow = 1; // mobile

  if (props.containerWidth > WIDTH_XL) {
    itemsPerRow = 5;
  } else if (props.containerWidth > WIDTH_LG) {
    itemsPerRow = 4;
  } else if (props.containerWidth > WIDTH_MD) {
    itemsPerRow = 3;
  }

  const showFileList = props.showSelectedFiles && !noFiles;
  const numberOfFilesForRecovery = props.recoveredState ? Object.keys(props.recoveredState.files).length : null;
  const numberOfGhosts = props.files ? Object.keys(props.files).filter(fileID => props.files[fileID].isGhost).length : null;

  const renderRestoredText = () => {
    if (numberOfGhosts > 0) {
      return props.i18n('recoveredXFiles', {
        smart_count: numberOfGhosts
      });
    }

    return props.i18n('recoveredAllFiles');
  };

  const dashboard = h("div", {
    className: dashboardClassName,
    "data-uppy-theme": props.theme,
    "data-uppy-num-acquirers": props.acquirers.length,
    "data-uppy-drag-drop-supported": !props.disableLocalFiles && isDragDropSupported(),
    "aria-hidden": props.inline ? 'false' : props.isHidden,
    "aria-disabled": props.disabled,
    "aria-label": !props.inline ? props.i18n('dashboardWindowTitle') : props.i18n('dashboardTitle'),
    onPaste: props.handlePaste,
    onDragOver: props.handleDragOver,
    onDragLeave: props.handleDragLeave,
    onDrop: props.handleDrop
  }, h("div", {
    "aria-hidden": "true",
    className: "uppy-Dashboard-overlay",
    tabIndex: -1,
    onClick: props.handleClickOutside
  }), h("div", {
    className: "uppy-Dashboard-inner",
    "aria-modal": !props.inline && 'true',
    role: !props.inline && 'dialog',
    style: {
      width: props.inline && props.width ? props.width : '',
      height: props.inline && props.height ? props.height : ''
    }
  }, !props.inline ? h("button", {
    className: "uppy-u-reset uppy-Dashboard-close",
    type: "button",
    "aria-label": props.i18n('closeModal'),
    title: props.i18n('closeModal'),
    onClick: props.closeModal
  }, h("span", {
    "aria-hidden": "true"
  }, "\xD7")) : null, h("div", {
    className: "uppy-Dashboard-innerWrap"
  }, h("div", {
    className: "uppy-Dashboard-dropFilesHereHint"
  }, props.i18n('dropHint')), showFileList && h(PanelTopBar, props), numberOfFilesForRecovery && h("div", {
    className: "uppy-Dashboard-serviceMsg"
  }, h("svg", {
    className: "uppy-Dashboard-serviceMsg-icon",
    "aria-hidden": "true",
    focusable: "false",
    width: "21",
    height: "16",
    viewBox: "0 0 24 19"
  }, h("g", {
    transform: "translate(0 -1)",
    fill: "none",
    fillRule: "evenodd"
  }, h("path", {
    d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z",
    fill: "#FFD300"
  }), h("path", {
    fill: "#000",
    d: "M11 6h2l-.3 8h-1.4z"
  }), h("circle", {
    fill: "#000",
    cx: "12",
    cy: "17",
    r: "1"
  }))), h("strong", {
    className: "uppy-Dashboard-serviceMsg-title"
  }, props.i18n('sessionRestored')), h("div", {
    className: "uppy-Dashboard-serviceMsg-text"
  }, renderRestoredText())), showFileList ? h(FileList, _extends({}, props, {
    itemsPerRow: itemsPerRow
  })) : h(AddFiles, _extends({}, props, {
    isSizeMD: isSizeMD
  })), h(Slide, null, props.showAddFilesPanel ? h(AddFilesPanel, _extends({
    key: "AddFiles"
  }, props, {
    isSizeMD: isSizeMD
  })) : null), h(Slide, null, props.fileCardFor ? h(FileCard, _extends({
    key: "FileCard"
  }, props)) : null), h(Slide, null, props.activePickerPanel ? h(PickerPanelContent, _extends({
    key: "Picker"
  }, props)) : null), h(Slide, null, props.showFileEditor ? h(EditorPanel, _extends({
    key: "Editor"
  }, props)) : null), h("div", {
    className: "uppy-Dashboard-progressindicators"
  }, props.progressindicators.map(target => {
    return props.uppy.getPlugin(target.id).render(props.state);
  })))));
  return (// Wrap it for RTL language support
    h("div", {
      className: wrapperClassName,
      dir: props.direction
    }, dashboard)
  );
};

},{"./../../../utils/lib/isDragDropSupported":171,"./AddFiles":52,"./AddFilesPanel":53,"./EditorPanel":55,"./FileCard":56,"./FileList":63,"./PickerPanelContent":65,"./PickerPanelTopBar":66,"./Slide":67,"classnames":4,"preact":18}],55:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const classNames = require('classnames');

function EditorPanel(props) {
  const file = props.files[props.fileCardFor];
  return h("div", {
    className: classNames('uppy-DashboardContent-panel', props.className),
    role: "tabpanel",
    "data-uppy-panelType": "FileEditor",
    id: "uppy-DashboardContent-panel--editor"
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18nArray('editing', {
    file: h("span", {
      className: "uppy-DashboardContent-titleFile"
    }, file.meta ? file.meta.name : file.name)
  })), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n('cancel')), h("button", {
    className: "uppy-DashboardContent-save",
    type: "button",
    onClick: props.saveFileEditor
  }, props.i18n('save'))), h("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.editors.map(target => {
    return props.uppy.getPlugin(target.id).render(props.state);
  })));
}

module.exports = EditorPanel;

},{"classnames":4,"preact":18}],56:[function(require,module,exports){
"use strict";

const {
  h,
  Component
} = require('preact');

const classNames = require('classnames');

const {
  nanoid
} = require('nanoid');

const getFileTypeIcon = require('../../utils/getFileTypeIcon');

const ignoreEvent = require('../../utils/ignoreEvent.js');

const FilePreview = require('../FilePreview');

class FileCard extends Component {
  constructor(props) {
    super(props);
    this.form = document.createElement('form');

    this.updateMeta = (newVal, name) => {
      this.setState(({
        formState
      }) => ({
        formState: { ...formState,
          [name]: newVal
        }
      }));
    };

    this.handleSave = e => {
      e.preventDefault();
      const fileID = this.props.fileCardFor;
      this.props.saveFileCard(this.state.formState, fileID);
    };

    this.handleCancel = () => {
      this.props.toggleFileCard(false);
    };

    this.saveOnEnter = ev => {
      if (ev.keyCode === 13) {
        ev.stopPropagation();
        ev.preventDefault();
        const file = this.props.files[this.props.fileCardFor];
        this.props.saveFileCard(this.state.formState, file.id);
      }
    };

    this.renderMetaFields = () => {
      const metaFields = this.getMetaFields() || [];
      const fieldCSSClasses = {
        text: 'uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input'
      };
      return metaFields.map(field => {
        const id = `uppy-Dashboard-FileCard-input-${field.id}`;
        const required = this.props.requiredMetaFields.includes(field.id);
        return h("fieldset", {
          key: field.id,
          className: "uppy-Dashboard-FileCard-fieldset"
        }, h("label", {
          className: "uppy-Dashboard-FileCard-label",
          htmlFor: id
        }, field.name), field.render !== undefined ? field.render({
          value: this.state.formState[field.id],
          onChange: newVal => this.updateMeta(newVal, field.id),
          fieldCSSClasses,
          required,
          form: this.form.id
        }, h) : h("input", {
          className: fieldCSSClasses.text,
          id: id,
          form: this.form.id,
          type: field.type || 'text',
          required: required,
          value: this.state.formState[field.id],
          placeholder: field.placeholder // If `form` attribute is not supported, we need to capture pressing Enter to avoid bubbling in case Uppy is
          // embedded inside a <form>.
          ,
          onKeyUp: 'form' in HTMLInputElement.prototype ? undefined : this.saveOnEnter,
          onKeyDown: 'form' in HTMLInputElement.prototype ? undefined : this.saveOnEnter,
          onKeyPress: 'form' in HTMLInputElement.prototype ? undefined : this.saveOnEnter,
          onInput: ev => this.updateMeta(ev.target.value, field.id),
          "data-uppy-super-focusable": true
        }));
      });
    };

    const _file = this.props.files[this.props.fileCardFor];

    const _metaFields = this.getMetaFields() || [];

    const storedMetaData = {};

    _metaFields.forEach(field => {
      storedMetaData[field.id] = _file.meta[field.id] || '';
    });

    this.state = {
      formState: storedMetaData
    };
    this.form.id = nanoid();
  } // TODO(aduh95): move this to `UNSAFE_componentWillMount` when updating to Preact X+.


  componentWillMount() {
    // eslint-disable-line react/no-deprecated
    this.form.addEventListener('submit', this.handleSave);
    document.body.appendChild(this.form);
  }

  componentWillUnmount() {
    this.form.removeEventListener('submit', this.handleSave);
    document.body.removeChild(this.form);
  }

  getMetaFields() {
    return typeof this.props.metaFields === 'function' ? this.props.metaFields(this.props.files[this.props.fileCardFor]) : this.props.metaFields;
  }

  render() {
    const file = this.props.files[this.props.fileCardFor];
    const showEditButton = this.props.canEditFile(file);
    return h("div", {
      className: classNames('uppy-Dashboard-FileCard', this.props.className),
      "data-uppy-panelType": "FileCard",
      onDragOver: ignoreEvent,
      onDragLeave: ignoreEvent,
      onDrop: ignoreEvent,
      onPaste: ignoreEvent
    }, h("div", {
      className: "uppy-DashboardContent-bar"
    }, h("div", {
      className: "uppy-DashboardContent-title",
      role: "heading",
      "aria-level": "1"
    }, this.props.i18nArray('editing', {
      file: h("span", {
        className: "uppy-DashboardContent-titleFile"
      }, file.meta ? file.meta.name : file.name)
    })), h("button", {
      className: "uppy-DashboardContent-back",
      type: "button",
      form: this.form.id,
      title: this.props.i18n('finishEditingFile'),
      onClick: this.handleCancel
    }, this.props.i18n('cancel'))), h("div", {
      className: "uppy-Dashboard-FileCard-inner"
    }, h("div", {
      className: "uppy-Dashboard-FileCard-preview",
      style: {
        backgroundColor: getFileTypeIcon(file.type).color
      }
    }, h(FilePreview, {
      file: file
    }), showEditButton && h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit",
      onClick: () => this.props.openFileEditor(file),
      form: this.form.id
    }, this.props.i18n('editFile'))), h("div", {
      className: "uppy-Dashboard-FileCard-info"
    }, this.renderMetaFields()), h("div", {
      className: "uppy-Dashboard-FileCard-actions"
    }, h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn" // If `form` attribute is supported, we want a submit button to trigger the form validation.
      // Otherwise, fallback to a classic button with a onClick event handler.
      ,
      type: 'form' in HTMLButtonElement.prototype ? 'submit' : 'button',
      onClick: 'form' in HTMLButtonElement.prototype ? undefined : this.handleSave,
      form: this.form.id
    }, this.props.i18n('saveChanges')), h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onClick: this.handleCancel,
      form: this.form.id
    }, this.props.i18n('cancel')))));
  }

}

module.exports = FileCard;

},{"../../utils/getFileTypeIcon":74,"../../utils/ignoreEvent.js":75,"../FilePreview":64,"classnames":4,"nanoid":16,"preact":18}],57:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const copyToClipboard = require('../../../utils/copyToClipboard');

function EditButton({
  file,
  uploadInProgressOrComplete,
  metaFields,
  canEditFile,
  i18n,
  onClick
}) {
  if (!uploadInProgressOrComplete && metaFields && metaFields.length > 0 || !uploadInProgressOrComplete && canEditFile(file)) {
    return h("button", {
      className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit",
      type: "button",
      "aria-label": i18n('editFileWithFilename', {
        file: file.meta.name
      }),
      title: i18n('editFileWithFilename', {
        file: file.meta.name
      }),
      onClick: () => onClick()
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "14",
      height: "14",
      viewBox: "0 0 14 14"
    }, h("g", {
      fillRule: "evenodd"
    }, h("path", {
      d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
      fillRule: "nonzero"
    }), h("rect", {
      x: "1",
      y: "12.293",
      width: "11",
      height: "1",
      rx: ".5"
    }), h("path", {
      fillRule: "nonzero",
      d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
    }))));
  }

  return null;
}

function RemoveButton({
  i18n,
  onClick,
  file
}) {
  return h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove",
    type: "button",
    "aria-label": i18n('removeFile', {
      file: file.meta.name
    }),
    title: i18n('removeFile', {
      file: file.meta.name
    }),
    onClick: () => onClick()
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "18",
    height: "18",
    viewBox: "0 0 18 18"
  }, h("path", {
    d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
  }), h("path", {
    fill: "#FFF",
    d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
  })));
}

const copyLinkToClipboard = (event, props) => {
  copyToClipboard(props.file.uploadURL, props.i18n('copyLinkToClipboardFallback')).then(() => {
    props.uppy.log('Link copied to clipboard.');
    props.uppy.info(props.i18n('copyLinkToClipboardSuccess'), 'info', 3000);
  }).catch(props.uppy.log) // avoid losing focus
  .then(() => event.target.focus({
    preventScroll: true
  }));
};

function CopyLinkButton(props) {
  const {
    i18n
  } = props;
  return h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink",
    type: "button",
    "aria-label": i18n('copyLink'),
    title: i18n('copyLink'),
    onClick: event => copyLinkToClipboard(event, props)
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 12"
  }, h("path", {
    d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
  })));
}

module.exports = function Buttons(props) {
  const {
    uppy,
    file,
    uploadInProgressOrComplete,
    canEditFile,
    metaFields,
    showLinkToFileUploadResult,
    showRemoveButton,
    i18n,
    toggleFileCard,
    openFileEditor
  } = props;

  const editAction = () => {
    if (metaFields && metaFields.length > 0) {
      toggleFileCard(true, file.id);
    } else {
      openFileEditor(file);
    }
  };

  return h("div", {
    className: "uppy-Dashboard-Item-actionWrapper"
  }, h(EditButton, {
    i18n: i18n,
    file: file,
    uploadInProgressOrComplete: uploadInProgressOrComplete,
    canEditFile: canEditFile,
    metaFields: metaFields,
    onClick: editAction
  }), showLinkToFileUploadResult && file.uploadURL ? h(CopyLinkButton, {
    file: file,
    uppy: uppy,
    i18n: i18n
  }) : null, showRemoveButton ? h(RemoveButton, {
    i18n: i18n,
    file: file,
    uppy: uppy,
    onClick: () => props.uppy.removeFile(file.id, 'removed-by-user')
  }) : null);
};

},{"../../../utils/copyToClipboard":71,"preact":18}],58:[function(require,module,exports){
"use strict";

const {
  h,
  Fragment
} = require('preact');

const prettierBytes = require('@transloadit/prettier-bytes');

const MetaErrorMessage = require('../MetaErrorMessage');

const truncateString = require('./../../../../../utils/lib/truncateString');

const renderFileName = props => {
  const {
    author,
    name
  } = props.file.meta;

  function getMaxNameLength() {
    if (props.containerWidth <= 352) {
      return 35;
    }

    if (props.containerWidth <= 576) {
      return 60;
    } // When `author` is present, we want to make sure
    // the file name fits on one line so we can place
    // the author on the second line.


    return author ? 20 : 30;
  }

  return h("div", {
    className: "uppy-Dashboard-Item-name",
    title: name
  }, truncateString(name, getMaxNameLength()));
};

const renderAuthor = props => {
  const {
    author
  } = props.file.meta;
  const {
    providerName
  } = props.file.remote;
  const dot = `\u00B7`;

  if (!author) {
    return null;
  }

  return h("div", {
    className: "uppy-Dashboard-Item-author"
  }, h("a", {
    href: `${author.url}?utm_source=Companion&utm_medium=referral`,
    target: "_blank",
    rel: "noopener noreferrer"
  }, truncateString(author.name, 13)), providerName ? h(Fragment, null, ` ${dot} `, providerName) : null);
};

const renderFileSize = props => props.file.size && h("div", {
  className: "uppy-Dashboard-Item-statusSize"
}, prettierBytes(props.file.size));

const ReSelectButton = props => props.file.isGhost && h("span", null, ' \u2022 ', h("button", {
  className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect",
  type: "button",
  onClick: props.toggleAddFilesPanel
}, props.i18n('reSelect')));

const ErrorButton = ({
  file,
  onClick
}) => {
  if (file.error) {
    return h("button", {
      className: "uppy-u-reset uppy-Dashboard-Item-errorDetails",
      "aria-label": file.error,
      "data-microtip-position": "bottom",
      "data-microtip-size": "medium",
      onClick: onClick,
      type: "button"
    }, "?");
  }

  return null;
};

module.exports = function FileInfo(props) {
  const {
    file
  } = props;
  return h("div", {
    className: "uppy-Dashboard-Item-fileInfo",
    "data-uppy-file-source": file.source
  }, h("div", {
    className: "uppy-Dashboard-Item-fileName"
  }, renderFileName(props), h(ErrorButton, {
    file: props.file // eslint-disable-next-line no-alert
    ,
    onClick: () => alert(props.file.error) // TODO: move to a custom alert implementation

  })), h("div", {
    className: "uppy-Dashboard-Item-status"
  }, renderAuthor(props), renderFileSize(props), ReSelectButton(props)), h(MetaErrorMessage, {
    file: props.file,
    i18n: props.i18n,
    toggleFileCard: props.toggleFileCard,
    metaFields: props.metaFields
  }));
};

},{"../MetaErrorMessage":61,"./../../../../../utils/lib/truncateString":181,"@transloadit/prettier-bytes":1,"preact":18}],59:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const FilePreview = require('../../FilePreview');

const MetaErrorMessage = require('../MetaErrorMessage');

const getFileTypeIcon = require('../../../utils/getFileTypeIcon');

module.exports = function FilePreviewAndLink(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-previewInnerWrap",
    style: {
      backgroundColor: getFileTypeIcon(props.file.type).color
    }
  }, props.showLinkToFileUploadResult && props.file.uploadURL && h("a", {
    className: "uppy-Dashboard-Item-previewLink",
    href: props.file.uploadURL,
    rel: "noreferrer noopener",
    target: "_blank",
    "aria-label": props.file.meta.name
  }, h("span", {
    hidden: true
  }, props.file.meta.name)), h(FilePreview, {
    file: props.file
  }), h(MetaErrorMessage, {
    file: props.file,
    i18n: props.i18n,
    toggleFileCard: props.toggleFileCard,
    metaFields: props.metaFields
  }));
};

},{"../../../utils/getFileTypeIcon":74,"../../FilePreview":64,"../MetaErrorMessage":61,"preact":18}],60:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

function onPauseResumeCancelRetry(props) {
  if (props.isUploaded) return;

  if (props.error && !props.hideRetryButton) {
    props.uppy.retryUpload(props.file.id);
    return;
  }

  if (props.resumableUploads && !props.hidePauseResumeButton) {
    props.uppy.pauseResume(props.file.id);
  } else if (props.individualCancellation && !props.hideCancelButton) {
    props.uppy.removeFile(props.file.id);
  }
}

function progressIndicatorTitle(props) {
  if (props.isUploaded) {
    return props.i18n('uploadComplete');
  }

  if (props.error) {
    return props.i18n('retryUpload');
  }

  if (props.resumableUploads) {
    if (props.file.isPaused) {
      return props.i18n('resumeUpload');
    }

    return props.i18n('pauseUpload');
  }

  if (props.individualCancellation) {
    return props.i18n('cancelUpload');
  }

  return '';
}

function ProgressIndicatorButton(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-progressIndicator",
    type: "button",
    "aria-label": progressIndicatorTitle(props),
    title: progressIndicatorTitle(props),
    onClick: () => onPauseResumeCancelRetry(props)
  }, props.children));
}

function ProgressCircleContainer({
  children
}) {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "70",
    height: "70",
    viewBox: "0 0 36 36",
    className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle"
  }, children);
}

function ProgressCircle({
  progress
}) {
  // circle length equals 2 * PI * R
  const circleLength = 2 * Math.PI * 15;
  return h("g", null, h("circle", {
    className: "uppy-Dashboard-Item-progressIcon--bg",
    r: "15",
    cx: "18",
    cy: "18",
    "stroke-width": "2",
    fill: "none"
  }), h("circle", {
    className: "uppy-Dashboard-Item-progressIcon--progress",
    r: "15",
    cx: "18",
    cy: "18",
    transform: "rotate(-90, 18, 18)",
    fill: "none",
    "stroke-width": "2",
    "stroke-dasharray": circleLength,
    "stroke-dashoffset": circleLength - circleLength / 100 * progress
  }));
}

module.exports = function FileProgress(props) {
  // Nothing if upload has not started
  if (!props.file.progress.uploadStarted) {
    return null;
  } // Green checkmark when complete


  if (props.isUploaded) {
    return h("div", {
      className: "uppy-Dashboard-Item-progress"
    }, h("div", {
      className: "uppy-Dashboard-Item-progressIndicator"
    }, h(ProgressCircleContainer, null, h("circle", {
      r: "15",
      cx: "18",
      cy: "18",
      fill: "#1bb240"
    }), h("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--check",
      transform: "translate(2, 3)",
      points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
    }))));
  }

  if (props.recoveredState) {
    return;
  } // Retry button for error


  if (props.error && !props.hideRetryButton) {
    return h(ProgressIndicatorButton, props, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry",
      width: "28",
      height: "31",
      viewBox: "0 0 16 19"
    }, h("path", {
      d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
    }), h("path", {
      d: "M7.9 3H10v2H7.9z"
    }), h("path", {
      d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
    }), h("path", {
      d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
    })));
  } // Pause/resume button for resumable uploads


  if (props.resumableUploads && !props.hidePauseResumeButton) {
    return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
      progress: props.file.progress.percentage
    }), props.file.isPaused ? h("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--play",
      transform: "translate(3, 3)",
      points: "12 20 12 10 20 15"
    }) : h("g", {
      className: "uppy-Dashboard-Item-progressIcon--pause",
      transform: "translate(14.5, 13)"
    }, h("rect", {
      x: "0",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }), h("rect", {
      x: "5",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }))));
  } // Cancel button for non-resumable uploads if individualCancellation is supported (not bundled)


  if (!props.resumableUploads && props.individualCancellation && !props.hideCancelButton) {
    return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
      progress: props.file.progress.percentage
    }), h("polygon", {
      className: "cancel",
      transform: "translate(2, 2)",
      points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
    })));
  } // Just progress when buttons are disabled


  return h("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h("div", {
    className: "uppy-Dashboard-Item-progressIndicator"
  }, h(ProgressCircleContainer, null, h(ProgressCircle, {
    progress: props.file.progress.percentage
  }))));
};

},{"preact":18}],61:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const metaFieldIdToName = (metaFieldId, metaFields) => {
  const field = metaFields.filter(f => f.id === metaFieldId);
  return field[0].name;
};

module.exports = function renderMissingMetaFieldsError(props) {
  const {
    file,
    toggleFileCard,
    i18n,
    metaFields
  } = props;
  const {
    missingRequiredMetaFields
  } = file;

  if (!(missingRequiredMetaFields != null && missingRequiredMetaFields.length)) {
    return null;
  }

  const metaFieldsString = missingRequiredMetaFields.map(missingMetaField => metaFieldIdToName(missingMetaField, metaFields)).join(', ');
  return h("div", {
    className: "uppy-Dashboard-Item-errorMessage"
  }, i18n('missingRequiredMetaFields', {
    smart_count: missingRequiredMetaFields.length,
    fields: metaFieldsString
  }), ' ', h("button", {
    type: "button",
    class: "uppy-u-reset uppy-Dashboard-Item-errorMessageBtn",
    onClick: () => toggleFileCard(true, file.id)
  }, i18n('editFile')));
};

},{"preact":18}],62:[function(require,module,exports){
"use strict";

const {
  h,
  Component
} = require('preact');

const classNames = require('classnames');

const shallowEqual = require('is-shallow-equal');

const FilePreviewAndLink = require('./FilePreviewAndLink');

const FileProgress = require('./FileProgress');

const FileInfo = require('./FileInfo');

const Buttons = require('./Buttons');

module.exports = class FileItem extends Component {
  componentDidMount() {
    const {
      file
    } = this.props;

    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  }

  shouldComponentUpdate(nextProps) {
    return !shallowEqual(this.props, nextProps);
  } // VirtualList mounts FileItems again and they emit `thumbnail:request`
  // Otherwise thumbnails are broken or missing after Golden Retriever restores files


  componentDidUpdate() {
    const {
      file
    } = this.props;

    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  }

  componentWillUnmount() {
    const {
      file
    } = this.props;

    if (!file.preview) {
      this.props.handleCancelThumbnail(file);
    }
  }

  render() {
    const {
      file
    } = this.props;
    const isProcessing = file.progress.preprocess || file.progress.postprocess;
    const isUploaded = file.progress.uploadComplete && !isProcessing && !file.error;
    const uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing;
    const uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
    const error = file.error || false; // File that Golden Retriever was able to partly restore (only meta, not blob),
    // users still need to re-add it, so its a ghost

    const {
      isGhost
    } = file;
    let showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;

    if (isUploaded && this.props.showRemoveButtonAfterComplete) {
      showRemoveButton = true;
    }

    const dashboardItemClass = classNames({
      'uppy-Dashboard-Item': true,
      'is-inprogress': uploadInProgress && !this.props.recoveredState,
      'is-processing': isProcessing,
      'is-complete': isUploaded,
      'is-error': !!error,
      'is-resumable': this.props.resumableUploads,
      'is-noIndividualCancellation': !this.props.individualCancellation,
      'is-ghost': isGhost
    });
    return h("div", {
      className: dashboardItemClass,
      id: `uppy_${file.id}`,
      role: this.props.role
    }, h("div", {
      className: "uppy-Dashboard-Item-preview"
    }, h(FilePreviewAndLink, {
      file: file,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      i18n: this.props.i18n,
      toggleFileCard: this.props.toggleFileCard,
      metaFields: this.props.metaFields
    }), h(FileProgress, {
      uppy: this.props.uppy,
      file: file,
      error: error,
      isUploaded: isUploaded,
      hideRetryButton: this.props.hideRetryButton,
      hideCancelButton: this.props.hideCancelButton,
      hidePauseResumeButton: this.props.hidePauseResumeButton,
      recoveredState: this.props.recoveredState,
      showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete,
      resumableUploads: this.props.resumableUploads,
      individualCancellation: this.props.individualCancellation,
      i18n: this.props.i18n
    })), h("div", {
      className: "uppy-Dashboard-Item-fileInfoAndButtons"
    }, h(FileInfo, {
      file: file,
      id: this.props.id,
      acquirers: this.props.acquirers,
      containerWidth: this.props.containerWidth,
      i18n: this.props.i18n,
      toggleAddFilesPanel: this.props.toggleAddFilesPanel,
      toggleFileCard: this.props.toggleFileCard,
      metaFields: this.props.metaFields
    }), h(Buttons, {
      file: file,
      metaFields: this.props.metaFields,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      showRemoveButton: showRemoveButton,
      canEditFile: this.props.canEditFile,
      uploadInProgressOrComplete: uploadInProgressOrComplete,
      toggleFileCard: this.props.toggleFileCard,
      openFileEditor: this.props.openFileEditor,
      uppy: this.props.uppy,
      i18n: this.props.i18n
    })));
  }

};

},{"./Buttons":57,"./FileInfo":58,"./FilePreviewAndLink":59,"./FileProgress":60,"classnames":4,"is-shallow-equal":8,"preact":18}],63:[function(require,module,exports){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const classNames = require('classnames');

const {
  h
} = require('preact');

const FileItem = require('./FileItem/index.js');

const VirtualList = require('./VirtualList');

function chunks(list, size) {
  const chunked = [];
  let currentChunk = [];
  list.forEach(item => {
    if (currentChunk.length < size) {
      currentChunk.push(item);
    } else {
      chunked.push(currentChunk);
      currentChunk = [item];
    }
  });
  if (currentChunk.length) chunked.push(currentChunk);
  return chunked;
}

module.exports = props => {
  const noFiles = props.totalFileCount === 0;
  const dashboardFilesClass = classNames('uppy-Dashboard-files', {
    'uppy-Dashboard-files--noFiles': noFiles
  }); // It's not great that this is hardcoded!
  // It's ESPECIALLY not great that this is checking against `itemsPerRow`!

  const rowHeight = props.itemsPerRow === 1 // Mobile
  ? 71 // 190px height + 2 * 5px margin
  : 200;
  const fileProps = {
    // FIXME This is confusing, it's actually the Dashboard's plugin ID
    id: props.id,
    error: props.error,
    // TODO move this to context
    i18n: props.i18n,
    uppy: props.uppy,
    // features
    acquirers: props.acquirers,
    resumableUploads: props.resumableUploads,
    individualCancellation: props.individualCancellation,
    // visual options
    hideRetryButton: props.hideRetryButton,
    hidePauseResumeButton: props.hidePauseResumeButton,
    hideCancelButton: props.hideCancelButton,
    showLinkToFileUploadResult: props.showLinkToFileUploadResult,
    showRemoveButtonAfterComplete: props.showRemoveButtonAfterComplete,
    isWide: props.isWide,
    metaFields: props.metaFields,
    recoveredState: props.recoveredState,
    // callbacks
    toggleFileCard: props.toggleFileCard,
    handleRequestThumbnail: props.handleRequestThumbnail,
    handleCancelThumbnail: props.handleCancelThumbnail
  };

  const sortByGhostComesFirst = (file1, file2) => {
    return props.files[file2].isGhost - props.files[file1].isGhost;
  }; // Sort files by file.isGhost, ghost files first, only if recoveredState is present


  const files = Object.keys(props.files);
  if (props.recoveredState) files.sort(sortByGhostComesFirst);
  const rows = chunks(files, props.itemsPerRow);

  const renderRow = row => // The `role="presentation` attribute ensures that the list items are properly
  // associated with the `VirtualList` element.
  // We use the first file ID as the keythis should not change across scroll rerenders
  h("div", {
    role: "presentation",
    key: row[0]
  }, row.map(fileID => h(FileItem, _extends({
    key: fileID,
    uppy: props.uppy
  }, fileProps, {
    role: "listitem",
    openFileEditor: props.openFileEditor,
    canEditFile: props.canEditFile,
    toggleAddFilesPanel: props.toggleAddFilesPanel,
    file: props.files[fileID]
  }))));

  return h(VirtualList, {
    class: dashboardFilesClass,
    role: "list",
    data: rows,
    renderRow: renderRow,
    rowHeight: rowHeight
  });
};

},{"./FileItem/index.js":62,"./VirtualList":68,"classnames":4,"preact":18}],64:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const getFileTypeIcon = require('../utils/getFileTypeIcon');

module.exports = function FilePreview(props) {
  const {
    file
  } = props;

  if (file.preview) {
    return h("img", {
      className: "uppy-Dashboard-Item-previewImg",
      alt: file.name,
      src: file.preview
    });
  }

  const {
    color,
    icon
  } = getFileTypeIcon(file.type);
  return h("div", {
    className: "uppy-Dashboard-Item-previewIconWrap"
  }, h("span", {
    className: "uppy-Dashboard-Item-previewIcon",
    style: {
      color
    }
  }, icon), h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-Dashboard-Item-previewIconBg",
    width: "58",
    height: "76",
    viewBox: "0 0 58 76"
  }, h("rect", {
    fill: "#FFF",
    width: "58",
    height: "76",
    rx: "3",
    fillRule: "evenodd"
  })));
};

},{"../utils/getFileTypeIcon":74,"preact":18}],65:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const classNames = require('classnames');

const ignoreEvent = require('../utils/ignoreEvent.js');

function PickerPanelContent(props) {
  return h("div", {
    className: classNames('uppy-DashboardContent-panel', props.className),
    role: "tabpanel",
    "data-uppy-panelType": "PickerPanel",
    id: `uppy-DashboardContent-panel--${props.activePickerPanel.id}`,
    onDragOver: ignoreEvent,
    onDragLeave: ignoreEvent,
    onDrop: ignoreEvent,
    onPaste: ignoreEvent
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n('importFrom', {
    name: props.activePickerPanel.name
  })), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n('cancel'))), h("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.uppy.getPlugin(props.activePickerPanel.id).render(props.state)));
}

module.exports = PickerPanelContent;

},{"../utils/ignoreEvent.js":75,"classnames":4,"preact":18}],66:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const uploadStates = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete',
  STATE_PAUSED: 'paused'
};

function getUploadingState(isAllErrored, isAllComplete, isAllPaused, files = {}) {
  if (isAllErrored) {
    return uploadStates.STATE_ERROR;
  }

  if (isAllComplete) {
    return uploadStates.STATE_COMPLETE;
  }

  if (isAllPaused) {
    return uploadStates.STATE_PAUSED;
  }

  let state = uploadStates.STATE_WAITING;
  const fileIDs = Object.keys(files);

  for (let i = 0; i < fileIDs.length; i++) {
    const {
      progress
    } = files[fileIDs[i]]; // If ANY files are being uploaded right now, show the uploading state.

    if (progress.uploadStarted && !progress.uploadComplete) {
      return uploadStates.STATE_UPLOADING;
    } // If files are being preprocessed AND postprocessed at this time, we show the
    // preprocess state. If any files are being uploaded we show uploading.


    if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) {
      state = uploadStates.STATE_PREPROCESSING;
    } // If NO files are being preprocessed or uploaded right now, but some files are
    // being postprocessed, show the postprocess state.


    if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) {
      state = uploadStates.STATE_POSTPROCESSING;
    }
  }

  return state;
}

function UploadStatus(props) {
  const uploadingState = getUploadingState(props.isAllErrored, props.isAllComplete, props.isAllPaused, props.files);

  switch (uploadingState) {
    case 'uploading':
      return props.i18n('uploadingXFiles', {
        smart_count: props.inProgressNotPausedFiles.length
      });

    case 'preprocessing':
    case 'postprocessing':
      return props.i18n('processingXFiles', {
        smart_count: props.processingFiles.length
      });

    case 'paused':
      return props.i18n('uploadPaused');

    case 'waiting':
      return props.i18n('xFilesSelected', {
        smart_count: props.newFiles.length
      });

    case 'complete':
      return props.i18n('uploadComplete');
  }
}

function PanelTopBar(props) {
  let {
    allowNewUpload
  } = props; // TODO maybe this should be done in ../index.js, then just pass that down as `allowNewUpload`

  if (allowNewUpload && props.maxNumberOfFiles) {
    allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
  }

  return h("div", {
    className: "uppy-DashboardContent-bar"
  }, !props.isAllComplete && !props.hideCancelButton ? h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: () => props.uppy.cancelAll()
  }, props.i18n('cancel')) : h("div", null), h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, h(UploadStatus, props)), allowNewUpload ? h("button", {
    className: "uppy-DashboardContent-addMore",
    type: "button",
    "aria-label": props.i18n('addMoreFiles'),
    title: props.i18n('addMoreFiles'),
    onClick: () => props.toggleAddFilesPanel(true)
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "15",
    height: "15",
    viewBox: "0 0 15 15"
  }, h("path", {
    d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
  })), h("span", {
    className: "uppy-DashboardContent-addMoreCaption"
  }, props.i18n('addMore'))) : h("div", null));
}

module.exports = PanelTopBar;

},{"preact":18}],67:[function(require,module,exports){
"use strict";

const {
  cloneElement,
  Component,
  toChildArray
} = require('preact');

const classNames = require('classnames');

const transitionName = 'uppy-transition-slideDownUp';
const duration = 250;
/**
 * Vertical slide transition.
 *
 * This can take a _single_ child component, which _must_ accept a `className` prop.
 *
 * Currently this is specific to the `uppy-transition-slideDownUp` transition,
 * but it should be simple to extend this for any type of single-element
 * transition by setting the CSS name and duration as props.
 */

class Slide extends Component {
  constructor(props) {
    super(props);
    this.state = {
      cachedChildren: null,
      className: ''
    };
  } // TODO: refactor to stable lifecycle method
  // eslint-disable-next-line


  componentWillUpdate(nextProps) {
    const {
      cachedChildren
    } = this.state;
    const child = toChildArray(nextProps.children)[0];
    if (cachedChildren === child) return null;
    const patch = {
      cachedChildren: child
    }; // Enter transition

    if (child && !cachedChildren) {
      patch.className = `${transitionName}-enter`;
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.leaveTimeout);
      this.leaveTimeout = undefined;
      this.animationFrame = requestAnimationFrame(() => {
        // Force it to render before we add the active class
        // this.base.getBoundingClientRect()
        this.setState({
          className: `${transitionName}-enter ${transitionName}-enter-active`
        });
        this.enterTimeout = setTimeout(() => {
          this.setState({
            className: ''
          });
        }, duration);
      });
    } // Leave transition


    if (cachedChildren && !child && this.leaveTimeout === undefined) {
      patch.cachedChildren = cachedChildren;
      patch.className = `${transitionName}-leave`;
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.enterTimeout);
      this.enterTimeout = undefined;
      this.animationFrame = requestAnimationFrame(() => {
        this.setState({
          className: `${transitionName}-leave ${transitionName}-leave-active`
        });
        this.leaveTimeout = setTimeout(() => {
          this.setState({
            cachedChildren: null,
            className: ''
          });
        }, duration);
      });
    } // eslint-disable-next-line


    this.setState(patch);
  }

  render() {
    const {
      cachedChildren,
      className
    } = this.state;

    if (!cachedChildren) {
      return null;
    }

    return cloneElement(cachedChildren, {
      className: classNames(className, cachedChildren.props.className)
    });
  }

}

module.exports = Slide;

},{"classnames":4,"preact":18}],68:[function(require,module,exports){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * Adapted from preact-virtual-list: https://github.com/developit/preact-virtual-list
 *
 *  2016 Jason Miller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Adaptations:
 * - Added role=presentation to helper elements
 * - Tweaked styles for Uppy's Dashboard use case
 */
const {
  h,
  Component
} = require('preact');

const STYLE_INNER = {
  position: 'relative',
  // Disabled for our use case: the wrapper elements around FileList already deal with overflow,
  // and this additional property would hide things that we want to show.
  //
  // overflow: 'hidden',
  width: '100%',
  minHeight: '100%'
};
const STYLE_CONTENT = {
  position: 'absolute',
  top: 0,
  left: 0,
  // Because the `top` value gets set to some offset, this `height` being 100% would make the scrollbar
  // stretch far beyond the content. For our use case, the content div actually can get its height from
  // the elements inside it, so we don't need to specify a `height` property at all.
  //
  // height: '100%',
  width: '100%',
  overflow: 'visible'
};

class VirtualList extends Component {
  constructor(props) {
    super(props); // The currently focused node, used to retain focus when the visible rows change.
    // To avoid update loops, this should not cause state updates, so it's kept as a plain property.

    this.handleScroll = () => {
      this.setState({
        offset: this.base.scrollTop
      });
    };

    this.handleResize = () => {
      this.resize();
    };

    this.focusElement = null;
    this.state = {
      offset: 0,
      height: 0
    };
  }

  componentDidMount() {
    this.resize();
    window.addEventListener('resize', this.handleResize);
  } // TODO: refactor to stable lifecycle method
  // eslint-disable-next-line


  componentWillUpdate() {
    if (this.base.contains(document.activeElement)) {
      this.focusElement = document.activeElement;
    }
  }

  componentDidUpdate() {
    // Maintain focus when rows are added and removed.
    if (this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement) {
      this.focusElement.focus();
    }

    this.focusElement = null;
    this.resize();
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }

  resize() {
    const {
      height
    } = this.state;

    if (height !== this.base.offsetHeight) {
      this.setState({
        height: this.base.offsetHeight
      });
    }
  }

  render({
    data,
    rowHeight,
    renderRow,
    overscanCount = 10,
    ...props
  }) {
    const {
      offset,
      height
    } = this.state; // first visible row index

    let start = Math.floor(offset / rowHeight); // actual number of visible rows (without overscan)

    let visibleRowCount = Math.floor(height / rowHeight); // Overscan: render blocks of rows modulo an overscan row count
    // This dramatically reduces DOM writes during scrolling

    if (overscanCount) {
      start = Math.max(0, start - start % overscanCount);
      visibleRowCount += overscanCount;
    } // last visible + overscan row index + padding to allow keyboard focus to travel past the visible area


    const end = start + visibleRowCount + 4; // data slice currently in viewport plus overscan items

    const selection = data.slice(start, end);
    const styleInner = { ...STYLE_INNER,
      height: data.length * rowHeight
    };
    const styleContent = { ...STYLE_CONTENT,
      top: start * rowHeight
    }; // The `role="presentation"` attributes ensure that these wrapper elements are not treated as list
    // items by accessibility and outline tools.

    return h("div", _extends({
      onScroll: this.handleScroll
    }, props), h("div", {
      role: "presentation",
      style: styleInner
    }, h("div", {
      role: "presentation",
      style: styleContent
    }, selection.map(renderRow))));
  }

}

module.exports = VirtualList;

},{"preact":18}],69:[function(require,module,exports){
"use strict";

var _class, _openFileEditorWhenFilesAdded, _attachRenderFunctionToTarget, _isTargetSupported, _getAcquirers, _getProgressIndicators, _getEditors, _temp;

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const {
  h
} = require('preact');

const {
  UIPlugin
} = require('./../../core');

const StatusBar = require('./../../status-bar');

const Informer = require('./../../informer');

const ThumbnailGenerator = require('./../../thumbnail-generator');

const findAllDOMElements = require('./../../utils/lib/findAllDOMElements');

const toArray = require('./../../utils/lib/toArray');

const getDroppedFiles = require('./../../utils/lib/getDroppedFiles');

const getTextDirection = require('./../../utils/lib/getTextDirection');

const {
  nanoid
} = require('nanoid');

const trapFocus = require('./utils/trapFocus');

const createSuperFocus = require('./utils/createSuperFocus');

const memoize = require('memoize-one').default || require('memoize-one');

const FOCUSABLE_ELEMENTS = require('./../../utils/lib/FOCUSABLE_ELEMENTS');

const DashboardUI = require('./components/Dashboard');

const locale = require('./locale');

const TAB_KEY = 9;
const ESC_KEY = 27;

function createPromise() {
  const o = {};
  o.promise = new Promise((resolve, reject) => {
    o.resolve = resolve;
    o.reject = reject;
  });
  return o;
}

function defaultPickerIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "30",
    height: "30",
    viewBox: "0 0 30 30"
  }, h("path", {
    d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
  }));
}
/**
 * Dashboard UI with previews, metadata editing, tabs for various services and more
 */


module.exports = (_temp = (_openFileEditorWhenFilesAdded = /*#__PURE__*/_classPrivateFieldLooseKey("openFileEditorWhenFilesAdded"), _attachRenderFunctionToTarget = /*#__PURE__*/_classPrivateFieldLooseKey("attachRenderFunctionToTarget"), _isTargetSupported = /*#__PURE__*/_classPrivateFieldLooseKey("isTargetSupported"), _getAcquirers = /*#__PURE__*/_classPrivateFieldLooseKey("getAcquirers"), _getProgressIndicators = /*#__PURE__*/_classPrivateFieldLooseKey("getProgressIndicators"), _getEditors = /*#__PURE__*/_classPrivateFieldLooseKey("getEditors"), _class = class Dashboard extends UIPlugin {
  constructor(uppy, _opts) {
    super(uppy, _opts);

    this.removeTarget = plugin => {
      const pluginState = this.getPluginState(); // filter out the one we want to remove

      const newTargets = pluginState.targets.filter(target => target.id !== plugin.id);
      this.setPluginState({
        targets: newTargets
      });
    };

    this.addTarget = plugin => {
      const callerPluginId = plugin.id || plugin.constructor.name;
      const callerPluginName = plugin.title || callerPluginId;
      const callerPluginType = plugin.type;

      if (callerPluginType !== 'acquirer' && callerPluginType !== 'progressindicator' && callerPluginType !== 'editor') {
        const msg = 'Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor';
        this.uppy.log(msg, 'error');
        return;
      }

      const target = {
        id: callerPluginId,
        name: callerPluginName,
        type: callerPluginType
      };
      const state = this.getPluginState();
      const newTargets = state.targets.slice();
      newTargets.push(target);
      this.setPluginState({
        targets: newTargets
      });
      return this.el;
    };

    this.hideAllPanels = () => {
      const state = this.getPluginState();
      const update = {
        activePickerPanel: false,
        showAddFilesPanel: false,
        activeOverlayType: null,
        fileCardFor: null,
        showFileEditor: false
      };

      if (state.activePickerPanel === update.activePickerPanel && state.showAddFilesPanel === update.showAddFilesPanel && state.showFileEditor === update.showFileEditor && state.activeOverlayType === update.activeOverlayType) {
        // avoid doing a state update if nothing changed
        return;
      }

      this.setPluginState(update);
    };

    this.showPanel = id => {
      const {
        targets
      } = this.getPluginState();
      const activePickerPanel = targets.filter(target => {
        return target.type === 'acquirer' && target.id === id;
      })[0];
      this.setPluginState({
        activePickerPanel,
        activeOverlayType: 'PickerPanel'
      });
    };

    this.canEditFile = file => {
      const {
        targets
      } = this.getPluginState();

      const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);

      return editors.some(target => this.uppy.getPlugin(target.id).canEditFile(file));
    };

    this.openFileEditor = file => {
      const {
        targets
      } = this.getPluginState();

      const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);

      this.setPluginState({
        showFileEditor: true,
        fileCardFor: file.id || null,
        activeOverlayType: 'FileEditor'
      });
      editors.forEach(editor => {
        this.uppy.getPlugin(editor.id).selectFile(file);
      });
    };

    this.saveFileEditor = () => {
      const {
        targets
      } = this.getPluginState();

      const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);

      editors.forEach(editor => {
        this.uppy.getPlugin(editor.id).save();
      });
      this.hideAllPanels();
    };

    this.openModal = () => {
      const {
        promise,
        resolve
      } = createPromise(); // save scroll position

      this.savedScrollPosition = window.pageYOffset; // save active element, so we can restore focus when modal is closed

      this.savedActiveElement = document.activeElement;

      if (this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.add('uppy-Dashboard-isFixed');
      }

      if (this.opts.animateOpenClose && this.getPluginState().isClosing) {
        const handler = () => {
          this.setPluginState({
            isHidden: false
          });
          this.el.removeEventListener('animationend', handler, false);
          resolve();
        };

        this.el.addEventListener('animationend', handler, false);
      } else {
        this.setPluginState({
          isHidden: false
        });
        resolve();
      }

      if (this.opts.browserBackButtonClose) {
        this.updateBrowserHistory();
      } // handle ESC and TAB keys in modal dialog


      document.addEventListener('keydown', this.handleKeyDownInModal);
      this.uppy.emit('dashboard:modal-open');
      return promise;
    };

    this.closeModal = (opts = {}) => {
      const {
        // Whether the modal is being closed by the user (`true`) or by other means (e.g. browser back button)
        manualClose = true
      } = opts;
      const {
        isHidden,
        isClosing
      } = this.getPluginState();

      if (isHidden || isClosing) {
        // short-circuit if animation is ongoing
        return;
      }

      const {
        promise,
        resolve
      } = createPromise();

      if (this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.remove('uppy-Dashboard-isFixed');
      }

      if (this.opts.animateOpenClose) {
        this.setPluginState({
          isClosing: true
        });

        const handler = () => {
          this.setPluginState({
            isHidden: true,
            isClosing: false
          });
          this.superFocus.cancel();
          this.savedActiveElement.focus();
          this.el.removeEventListener('animationend', handler, false);
          resolve();
        };

        this.el.addEventListener('animationend', handler, false);
      } else {
        this.setPluginState({
          isHidden: true
        });
        this.superFocus.cancel();
        this.savedActiveElement.focus();
        resolve();
      } // handle ESC and TAB keys in modal dialog


      document.removeEventListener('keydown', this.handleKeyDownInModal);

      if (manualClose) {
        if (this.opts.browserBackButtonClose) {
          var _history$state;

          // Make sure that the latest entry in the history state is our modal name
          // eslint-disable-next-line no-restricted-globals
          if ((_history$state = history.state) != null && _history$state[this.modalName]) {
            // Go back in history to clear out the entry we created (ultimately closing the modal)
            // eslint-disable-next-line no-restricted-globals
            history.back();
          }
        }
      }

      this.uppy.emit('dashboard:modal-closed');
      return promise;
    };

    this.isModalOpen = () => {
      return !this.getPluginState().isHidden || false;
    };

    this.requestCloseModal = () => {
      if (this.opts.onRequestCloseModal) {
        return this.opts.onRequestCloseModal();
      }

      return this.closeModal();
    };

    this.setDarkModeCapability = isDarkModeOn => {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: { ...capabilities,
          darkMode: isDarkModeOn
        }
      });
    };

    this.handleSystemDarkModeChange = event => {
      const isDarkModeOnNow = event.matches;
      this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnNow ? 'on' : 'off'}`);
      this.setDarkModeCapability(isDarkModeOnNow);
    };

    this.toggleFileCard = (show, fileID) => {
      const file = this.uppy.getFile(fileID);

      if (show) {
        this.uppy.emit('dashboard:file-edit-start', file);
      } else {
        this.uppy.emit('dashboard:file-edit-complete', file);
      }

      this.setPluginState({
        fileCardFor: show ? fileID : null,
        activeOverlayType: show ? 'FileCard' : null
      });
    };

    this.toggleAddFilesPanel = show => {
      this.setPluginState({
        showAddFilesPanel: show,
        activeOverlayType: show ? 'AddFiles' : null
      });
    };

    this.addFiles = files => {
      const descriptors = files.map(file => ({
        source: this.id,
        name: file.name,
        type: file.type,
        data: file,
        meta: {
          // path of the file relative to the ancestor directory the user selected.
          // e.g. 'docs/Old Prague/airbnb.pdf'
          relativePath: file.relativePath || null
        }
      }));

      try {
        this.uppy.addFiles(descriptors);
      } catch (err) {
        this.uppy.log(err);
      }
    };

    this.startListeningToResize = () => {
      // Watch for Dashboard container (`.uppy-Dashboard-inner`) resize
      // and update containerWidth/containerHeight in plugin state accordingly.
      // Emits first event on initialization.
      this.resizeObserver = new ResizeObserver(entries => {
        const uppyDashboardInnerEl = entries[0];
        const {
          width,
          height
        } = uppyDashboardInnerEl.contentRect;
        this.uppy.log(`[Dashboard] resized: ${width} / ${height}`, 'debug');
        this.setPluginState({
          containerWidth: width,
          containerHeight: height,
          areInsidesReadyToBeVisible: true
        });
      });
      this.resizeObserver.observe(this.el.querySelector('.uppy-Dashboard-inner')); // If ResizeObserver fails to emit an event telling us what size to use - default to the mobile view

      this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(() => {
        const pluginState = this.getPluginState();
        const isModalAndClosed = !this.opts.inline && pluginState.isHidden;

        if ( // if ResizeObserver hasn't yet fired,
        !pluginState.areInsidesReadyToBeVisible // and it's not due to the modal being closed
        && !isModalAndClosed) {
          this.uppy.log("[Dashboard] resize event didn't fire on time: defaulted to mobile layout", 'debug');
          this.setPluginState({
            areInsidesReadyToBeVisible: true
          });
        }
      }, 1000);
    };

    this.stopListeningToResize = () => {
      this.resizeObserver.disconnect();
      clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout);
    };

    this.recordIfFocusedOnUppyRecently = event => {
      if (this.el.contains(event.target)) {
        this.ifFocusedOnUppyRecently = true;
      } else {
        this.ifFocusedOnUppyRecently = false; // ___Why run this.superFocus.cancel here when it already runs in superFocusOnEachUpdate?
        //    Because superFocus is debounced, when we move from Uppy to some other element on the page,
        //    previously run superFocus sometimes hits and moves focus back to Uppy.

        this.superFocus.cancel();
      }
    };

    this.disableAllFocusableElements = disable => {
      const focusableNodes = toArray(this.el.querySelectorAll(FOCUSABLE_ELEMENTS));

      if (disable) {
        focusableNodes.forEach(node => {
          // save previous tabindex in a data-attribute, to restore when enabling
          const currentTabIndex = node.getAttribute('tabindex');

          if (currentTabIndex) {
            node.dataset.inertTabindex = currentTabIndex;
          }

          node.setAttribute('tabindex', '-1');
        });
      } else {
        focusableNodes.forEach(node => {
          if ('inertTabindex' in node.dataset) {
            node.setAttribute('tabindex', node.dataset.inertTabindex);
          } else {
            node.removeAttribute('tabindex');
          }
        });
      }

      this.dashboardIsDisabled = disable;
    };

    this.updateBrowserHistory = () => {
      var _history$state2;

      // Ensure history state does not already contain our modal name to avoid double-pushing
      // eslint-disable-next-line no-restricted-globals
      if (!((_history$state2 = history.state) != null && _history$state2[this.modalName])) {
        // Push to history so that the page is not lost on browser back button press
        // eslint-disable-next-line no-restricted-globals
        history.pushState({ // eslint-disable-next-line no-restricted-globals
          ...history.state,
          [this.modalName]: true
        }, '');
      } // Listen for back button presses


      window.addEventListener('popstate', this.handlePopState, false);
    };

    this.handlePopState = event => {
      var _event$state;

      // Close the modal if the history state no longer contains our modal name
      if (this.isModalOpen() && (!event.state || !event.state[this.modalName])) {
        this.closeModal({
          manualClose: false
        });
      } // When the browser back button is pressed and uppy is now the latest entry
      // in the history but the modal is closed, fix the history by removing the
      // uppy history entry.
      // This occurs when another entry is added into the history state while the
      // modal is open, and then the modal gets manually closed.
      // Solves PR #575 (https://github.com/transloadit/uppy/pull/575)


      if (!this.isModalOpen() && (_event$state = event.state) != null && _event$state[this.modalName]) {
        // eslint-disable-next-line no-restricted-globals
        history.back();
      }
    };

    this.handleKeyDownInModal = event => {
      // close modal on esc key press
      if (event.keyCode === ESC_KEY) this.requestCloseModal(event); // trap focus on tab key press

      if (event.keyCode === TAB_KEY) trapFocus.forModal(event, this.getPluginState().activeOverlayType, this.el);
    };

    this.handleClickOutside = () => {
      if (this.opts.closeModalOnClickOutside) this.requestCloseModal();
    };

    this.handlePaste = event => {
      // Let any acquirer plugin (Url/Webcam/etc.) handle pastes to the root
      this.uppy.iteratePlugins(plugin => {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootPaste(event)
          plugin.handleRootPaste == null ? void 0 : plugin.handleRootPaste(event);
        }
      }); // Add all dropped files

      const files = toArray(event.clipboardData.files);

      if (files.length > 0) {
        this.uppy.log('[Dashboard] Files pasted');
        this.addFiles(files);
      }
    };

    this.handleInputChange = event => {
      event.preventDefault();
      const files = toArray(event.target.files);

      if (files.length > 0) {
        this.uppy.log('[Dashboard] Files selected through input');
        this.addFiles(files);
      }
    };

    this.handleDragOver = event => {
      var _this$opts$onDragOver, _this$opts;

      event.preventDefault();
      event.stopPropagation(); // Check if some plugin can handle the datatransfer without files 
      // for instance, the Url plugin can import a url

      const canSomePluginHandleRootDrop = () => {
        let somePluginCanHandleRootDrop = true;
        this.uppy.iteratePlugins(plugin => {
          if (plugin.canHandleRootDrop != null && plugin.canHandleRootDrop(event)) {
            somePluginCanHandleRootDrop = true;
          }
        });
        return somePluginCanHandleRootDrop;
      }; // Check if the "type" of the datatransfer object includes files


      const doesEventHaveFiles = () => {
        const {
          types
        } = event.dataTransfer;
        return types.some(type => type === 'Files');
      }; // Deny drop, if no plugins can handle datatransfer, there are no files,
      // or when opts.disabled is set, or new uploads are not allowed


      const somePluginCanHandleRootDrop = canSomePluginHandleRootDrop(event);
      const hasFiles = doesEventHaveFiles(event);

      if (!somePluginCanHandleRootDrop && !hasFiles || this.opts.disabled // opts.disableLocalFiles should only be taken into account if no plugins
      // can handle the datatransfer
      || this.opts.disableLocalFiles && (hasFiles || !somePluginCanHandleRootDrop) || !this.uppy.getState().allowNewUpload) {
        event.dataTransfer.dropEffect = 'none';
        clearTimeout(this.removeDragOverClassTimeout);
        return;
      } // Add a small (+) icon on drop
      // (and prevent browsers from interpreting this as files being _moved_ into the
      // browser, https://github.com/transloadit/uppy/issues/1978).


      event.dataTransfer.dropEffect = 'copy';
      clearTimeout(this.removeDragOverClassTimeout);
      this.setPluginState({
        isDraggingOver: true
      });
      (_this$opts$onDragOver = (_this$opts = this.opts).onDragOver) == null ? void 0 : _this$opts$onDragOver.call(_this$opts, event);
    };

    this.handleDragLeave = event => {
      var _this$opts$onDragLeav, _this$opts2;

      event.preventDefault();
      event.stopPropagation();
      clearTimeout(this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library.
      // Solution with 'pointer-events: none' didn't work across browsers.

      this.removeDragOverClassTimeout = setTimeout(() => {
        this.setPluginState({
          isDraggingOver: false
        });
      }, 50);
      (_this$opts$onDragLeav = (_this$opts2 = this.opts).onDragLeave) == null ? void 0 : _this$opts$onDragLeav.call(_this$opts2, event);
    };

    this.handleDrop = async event => {
      var _this$opts$onDrop, _this$opts3;

      event.preventDefault();
      event.stopPropagation();
      clearTimeout(this.removeDragOverClassTimeout);
      this.setPluginState({
        isDraggingOver: false
      }); // Let any acquirer plugin (Url/Webcam/etc.) handle drops to the root

      this.uppy.iteratePlugins(plugin => {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootDrop(event)
          plugin.handleRootDrop == null ? void 0 : plugin.handleRootDrop(event);
        }
      }); // Add all dropped files

      let executedDropErrorOnce = false;

      const logDropError = error => {
        this.uppy.log(error, 'error'); // In practice all drop errors are most likely the same,
        // so let's just show one to avoid overwhelming the user

        if (!executedDropErrorOnce) {
          this.uppy.info(error.message, 'error');
          executedDropErrorOnce = true;
        }
      }; // Add all dropped files


      const files = await getDroppedFiles(event.dataTransfer, {
        logDropError
      });

      if (files.length > 0) {
        this.uppy.log('[Dashboard] Files dropped');
        this.addFiles(files);
      }

      (_this$opts$onDrop = (_this$opts3 = this.opts).onDrop) == null ? void 0 : _this$opts$onDrop.call(_this$opts3, event);
    };

    this.handleRequestThumbnail = file => {
      if (!this.opts.waitForThumbnailsBeforeUpload) {
        this.uppy.emit('thumbnail:request', file);
      }
    };

    this.handleCancelThumbnail = file => {
      if (!this.opts.waitForThumbnailsBeforeUpload) {
        this.uppy.emit('thumbnail:cancel', file);
      }
    };

    this.handleKeyDownInInline = event => {
      // Trap focus on tab key press.
      if (event.keyCode === TAB_KEY) trapFocus.forInline(event, this.getPluginState().activeOverlayType, this.el);
    };

    this.handlePasteOnBody = event => {
      const isFocusInOverlay = this.el.contains(document.activeElement);

      if (isFocusInOverlay) {
        this.handlePaste(event);
      }
    };

    this.handleComplete = ({
      failed
    }) => {
      if (this.opts.closeAfterFinish && failed.length === 0) {
        // All uploads are done
        this.requestCloseModal();
      }
    };

    this.handleCancelRestore = () => {
      this.uppy.emit('restore-canceled');
    };

    Object.defineProperty(this, _openFileEditorWhenFilesAdded, {
      writable: true,
      value: files => {
        const firstFile = files[0];

        if (this.canEditFile(firstFile)) {
          this.openFileEditor(firstFile);
        }
      }
    });

    this.initEvents = () => {
      // Modal open button
      if (this.opts.trigger && !this.opts.inline) {
        const showModalTrigger = findAllDOMElements(this.opts.trigger);

        if (showModalTrigger) {
          showModalTrigger.forEach(trigger => trigger.addEventListener('click', this.openModal));
        } else {
          this.uppy.log('Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself', 'warning');
        }
      }

      this.startListeningToResize();
      document.addEventListener('paste', this.handlePasteOnBody);
      this.uppy.on('plugin-remove', this.removeTarget);
      this.uppy.on('file-added', this.hideAllPanels);
      this.uppy.on('dashboard:modal-closed', this.hideAllPanels);
      this.uppy.on('file-editor:complete', this.hideAllPanels);
      this.uppy.on('complete', this.handleComplete); // ___Why fire on capture?
      //    Because this.ifFocusedOnUppyRecently needs to change before onUpdate() fires.

      document.addEventListener('focus', this.recordIfFocusedOnUppyRecently, true);
      document.addEventListener('click', this.recordIfFocusedOnUppyRecently, true);

      if (this.opts.inline) {
        this.el.addEventListener('keydown', this.handleKeyDownInInline);
      }

      if (this.opts.autoOpenFileEditor) {
        this.uppy.on('files-added', _classPrivateFieldLooseBase(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
      }
    };

    this.removeEvents = () => {
      const showModalTrigger = findAllDOMElements(this.opts.trigger);

      if (!this.opts.inline && showModalTrigger) {
        showModalTrigger.forEach(trigger => trigger.removeEventListener('click', this.openModal));
      }

      this.stopListeningToResize();
      document.removeEventListener('paste', this.handlePasteOnBody);
      window.removeEventListener('popstate', this.handlePopState, false);
      this.uppy.off('plugin-remove', this.removeTarget);
      this.uppy.off('file-added', this.hideAllPanels);
      this.uppy.off('dashboard:modal-closed', this.hideAllPanels);
      this.uppy.off('file-editor:complete', this.hideAllPanels);
      this.uppy.off('complete', this.handleComplete);
      document.removeEventListener('focus', this.recordIfFocusedOnUppyRecently);
      document.removeEventListener('click', this.recordIfFocusedOnUppyRecently);

      if (this.opts.inline) {
        this.el.removeEventListener('keydown', this.handleKeyDownInInline);
      }

      if (this.opts.autoOpenFileEditor) {
        this.uppy.off('files-added', _classPrivateFieldLooseBase(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
      }
    };

    this.superFocusOnEachUpdate = () => {
      const isFocusInUppy = this.el.contains(document.activeElement); // When focus is lost on the page (== focus is on body for most browsers, or focus is null for IE11)

      const isFocusNowhere = document.activeElement === document.body || document.activeElement === null;
      const isInformerHidden = this.uppy.getState().info.isHidden;
      const isModal = !this.opts.inline;

      if ( // If update is connected to showing the Informer - let the screen reader calmly read it.
      isInformerHidden && ( // If we are in a modal - always superfocus without concern for other elements
      // on the page (user is unlikely to want to interact with the rest of the page)
      isModal // If we are already inside of Uppy, or
      || isFocusInUppy // If we are not focused on anything BUT we have already, at least once, focused on uppy
      //   1. We focus when isFocusNowhere, because when the element we were focused
      //      on disappears (e.g. an overlay), - focus gets lost. If user is typing
      //      something somewhere else on the page, - focus won't be 'nowhere'.
      //   2. We only focus when focus is nowhere AND this.ifFocusedOnUppyRecently,
      //      to avoid focus jumps if we do something else on the page.
      //   [Practical check] Without '&& this.ifFocusedOnUppyRecently', in Safari, in inline mode,
      //                     when file is uploading, - navigate via tab to the checkbox,
      //                     try to press space multiple times. Focus will jump to Uppy.
      || isFocusNowhere && this.ifFocusedOnUppyRecently)) {
        this.superFocus(this.el, this.getPluginState().activeOverlayType);
      } else {
        this.superFocus.cancel();
      }
    };

    this.afterUpdate = () => {
      if (this.opts.disabled && !this.dashboardIsDisabled) {
        this.disableAllFocusableElements(true);
        return;
      }

      if (!this.opts.disabled && this.dashboardIsDisabled) {
        this.disableAllFocusableElements(false);
      }

      this.superFocusOnEachUpdate();
    };

    this.saveFileCard = (meta, fileID) => {
      this.uppy.setFileMeta(fileID, meta);
      this.toggleFileCard(false, fileID);
    };

    Object.defineProperty(this, _attachRenderFunctionToTarget, {
      writable: true,
      value: target => {
        const plugin = this.uppy.getPlugin(target.id);
        return { ...target,
          icon: plugin.icon || this.opts.defaultPickerIcon,
          render: plugin.render
        };
      }
    });
    Object.defineProperty(this, _isTargetSupported, {
      writable: true,
      value: target => {
        const plugin = this.uppy.getPlugin(target.id); // If the plugin does not provide a `supported` check, assume the plugin works everywhere.

        if (typeof plugin.isSupported !== 'function') {
          return true;
        }

        return plugin.isSupported();
      }
    });
    Object.defineProperty(this, _getAcquirers, {
      writable: true,
      value: memoize(targets => {
        return targets.filter(target => target.type === 'acquirer' && _classPrivateFieldLooseBase(this, _isTargetSupported)[_isTargetSupported](target)).map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
      })
    });
    Object.defineProperty(this, _getProgressIndicators, {
      writable: true,
      value: memoize(targets => {
        return targets.filter(target => target.type === 'progressindicator').map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
      })
    });
    Object.defineProperty(this, _getEditors, {
      writable: true,
      value: memoize(targets => {
        return targets.filter(target => target.type === 'editor').map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
      })
    });

    this.render = state => {
      const pluginState = this.getPluginState();
      const {
        files,
        capabilities,
        allowNewUpload
      } = state;
      const {
        newFiles,
        uploadStartedFiles,
        completeFiles,
        erroredFiles,
        inProgressFiles,
        inProgressNotPausedFiles,
        processingFiles,
        isUploadStarted,
        isAllComplete,
        isAllErrored,
        isAllPaused
      } = this.uppy.getObjectOfFilesPerState();

      const acquirers = _classPrivateFieldLooseBase(this, _getAcquirers)[_getAcquirers](pluginState.targets);

      const progressindicators = _classPrivateFieldLooseBase(this, _getProgressIndicators)[_getProgressIndicators](pluginState.targets);

      const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](pluginState.targets);

      let theme;

      if (this.opts.theme === 'auto') {
        theme = capabilities.darkMode ? 'dark' : 'light';
      } else {
        theme = this.opts.theme;
      }

      if (['files', 'folders', 'both'].indexOf(this.opts.fileManagerSelectionType) < 0) {
        this.opts.fileManagerSelectionType = 'files'; // eslint-disable-next-line no-console

        console.warn(`Unsupported option for "fileManagerSelectionType". Using default of "${this.opts.fileManagerSelectionType}".`);
      }

      return DashboardUI({
        state,
        isHidden: pluginState.isHidden,
        files,
        newFiles,
        uploadStartedFiles,
        completeFiles,
        erroredFiles,
        inProgressFiles,
        inProgressNotPausedFiles,
        processingFiles,
        isUploadStarted,
        isAllComplete,
        isAllErrored,
        isAllPaused,
        totalFileCount: Object.keys(files).length,
        totalProgress: state.totalProgress,
        allowNewUpload,
        acquirers,
        theme,
        disabled: this.opts.disabled,
        disableLocalFiles: this.opts.disableLocalFiles,
        direction: this.opts.direction,
        activePickerPanel: pluginState.activePickerPanel,
        showFileEditor: pluginState.showFileEditor,
        saveFileEditor: this.saveFileEditor,
        disableAllFocusableElements: this.disableAllFocusableElements,
        animateOpenClose: this.opts.animateOpenClose,
        isClosing: pluginState.isClosing,
        progressindicators,
        editors,
        autoProceed: this.uppy.opts.autoProceed,
        id: this.id,
        closeModal: this.requestCloseModal,
        handleClickOutside: this.handleClickOutside,
        handleInputChange: this.handleInputChange,
        handlePaste: this.handlePaste,
        inline: this.opts.inline,
        showPanel: this.showPanel,
        hideAllPanels: this.hideAllPanels,
        i18n: this.i18n,
        i18nArray: this.i18nArray,
        uppy: this.uppy,
        note: this.opts.note,
        recoveredState: state.recoveredState,
        metaFields: pluginState.metaFields,
        resumableUploads: capabilities.resumableUploads || false,
        individualCancellation: capabilities.individualCancellation,
        isMobileDevice: capabilities.isMobileDevice,
        fileCardFor: pluginState.fileCardFor,
        toggleFileCard: this.toggleFileCard,
        toggleAddFilesPanel: this.toggleAddFilesPanel,
        showAddFilesPanel: pluginState.showAddFilesPanel,
        saveFileCard: this.saveFileCard,
        openFileEditor: this.openFileEditor,
        canEditFile: this.canEditFile,
        width: this.opts.width,
        height: this.opts.height,
        showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult,
        fileManagerSelectionType: this.opts.fileManagerSelectionType,
        proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy,
        hideCancelButton: this.opts.hideCancelButton,
        hideRetryButton: this.opts.hideRetryButton,
        hidePauseResumeButton: this.opts.hidePauseResumeButton,
        showRemoveButtonAfterComplete: this.opts.showRemoveButtonAfterComplete,
        containerWidth: pluginState.containerWidth,
        containerHeight: pluginState.containerHeight,
        areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
        isTargetDOMEl: this.isTargetDOMEl,
        parentElement: this.el,
        allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes,
        maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles,
        requiredMetaFields: this.uppy.opts.restrictions.requiredMetaFields,
        showSelectedFiles: this.opts.showSelectedFiles,
        handleCancelRestore: this.handleCancelRestore,
        handleRequestThumbnail: this.handleRequestThumbnail,
        handleCancelThumbnail: this.handleCancelThumbnail,
        // drag props
        isDraggingOver: pluginState.isDraggingOver,
        handleDragOver: this.handleDragOver,
        handleDragLeave: this.handleDragLeave,
        handleDrop: this.handleDrop
      });
    };

    this.discoverProviderPlugins = () => {
      this.uppy.iteratePlugins(plugin => {
        if (plugin && !plugin.target && plugin.opts && plugin.opts.target === this.constructor) {
          this.addTarget(plugin);
        }
      });
    };

    this.install = () => {
      // Set default state for Dashboard
      this.setPluginState({
        isHidden: true,
        fileCardFor: null,
        activeOverlayType: null,
        showAddFilesPanel: false,
        activePickerPanel: false,
        showFileEditor: false,
        metaFields: this.opts.metaFields,
        targets: [],
        // We'll make them visible once .containerWidth is determined
        areInsidesReadyToBeVisible: false,
        isDraggingOver: false
      });
      const {
        inline,
        closeAfterFinish
      } = this.opts;

      if (inline && closeAfterFinish) {
        throw new Error('[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.');
      }

      const {
        allowMultipleUploads,
        allowMultipleUploadBatches
      } = this.uppy.opts;

      if ((allowMultipleUploads || allowMultipleUploadBatches) && closeAfterFinish) {
        this.uppy.log('[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploadBatches` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true', 'warning');
      }

      const {
        target
      } = this.opts;

      if (target) {
        this.mount(target, this);
      }

      const plugins = this.opts.plugins || [];
      plugins.forEach(pluginID => {
        const plugin = this.uppy.getPlugin(pluginID);

        if (plugin) {
          plugin.mount(this, plugin);
        }
      });

      if (!this.opts.disableStatusBar) {
        this.uppy.use(StatusBar, {
          id: `${this.id}:StatusBar`,
          target: this,
          hideUploadButton: this.opts.hideUploadButton,
          hideRetryButton: this.opts.hideRetryButton,
          hidePauseResumeButton: this.opts.hidePauseResumeButton,
          hideCancelButton: this.opts.hideCancelButton,
          showProgressDetails: this.opts.showProgressDetails,
          hideAfterFinish: this.opts.hideProgressAfterFinish,
          locale: this.opts.locale,
          doneButtonHandler: this.opts.doneButtonHandler
        });
      }

      if (!this.opts.disableInformer) {
        this.uppy.use(Informer, {
          id: `${this.id}:Informer`,
          target: this
        });
      }

      if (!this.opts.disableThumbnailGenerator) {
        this.uppy.use(ThumbnailGenerator, {
          id: `${this.id}:ThumbnailGenerator`,
          thumbnailWidth: this.opts.thumbnailWidth,
          thumbnailType: this.opts.thumbnailType,
          waitForThumbnailsBeforeUpload: this.opts.waitForThumbnailsBeforeUpload,
          // If we don't block on thumbnails, we can lazily generate them
          lazy: !this.opts.waitForThumbnailsBeforeUpload
        });
      } // Dark Mode / theme


      this.darkModeMediaQuery = typeof window !== 'undefined' && window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
      const isDarkModeOnFromTheStart = this.darkModeMediaQuery ? this.darkModeMediaQuery.matches : false;
      this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnFromTheStart ? 'on' : 'off'}`);
      this.setDarkModeCapability(isDarkModeOnFromTheStart);

      if (this.opts.theme === 'auto') {
        this.darkModeMediaQuery.addListener(this.handleSystemDarkModeChange);
      }

      this.discoverProviderPlugins();
      this.initEvents();
    };

    this.uninstall = () => {
      if (!this.opts.disableInformer) {
        const informer = this.uppy.getPlugin(`${this.id}:Informer`); // Checking if this plugin exists, in case it was removed by uppy-core
        // before the Dashboard was.

        if (informer) this.uppy.removePlugin(informer);
      }

      if (!this.opts.disableStatusBar) {
        const statusBar = this.uppy.getPlugin(`${this.id}:StatusBar`);
        if (statusBar) this.uppy.removePlugin(statusBar);
      }

      if (!this.opts.disableThumbnailGenerator) {
        const thumbnail = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`);
        if (thumbnail) this.uppy.removePlugin(thumbnail);
      }

      const plugins = this.opts.plugins || [];
      plugins.forEach(pluginID => {
        const plugin = this.uppy.getPlugin(pluginID);
        if (plugin) plugin.unmount();
      });

      if (this.opts.theme === 'auto') {
        this.darkModeMediaQuery.removeListener(this.handleSystemDarkModeChange);
      }

      this.unmount();
      this.removeEvents();
    };

    this.id = this.opts.id || 'Dashboard';
    this.title = 'Dashboard';
    this.type = 'orchestrator';
    this.modalName = `uppy-Dashboard-${nanoid()}`;
    this.defaultLocale = locale; // set default options

    const defaultOptions = {
      target: 'body',
      metaFields: [],
      trigger: null,
      inline: false,
      width: 750,
      height: 550,
      thumbnailWidth: 280,
      thumbnailType: 'image/jpeg',
      waitForThumbnailsBeforeUpload: false,
      defaultPickerIcon,
      showLinkToFileUploadResult: false,
      showProgressDetails: false,
      hideUploadButton: false,
      hideCancelButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideProgressAfterFinish: false,
      doneButtonHandler: () => {
        this.uppy.reset();
        this.requestCloseModal();
      },
      note: null,
      closeModalOnClickOutside: false,
      closeAfterFinish: false,
      disableStatusBar: false,
      disableInformer: false,
      disableThumbnailGenerator: false,
      disablePageScrollWhenModalOpen: true,
      animateOpenClose: true,
      fileManagerSelectionType: 'files',
      proudlyDisplayPoweredByUppy: true,
      onRequestCloseModal: () => this.closeModal(),
      showSelectedFiles: true,
      showRemoveButtonAfterComplete: false,
      browserBackButtonClose: false,
      theme: 'light',
      autoOpenFileEditor: false,
      disabled: false,
      disableLocalFiles: false
    }; // merge default options with the ones set by user

    this.opts = { ...defaultOptions,
      ..._opts
    };
    this.i18nInit();
    this.superFocus = createSuperFocus();
    this.ifFocusedOnUppyRecently = false; // Timeouts

    this.makeDashboardInsidesVisibleAnywayTimeout = null;
    this.removeDragOverClassTimeout = null;
  }

  onMount() {
    // Set the text direction if the page has not defined one.
    const element = this.el;
    const direction = getTextDirection(element);

    if (!direction) {
      element.dir = 'ltr';
    }
  }

}), _class.VERSION = "2.1.1", _temp);

},{"./../../core":48,"./../../informer":94,"./../../status-bar":133,"./../../thumbnail-generator":136,"./../../utils/lib/FOCUSABLE_ELEMENTS":145,"./../../utils/lib/findAllDOMElements":153,"./../../utils/lib/getDroppedFiles":157,"./../../utils/lib/getTextDirection":167,"./../../utils/lib/toArray":180,"./components/Dashboard":54,"./locale":70,"./utils/createSuperFocus":72,"./utils/trapFocus":76,"memoize-one":12,"nanoid":16,"preact":18}],70:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    // When `inline: false`, used as the screen reader label for the button that closes the modal.
    closeModal: 'Close Modal',
    // Used as the screen reader label for the plus (+) button that shows the Add more files screen
    addMoreFiles: 'Add more files',
    addingMoreFiles: 'Adding more files',
    // Used as the header for import panels, e.g., Import from Google Drive.
    importFrom: 'Import from %{name}',
    // When `inline: false`, used as the screen reader label for the dashboard modal.
    dashboardWindowTitle: 'Uppy Dashboard Window (Press escape to close)',
    // When `inline: true`, used as the screen reader label for the dashboard area.
    dashboardTitle: 'Uppy Dashboard',
    // Shown in the Informer when a link to a file was copied to the clipboard.
    copyLinkToClipboardSuccess: 'Link copied to clipboard.',
    // Used when a link cannot be copied automatically  the user has to select the text from the
    // input element below this string.
    copyLinkToClipboardFallback: 'Copy the URL below',
    // Used as the hover title and screen reader label for buttons that copy a file link.
    copyLink: 'Copy link',
    back: 'Back',
    // Used as the screen reader label for buttons that remove a file.
    removeFile: 'Remove file',
    // Used as the screen reader label for buttons that open the metadata editor panel for a file.
    editFile: 'Edit file',
    // Shown in the panel header for the metadata editor. Rendered as Editing image.png.
    editing: 'Editing %{file}',
    // Used as the screen reader label for the button that saves metadata edits and returns to the
    // file list view.
    finishEditingFile: 'Finish editing file',
    saveChanges: 'Save changes',
    // Used as the label for the tab button that opens the system file selection dialog.
    myDevice: 'My Device',
    dropHint: 'Drop your files here',
    // Used as the hover text and screen reader label for file progress indicators when
    // they have been fully uploaded.
    uploadComplete: 'Upload complete',
    uploadPaused: 'Upload paused',
    // Used as the hover text and screen reader label for the buttons to resume paused uploads.
    resumeUpload: 'Resume upload',
    // Used as the hover text and screen reader label for the buttons to pause uploads.
    pauseUpload: 'Pause upload',
    // Used as the hover text and screen reader label for the buttons to retry failed uploads.
    retryUpload: 'Retry upload',
    // Used as the hover text and screen reader label for the buttons to cancel uploads.
    cancelUpload: 'Cancel upload',
    // Used in a title, how many files are currently selected
    xFilesSelected: {
      0: '%{smart_count} file selected',
      1: '%{smart_count} files selected'
    },
    uploadingXFiles: {
      0: 'Uploading %{smart_count} file',
      1: 'Uploading %{smart_count} files'
    },
    processingXFiles: {
      0: 'Processing %{smart_count} file',
      1: 'Processing %{smart_count} files'
    },
    // The "powered by Uppy" link at the bottom of the Dashboard.
    poweredBy: 'Powered by %{uppy}',
    addMore: 'Add more',
    editFileWithFilename: 'Edit file %{file}',
    save: 'Save',
    cancel: 'Cancel',
    dropPasteFiles: 'Drop files here or %{browseFiles}',
    dropPasteFolders: 'Drop files here or %{browseFolders}',
    dropPasteBoth: 'Drop files here, %{browseFiles} or %{browseFolders}',
    dropPasteImportFiles: 'Drop files here, %{browseFiles} or import from:',
    dropPasteImportFolders: 'Drop files here, %{browseFolders} or import from:',
    dropPasteImportBoth: 'Drop files here, %{browseFiles}, %{browseFolders} or import from:',
    importFiles: 'Import files from:',
    browseFiles: 'browse files',
    browseFolders: 'browse folders',
    recoveredXFiles: {
      0: 'We could not fully recover 1 file. Please re-select it and resume the upload.',
      1: 'We could not fully recover %{smart_count} files. Please re-select them and resume the upload.'
    },
    recoveredAllFiles: 'We restored all files. You can now resume the upload.',
    sessionRestored: 'Session restored',
    reSelect: 'Re-select',
    missingRequiredMetaFields: {
      0: 'Missing required meta field: %{fields}.',
      1: 'Missing required meta fields: %{fields}.'
    }
  }
};

},{}],71:[function(require,module,exports){
"use strict";

/**
 * Copies text to clipboard by creating an almost invisible textarea,
 * adding text there, then running execCommand('copy').
 * Falls back to prompt() when the easy way fails (hello, Safari!)
 * From http://stackoverflow.com/a/30810322
 *
 * @param {string} textToCopy
 * @param {string} fallbackString
 * @returns {Promise}
 */
module.exports = function copyToClipboard(textToCopy, fallbackString) {
  fallbackString = fallbackString || 'Copy the URL below';
  return new Promise(resolve => {
    const textArea = document.createElement('textarea');
    textArea.setAttribute('style', {
      position: 'fixed',
      top: 0,
      left: 0,
      width: '2em',
      height: '2em',
      padding: 0,
      border: 'none',
      outline: 'none',
      boxShadow: 'none',
      background: 'transparent'
    });
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();

    const magicCopyFailed = () => {
      document.body.removeChild(textArea); // eslint-disable-next-line no-alert

      window.prompt(fallbackString, textToCopy);
      resolve();
    };

    try {
      const successful = document.execCommand('copy');

      if (!successful) {
        return magicCopyFailed('copy command unavailable');
      }

      document.body.removeChild(textArea);
      return resolve();
    } catch (err) {
      document.body.removeChild(textArea);
      return magicCopyFailed(err);
    }
  });
};

},{}],72:[function(require,module,exports){
"use strict";

const debounce = require('lodash.debounce');

const FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

const getActiveOverlayEl = require('./getActiveOverlayEl');
/*
  Focuses on some element in the currently topmost overlay.

  1. If there are some [data-uppy-super-focusable] elements rendered already - focuses
     on the first superfocusable element, and leaves focus up to the control of
     a user (until currently focused element disappears from the screen [which
     can happen when overlay changes, or, e.g., when we click on a folder in googledrive]).
  2. If there are no [data-uppy-super-focusable] elements yet (or ever) - focuses
     on the first focusable element, but switches focus if superfocusable elements appear on next render.
*/


module.exports = function createSuperFocus() {
  let lastFocusWasOnSuperFocusableEl = false;

  const superFocus = (dashboardEl, activeOverlayType) => {
    const overlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
    const isFocusInOverlay = overlayEl.contains(document.activeElement); // If focus is already in the topmost overlay, AND on last update we focused on the superfocusable
    // element - then leave focus up to the user.
    // [Practical check] without this line, typing in the search input in googledrive overlay won't work.

    if (isFocusInOverlay && lastFocusWasOnSuperFocusableEl) return;
    const superFocusableEl = overlayEl.querySelector('[data-uppy-super-focusable]'); // If we are already in the topmost overlay, AND there are no super focusable elements yet, - leave focus up to the user.
    // [Practical check] without this line, if you are in an empty folder in google drive, and something's uploading in the
    // bg, - focus will be jumping to Done all the time.

    if (isFocusInOverlay && !superFocusableEl) return;

    if (superFocusableEl) {
      superFocusableEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = true;
    } else {
      const firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS);
      firstEl == null ? void 0 : firstEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = false;
    }
  }; // ___Why do we need to debounce?
  //    1. To deal with animations: overlay changes via animations, which results in the DOM updating AFTER plugin.update()
  //       already executed.
  //    [Practical check] without debounce, if we open the Url overlay, and click 'Done', Dashboard won't get focused again.
  //    [Practical check] if we delay 250ms instead of 260ms - IE11 won't get focused in same situation.
  //    2. Performance: there can be many state update()s in a second, and this function is called every time.


  return debounce(superFocus, 260);
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":145,"./getActiveOverlayEl":73,"lodash.debounce":10}],73:[function(require,module,exports){
"use strict";

/**
 * @returns {HTMLElement} - either dashboard element, or the overlay that's most on top
 */
module.exports = function getActiveOverlayEl(dashboardEl, activeOverlayType) {
  if (activeOverlayType) {
    const overlayEl = dashboardEl.querySelector(`[data-uppy-paneltype="${activeOverlayType}"]`); // if an overlay is already mounted

    if (overlayEl) return overlayEl;
  }

  return dashboardEl;
};

},{}],74:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

function iconImage() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#686DE0",
    fillRule: "evenodd"
  }, h("path", {
    d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z",
    fillRule: "nonzero"
  }), h("path", {
    d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z",
    fillRule: "nonzero"
  }), h("circle", {
    cx: "7.5",
    cy: "9.5",
    r: "1.5"
  })));
}

function iconAudio() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
    fill: "#049BCF",
    fillRule: "nonzero"
  }));
}

function iconVideo() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
    fill: "#19AF67",
    fillRule: "nonzero"
  }));
}

function iconPDF() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
    fill: "#E2514A",
    fillRule: "nonzero"
  }));
}

function iconArchive() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z",
    fill: "#00C469",
    fillRule: "nonzero"
  }));
}

function iconFile() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#A7AFB7",
    fillRule: "nonzero"
  }, h("path", {
    d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
  }), h("path", {
    d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
  })));
}

function iconText() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
    fill: "#5A5E69",
    fillRule: "nonzero"
  }));
}

module.exports = function getIconByMime(fileType) {
  const defaultChoice = {
    color: '#838999',
    icon: iconFile()
  };
  if (!fileType) return defaultChoice;
  const fileTypeGeneral = fileType.split('/')[0];
  const fileTypeSpecific = fileType.split('/')[1]; // Text

  if (fileTypeGeneral === 'text') {
    return {
      color: '#5a5e69',
      icon: iconText()
    };
  } // Image


  if (fileTypeGeneral === 'image') {
    return {
      color: '#686de0',
      icon: iconImage()
    };
  } // Audio


  if (fileTypeGeneral === 'audio') {
    return {
      color: '#068dbb',
      icon: iconAudio()
    };
  } // Video


  if (fileTypeGeneral === 'video') {
    return {
      color: '#19af67',
      icon: iconVideo()
    };
  } // PDF


  if (fileTypeGeneral === 'application' && fileTypeSpecific === 'pdf') {
    return {
      color: '#e25149',
      icon: iconPDF()
    };
  } // Archive


  const archiveTypes = ['zip', 'x-7z-compressed', 'x-rar-compressed', 'x-tar', 'x-gzip', 'x-apple-diskimage'];

  if (fileTypeGeneral === 'application' && archiveTypes.indexOf(fileTypeSpecific) !== -1) {
    return {
      color: '#00C469',
      icon: iconArchive()
    };
  }

  return defaultChoice;
};

},{"preact":18}],75:[function(require,module,exports){
"use strict";

// ignore drop/paste events if they are not in input or textarea 
// otherwise when Url plugin adds drop/paste listeners to this.el,
// draging UI elements or pasting anything into any field triggers those events 
// Url treats them as URLs that need to be imported
function ignoreEvent(ev) {
  const {
    tagName
  } = ev.target;

  if (tagName === 'INPUT' || tagName === 'TEXTAREA') {
    ev.stopPropagation();
    return;
  }

  ev.preventDefault();
  ev.stopPropagation();
}

module.exports = ignoreEvent;

},{}],76:[function(require,module,exports){
"use strict";

const toArray = require('./../../../utils/lib/toArray');

const FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

const getActiveOverlayEl = require('./getActiveOverlayEl');

function focusOnFirstNode(event, nodes) {
  const node = nodes[0];

  if (node) {
    node.focus();
    event.preventDefault();
  }
}

function focusOnLastNode(event, nodes) {
  const node = nodes[nodes.length - 1];

  if (node) {
    node.focus();
    event.preventDefault();
  }
} // ___Why not just use (focusedItemIndex === -1)?
//    Firefox thinks <ul> is focusable, but we don't have <ul>s in our FOCUSABLE_ELEMENTS. Which means that if we tab into
//    the <ul>, code will think that we are not in the active overlay, and we should focusOnFirstNode() of the currently
//    active overlay!
//    [Practical check] if we use (focusedItemIndex === -1), instagram provider in firefox will never get focus on its pics
//    in the <ul>.


function isFocusInOverlay(activeOverlayEl) {
  return activeOverlayEl.contains(document.activeElement);
}

function trapFocus(event, activeOverlayType, dashboardEl) {
  const activeOverlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
  const focusableNodes = toArray(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS));
  const focusedItemIndex = focusableNodes.indexOf(document.activeElement); // If we pressed tab, and focus is not yet within the current overlay - focus on
  // the first element within the current overlay.
  // This is a safety measure (for when user returns from another tab e.g.), most
  // plugins will try to focus on some important element as it loads.

  if (!isFocusInOverlay(activeOverlayEl)) {
    focusOnFirstNode(event, focusableNodes); // If we pressed shift + tab, and we're on the first element of a modal
  } else if (event.shiftKey && focusedItemIndex === 0) {
    focusOnLastNode(event, focusableNodes); // If we pressed tab, and we're on the last element of the modal
  } else if (!event.shiftKey && focusedItemIndex === focusableNodes.length - 1) {
    focusOnFirstNode(event, focusableNodes);
  }
}

module.exports = {
  // Traps focus inside of the currently open overlay (e.g. Dashboard, or e.g. Instagram),
  // never lets focus disappear from the modal.
  forModal: (event, activeOverlayType, dashboardEl) => {
    trapFocus(event, activeOverlayType, dashboardEl);
  },
  // Traps focus inside of the currently open overlay, unless overlay is null - then let the user tab away.
  forInline: (event, activeOverlayType, dashboardEl) => {
    // ___When we're in the bare 'Drop files here, paste, browse or import from' screen
    if (activeOverlayType === null) {// Do nothing and let the browser handle it, user can tab away from Uppy to other elements on the page
      // ___When there is some overlay with 'Done' button
    } else {
      // Trap the focus inside this overlay!
      // User can close the overlay (click 'Done') if they want to travel away from Uppy.
      trapFocus(event, activeOverlayType, dashboardEl);
    }
  }
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":145,"./../../../utils/lib/toArray":180,"./getActiveOverlayEl":73}],77:[function(require,module,exports){
"use strict";

var _class, _temp;

const BasePlugin = require('./../../core/lib/BasePlugin');

const getDroppedFiles = require('./../../utils/lib/getDroppedFiles');

const toArray = require('./../../utils/lib/toArray');
/**
 * Drop Target plugin
 *
 */


module.exports = (_temp = _class = class DropTarget extends BasePlugin {
  constructor(uppy, opts) {
    super(uppy, opts);

    this.addFiles = files => {
      const descriptors = files.map(file => ({
        source: this.id,
        name: file.name,
        type: file.type,
        data: file,
        meta: {
          // path of the file relative to the ancestor directory the user selected.
          // e.g. 'docs/Old Prague/airbnb.pdf'
          relativePath: file.relativePath || null
        }
      }));

      try {
        this.uppy.addFiles(descriptors);
      } catch (err) {
        this.uppy.log(err);
      }
    };

    this.handleDrop = async event => {
      var _this$opts$onDrop, _this$opts;

      event.preventDefault();
      event.stopPropagation();
      clearTimeout(this.removeDragOverClassTimeout); // Remove dragover class

      event.currentTarget.classList.remove('uppy-is-drag-over');
      this.setPluginState({
        isDraggingOver: false
      }); // Let any acquirer plugin (Url/Webcam/etc.) handle drops to the root

      this.uppy.iteratePlugins(plugin => {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootDrop(event)
          plugin.handleRootDrop == null ? void 0 : plugin.handleRootDrop(event);
        }
      }); // Add all dropped files, handle errors

      let executedDropErrorOnce = false;

      const logDropError = error => {
        this.uppy.log(error, 'error'); // In practice all drop errors are most likely the same,
        // so let's just show one to avoid overwhelming the user

        if (!executedDropErrorOnce) {
          this.uppy.info(error.message, 'error');
          executedDropErrorOnce = true;
        }
      };

      const files = await getDroppedFiles(event.dataTransfer, {
        logDropError
      });

      if (files.length > 0) {
        this.uppy.log('[DropTarget] Files were dropped');
        this.addFiles(files);
      }

      (_this$opts$onDrop = (_this$opts = this.opts).onDrop) == null ? void 0 : _this$opts$onDrop.call(_this$opts, event);
    };

    this.handleDragOver = event => {
      var _this$opts$onDragOver, _this$opts2;

      event.preventDefault();
      event.stopPropagation(); // Add a small (+) icon on drop
      // (and prevent browsers from interpreting this as files being _moved_ into the browser,
      // https://github.com/transloadit/uppy/issues/1978)

      event.dataTransfer.dropEffect = 'copy';
      clearTimeout(this.removeDragOverClassTimeout);
      event.currentTarget.classList.add('uppy-is-drag-over');
      this.setPluginState({
        isDraggingOver: true
      });
      (_this$opts$onDragOver = (_this$opts2 = this.opts).onDragOver) == null ? void 0 : _this$opts$onDragOver.call(_this$opts2, event);
    };

    this.handleDragLeave = event => {
      var _this$opts$onDragLeav, _this$opts3;

      event.preventDefault();
      event.stopPropagation();
      const {
        currentTarget
      } = event;
      clearTimeout(this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library.
      // Solution with 'pointer-events: none' didn't work across browsers.

      this.removeDragOverClassTimeout = setTimeout(() => {
        currentTarget.classList.remove('uppy-is-drag-over');
        this.setPluginState({
          isDraggingOver: false
        });
      }, 50);
      (_this$opts$onDragLeav = (_this$opts3 = this.opts).onDragLeave) == null ? void 0 : _this$opts$onDragLeav.call(_this$opts3, event);
    };

    this.addListeners = () => {
      const {
        target
      } = this.opts;

      if (target instanceof Element) {
        this.nodes = [target];
      } else if (typeof target === 'string') {
        this.nodes = toArray(document.querySelectorAll(target));
      }

      if (!this.nodes && !this.nodes.length > 0) {
        throw new Error(`"${target}" does not match any HTML elements`);
      }

      this.nodes.forEach(node => {
        node.addEventListener('dragover', this.handleDragOver, false);
        node.addEventListener('dragleave', this.handleDragLeave, false);
        node.addEventListener('drop', this.handleDrop, false);
      });
    };

    this.removeListeners = () => {
      if (this.nodes) {
        this.nodes.forEach(node => {
          node.removeEventListener('dragover', this.handleDragOver, false);
          node.removeEventListener('dragleave', this.handleDragLeave, false);
          node.removeEventListener('drop', this.handleDrop, false);
        });
      }
    };

    this.type = 'acquirer';
    this.id = this.opts.id || 'DropTarget';
    this.title = 'Drop Target'; // Default options

    const defaultOpts = {
      target: null
    }; // Merge default options with the ones set by user

    this.opts = { ...defaultOpts,
      ...opts
    };
    this.removeDragOverClassTimeout = null;
  }

  install() {
    this.setPluginState({
      isDraggingOver: false
    });
    this.addListeners();
  }

  uninstall() {
    this.removeListeners();
  }

}, _class.VERSION = "1.1.1", _temp);

},{"./../../core/lib/BasePlugin":44,"./../../utils/lib/getDroppedFiles":157,"./../../utils/lib/toArray":180}],78:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const {
  Provider
} = require('./../../companion-client');

const {
  ProviderViews
} = require('./../../provider-views');

const {
  h
} = require('preact');

const locale = require('./locale');

module.exports = (_temp = _class = class Dropbox extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.id = this.opts.id || 'Dropbox';
    Provider.initPlugin(this, opts);
    this.title = this.opts.title || 'Dropbox';

    this.icon = () => h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, h("g", {
      fill: "none",
      fillRule: "evenodd"
    }, h("rect", {
      className: "uppy-ProviderIconBg",
      fill: "#0D2481",
      width: "32",
      height: "32",
      rx: "16"
    }), h("path", {
      d: "M11 8l5 3.185-5 3.186-5-3.186L11 8zm10 0l5 3.185-5 3.186-5-3.186L21 8zM6 17.556l5-3.185 5 3.185-5 3.186-5-3.186zm15-3.185l5 3.185-5 3.186-5-3.186 5-3.185zm-10 7.432l5-3.185 5 3.185-5 3.186-5-3.186z",
      fill: "#FFF",
      fillRule: "nonzero"
    })));

    this.provider = new Provider(uppy, {
      companionUrl: this.opts.companionUrl,
      companionHeaders: this.opts.companionHeaders,
      companionKeysParams: this.opts.companionKeysParams,
      companionCookiesRule: this.opts.companionCookiesRule,
      provider: 'dropbox',
      pluginId: this.id
    });
    this.defaultLocale = locale;
    this.i18nInit();
    this.title = this.i18n('pluginNameDropbox');
    this.onFirstRender = this.onFirstRender.bind(this);
    this.render = this.render.bind(this);
  }

  install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.view.tearDown();
    this.unmount();
  }

  onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  }

  render(state) {
    return this.view.render(state);
  }

}, _class.VERSION = "2.0.4", _temp);

},{"./../../companion-client":42,"./../../core":48,"./../../provider-views":120,"./locale":79,"preact":18}],79:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    pluginNameDropbox: 'Dropbox'
  }
};

},{}],80:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const {
  Provider
} = require('./../../companion-client');

const {
  ProviderViews
} = require('./../../provider-views');

const {
  h
} = require('preact');

const locale = require('./locale.js');

module.exports = (_temp = _class = class Facebook extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.id = this.opts.id || 'Facebook';
    Provider.initPlugin(this, opts);
    this.title = this.opts.title || 'Facebook';

    this.icon = () => h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, h("g", {
      fill: "none",
      fillRule: "evenodd"
    }, h("rect", {
      className: "uppy-ProviderIconBg",
      width: "32",
      height: "32",
      rx: "16",
      fill: "#3C5A99"
    }), h("path", {
      d: "M17.842 26v-8.667h2.653l.398-3.377h-3.051v-2.157c0-.978.248-1.644 1.527-1.644H21V7.132A19.914 19.914 0 0 0 18.623 7c-2.352 0-3.963 1.574-3.963 4.465v2.49H12v3.378h2.66V26h3.182z",
      fill: "#FFF",
      fillRule: "nonzero"
    })));

    this.provider = new Provider(uppy, {
      companionUrl: this.opts.companionUrl,
      companionHeaders: this.opts.companionHeaders,
      companionKeysParams: this.opts.companionKeysParams,
      companionCookiesRule: this.opts.companionCookiesRule,
      provider: 'facebook',
      pluginId: this.id
    });
    this.defaultLocale = locale;
    this.i18nInit();
    this.title = this.i18n('pluginNameFacebook');
    this.onFirstRender = this.onFirstRender.bind(this);
    this.render = this.render.bind(this);
  }

  install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.view.tearDown();
    this.unmount();
  }

  onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  }

  render(state) {
    const viewOptions = {};

    if (this.getPluginState().files.length && !this.getPluginState().folders.length) {
      viewOptions.viewType = 'grid';
      viewOptions.showFilter = false;
      viewOptions.showTitles = false;
    }

    return this.view.render(state, viewOptions);
  }

}, _class.VERSION = "2.0.4", _temp);

},{"./../../companion-client":42,"./../../core":48,"./../../provider-views":120,"./locale.js":81,"preact":18}],81:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    pluginNameFacebook: 'Facebook'
  }
};

},{}],82:[function(require,module,exports){
"use strict";

const indexedDB = typeof window !== 'undefined' && (window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB);
const isSupported = !!indexedDB;
const DB_NAME = 'uppy-blobs';
const STORE_NAME = 'files'; // maybe have a thumbnail store in the future

const DEFAULT_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

const DB_VERSION = 3; // Set default `expires` dates on existing stored blobs.

function migrateExpiration(store) {
  const request = store.openCursor();

  request.onsuccess = event => {
    const cursor = event.target.result;

    if (!cursor) {
      return;
    }

    const entry = cursor.value;
    entry.expires = Date.now() + DEFAULT_EXPIRY;
    cursor.update(entry);
  };
}

function connect(dbName) {
  const request = indexedDB.open(dbName, DB_VERSION);
  return new Promise((resolve, reject) => {
    request.onupgradeneeded = event => {
      const db = event.target.result;
      const {
        transaction
      } = event.currentTarget;

      if (event.oldVersion < 2) {
        // Added in v2: DB structure changed to a single shared object store
        const store = db.createObjectStore(STORE_NAME, {
          keyPath: 'id'
        });
        store.createIndex('store', 'store', {
          unique: false
        });
      }

      if (event.oldVersion < 3) {
        // Added in v3
        const store = transaction.objectStore(STORE_NAME);
        store.createIndex('expires', 'expires', {
          unique: false
        });
        migrateExpiration(store);
      }

      transaction.oncomplete = () => {
        resolve(db);
      };
    };

    request.onsuccess = event => {
      resolve(event.target.result);
    };

    request.onerror = reject;
  });
}

function waitForRequest(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = event => {
      resolve(event.target.result);
    };

    request.onerror = reject;
  });
}

let cleanedUp = false;

class IndexedDBStore {
  constructor(opts) {
    this.opts = {
      dbName: DB_NAME,
      storeName: 'default',
      expires: DEFAULT_EXPIRY,
      // 24 hours
      maxFileSize: 10 * 1024 * 1024,
      // 10 MB
      maxTotalSize: 300 * 1024 * 1024,
      // 300 MB
      ...opts
    };
    this.name = this.opts.storeName;

    const createConnection = () => {
      return connect(this.opts.dbName);
    };

    if (!cleanedUp) {
      cleanedUp = true;
      this.ready = IndexedDBStore.cleanup().then(createConnection, createConnection);
    } else {
      this.ready = createConnection();
    }
  }

  key(fileID) {
    return `${this.name}!${fileID}`;
  }
  /**
   * List all file blobs currently in the store.
   */


  list() {
    return this.ready.then(db => {
      const transaction = db.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.index('store').getAll(IDBKeyRange.only(this.name));
      return waitForRequest(request);
    }).then(files => {
      const result = {};
      files.forEach(file => {
        result[file.fileID] = file.data;
      });
      return result;
    });
  }
  /**
   * Get one file blob from the store.
   */


  get(fileID) {
    return this.ready.then(db => {
      const transaction = db.transaction([STORE_NAME], 'readonly');
      const request = transaction.objectStore(STORE_NAME).get(this.key(fileID));
      return waitForRequest(request);
    }).then(result => ({
      id: result.data.fileID,
      data: result.data.data
    }));
  }
  /**
   * Get the total size of all stored files.
   *
   * @private
   */


  getSize() {
    return this.ready.then(db => {
      const transaction = db.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.index('store').openCursor(IDBKeyRange.only(this.name));
      return new Promise((resolve, reject) => {
        let size = 0;

        request.onsuccess = event => {
          const cursor = event.target.result;

          if (cursor) {
            size += cursor.value.data.size;
            cursor.continue();
          } else {
            resolve(size);
          }
        };

        request.onerror = () => {
          reject(new Error('Could not retrieve stored blobs size'));
        };
      });
    });
  }
  /**
   * Save a file in the store.
   */


  put(file) {
    if (file.data.size > this.opts.maxFileSize) {
      return Promise.reject(new Error('File is too big to store.'));
    }

    return this.getSize().then(size => {
      if (size > this.opts.maxTotalSize) {
        return Promise.reject(new Error('No space left'));
      }

      return this.ready;
    }).then(db => {
      const transaction = db.transaction([STORE_NAME], 'readwrite');
      const request = transaction.objectStore(STORE_NAME).add({
        id: this.key(file.id),
        fileID: file.id,
        store: this.name,
        expires: Date.now() + this.opts.expires,
        data: file.data
      });
      return waitForRequest(request);
    });
  }
  /**
   * Delete a file blob from the store.
   */


  delete(fileID) {
    return this.ready.then(db => {
      const transaction = db.transaction([STORE_NAME], 'readwrite');
      const request = transaction.objectStore(STORE_NAME).delete(this.key(fileID));
      return waitForRequest(request);
    });
  }
  /**
   * Delete all stored blobs that have an expiry date that is before Date.now().
   * This is a static method because it deletes expired blobs from _all_ Uppy instances.
   */


  static cleanup() {
    return connect(DB_NAME).then(db => {
      const transaction = db.transaction([STORE_NAME], 'readwrite');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.index('expires').openCursor(IDBKeyRange.upperBound(Date.now()));
      return new Promise((resolve, reject) => {
        request.onsuccess = event => {
          const cursor = event.target.result;

          if (cursor) {
            cursor.delete(); // Ignoring return value  it's not terrible if this goes wrong.

            cursor.continue();
          } else {
            resolve(db);
          }
        };

        request.onerror = reject;
      });
    }).then(db => {
      db.close();
    });
  }

}

IndexedDBStore.isSupported = isSupported;
module.exports = IndexedDBStore;

},{}],83:[function(require,module,exports){
"use strict";

/**
 * Get uppy instance IDs for which state is stored.
 */
function findUppyInstances() {
  const instances = [];

  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);

    if (/^uppyState:/.test(key)) {
      instances.push(key.slice('uppyState:'.length));
    }
  }

  return instances;
}
/**
 * Try to JSON-parse a string, return null on failure.
 */


function maybeParse(str) {
  try {
    return JSON.parse(str);
  } catch (err) {
    return null;
  }
}

let cleanedUp = false;
module.exports = class MetaDataStore {
  constructor(opts) {
    this.opts = {
      expires: 24 * 60 * 60 * 1000,
      // 24 hours
      ...opts
    };
    this.name = `uppyState:${opts.storeName}`;

    if (!cleanedUp) {
      cleanedUp = true;
      MetaDataStore.cleanup();
    }
  }
  /**
   *
   */


  load() {
    const savedState = localStorage.getItem(this.name);
    if (!savedState) return null;
    const data = maybeParse(savedState);
    if (!data) return null; // Upgrade pre-0.20.0 uppyState: it used to be just a flat object,
    // without `expires`.

    if (!data.metadata) {
      this.save(data);
      return data;
    }

    return data.metadata;
  }

  save(metadata) {
    const expires = Date.now() + this.opts.expires;
    const state = JSON.stringify({
      metadata,
      expires
    });
    localStorage.setItem(this.name, state);
  }
  /**
   * Remove all expired state.
   */


  static cleanup(instanceID) {
    if (instanceID) {
      localStorage.removeItem(`uppyState:${instanceID}`);
      return;
    }

    const instanceIDs = findUppyInstances();
    const now = Date.now();
    instanceIDs.forEach(id => {
      const data = localStorage.getItem(`uppyState:${id}`);
      if (!data) return null;
      const obj = maybeParse(data);
      if (!obj) return null;

      if (obj.expires && obj.expires < now) {
        localStorage.removeItem(`uppyState:${id}`);
      }
    });
  }

};

},{}],84:[function(require,module,exports){
"use strict";

/*eslint-disable */
const isSupported = typeof navigator !== 'undefined' && 'serviceWorker' in navigator;

function waitForServiceWorker() {
  return new Promise((resolve, reject) => {
    if (!isSupported) {
      reject(new Error('Unsupported'));
    } else if (navigator.serviceWorker.controller) {
      // A serviceWorker is already registered and active.
      resolve();
    } else {
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        resolve();
      });
    }
  });
}

class ServiceWorkerStore {
  constructor(opts) {
    this.ready = waitForServiceWorker();
    this.name = opts.storeName;
  }

  list() {
    const defer = {};
    const promise = new Promise((resolve, reject) => {
      defer.resolve = resolve;
      defer.reject = reject;
    });
    console.log('Loading stored blobs from Service Worker');

    const onMessage = event => {
      if (event.data.store !== this.name) {
        return;
      }

      switch (event.data.type) {
        case 'uppy/ALL_FILES':
          defer.resolve(event.data.files);
          navigator.serviceWorker.removeEventListener('message', onMessage);
          break;

        default:
          defer.reject();
      }
    };

    this.ready.then(() => {
      navigator.serviceWorker.addEventListener('message', onMessage);
      navigator.serviceWorker.controller.postMessage({
        type: 'uppy/GET_FILES',
        store: this.name
      });
    });
    return promise;
  }

  put(file) {
    return this.ready.then(() => {
      navigator.serviceWorker.controller.postMessage({
        type: 'uppy/ADD_FILE',
        store: this.name,
        file: file
      });
    });
  }

  delete(fileID) {
    return this.ready.then(() => {
      navigator.serviceWorker.controller.postMessage({
        type: 'uppy/REMOVE_FILE',
        store: this.name,
        fileID: fileID
      });
    });
  }

}

ServiceWorkerStore.isSupported = isSupported;
module.exports = ServiceWorkerStore;

},{}],85:[function(require,module,exports){
"use strict";

var _class, _temp;

const throttle = require('lodash.throttle');

const BasePlugin = require('./../../core/lib/BasePlugin');

const ServiceWorkerStore = require('./ServiceWorkerStore');

const IndexedDBStore = require('./IndexedDBStore');

const MetaDataStore = require('./MetaDataStore');
/**
 * The GoldenRetriever plugin  restores selected files and resumes uploads
 * after a closed tab or a browser crash!
 *
 * Uses localStorage, IndexedDB and ServiceWorker to do its magic, read more:
 * https://uppy.io/blog/2017/07/golden-retriever/
 */


module.exports = (_temp = _class = class GoldenRetriever extends BasePlugin {
  constructor(uppy, opts) {
    super(uppy, opts);

    this.addBlobToStores = file => {
      if (file.isRemote) return;

      if (this.ServiceWorkerStore) {
        this.ServiceWorkerStore.put(file).catch(err => {
          this.uppy.log('[GoldenRetriever] Could not store file', 'warning');
          this.uppy.log(err);
        });
      }

      this.IndexedDBStore.put(file).catch(err => {
        this.uppy.log('[GoldenRetriever] Could not store file', 'warning');
        this.uppy.log(err);
      });
    };

    this.removeBlobFromStores = file => {
      if (this.ServiceWorkerStore) {
        this.ServiceWorkerStore.delete(file.id).catch(err => {
          this.uppy.log('[GoldenRetriever] Failed to remove file', 'warning');
          this.uppy.log(err);
        });
      }

      this.IndexedDBStore.delete(file.id).catch(err => {
        this.uppy.log('[GoldenRetriever] Failed to remove file', 'warning');
        this.uppy.log(err);
      });
    };

    this.replaceBlobInStores = file => {
      this.removeBlobFromStores(file);
      this.addBlobToStores(file);
    };

    this.handleRestoreConfirmed = () => {
      this.uppy.log('[GoldenRetriever] Restore confirmed, proceeding...'); // start all uploads again when file blobs are restored

      const {
        currentUploads
      } = this.uppy.getState();

      if (currentUploads) {
        Object.keys(currentUploads).forEach(uploadId => {
          this.uppy.restore(uploadId, currentUploads[uploadId]);
        });
        this.uppy.resumeAll();
      }

      this.uppy.upload();
      this.uppy.setState({
        recoveredState: null
      });
    };

    this.abortRestore = () => {
      this.uppy.log('[GoldenRetriever] Aborting restore...');
      const fileIDs = Object.keys(this.uppy.getState().files);
      this.deleteBlobs(fileIDs).then(() => {
        this.uppy.log(`[GoldenRetriever] Removed ${fileIDs.length} files`);
      }).catch(err => {
        this.uppy.log(`[GoldenRetriever] Could not remove ${fileIDs.length} files`, 'warning');
        this.uppy.log(err);
      });
      this.uppy.cancelAll();
      this.uppy.setState({
        recoveredState: null
      });
      MetaDataStore.cleanup(this.uppy.opts.id);
    };

    this.handleComplete = ({
      successful
    }) => {
      const fileIDs = successful.map(file => file.id);
      this.deleteBlobs(fileIDs).then(() => {
        this.uppy.log(`[GoldenRetriever] Removed ${successful.length} files that finished uploading`);
      }).catch(err => {
        this.uppy.log(`[GoldenRetriever] Could not remove ${successful.length} files that finished uploading`, 'warning');
        this.uppy.log(err);
      });
      this.uppy.setState({
        recoveredState: null
      });
      MetaDataStore.cleanup(this.uppy.opts.id);
    };

    this.restoreBlobs = () => {
      if (this.uppy.getFiles().length > 0) {
        Promise.all([this.loadFileBlobsFromServiceWorker(), this.loadFileBlobsFromIndexedDB()]).then(resultingArrayOfObjects => {
          const blobs = { ...resultingArrayOfObjects[0],
            ...resultingArrayOfObjects[1]
          };
          this.onBlobsLoaded(blobs);
        });
      } else {
        this.uppy.log('[GoldenRetriever] No files need to be loaded, only restoring processing state...');
        this.onBlobsLoaded([]);
      }
    };

    this.type = 'debugger';
    this.id = this.opts.id || 'GoldenRetriever';
    this.title = 'Golden Retriever';
    const defaultOptions = {
      expires: 24 * 60 * 60 * 1000,
      // 24 hours
      serviceWorker: false
    };
    this.opts = { ...defaultOptions,
      ...opts
    };
    this.MetaDataStore = new MetaDataStore({
      expires: this.opts.expires,
      storeName: uppy.getID()
    });
    this.ServiceWorkerStore = null;

    if (this.opts.serviceWorker) {
      this.ServiceWorkerStore = new ServiceWorkerStore({
        storeName: uppy.getID()
      });
    }

    this.IndexedDBStore = new IndexedDBStore({
      expires: this.opts.expires,
      ...(this.opts.indexedDB || {}),
      storeName: uppy.getID()
    });
    this.saveFilesStateToLocalStorage = throttle(this.saveFilesStateToLocalStorage.bind(this), 500, {
      leading: true,
      trailing: true
    });
    this.restoreState = this.restoreState.bind(this);
    this.loadFileBlobsFromServiceWorker = this.loadFileBlobsFromServiceWorker.bind(this);
    this.loadFileBlobsFromIndexedDB = this.loadFileBlobsFromIndexedDB.bind(this);
    this.onBlobsLoaded = this.onBlobsLoaded.bind(this);
  }

  restoreState() {
    const savedState = this.MetaDataStore.load();

    if (savedState) {
      this.uppy.log('[GoldenRetriever] Recovered some state from Local Storage');
      this.uppy.setState({
        currentUploads: savedState.currentUploads || {},
        files: savedState.files || {},
        recoveredState: savedState
      });
      this.savedPluginData = savedState.pluginData;
    }
  }
  /**
   * Get file objects that are currently waiting: they've been selected,
   * but aren't yet being uploaded.
   */


  getWaitingFiles() {
    const waitingFiles = {};
    this.uppy.getFiles().forEach(file => {
      if (!file.progress || !file.progress.uploadStarted) {
        waitingFiles[file.id] = file;
      }
    });
    return waitingFiles;
  }
  /**
   * Get file objects that are currently being uploaded. If a file has finished
   * uploading, but the other files in the same batch have not, the finished
   * file is also returned.
   */


  getUploadingFiles() {
    const uploadingFiles = {};
    const {
      currentUploads
    } = this.uppy.getState();

    if (currentUploads) {
      const uploadIDs = Object.keys(currentUploads);
      uploadIDs.forEach(uploadID => {
        const filesInUpload = currentUploads[uploadID].fileIDs;
        filesInUpload.forEach(fileID => {
          uploadingFiles[fileID] = this.uppy.getFile(fileID);
        });
      });
    }

    return uploadingFiles;
  }

  saveFilesStateToLocalStorage() {
    const filesToSave = { ...this.getWaitingFiles(),
      ...this.getUploadingFiles()
    }; // If all files have been removed by the user, clear recovery state

    if (Object.keys(filesToSave).length === 0) {
      this.uppy.setState({
        recoveredState: null
      });
      MetaDataStore.cleanup(this.uppy.opts.id);
      return;
    } // We dontt need to store file.data on local files, because the actual blob will be restored later,
    // and we want to avoid having weird properties in the serialized object.
    // Also adding file.isRestored to all files, since they will be restored from local storage


    const filesToSaveWithoutData = {};
    Object.keys(filesToSave).forEach(file => {
      if (filesToSave[file].isRemote) {
        filesToSaveWithoutData[file] = { ...filesToSave[file],
          isRestored: true
        };
      } else {
        filesToSaveWithoutData[file] = { ...filesToSave[file],
          isRestored: true,
          data: null,
          preview: null
        };
      }
    });
    const pluginData = {}; // TODO Find a better way to do this?
    // Other plugins can attach a restore:get-data listener that receives this callback.
    // Plugins can then use this callback (sync) to provide data to be stored.

    this.uppy.emit('restore:get-data', data => {
      Object.assign(pluginData, data);
    });
    const {
      currentUploads
    } = this.uppy.getState();
    this.MetaDataStore.save({
      currentUploads,
      files: filesToSaveWithoutData,
      pluginData
    });
  }

  loadFileBlobsFromServiceWorker() {
    if (!this.ServiceWorkerStore) {
      return Promise.resolve({});
    }

    return this.ServiceWorkerStore.list().then(blobs => {
      const files = this.uppy.getFiles();
      const localFilesOnly = files.filter(file => {
        // maybe && !file.progress.uploadComplete
        return !file.isRemote;
      });
      const numberOfFilesRecovered = Object.keys(blobs).length;
      const numberOfFilesTryingToRecover = localFilesOnly.length;

      if (numberOfFilesRecovered === numberOfFilesTryingToRecover) {
        this.uppy.log(`[GoldenRetriever] Successfully recovered ${numberOfFilesRecovered} blobs from Service Worker!`);
        return blobs;
      }

      this.uppy.log('[GoldenRetriever] No blobs found in Service Worker, trying IndexedDB now...');
      return {};
    }).catch(err => {
      this.uppy.log('[GoldenRetriever] Failed to recover blobs from Service Worker', 'warning');
      this.uppy.log(err);
      return {};
    });
  }

  loadFileBlobsFromIndexedDB() {
    return this.IndexedDBStore.list().then(blobs => {
      const numberOfFilesRecovered = Object.keys(blobs).length;

      if (numberOfFilesRecovered > 0) {
        this.uppy.log(`[GoldenRetriever] Successfully recovered ${numberOfFilesRecovered} blobs from IndexedDB!`);
        return blobs;
      }

      this.uppy.log('[GoldenRetriever] No blobs found in IndexedDB');
      return {};
    }).catch(err => {
      this.uppy.log('[GoldenRetriever] Failed to recover blobs from IndexedDB', 'warning');
      this.uppy.log(err);
      return {};
    });
  }

  onBlobsLoaded(blobs) {
    const obsoleteBlobs = [];
    const updatedFiles = { ...this.uppy.getState().files
    }; // Loop through blobs that we can restore, add blobs to file objects

    Object.keys(blobs).forEach(fileID => {
      const originalFile = this.uppy.getFile(fileID);

      if (!originalFile) {
        obsoleteBlobs.push(fileID);
        return;
      }

      const cachedData = blobs[fileID];
      const updatedFileData = {
        data: cachedData,
        isRestored: true,
        isGhost: false
      };
      updatedFiles[fileID] = { ...originalFile,
        ...updatedFileData
      };
    }); // Loop through files that we cant restore fully  we only have meta, not blobs,
    // set .isGhost on them, also set isRestored to all files

    Object.keys(updatedFiles).forEach(fileID => {
      if (updatedFiles[fileID].data === null) {
        updatedFiles[fileID] = { ...updatedFiles[fileID],
          isGhost: true
        };
      }
    });
    this.uppy.setState({
      files: updatedFiles
    });
    this.uppy.emit('restored', this.savedPluginData);

    if (obsoleteBlobs.length) {
      this.deleteBlobs(obsoleteBlobs).then(() => {
        this.uppy.log(`[GoldenRetriever] Cleaned up ${obsoleteBlobs.length} old files`);
      }).catch(err => {
        this.uppy.log(`[GoldenRetriever] Could not clean up ${obsoleteBlobs.length} old files`, 'warning');
        this.uppy.log(err);
      });
    }
  }

  deleteBlobs(fileIDs) {
    const promises = [];
    fileIDs.forEach(id => {
      if (this.ServiceWorkerStore) {
        promises.push(this.ServiceWorkerStore.delete(id));
      }

      if (this.IndexedDBStore) {
        promises.push(this.IndexedDBStore.delete(id));
      }
    });
    return Promise.all(promises);
  }

  install() {
    this.restoreState();
    this.restoreBlobs();
    this.uppy.on('file-added', this.addBlobToStores);
    this.uppy.on('file-editor:complete', this.replaceBlobInStores);
    this.uppy.on('file-removed', this.removeBlobFromStores);
    this.uppy.on('state-update', this.saveFilesStateToLocalStorage);
    this.uppy.on('restore-confirmed', this.handleRestoreConfirmed);
    this.uppy.on('restore-canceled', this.abortRestore);
    this.uppy.on('complete', this.handleComplete);
  }

  uninstall() {
    this.uppy.off('file-added', this.addBlobToStores);
    this.uppy.off('file-editor:complete', this.replaceBlobInStores);
    this.uppy.off('file-removed', this.removeBlobFromStores);
    this.uppy.off('state-update', this.saveFilesStateToLocalStorage);
    this.uppy.off('restore-confirmed', this.handleRestoreConfirmed);
    this.uppy.off('restore-canceled', this.abortRestore);
    this.uppy.off('complete', this.handleComplete);
  }

}, _class.VERSION = "2.0.5", _temp);

},{"./../../core/lib/BasePlugin":44,"./IndexedDBStore":82,"./MetaDataStore":83,"./ServiceWorkerStore":84,"lodash.throttle":11}],86:[function(require,module,exports){
"use strict";

const {
  ProviderViews
} = require('./../../provider-views');

module.exports = class DriveProviderViews extends ProviderViews {
  toggleCheckbox(e, file) {
    e.stopPropagation();
    e.preventDefault(); // Shared Drives aren't selectable; for all else, defer to the base ProviderView.

    if (!file.custom.isSharedDrive) {
      super.toggleCheckbox(e, file);
    }
  }

};

},{"./../../provider-views":120}],87:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const {
  Provider
} = require('./../../companion-client');

const {
  h
} = require('preact');

const DriveProviderViews = require('./DriveProviderViews');

const locale = require('./locale');

module.exports = (_temp = _class = class GoogleDrive extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.id = this.opts.id || 'GoogleDrive';
    this.title = this.opts.title || 'Google Drive';
    Provider.initPlugin(this, opts);
    this.title = this.opts.title || 'Google Drive';

    this.icon = () => h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, h("g", {
      fill: "none",
      fillRule: "evenodd"
    }, h("rect", {
      className: "uppy-ProviderIconBg",
      fill: "#4285F4",
      width: "32",
      height: "32",
      rx: "16"
    }), h("path", {
      d: "M25.216 17.736L19.043 7h-6.086l6.175 10.736h6.084zm-11.275.896L10.9 24h11.723l3.04-5.368H13.942zm-1.789-10.29l-5.816 10.29L9.38 24l5.905-10.29-3.132-5.369z",
      fill: "#FFF"
    })));

    this.provider = new Provider(uppy, {
      companionUrl: this.opts.companionUrl,
      companionHeaders: this.opts.companionHeaders,
      companionKeysParams: this.opts.companionKeysParams,
      companionCookiesRule: this.opts.companionCookiesRule,
      provider: 'drive',
      pluginId: this.id
    });
    this.defaultLocale = locale;
    this.i18nInit();
    this.title = this.i18n('pluginNameGoogleDrive');
    this.onFirstRender = this.onFirstRender.bind(this);
    this.render = this.render.bind(this);
  }

  install() {
    this.view = new DriveProviderViews(this, {
      provider: this.provider
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.view.tearDown();
    this.unmount();
  }

  onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder('root', '/')]);
  }

  render(state) {
    return this.view.render(state);
  }

}, _class.VERSION = "2.0.4", _temp);

},{"./../../companion-client":42,"./../../core":48,"./DriveProviderViews":86,"./locale":88,"preact":18}],88:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    pluginNameGoogleDrive: 'Google Drive'
  }
};

},{}],89:[function(require,module,exports){
"use strict";

const CropperImport = require('cropperjs');

const {
  h,
  Component
} = require('preact'); // @TODO A silly hack that we can get rid of when moving to ESM.
// eslint-disable-next-line no-underscore-dangle


const Cropper = CropperImport.__esModule ? CropperImport.default : CropperImport;
module.exports = class Editor extends Component {
  constructor(props) {
    super(props);

    this.save = () => {
      const {
        opts,
        save,
        currentImage
      } = this.props;
      this.cropper.getCroppedCanvas(opts.cropperOptions.croppedCanvasOptions).toBlob(blob => save(blob), currentImage.type, opts.quality);
    };

    this.granularRotateOnChange = ev => {
      const {
        rotationAngle,
        rotationDelta
      } = this.state;
      const pendingRotationDelta = Number(ev.target.value) - rotationDelta;
      cancelAnimationFrame(this.granularRotateOnInputNextFrame);

      if (pendingRotationDelta !== 0) {
        const pendingRotationAngle = rotationAngle + pendingRotationDelta;
        this.granularRotateOnInputNextFrame = requestAnimationFrame(() => {
          this.cropper.rotateTo(pendingRotationAngle);
        });
      }
    };

    this.state = {
      rotationAngle: 0,
      rotationDelta: 0
    };
  }

  componentDidMount() {
    const {
      opts,
      storeCropperInstance
    } = this.props;
    this.cropper = new Cropper(this.imgElement, opts.cropperOptions);
    storeCropperInstance(this.cropper);

    if (opts.actions.granularRotate) {
      this.imgElement.addEventListener('crop', ev => {
        const rotationAngle = ev.detail.rotate;
        this.setState({
          rotationAngle,
          // 405 == 360 + 45
          rotationDelta: (rotationAngle + 405) % 90 - 45
        });
      });
    }
  }

  componentWillUnmount() {
    this.cropper.destroy();
  }

  renderGranularRotate() {
    const {
      i18n
    } = this.props;
    const {
      rotationDelta,
      rotationAngle
    } = this.state;
    return (// eslint-disable-next-line jsx-a11y/label-has-associated-control
      h("label", {
        "data-microtip-position": "top",
        role: "tooltip",
        "aria-label": `${rotationAngle}`,
        className: "uppy-ImageCropper-rangeWrapper uppy-u-reset"
      }, h("input", {
        className: "uppy-ImageCropper-range uppy-u-reset",
        type: "range",
        onInput: this.granularRotateOnChange,
        onChange: this.granularRotateOnChange,
        value: rotationDelta,
        min: "-45",
        max: "44",
        "aria-label": i18n('rotate')
      }))
    );
  }

  renderRevert() {
    const {
      i18n
    } = this.props;
    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": i18n('revert'),
      "data-microtip-position": "top",
      onClick: () => {
        this.cropper.reset();
        this.cropper.setAspectRatio(0);
      }
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), h("path", {
      d: "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"
    })));
  }

  renderRotate() {
    const {
      i18n
    } = this.props;
    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      onClick: () => this.cropper.rotate(-90),
      "aria-label": i18n('rotate'),
      "data-microtip-position": "top"
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0V0zm0 0h24v24H0V0z",
      fill: "none"
    }), h("path", {
      d: "M14 10a2 2 0 012 2v7a2 2 0 01-2 2H6a2 2 0 01-2-2v-7a2 2 0 012-2h8zm0 1.75H6a.25.25 0 00-.243.193L5.75 12v7a.25.25 0 00.193.243L6 19.25h8a.25.25 0 00.243-.193L14.25 19v-7a.25.25 0 00-.193-.243L14 11.75zM12 .76V4c2.3 0 4.61.88 6.36 2.64a8.95 8.95 0 012.634 6.025L21 13a1 1 0 01-1.993.117L19 13h-.003a6.979 6.979 0 00-2.047-4.95 6.97 6.97 0 00-4.652-2.044L12 6v3.24L7.76 5 12 .76z"
    })));
  }

  renderFlip() {
    const {
      i18n
    } = this.props;
    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": i18n('flipHorizontal'),
      "data-microtip-position": "top",
      onClick: () => this.cropper.scaleX(-this.cropper.getData().scaleX || -1)
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), h("path", {
      d: "M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"
    })));
  }

  renderZoomIn() {
    const {
      i18n
    } = this.props;
    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": i18n('zoomIn'),
      "data-microtip-position": "top",
      onClick: () => this.cropper.zoom(0.1)
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24"
    }, h("path", {
      d: "M0 0h24v24H0V0z",
      fill: "none"
    }), h("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
    }), h("path", {
      d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"
    })));
  }

  renderZoomOut() {
    const {
      i18n
    } = this.props;
    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": i18n('zoomOut'),
      "data-microtip-position": "top",
      onClick: () => this.cropper.zoom(-0.1)
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0V0z",
      fill: "none"
    }), h("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"
    })));
  }

  renderCropSquare() {
    const {
      i18n
    } = this.props;
    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": i18n('aspectRatioSquare'),
      "data-microtip-position": "top",
      onClick: () => this.cropper.setAspectRatio(1)
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), h("path", {
      d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
    })));
  }

  renderCropWidescreen() {
    const {
      i18n
    } = this.props;
    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": i18n('aspectRatioLandscape'),
      "data-microtip-position": "top",
      onClick: () => this.cropper.setAspectRatio(16 / 9)
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M 19,4.9999992 V 17.000001 H 4.9999998 V 6.9999992 H 19 m 0,-2 H 4.9999998 c -1.0999999,0 -1.9999999,0.9000001 -1.9999999,2 V 17.000001 c 0,1.1 0.9,2 1.9999999,2 H 19 c 1.1,0 2,-0.9 2,-2 V 6.9999992 c 0,-1.0999999 -0.9,-2 -2,-2 z"
    }), h("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    })));
  }

  renderCropWidescreenVertical() {
    const {
      i18n
    } = this.props;
    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": i18n('aspectRatioPortrait'),
      "data-microtip-position": "top",
      onClick: () => this.cropper.setAspectRatio(9 / 16)
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M 19.000001,19 H 6.999999 V 5 h 10.000002 v 14 m 2,0 V 5 c 0,-1.0999999 -0.9,-1.9999999 -2,-1.9999999 H 6.999999 c -1.1,0 -2,0.9 -2,1.9999999 v 14 c 0,1.1 0.9,2 2,2 h 10.000002 c 1.1,0 2,-0.9 2,-2 z"
    }), h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    })));
  }

  render() {
    const {
      currentImage,
      opts
    } = this.props;
    const {
      actions
    } = opts;
    const imageURL = URL.createObjectURL(currentImage.data);
    return h("div", {
      className: "uppy-ImageCropper"
    }, h("div", {
      className: "uppy-ImageCropper-container"
    }, h("img", {
      className: "uppy-ImageCropper-image",
      alt: currentImage.name,
      src: imageURL,
      ref: ref => {
        this.imgElement = ref;
      }
    })), h("div", {
      className: "uppy-ImageCropper-controls"
    }, actions.revert && this.renderRevert(), actions.rotate && this.renderRotate(), actions.granularRotate && this.renderGranularRotate(), actions.flip && this.renderFlip(), actions.zoomIn && this.renderZoomIn(), actions.zoomOut && this.renderZoomOut(), actions.cropSquare && this.renderCropSquare(), actions.cropWidescreen && this.renderCropWidescreen(), actions.cropWidescreenVertical && this.renderCropWidescreenVertical()));
  }

};

},{"cropperjs":5,"preact":18}],90:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const {
  h
} = require('preact');

const Editor = require('./Editor');

const locale = require('./locale.js');

module.exports = (_temp = _class = class ImageEditor extends UIPlugin {
  // eslint-disable-next-line global-require
  constructor(uppy, opts) {
    super(uppy, opts);

    this.save = () => {
      const saveBlobCallback = blob => {
        const {
          currentImage
        } = this.getPluginState();
        this.uppy.setFileState(currentImage.id, {
          data: blob,
          size: blob.size,
          preview: null
        });
        const updatedFile = this.uppy.getFile(currentImage.id);
        this.uppy.emit('thumbnail:request', updatedFile);
        this.setPluginState({
          currentImage: updatedFile
        });
        this.uppy.emit('file-editor:complete', updatedFile);
      };

      const {
        currentImage
      } = this.getPluginState();
      this.cropper.getCroppedCanvas().toBlob(saveBlobCallback, currentImage.type, this.opts.quality);
    };

    this.storeCropperInstance = cropper => {
      this.cropper = cropper;
    };

    this.selectFile = file => {
      this.uppy.emit('file-editor:start', file);
      this.setPluginState({
        currentImage: file
      });
    };

    this.id = this.opts.id || 'ImageEditor';
    this.title = 'Image Editor';
    this.type = 'editor';
    this.defaultLocale = locale;
    const defaultCropperOptions = {
      viewMode: 1,
      background: false,
      autoCropArea: 1,
      responsive: true,
      croppedCanvasOptions: {}
    };
    const defaultActions = {
      revert: true,
      rotate: true,
      granularRotate: true,
      flip: true,
      zoomIn: true,
      zoomOut: true,
      cropSquare: true,
      cropWidescreen: true,
      cropWidescreenVertical: true
    };
    const defaultOptions = {
      quality: 0.8
    };
    this.opts = { ...defaultOptions,
      ...opts,
      actions: { ...defaultActions,
        ...opts.actions
      },
      cropperOptions: { ...defaultCropperOptions,
        ...opts.cropperOptions
      }
    };
    this.i18nInit();
  } // eslint-disable-next-line class-methods-use-this


  canEditFile(file) {
    if (!file.type || file.isRemote) {
      return false;
    }

    const fileTypeSpecific = file.type.split('/')[1];

    if (/^(jpe?g|gif|png|bmp|webp)$/.test(fileTypeSpecific)) {
      return true;
    }

    return false;
  }

  install() {
    this.setPluginState({
      currentImage: null
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.unmount();
  }

  render() {
    const {
      currentImage
    } = this.getPluginState();

    if (currentImage === null || currentImage.isRemote) {
      return null;
    }

    return h(Editor, {
      currentImage: currentImage,
      storeCropperInstance: this.storeCropperInstance,
      save: this.save,
      opts: this.opts,
      i18n: this.i18n
    });
  }

}, _class.VERSION = "1.0.4", _temp);

},{"./../../core":48,"./Editor":89,"./locale.js":91,"preact":18}],91:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    revert: 'Revert',
    rotate: 'Rotate',
    zoomIn: 'Zoom in',
    zoomOut: 'Zoom out',
    flipHorizontal: 'Flip horizontal',
    aspectRatioSquare: 'Crop square',
    aspectRatioLandscape: 'Crop landscape (16:9)',
    aspectRatioPortrait: 'Crop portrait (9:16)'
  }
};

},{}],92:[function(require,module,exports){
"use strict";

const {
  h,
  Component,
  createRef
} = require('preact');

const TRANSITION_MS = 300;
module.exports = class FadeIn extends Component {
  constructor(...args) {
    super(...args);
    this.ref = createRef();
  }

  componentWillEnter(callback) {
    this.ref.current.style.opacity = '1';
    this.ref.current.style.transform = 'none';
    setTimeout(callback, TRANSITION_MS);
  }

  componentWillLeave(callback) {
    this.ref.current.style.opacity = '0';
    this.ref.current.style.transform = 'translateY(350%)';
    setTimeout(callback, TRANSITION_MS);
  }

  render() {
    const {
      children
    } = this.props;
    return h("div", {
      className: "uppy-Informer-animated",
      ref: this.ref
    }, children);
  }

};

},{"preact":18}],93:[function(require,module,exports){
/* eslint-disable */

/**
 * @source https://github.com/developit/preact-transition-group
 */
'use strict';

const {
  Component,
  cloneElement,
  h,
  toChildArray
} = require('preact');

function assign(obj, props) {
  return Object.assign(obj, props);
}

function getKey(vnode, fallback) {
  var _vnode$key;

  return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;
}

function linkRef(component, name) {
  const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});
  return cache[name] || (cache[name] = c => {
    component.refs[name] = c;
  });
}

function getChildMapping(children) {
  const out = {};

  for (let i = 0; i < children.length; i++) {
    if (children[i] != null) {
      const key = getKey(children[i], i.toString(36));
      out[key] = children[i];
    }
  }

  return out;
}

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  const getValueForKey = key => next.hasOwnProperty(key) ? next[key] : prev[key]; // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  const nextKeysPending = {};
  let pendingKeys = [];

  for (const prevKey in prev) {
    if (next.hasOwnProperty(prevKey)) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  const childMapping = {};

  for (const nextKey in next) {
    if (nextKeysPending.hasOwnProperty(nextKey)) {
      for (let i = 0; i < nextKeysPending[nextKey].length; i++) {
        const pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (let i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

const identity = i => i;

class TransitionGroup extends Component {
  constructor(props, context) {
    super(props, context);
    this.refs = {};
    this.state = {
      children: getChildMapping(toChildArray(toChildArray(this.props.children)) || [])
    };
    this.performAppear = this.performAppear.bind(this);
    this.performEnter = this.performEnter.bind(this);
    this.performLeave = this.performLeave.bind(this);
  }

  componentWillMount() {
    this.currentlyTransitioningKeys = {};
    this.keysToAbortLeave = [];
    this.keysToEnter = [];
    this.keysToLeave = [];
  }

  componentDidMount() {
    const initialChildMapping = this.state.children;

    for (const key in initialChildMapping) {
      if (initialChildMapping[key]) {
        // this.performAppear(getKey(initialChildMapping[key], key));
        this.performAppear(key);
      }
    }
  }

  componentWillReceiveProps(nextProps) {
    const nextChildMapping = getChildMapping(toChildArray(nextProps.children) || []);
    const prevChildMapping = this.state.children;
    this.setState(prevState => ({
      children: mergeChildMappings(prevState.children, nextChildMapping)
    }));
    let key;

    for (key in nextChildMapping) {
      if (nextChildMapping.hasOwnProperty(key)) {
        const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key); // We should re-enter the component and abort its leave function

        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {
          this.keysToEnter.push(key);
          this.keysToAbortLeave.push(key);
        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
          this.keysToEnter.push(key);
        }
      }
    }

    for (key in prevChildMapping) {
      if (prevChildMapping.hasOwnProperty(key)) {
        const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);

        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
          this.keysToLeave.push(key);
        }
      }
    }
  }

  componentDidUpdate() {
    const {
      keysToEnter
    } = this;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);
    const {
      keysToLeave
    } = this;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  }

  _finishAbort(key) {
    const idx = this.keysToAbortLeave.indexOf(key);

    if (idx !== -1) {
      this.keysToAbortLeave.splice(idx, 1);
    }
  }

  performAppear(key) {
    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];

    if (component.componentWillAppear) {
      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
    } else {
      this._handleDoneAppearing(key);
    }
  }

  _handleDoneAppearing(key) {
    const component = this.refs[key];

    if (component.componentDidAppear) {
      component.componentDidAppear();
    }

    delete this.currentlyTransitioningKeys[key];

    this._finishAbort(key);

    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully appeared. Remove it.
      this.performLeave(key);
    }
  }

  performEnter(key) {
    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];

    if (component.componentWillEnter) {
      component.componentWillEnter(this._handleDoneEntering.bind(this, key));
    } else {
      this._handleDoneEntering(key);
    }
  }

  _handleDoneEntering(key) {
    const component = this.refs[key];

    if (component.componentDidEnter) {
      component.componentDidEnter();
    }

    delete this.currentlyTransitioningKeys[key];

    this._finishAbort(key);

    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully entered. Remove it.
      this.performLeave(key);
    }
  }

  performLeave(key) {
    // If we should immediately abort this leave function,
    // don't run the leave transition at all.
    const idx = this.keysToAbortLeave.indexOf(key);

    if (idx !== -1) {
      return;
    }

    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];

    if (component.componentWillLeave) {
      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
    } else {
      // Note that this is somewhat dangerous b/c it calls setState()
      // again, effectively mutating the component before all the work
      // is done.
      this._handleDoneLeaving(key);
    }
  }

  _handleDoneLeaving(key) {
    // If we should immediately abort the leave,
    // then skip this altogether
    const idx = this.keysToAbortLeave.indexOf(key);

    if (idx !== -1) {
      return;
    }

    const component = this.refs[key];

    if (component.componentDidLeave) {
      component.componentDidLeave();
    }

    delete this.currentlyTransitioningKeys[key];
    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);

    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
      // This entered again before it fully left. Add it again.
      this.performEnter(key);
    } else {
      const children = assign({}, this.state.children);
      delete children[key];
      this.setState({
        children
      });
    }
  }

  render({
    childFactory,
    transitionLeave,
    transitionName,
    transitionAppear,
    transitionEnter,
    transitionLeaveTimeout,
    transitionEnterTimeout,
    transitionAppearTimeout,
    component,
    ...props
  }, {
    children
  }) {
    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    const childrenToRender = [];

    for (const key in children) {
      if (children.hasOwnProperty(key)) {
        const child = children[key];

        if (child) {
          const ref = linkRef(this, key),
                el = cloneElement(childFactory(child), {
            ref,
            key
          });
          childrenToRender.push(el);
        }
      }
    }

    return h(component, props, childrenToRender);
  }

}

TransitionGroup.defaultProps = {
  component: 'span',
  childFactory: identity
};
module.exports = TransitionGroup;

},{"preact":18}],94:[function(require,module,exports){
"use strict";

var _class, _temp;

/* eslint-disable jsx-a11y/no-noninteractive-element-interactions  */

/* eslint-disable jsx-a11y/click-events-have-key-events */
const {
  h
} = require('preact');

const {
  UIPlugin
} = require('./../../core');

const FadeIn = require('./FadeIn');

const TransitionGroup = require('./TransitionGroup');
/**
 * Informer
 * Shows rad message bubbles
 * used like this: `uppy.info('hello world', 'info', 5000)`
 * or for errors: `uppy.info('Error uploading img.jpg', 'error', 5000)`
 *
 */


module.exports = (_temp = _class = class Informer extends UIPlugin {
  // eslint-disable-next-line global-require
  constructor(uppy, opts) {
    super(uppy, opts);

    this.render = state => {
      return h("div", {
        className: "uppy uppy-Informer"
      }, h(TransitionGroup, null, state.info.map(info => h(FadeIn, {
        key: info.message
      }, h("p", {
        role: "alert"
      }, info.message, ' ', info.details && h("span", {
        "aria-label": info.details,
        "data-microtip-position": "top-left",
        "data-microtip-size": "medium",
        role: "tooltip" // eslint-disable-next-line no-alert
        ,
        onClick: () => alert(`${info.message} \n\n ${info.details}`)
      }, "?"))))));
    };

    this.type = 'progressindicator';
    this.id = this.opts.id || 'Informer';
    this.title = 'Informer'; // set default options

    const defaultOptions = {}; // merge default options with the ones set by user

    this.opts = { ...defaultOptions,
      ...opts
    };
  }

  install() {
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

}, _class.VERSION = "2.0.4", _temp);

},{"./../../core":48,"./FadeIn":92,"./TransitionGroup":93,"preact":18}],95:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const {
  Provider
} = require('./../../companion-client');

const {
  ProviderViews
} = require('./../../provider-views');

const {
  h
} = require('preact');

const locale = require('./locale.js');

module.exports = (_temp = _class = class Instagram extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.id = this.opts.id || 'Instagram';
    Provider.initPlugin(this, opts);

    this.icon = () => h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, h("g", {
      fill: "none",
      fillRule: "evenodd"
    }, h("rect", {
      className: "uppy-ProviderIconBg",
      fill: "#E1306C",
      width: "32",
      height: "32",
      rx: "16"
    }), h("path", {
      d: "M16 8.622c2.403 0 2.688.009 3.637.052.877.04 1.354.187 1.67.31.392.144.745.374 1.036.673.299.29.529.644.673 1.035.123.317.27.794.31 1.671.043.95.052 1.234.052 3.637s-.009 2.688-.052 3.637c-.04.877-.187 1.354-.31 1.671a2.98 2.98 0 0 1-1.708 1.708c-.317.123-.794.27-1.671.31-.95.043-1.234.053-3.637.053s-2.688-.01-3.637-.053c-.877-.04-1.354-.187-1.671-.31a2.788 2.788 0 0 1-1.035-.673 2.788 2.788 0 0 1-.673-1.035c-.123-.317-.27-.794-.31-1.671-.043-.949-.052-1.234-.052-3.637s.009-2.688.052-3.637c.04-.877.187-1.354.31-1.67.144-.392.374-.745.673-1.036.29-.299.644-.529 1.035-.673.317-.123.794-.27 1.671-.31.95-.043 1.234-.052 3.637-.052zM16 7c-2.444 0-2.75.01-3.71.054-.959.044-1.613.196-2.185.419-.6.225-1.145.58-1.594 1.038-.458.45-.813.993-1.039 1.594-.222.572-.374 1.226-.418 2.184C7.01 13.25 7 13.556 7 16s.01 2.75.054 3.71c.044.959.196 1.613.419 2.185.226.6.58 1.145 1.038 1.594.45.458.993.813 1.594 1.038.572.223 1.227.375 2.184.419.96.044 1.267.054 3.711.054s2.75-.01 3.71-.054c.959-.044 1.613-.196 2.185-.419a4.602 4.602 0 0 0 2.632-2.632c.223-.572.375-1.226.419-2.184.044-.96.054-1.267.054-3.711s-.01-2.75-.054-3.71c-.044-.959-.196-1.613-.419-2.185A4.412 4.412 0 0 0 23.49 8.51a4.412 4.412 0 0 0-1.594-1.039c-.572-.222-1.226-.374-2.184-.418C18.75 7.01 18.444 7 16 7zm0 4.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9zm0 7.421a2.921 2.921 0 1 1 0-5.842 2.921 2.921 0 0 1 0 5.842zm4.875-6.671a1.125 1.125 0 1 1 0-2.25 1.125 1.125 0 0 1 0 2.25z",
      fill: "#FFF"
    })));

    this.defaultLocale = locale;
    this.i18nInit();
    this.title = this.i18n('pluginNameInstagram');
    this.provider = new Provider(uppy, {
      companionUrl: this.opts.companionUrl,
      companionHeaders: this.opts.companionHeaders,
      companionKeysParams: this.opts.companionKeysParams,
      companionCookiesRule: this.opts.companionCookiesRule,
      provider: 'instagram',
      pluginId: this.id
    });
    this.onFirstRender = this.onFirstRender.bind(this);
    this.render = this.render.bind(this);
  }

  install() {
    this.view = new ProviderViews(this, {
      provider: this.provider,
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.view.tearDown();
    this.unmount();
  }

  onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder('recent')]);
  }

  render(state) {
    return this.view.render(state);
  }

}, _class.VERSION = "2.0.4", _temp);

},{"./../../companion-client":42,"./../../core":48,"./../../provider-views":120,"./locale.js":96,"preact":18}],96:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    pluginNameInstagram: 'Instagram'
  }
};

},{}],97:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const {
  Provider
} = require('./../../companion-client');

const {
  ProviderViews
} = require('./../../provider-views');

const {
  h
} = require('preact');

const locale = require('./locale');

module.exports = (_temp = _class = class OneDrive extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.id = this.opts.id || 'OneDrive';
    Provider.initPlugin(this, opts);
    this.title = this.opts.title || 'OneDrive';

    this.icon = () => h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, h("g", {
      fill: "none",
      fillRule: "evenodd"
    }, h("rect", {
      className: "uppy-ProviderIconBg",
      width: "32",
      height: "32",
      rx: "16",
      fill: "#0262C0"
    }), h("g", {
      fill: "#FFF",
      fillRule: "nonzero"
    }, h("path", {
      d: "M24.157 22s1.492-.205 1.79-1.655a2.624 2.624 0 0 0 .03-.878c-.22-1.64-1.988-2.01-1.988-2.01s.307-1.765-1.312-2.69c-1.62-.925-3.1 0-3.1 0S18.711 13 16.366 13c-3.016 0-3.519 3.448-3.519 3.448S10 16.618 10 19.14c0 2.523 2.597 2.86 2.597 2.86h11.56z"
    }), h("path", {
      d: "M9.421 19.246c0-2.197 1.606-3.159 2.871-3.472.44-1.477 1.654-3.439 4.135-3.439H16.445c1.721 0 2.79.823 3.368 1.476a3.99 3.99 0 0 1 1.147-.171h.01l.03.002C21.017 13.5 20.691 10 16.757 10c-2.69 0-3.639 2.345-3.639 2.345s-1.95-1.482-3.955.567c-1.028 1.052-.79 2.669-.79 2.669S6 15.824 6 18.412C6 20.757 8.452 21 8.452 21h1.372a3.77 3.77 0 0 1-.403-1.754z"
    }))));

    this.provider = new Provider(uppy, {
      companionUrl: this.opts.companionUrl,
      companionHeaders: this.opts.companionHeaders,
      companionCookiesRule: this.opts.companionCookiesRule,
      provider: 'onedrive',
      pluginId: this.id
    });
    this.defaultLocale = locale;
    this.i18nInit();
    this.title = this.i18n('pluginNameOneDrive');
    this.onFirstRender = this.onFirstRender.bind(this);
    this.render = this.render.bind(this);
  }

  install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.view.tearDown();
    this.unmount();
  }

  onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  }

  render(state) {
    return this.view.render(state);
  }

}, _class.VERSION = "2.0.4", _temp);

},{"./../../companion-client":42,"./../../core":48,"./../../provider-views":120,"./locale":98,"preact":18}],98:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    pluginNameOneDrive: 'OneDrive'
  }
};

},{}],99:[function(require,module,exports){
"use strict";

const {
  h,
  Fragment
} = require('preact');

const Breadcrumb = props => {
  const {
    getFolder,
    title,
    isLast
  } = props;
  return h(Fragment, null, h("button", {
    type: "button",
    className: "uppy-u-reset",
    onClick: getFolder
  }, title), !isLast ? ' / ' : '');
};

module.exports = props => {
  const {
    getFolder,
    title,
    breadcrumbsIcon,
    directories
  } = props;
  return h("div", {
    className: "uppy-Provider-breadcrumbs"
  }, h("div", {
    className: "uppy-Provider-breadcrumbsIcon"
  }, breadcrumbsIcon), directories.map((directory, i) => h(Breadcrumb, {
    key: directory.id,
    getFolder: () => getFolder(directory.id),
    title: i === 0 ? title : directory.title,
    isLast: i + 1 === directories.length
  })));
};

},{"preact":18}],100:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const classNames = require('classnames');

const remoteFileObjToLocal = require('./../../utils/lib/remoteFileObjToLocal');

const Filter = require('./Filter');

const FooterActions = require('./FooterActions');

const Item = require('./Item/index');

const VIRTUAL_SHARED_DIR = 'shared-with-me';

function Browser(props) {
  const {
    currentSelection,
    folders,
    files,
    uppyFiles,
    viewType,
    headerComponent,
    showBreadcrumbs,
    isChecked,
    toggleCheckbox,
    handleScroll,
    showTitles,
    i18n,
    validateRestrictions,
    showFilter,
    filterQuery,
    filterInput,
    getNextFolder,
    cancel,
    done,
    columns
  } = props;
  const selected = currentSelection.length;
  return h("div", {
    className: classNames('uppy-ProviderBrowser', `uppy-ProviderBrowser-viewType--${viewType}`)
  }, h("div", {
    className: "uppy-ProviderBrowser-header"
  }, h("div", {
    className: classNames('uppy-ProviderBrowser-headerBar', !showBreadcrumbs && 'uppy-ProviderBrowser-headerBar--simple')
  }, headerComponent)), showFilter && h(Filter, {
    i18n: i18n,
    filterQuery: filterQuery,
    filterInput: filterInput
  }), (() => {
    if (!folders.length && !files.length) {
      return h("div", {
        className: "uppy-Provider-empty"
      }, props.i18n('noFilesFound'));
    }

    return h("div", {
      className: "uppy-ProviderBrowser-body"
    }, h("ul", {
      className: "uppy-ProviderBrowser-list",
      onScroll: handleScroll,
      role: "listbox" // making <ul> not focusable for firefox
      ,
      tabIndex: "-1"
    }, folders.map(folder => {
      var _isChecked;

      return Item({
        columns,
        showTitles,
        viewType,
        i18n,
        id: folder.id,
        title: folder.name,
        getItemIcon: () => folder.icon,
        isChecked: isChecked(folder),
        toggleCheckbox: event => toggleCheckbox(event, folder),
        type: 'folder',
        isDisabled: (_isChecked = isChecked(folder)) == null ? void 0 : _isChecked.loading,
        isCheckboxDisabled: folder.id === VIRTUAL_SHARED_DIR,
        handleFolderClick: () => getNextFolder(folder)
      });
    }), files.map(file => {
      const validated = validateRestrictions(remoteFileObjToLocal(file), [...uppyFiles, ...currentSelection]);
      return Item({
        id: file.id,
        title: file.name,
        author: file.author,
        getItemIcon: () => file.icon,
        isChecked: isChecked(file),
        toggleCheckbox: event => toggleCheckbox(event, file),
        columns,
        showTitles,
        viewType,
        i18n,
        type: 'file',
        isDisabled: !validated.result && !isChecked(file),
        restrictionReason: validated.reason
      });
    })));
  })(), selected > 0 && h(FooterActions, {
    selected: selected,
    done: done,
    cancel: cancel,
    i18n: i18n
  }));
}

module.exports = Browser;

},{"./../../utils/lib/remoteFileObjToLocal":177,"./Filter":102,"./FooterActions":103,"./Item/index":107,"classnames":4,"preact":18}],101:[function(require,module,exports){
"use strict";

const {
  Component,
  toChildArray
} = require('preact');

module.exports = class CloseWrapper extends Component {
  componentWillUnmount() {
    const {
      onUnmount
    } = this.props;
    onUnmount();
  }

  render() {
    const {
      children
    } = this.props;
    return toChildArray(children)[0];
  }

};

},{"preact":18}],102:[function(require,module,exports){
"use strict";

const {
  h,
  Component
} = require('preact');

module.exports = class Filter extends Component {
  constructor(props) {
    super(props);
    this.preventEnterPress = this.preventEnterPress.bind(this);
  }

  preventEnterPress(ev) {
    if (ev.keyCode === 13) {
      ev.stopPropagation();
      ev.preventDefault();
    }
  }

  render() {
    return h("div", {
      className: "uppy-ProviderBrowser-search"
    }, h("input", {
      className: "uppy-u-reset uppy-ProviderBrowser-searchInput",
      type: "text",
      placeholder: this.props.i18n('filter'),
      "aria-label": this.props.i18n('filter'),
      onKeyUp: this.preventEnterPress,
      onKeyDown: this.preventEnterPress,
      onKeyPress: this.preventEnterPress,
      onInput: e => this.props.filterQuery(e),
      value: this.props.filterInput
    }), h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-ProviderBrowser-searchIcon",
      width: "12",
      height: "12",
      viewBox: "0 0 12 12"
    }, h("path", {
      d: "M8.638 7.99l3.172 3.172a.492.492 0 1 1-.697.697L7.91 8.656a4.977 4.977 0 0 1-2.983.983C2.206 9.639 0 7.481 0 4.819 0 2.158 2.206 0 4.927 0c2.721 0 4.927 2.158 4.927 4.82a4.74 4.74 0 0 1-1.216 3.17zm-3.71.685c2.176 0 3.94-1.726 3.94-3.856 0-2.129-1.764-3.855-3.94-3.855C2.75.964.984 2.69.984 4.819c0 2.13 1.765 3.856 3.942 3.856z"
    })), this.props.filterInput && h("button", {
      className: "uppy-u-reset uppy-ProviderBrowser-searchClose",
      type: "button",
      "aria-label": this.props.i18n('resetFilter'),
      title: this.props.i18n('resetFilter'),
      onClick: this.props.filterQuery
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      viewBox: "0 0 19 19"
    }, h("path", {
      d: "M17.318 17.232L9.94 9.854 9.586 9.5l-.354.354-7.378 7.378h.707l-.62-.62v.706L9.318 9.94l.354-.354-.354-.354L1.94 1.854v.707l.62-.62h-.706l7.378 7.378.354.354.354-.354 7.378-7.378h-.707l.622.62v-.706L9.854 9.232l-.354.354.354.354 7.378 7.378.708-.707-7.38-7.378v.708l7.38-7.38.353-.353-.353-.353-.622-.622-.353-.353-.354.352-7.378 7.38h.708L2.56 1.23 2.208.88l-.353.353-.622.62-.353.355.352.353 7.38 7.38v-.708l-7.38 7.38-.353.353.352.353.622.622.353.353.354-.353 7.38-7.38h-.708l7.38 7.38z"
    }))));
  }

};

},{"preact":18}],103:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = props => {
  return h("div", {
    className: "uppy-ProviderBrowser-footer"
  }, h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary",
    onClick: props.done,
    type: "button"
  }, props.i18n('selectX', {
    smart_count: props.selected
  })), h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-link",
    onClick: props.cancel,
    type: "button"
  }, props.i18n('cancel')));
};

},{"preact":18}],104:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

function GridListItem(props) {
  const {
    className,
    isDisabled,
    restrictionReason,
    isChecked,
    title,
    itemIconEl,
    showTitles,
    toggleCheckbox,
    id,
    children
  } = props;
  return h("li", {
    className: className,
    title: isDisabled ? restrictionReason : null
  }, h("input", {
    type: "checkbox",
    className: `uppy-u-reset uppy-ProviderBrowserItem-checkbox ${isChecked ? 'uppy-ProviderBrowserItem-checkbox--is-checked' : ''} uppy-ProviderBrowserItem-checkbox--grid`,
    onChange: toggleCheckbox,
    name: "listitem",
    id: id,
    checked: isChecked,
    disabled: isDisabled,
    "data-uppy-super-focusable": true
  }), h("label", {
    htmlFor: id,
    "aria-label": title,
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner"
  }, h("span", {
    className: "uppy-ProviderBrowserItem-inner-relative"
  }, itemIconEl, showTitles && title, children)));
}

module.exports = GridListItem;

},{"preact":18}],105:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

function FileIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: 11,
    height: 14.5,
    viewBox: "0 0 44 58"
  }, h("path", {
    d: "M27.437.517a1 1 0 0 0-.094.03H4.25C2.037.548.217 2.368.217 4.58v48.405c0 2.212 1.82 4.03 4.03 4.03H39.03c2.21 0 4.03-1.818 4.03-4.03V15.61a1 1 0 0 0-.03-.28 1 1 0 0 0 0-.093 1 1 0 0 0-.03-.032 1 1 0 0 0 0-.03 1 1 0 0 0-.032-.063 1 1 0 0 0-.03-.063 1 1 0 0 0-.032 0 1 1 0 0 0-.03-.063 1 1 0 0 0-.032-.03 1 1 0 0 0-.03-.063 1 1 0 0 0-.063-.062l-14.593-14a1 1 0 0 0-.062-.062A1 1 0 0 0 28 .708a1 1 0 0 0-.374-.157 1 1 0 0 0-.156 0 1 1 0 0 0-.03-.03l-.003-.003zM4.25 2.547h22.218v9.97c0 2.21 1.82 4.03 4.03 4.03h10.564v36.438a2.02 2.02 0 0 1-2.032 2.032H4.25c-1.13 0-2.032-.9-2.032-2.032V4.58c0-1.13.902-2.032 2.03-2.032zm24.218 1.345l10.375 9.937.75.718H30.5c-1.13 0-2.032-.9-2.032-2.03V3.89z"
  }));
}

function FolderIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    style: {
      minWidth: 16,
      marginRight: 3
    },
    viewBox: "0 0 276.157 276.157"
  }, h("path", {
    d: "M273.08 101.378c-3.3-4.65-8.86-7.32-15.254-7.32h-24.34V67.59c0-10.2-8.3-18.5-18.5-18.5h-85.322c-3.63 0-9.295-2.875-11.436-5.805l-6.386-8.735c-4.982-6.814-15.104-11.954-23.546-11.954H58.73c-9.292 0-18.638 6.608-21.737 15.372l-2.033 5.752c-.958 2.71-4.72 5.37-7.596 5.37H18.5C8.3 49.09 0 57.39 0 67.59v167.07c0 .886.16 1.73.443 2.52.152 3.306 1.18 6.424 3.053 9.064 3.3 4.652 8.86 7.32 15.255 7.32h188.487c11.395 0 23.27-8.425 27.035-19.18l40.677-116.188c2.11-6.035 1.43-12.164-1.87-16.816zM18.5 64.088h8.864c9.295 0 18.64-6.607 21.738-15.37l2.032-5.75c.96-2.712 4.722-5.373 7.597-5.373h29.565c3.63 0 9.295 2.876 11.437 5.806l6.386 8.735c4.982 6.815 15.104 11.954 23.546 11.954h85.322c1.898 0 3.5 1.602 3.5 3.5v26.47H69.34c-11.395 0-23.27 8.423-27.035 19.178L15 191.23V67.59c0-1.898 1.603-3.5 3.5-3.5zm242.29 49.15l-40.676 116.188c-1.674 4.78-7.812 9.135-12.877 9.135H18.75c-1.447 0-2.576-.372-3.02-.997-.442-.625-.422-1.814.057-3.18l40.677-116.19c1.674-4.78 7.812-9.134 12.877-9.134h188.487c1.448 0 2.577.372 3.02.997.443.625.423 1.814-.056 3.18z"
  }));
}

function VideoIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    style: {
      width: 16,
      marginRight: 4
    },
    viewBox: "0 0 58 58"
  }, h("path", {
    d: "M36.537 28.156l-11-7a1.005 1.005 0 0 0-1.02-.033C24.2 21.3 24 21.635 24 22v14a1 1 0 0 0 1.537.844l11-7a1.002 1.002 0 0 0 0-1.688zM26 34.18V23.82L34.137 29 26 34.18z"
  }), h("path", {
    d: "M57 6H1a1 1 0 0 0-1 1v44a1 1 0 0 0 1 1h56a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM10 28H2v-9h8v9zm-8 2h8v9H2v-9zm10 10V8h34v42H12V40zm44-12h-8v-9h8v9zm-8 2h8v9h-8v-9zm8-22v9h-8V8h8zM2 8h8v9H2V8zm0 42v-9h8v9H2zm54 0h-8v-9h8v9z"
  }));
}

module.exports = props => {
  if (props.itemIconString === null) return;

  switch (props.itemIconString) {
    case 'file':
      return h(FileIcon, null);

    case 'folder':
      return h(FolderIcon, null);

    case 'video':
      return h(VideoIcon, null);

    default:
      return h("img", {
        src: props.itemIconString,
        alt: props.alt
      });
  }
};

},{"preact":18}],106:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact'); // if folder:
//   + checkbox (selects all files from folder)
//   + folder name (opens folder)
// if file:
//   + checkbox (selects file)
//   + file name (selects file)


function ListItem(props) {
  const {
    className,
    isDisabled,
    restrictionReason,
    isCheckboxDisabled,
    isChecked,
    toggleCheckbox,
    type,
    id,
    itemIconEl,
    title,
    handleFolderClick,
    showTitles,
    i18n
  } = props;
  return h("li", {
    className: className,
    title: isDisabled ? restrictionReason : null
  }, !isCheckboxDisabled ? h("input", {
    type: "checkbox",
    className: `uppy-u-reset uppy-ProviderBrowserItem-checkbox ${isChecked ? 'uppy-ProviderBrowserItem-checkbox--is-checked' : ''}`,
    onChange: toggleCheckbox // for the <label/>
    ,
    name: "listitem",
    id: id,
    checked: isChecked,
    "aria-label": type === 'file' ? null : i18n('allFilesFromFolderNamed', {
      name: title
    }),
    disabled: isDisabled,
    "data-uppy-super-focusable": true
  }) : null, type === 'file' ? // label for a checkbox
  h("label", {
    htmlFor: id,
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner"
  }, h("div", {
    className: "uppy-ProviderBrowserItem-iconWrap"
  }, itemIconEl), showTitles && title) : // button to open a folder
  h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onClick: handleFolderClick,
    "aria-label": i18n('openFolderNamed', {
      name: title
    })
  }, h("div", {
    className: "uppy-ProviderBrowserItem-iconWrap"
  }, itemIconEl), showTitles && h("span", null, title)));
}

module.exports = ListItem;

},{"preact":18}],107:[function(require,module,exports){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const {
  h
} = require('preact');

const classNames = require('classnames');

const ItemIcon = require('./components/ItemIcon');

const GridListItem = require('./components/GridLi');

const ListItem = require('./components/ListLi');

module.exports = props => {
  const {
    author
  } = props;
  const itemIconString = props.getItemIcon();
  const className = classNames('uppy-ProviderBrowserItem', {
    'uppy-ProviderBrowserItem--selected': props.isChecked
  }, {
    'uppy-ProviderBrowserItem--disabled': props.isDisabled
  }, {
    'uppy-ProviderBrowserItem--noPreview': itemIconString === 'video'
  });
  const itemIconEl = h(ItemIcon, {
    itemIconString: itemIconString
  });

  switch (props.viewType) {
    case 'grid':
      return h(GridListItem, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    case 'list':
      return h(ListItem, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    case 'unsplash':
      return h(GridListItem, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }), h("a", {
        href: `${author.url}?utm_source=Companion&utm_medium=referral`,
        target: "_blank",
        rel: "noopener noreferrer",
        className: "uppy-ProviderBrowserItem-author"
      }, author.name));

    default:
      throw new Error(`There is no such type ${props.viewType}`);
  }
};

},{"./components/GridLi":104,"./components/ItemIcon":105,"./components/ListLi":106,"classnames":4,"preact":18}],108:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = props => {
  return h("div", {
    className: "uppy-Provider-loading"
  }, h("span", null, props.i18n('loading')));
};

},{"preact":18}],109:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

function GoogleIcon() {
  return h("svg", {
    width: "26",
    height: "26",
    viewBox: "0 0 26 26",
    xmlns: "http://www.w3.org/2000/svg"
  }, h("g", {
    fill: "none",
    "fill-rule": "evenodd"
  }, h("circle", {
    fill: "#FFF",
    cx: "13",
    cy: "13",
    r: "13"
  }), h("path", {
    d: "M21.64 13.205c0-.639-.057-1.252-.164-1.841H13v3.481h4.844a4.14 4.14 0 01-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z",
    fill: "#4285F4",
    "fill-rule": "nonzero"
  }), h("path", {
    d: "M13 22c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H4.957v2.332A8.997 8.997 0 0013 22z",
    fill: "#34A853",
    "fill-rule": "nonzero"
  }), h("path", {
    d: "M7.964 14.71A5.41 5.41 0 017.682 13c0-.593.102-1.17.282-1.71V8.958H4.957A8.996 8.996 0 004 13c0 1.452.348 2.827.957 4.042l3.007-2.332z",
    fill: "#FBBC05",
    "fill-rule": "nonzero"
  }), h("path", {
    d: "M13 7.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C17.463 4.891 15.426 4 13 4a8.997 8.997 0 00-8.043 4.958l3.007 2.332C8.672 9.163 10.656 7.58 13 7.58z",
    fill: "#EA4335",
    "fill-rule": "nonzero"
  }), h("path", {
    d: "M4 4h18v18H4z"
  })));
}

function AuthView(props) {
  const {
    pluginName,
    pluginIcon,
    i18nArray,
    handleAuth
  } = props; // In order to comply with Google's brand we need to create a different button
  // for the Google Drive plugin

  const isGoogleDrive = pluginName === 'Google Drive';
  const pluginNameComponent = h("span", {
    className: "uppy-Provider-authTitleName"
  }, pluginName, h("br", null));
  return h("div", {
    className: "uppy-Provider-auth"
  }, h("div", {
    className: "uppy-Provider-authIcon"
  }, pluginIcon()), h("div", {
    className: "uppy-Provider-authTitle"
  }, i18nArray('authenticateWithTitle', {
    pluginName: pluginNameComponent
  })), isGoogleDrive ? h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn uppy-Provider-btn-google",
    onClick: handleAuth,
    "data-uppy-super-focusable": true
  }, h(GoogleIcon, null), i18nArray('signInWithGoogle')) : h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn",
    onClick: handleAuth,
    "data-uppy-super-focusable": true
  }, i18nArray('authenticateWith', {
    pluginName
  })));
}

module.exports = AuthView;

},{"preact":18}],110:[function(require,module,exports){
"use strict";

const User = require('./User');

const Breadcrumbs = require('../Breadcrumbs');

module.exports = props => {
  const components = [];

  if (props.showBreadcrumbs) {
    components.push(Breadcrumbs({
      getFolder: props.getFolder,
      directories: props.directories,
      breadcrumbsIcon: props.pluginIcon && props.pluginIcon(),
      title: props.title
    }));
  }

  components.push(User({
    logout: props.logout,
    username: props.username,
    i18n: props.i18n
  }));
  return components;
};

},{"../Breadcrumbs":99,"./User":112}],111:[function(require,module,exports){
"use strict";

var _class, _updateFilesAndFolders, _isOriginAllowed, _temp;

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const {
  h
} = require('preact');

const AuthView = require('./AuthView');

const Header = require('./Header');

const Browser = require('../Browser');

const LoaderView = require('../Loader');

const CloseWrapper = require('../CloseWrapper');

const View = require('../View');

function getOrigin() {
  // eslint-disable-next-line no-restricted-globals
  return location.origin;
}
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = (_updateFilesAndFolders = /*#__PURE__*/_classPrivateFieldLooseKey("updateFilesAndFolders"), _isOriginAllowed = /*#__PURE__*/_classPrivateFieldLooseKey("isOriginAllowed"), _class = class ProviderView extends View {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  constructor(plugin, opts) {
    super(plugin, opts); // set default options

    Object.defineProperty(this, _isOriginAllowed, {
      value: _isOriginAllowed2
    });
    Object.defineProperty(this, _updateFilesAndFolders, {
      value: _updateFilesAndFolders2
    });
    const defaultOptions = {
      viewType: 'list',
      showTitles: true,
      showFilter: true,
      showBreadcrumbs: true
    }; // merge default options with the ones set by user

    this.opts = { ...defaultOptions,
      ...opts
    }; // Logic

    this.filterQuery = this.filterQuery.bind(this);
    this.getFolder = this.getFolder.bind(this);
    this.getNextFolder = this.getNextFolder.bind(this);
    this.logout = this.logout.bind(this);
    this.handleAuth = this.handleAuth.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.listAllFiles = this.listAllFiles.bind(this);
    this.donePicking = this.donePicking.bind(this); // Visual

    this.render = this.render.bind(this); // Set default state for the plugin

    this.plugin.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      filterInput: '',
      isSearchVisible: false,
      currentSelection: []
    });
  }

  tearDown() {// Nothing.
  }

  /**
   * Based on folder ID, fetch a new folder and update it to state
   *
   * @param  {string} id Folder id
   * @returns {Promise}   Folders/files in folder
   */
  getFolder(id, name) {
    return this.sharedHandler.loaderWrapper(this.provider.list(id), res => {
      const folders = [];
      const files = [];
      let updatedDirectories;
      const state = this.plugin.getPluginState();
      const index = state.directories.findIndex(dir => id === dir.id);

      if (index !== -1) {
        updatedDirectories = state.directories.slice(0, index + 1);
      } else {
        updatedDirectories = state.directories.concat([{
          id,
          title: name
        }]);
      }

      this.username = res.username || this.username;

      _classPrivateFieldLooseBase(this, _updateFilesAndFolders)[_updateFilesAndFolders](res, files, folders);

      this.plugin.setPluginState({
        directories: updatedDirectories
      });
    }, this.handleError);
  }
  /**
   * Fetches new folder
   *
   * @param  {object} folder
   */


  getNextFolder(folder) {
    this.getFolder(folder.requestPath, folder.name);
    this.lastCheckbox = undefined;
  }
  /**
   * Removes session token on client side.
   */


  logout() {
    this.provider.logout().then(res => {
      if (res.ok) {
        if (!res.revoked) {
          const message = this.plugin.uppy.i18n('companionUnauthorizeHint', {
            provider: this.plugin.title,
            url: res.manual_revoke_url
          });
          this.plugin.uppy.info(message, 'info', 7000);
        }

        const newState = {
          authenticated: false,
          files: [],
          folders: [],
          directories: []
        };
        this.plugin.setPluginState(newState);
      }
    }).catch(this.handleError);
  }

  filterQuery(e) {
    const state = this.plugin.getPluginState();
    this.plugin.setPluginState({ ...state,
      filterInput: e ? e.target.value : ''
    });
  }
  /**
   * Adds all files found inside of specified folder.
   *
   * Uses separated state while folder contents are being fetched and
   * mantains list of selected folders, which are separated from files.
   */


  addFolder(folder) {
    const folderId = this.providerFileToId(folder);
    const state = this.plugin.getPluginState();
    const folders = { ...state.selectedFolders
    };

    if (folderId in folders && folders[folderId].loading) {
      return;
    }

    folders[folderId] = {
      loading: true,
      files: []
    };
    this.plugin.setPluginState({
      selectedFolders: { ...folders
      }
    }); // eslint-disable-next-line consistent-return

    return this.listAllFiles(folder.requestPath).then(files => {
      let count = 0; // If the same folder is added again, we don't want to send
      // X amount of duplicate file notifications, we want to say
      // the folder was already added. This checks if all files are duplicate,
      // if that's the case, we don't add the files.

      files.forEach(file => {
        const id = this.providerFileToId(file);

        if (!this.plugin.uppy.checkIfFileAlreadyExists(id)) {
          count++;
        }
      });

      if (count > 0) {
        files.forEach(file => this.addFile(file));
      }

      const ids = files.map(this.providerFileToId);
      folders[folderId] = {
        loading: false,
        files: ids
      };
      this.plugin.setPluginState({
        selectedFolders: folders
      });
      let message;

      if (count === 0) {
        message = this.plugin.uppy.i18n('folderAlreadyAdded', {
          folder: folder.name
        });
      } else if (files.length) {
        message = this.plugin.uppy.i18n('folderAdded', {
          smart_count: count,
          folder: folder.name
        });
      } else {
        message = this.plugin.uppy.i18n('emptyFolderAdded');
      }

      this.plugin.uppy.info(message);
    }).catch(e => {
      const state = this.plugin.getPluginState();
      const selectedFolders = { ...state.selectedFolders
      };
      delete selectedFolders[folderId];
      this.plugin.setPluginState({
        selectedFolders
      });
      this.handleError(e);
    });
  }

  handleAuth() {
    const authState = btoa(JSON.stringify({
      origin: getOrigin()
    }));
    const clientVersion = `@uppy/provider-views=${ProviderView.VERSION}`;
    const link = this.provider.authUrl({
      state: authState,
      uppyVersions: clientVersion
    });
    const authWindow = window.open(link, '_blank');

    const handleToken = e => {
      if (!_classPrivateFieldLooseBase(this, _isOriginAllowed)[_isOriginAllowed](e.origin, this.plugin.opts.companionAllowedHosts) || e.source !== authWindow) {
        this.plugin.uppy.log(`rejecting event from ${e.origin} vs allowed pattern ${this.plugin.opts.companionAllowedHosts}`);
        return;
      } // Check if it's a string before doing the JSON.parse to maintain support
      // for older Companion versions that used object references


      const data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

      if (data.error) {
        this.plugin.uppy.log('auth aborted');
        const {
          uppy
        } = this.plugin;
        const message = uppy.i18n('authAborted');
        uppy.info({
          message
        }, 'warning', 5000);
        return;
      }

      if (!data.token) {
        this.plugin.uppy.log('did not receive token from auth window');
        return;
      }

      authWindow.close();
      window.removeEventListener('message', handleToken);
      this.provider.setAuthToken(data.token);
      this.preFirstRender();
    };

    window.addEventListener('message', handleToken);
  }

  async handleScroll(event) {
    const path = this.nextPagePath || null;

    if (this.shouldHandleScroll(event) && path) {
      this.isHandlingScroll = true;

      try {
        const response = await this.provider.list(path);
        const {
          files,
          folders
        } = this.plugin.getPluginState();

        _classPrivateFieldLooseBase(this, _updateFilesAndFolders)[_updateFilesAndFolders](response, files, folders);
      } catch (error) {
        this.handleError(error);
      } finally {
        this.isHandlingScroll = false;
      }
    }
  }

  listAllFiles(path, files = null) {
    files = files || [];
    return new Promise((resolve, reject) => {
      this.provider.list(path).then(res => {
        res.items.forEach(item => {
          if (!item.isFolder) {
            files.push(item);
          } else {
            this.addFolder(item);
          }
        });
        const moreFiles = res.nextPagePath || null;

        if (moreFiles) {
          return this.listAllFiles(moreFiles, files).then(files => resolve(files)).catch(e => reject(e));
        }

        return resolve(files);
      }).catch(e => reject(e));
    });
  }

  donePicking() {
    const {
      currentSelection
    } = this.plugin.getPluginState();
    const promises = currentSelection.map(file => {
      if (file.isFolder) {
        return this.addFolder(file);
      }

      return this.addFile(file);
    });
    this.sharedHandler.loaderWrapper(Promise.all(promises), () => {
      this.clearSelection();
    }, () => {});
  }

  render(state, viewOptions = {}) {
    const {
      authenticated,
      didFirstRender
    } = this.plugin.getPluginState();

    if (!didFirstRender) {
      this.preFirstRender();
    }

    const targetViewOptions = { ...this.opts,
      ...viewOptions
    };
    const {
      files,
      folders,
      filterInput,
      loading,
      currentSelection
    } = this.plugin.getPluginState();
    const {
      isChecked,
      toggleCheckbox,
      filterItems
    } = this.sharedHandler;
    const hasInput = filterInput !== '';
    const headerProps = {
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      getFolder: this.getFolder,
      directories: this.plugin.getPluginState().directories,
      pluginIcon: this.plugin.icon,
      title: this.plugin.title,
      logout: this.logout,
      username: this.username,
      i18n: this.plugin.uppy.i18n
    };
    const browserProps = {
      isChecked,
      toggleCheckbox,
      currentSelection,
      files: hasInput ? filterItems(files) : files,
      folders: hasInput ? filterItems(folders) : folders,
      username: this.username,
      getNextFolder: this.getNextFolder,
      getFolder: this.getFolder,
      filterItems: this.sharedHandler.filterItems,
      filterQuery: this.filterQuery,
      logout: this.logout,
      handleScroll: this.handleScroll,
      listAllFiles: this.listAllFiles,
      done: this.donePicking,
      cancel: this.cancelPicking,
      headerComponent: Header(headerProps),
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n,
      uppyFiles: this.plugin.uppy.getFiles(),
      validateRestrictions: (...args) => this.plugin.uppy.validateRestrictions(...args)
    };

    if (loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (!authenticated) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(AuthView, {
        pluginName: this.plugin.title,
        pluginIcon: this.plugin.icon,
        handleAuth: this.handleAuth,
        i18n: this.plugin.uppy.i18n,
        i18nArray: this.plugin.uppy.i18nArray
      }));
    }

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  }

}), _class.VERSION = "2.0.5", _temp);

function _updateFilesAndFolders2(res, files, folders) {
  this.nextPagePath = res.nextPagePath;
  res.items.forEach(item => {
    if (item.isFolder) {
      folders.push(item);
    } else {
      files.push(item);
    }
  });
  this.plugin.setPluginState({
    folders,
    files
  });
}

function _isOriginAllowed2(origin, allowedOrigin) {
  const getRegex = value => {
    if (typeof value === 'string') {
      return new RegExp(`^${value}$`);
    }

    if (value instanceof RegExp) {
      return value;
    }
  };

  const patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(getRegex) : [getRegex(allowedOrigin)];
  return patterns.filter(pattern => pattern != null) // loose comparison to catch undefined
  .some(pattern => pattern.test(origin) || pattern.test(`${origin}/`)); // allowing for trailing '/'
}

},{"../Browser":100,"../CloseWrapper":101,"../Loader":108,"../View":119,"./AuthView":109,"./Header":110,"preact":18}],112:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = props => {
  return [h("span", {
    className: "uppy-ProviderBrowser-user",
    key: "username"
  }, props.username), h("button", {
    type: "button",
    onClick: props.logout,
    className: "uppy-u-reset uppy-ProviderBrowser-userLogout",
    key: "logout"
  }, props.i18n('logOut'))];
};

},{"preact":18}],113:[function(require,module,exports){
"use strict";

module.exports = require('./ProviderView');

},{"./ProviderView":111}],114:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = props => {
  return h("button", {
    type: "button",
    onClick: props.triggerSearchInput,
    className: "uppy-u-reset uppy-ProviderBrowser-userLogout"
  }, props.i18n('backToSearch'));
};

},{"preact":18}],115:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = props => {
  let input;

  const handleKeyPress = ev => {
    if (ev.keyCode === 13) {
      validateAndSearch();
    }
  };

  const validateAndSearch = () => {
    if (input.value) {
      props.search(input.value);
    }
  };

  return h("div", {
    className: "uppy-SearchProvider"
  }, h("input", {
    className: "uppy-u-reset uppy-c-textInput uppy-SearchProvider-input",
    type: "text",
    "aria-label": props.i18n('enterTextToSearch'),
    placeholder: props.i18n('enterTextToSearch'),
    onKeyUp: handleKeyPress,
    ref: input_ => {
      input = input_;
    },
    "data-uppy-super-focusable": true
  }), h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-SearchProvider-searchButton",
    type: "button",
    onClick: validateAndSearch
  }, props.i18n('searchImages')));
};

},{"preact":18}],116:[function(require,module,exports){
"use strict";

var _class, _searchTerm, _updateFilesAndInputMode, _temp;

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const {
  h
} = require('preact');

const SearchInput = require('./InputView');

const Browser = require('../Browser');

const LoaderView = require('../Loader');

const Header = require('./Header');

const CloseWrapper = require('../CloseWrapper');

const View = require('../View');
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = (_searchTerm = /*#__PURE__*/_classPrivateFieldLooseKey("searchTerm"), _updateFilesAndInputMode = /*#__PURE__*/_classPrivateFieldLooseKey("updateFilesAndInputMode"), _class = class SearchProviderView extends View {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  constructor(plugin, opts) {
    super(plugin, opts); // set default options

    Object.defineProperty(this, _updateFilesAndInputMode, {
      value: _updateFilesAndInputMode2
    });
    Object.defineProperty(this, _searchTerm, {
      writable: true,
      value: void 0
    });
    const defaultOptions = {
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    }; // merge default options with the ones set by user

    this.opts = { ...defaultOptions,
      ...opts
    }; // Logic

    this.search = this.search.bind(this);
    this.triggerSearchInput = this.triggerSearchInput.bind(this);
    this.addFile = this.addFile.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.donePicking = this.donePicking.bind(this); // Visual

    this.render = this.render.bind(this); // Set default state for the plugin

    this.plugin.setPluginState({
      isInputMode: true,
      files: [],
      folders: [],
      directories: [],
      filterInput: '',
      isSearchVisible: false,
      currentSelection: []
    });
  }

  tearDown() {// Nothing.
  }

  search(query) {
    if (query && query === _classPrivateFieldLooseBase(this, _searchTerm)[_searchTerm]) {
      // no need to search again as this is the same as the previous search
      this.plugin.setPluginState({
        isInputMode: false
      });
      return;
    }

    return this.sharedHandler.loaderWrapper(this.provider.search(query), res => {
      _classPrivateFieldLooseBase(this, _updateFilesAndInputMode)[_updateFilesAndInputMode](res, []);
    }, this.handleError);
  }

  triggerSearchInput() {
    this.plugin.setPluginState({
      isInputMode: true
    });
  }

  async handleScroll(event) {
    const query = this.nextPageQuery || null;

    if (this.shouldHandleScroll(event) && query) {
      this.isHandlingScroll = true;

      try {
        const response = await this.provider.search(_classPrivateFieldLooseBase(this, _searchTerm)[_searchTerm], query);
        const {
          files
        } = this.plugin.getPluginState();

        _classPrivateFieldLooseBase(this, _updateFilesAndInputMode)[_updateFilesAndInputMode](response, files);
      } catch (error) {
        this.handleError(error);
      } finally {
        this.isHandlingScroll = false;
      }
    }
  }

  donePicking() {
    const {
      currentSelection
    } = this.plugin.getPluginState();
    const promises = currentSelection.map(file => this.addFile(file));
    this.sharedHandler.loaderWrapper(Promise.all(promises), () => {
      this.clearSelection();
    }, () => {});
  }

  render(state, viewOptions = {}) {
    const {
      didFirstRender,
      isInputMode
    } = this.plugin.getPluginState();

    if (!didFirstRender) {
      this.preFirstRender();
    }

    const targetViewOptions = { ...this.opts,
      ...viewOptions
    };
    const {
      files,
      folders,
      filterInput,
      loading,
      currentSelection
    } = this.plugin.getPluginState();
    const {
      isChecked,
      toggleCheckbox,
      filterItems
    } = this.sharedHandler;
    const hasInput = filterInput !== '';
    const browserProps = {
      isChecked,
      toggleCheckbox,
      currentSelection,
      files: hasInput ? filterItems(files) : files,
      folders: hasInput ? filterItems(folders) : folders,
      handleScroll: this.handleScroll,
      done: this.donePicking,
      cancel: this.cancelPicking,
      headerComponent: Header({
        triggerSearchInput: this.triggerSearchInput,
        i18n: this.plugin.uppy.i18n
      }),
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n,
      uppyFiles: this.plugin.uppy.getFiles(),
      validateRestrictions: (...args) => this.plugin.uppy.validateRestrictions(...args)
    };

    if (loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (isInputMode) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(SearchInput, {
        search: this.search,
        i18n: this.plugin.uppy.i18n
      }));
    }

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  }

}), _class.VERSION = "2.0.5", _temp);

function _updateFilesAndInputMode2(res, files) {
  this.nextPageQuery = res.nextPageQuery;
  _classPrivateFieldLooseBase(this, _searchTerm)[_searchTerm] = res.searchedFor;
  res.items.forEach(item => {
    files.push(item);
  });
  this.plugin.setPluginState({
    isInputMode: false,
    files
  });
}

},{"../Browser":100,"../CloseWrapper":101,"../Loader":108,"../View":119,"./Header":114,"./InputView":115,"preact":18}],117:[function(require,module,exports){
"use strict";

module.exports = require('./SearchProviderView');

},{"./SearchProviderView":116}],118:[function(require,module,exports){
"use strict";

const remoteFileObjToLocal = require('./../../utils/lib/remoteFileObjToLocal');

module.exports = class SharedHandler {
  constructor(plugin) {
    this.plugin = plugin;
    this.filterItems = this.filterItems.bind(this);
    this.toggleCheckbox = this.toggleCheckbox.bind(this);
    this.isChecked = this.isChecked.bind(this);
    this.loaderWrapper = this.loaderWrapper.bind(this);
  }

  filterItems(items) {
    const state = this.plugin.getPluginState();

    if (!state.filterInput || state.filterInput === '') {
      return items;
    }

    return items.filter(folder => {
      return folder.name.toLowerCase().indexOf(state.filterInput.toLowerCase()) !== -1;
    });
  }
  /**
   * Toggles file/folder checkbox to on/off state while updating files list.
   *
   * Note that some extra complexity comes from supporting shift+click to
   * toggle multiple checkboxes at once, which is done by getting all files
   * in between last checked file and current one.
   */


  toggleCheckbox(e, file) {
    e.stopPropagation();
    e.preventDefault();
    e.currentTarget.focus();
    const {
      folders,
      files
    } = this.plugin.getPluginState();
    const items = this.filterItems(folders.concat(files)); // Shift-clicking selects a single consecutive list of items
    // starting at the previous click and deselects everything else.

    if (this.lastCheckbox && e.shiftKey) {
      const prevIndex = items.indexOf(this.lastCheckbox);
      const currentIndex = items.indexOf(file);
      const currentSelection = prevIndex < currentIndex ? items.slice(prevIndex, currentIndex + 1) : items.slice(currentIndex, prevIndex + 1);
      const reducedCurrentSelection = []; // Check restrictions on each file in currentSelection,
      // reduce it to only contain files that pass restrictions

      for (const item of currentSelection) {
        const {
          uppy
        } = this.plugin;
        const validatedRestrictions = uppy.validateRestrictions(remoteFileObjToLocal(item), [...uppy.getFiles(), ...reducedCurrentSelection]);

        if (validatedRestrictions.result) {
          reducedCurrentSelection.push(item);
        } else {
          uppy.info({
            message: validatedRestrictions.reason
          }, 'error', uppy.opts.infoTimeout);
        }
      }

      this.plugin.setPluginState({
        currentSelection: reducedCurrentSelection
      });
      return;
    }

    this.lastCheckbox = file;
    const {
      currentSelection
    } = this.plugin.getPluginState();

    if (this.isChecked(file)) {
      this.plugin.setPluginState({
        currentSelection: currentSelection.filter(item => item.id !== file.id)
      });
    } else {
      this.plugin.setPluginState({
        currentSelection: currentSelection.concat([file])
      });
    }
  }

  isChecked(file) {
    const {
      currentSelection
    } = this.plugin.getPluginState(); // comparing id instead of the file object, because the reference to the object
    // changes when we switch folders, and the file list is updated

    return currentSelection.some(item => item.id === file.id);
  }

  loaderWrapper(promise, then, catch_) {
    promise.then(result => {
      this.plugin.setPluginState({
        loading: false
      });
      then(result);
    }).catch(err => {
      this.plugin.setPluginState({
        loading: false
      });
      catch_(err);
    });
    this.plugin.setPluginState({
      loading: true
    });
  }

};

},{"./../../utils/lib/remoteFileObjToLocal":177}],119:[function(require,module,exports){
"use strict";

const getFileType = require('./../../utils/lib/getFileType');

const isPreviewSupported = require('./../../utils/lib/isPreviewSupported');

const generateFileID = require('./../../utils/lib/generateFileID'); // TODO: now that we have a shared `View` class,
// `SharedHandler` could be cleaned up and moved into here


const SharedHandler = require('./SharedHandler');

module.exports = class View {
  constructor(plugin, opts) {
    this.plugin = plugin;
    this.provider = opts.provider;
    this.sharedHandler = new SharedHandler(plugin);
    this.isHandlingScroll = false;
    this.preFirstRender = this.preFirstRender.bind(this);
    this.handleError = this.handleError.bind(this);
    this.addFile = this.addFile.bind(this);
    this.clearSelection = this.clearSelection.bind(this);
    this.cancelPicking = this.cancelPicking.bind(this);
  } // eslint-disable-next-line class-methods-use-this


  providerFileToId(file) {
    return generateFileID({
      data: file,
      name: file.name || file.id,
      type: file.mimetype
    });
  }

  preFirstRender() {
    this.plugin.setPluginState({
      didFirstRender: true
    });
    this.plugin.onFirstRender();
  } // eslint-disable-next-line class-methods-use-this


  shouldHandleScroll(event) {
    const {
      scrollHeight,
      scrollTop,
      offsetHeight
    } = event.target;
    const scrollPosition = scrollHeight - (scrollTop + offsetHeight);
    return scrollPosition < 50 && !this.isHandlingScroll;
  }

  clearSelection() {
    this.plugin.setPluginState({
      currentSelection: []
    });
  }

  cancelPicking() {
    this.clearSelection();
    const dashboard = this.plugin.uppy.getPlugin('Dashboard');

    if (dashboard) {
      dashboard.hideAllPanels();
    }
  }

  handleError(error) {
    const {
      uppy
    } = this.plugin;
    const message = uppy.i18n('companionError');
    uppy.log(error.toString());

    if (error.isAuthError) {
      return;
    }

    uppy.info({
      message,
      details: error.toString()
    }, 'error', 5000);
  }

  addFile(file) {
    const tagFile = {
      id: this.providerFileToId(file),
      source: this.plugin.id,
      data: file,
      name: file.name || file.id,
      type: file.mimeType,
      isRemote: true,
      meta: {},
      body: {
        fileId: file.id
      },
      remote: {
        companionUrl: this.plugin.opts.companionUrl,
        url: `${this.provider.fileUrl(file.requestPath)}`,
        body: {
          fileId: file.id
        },
        providerOptions: this.provider.opts,
        providerName: this.provider.name
      }
    };
    const fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?

    if (fileType && isPreviewSupported(fileType)) {
      tagFile.preview = file.thumbnail;
    }

    if (file.author) {
      tagFile.meta.author = file.author;
    }

    this.plugin.uppy.log('Adding remote file');

    try {
      this.plugin.uppy.addFile(tagFile);
      return true;
    } catch (err) {
      if (!err.isRestriction) {
        this.plugin.uppy.log(err);
      }

      return false;
    }
  }

};

},{"./../../utils/lib/generateFileID":155,"./../../utils/lib/getFileType":163,"./../../utils/lib/isPreviewSupported":174,"./SharedHandler":118}],120:[function(require,module,exports){
"use strict";

const ProviderViews = require('./ProviderView');

const SearchProviderViews = require('./SearchProviderView');

module.exports = {
  ProviderViews,
  SearchProviderViews
};

},{"./ProviderView":113,"./SearchProviderView":117}],121:[function(require,module,exports){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const {
  h,
  Component
} = require('preact');

const RecordButton = require('./RecordButton');

const SubmitButton = require('./SubmitButton');

const StopWatch = require('./StopWatch');

const StreamStatus = require('./StreamStatus');

class RecorderScreen extends Component {
  componentWillUnmount() {
    this.props.onStop();
  }

  render() {
    const {
      recording,
      stream: videoStream,
      recordedVideo
    } = this.props;
    const videoProps = {
      playsinline: true
    }; // show stream

    if (recording || !recordedVideo && !recording) {
      videoProps.muted = true;
      videoProps.autoplay = true;
      videoProps.srcObject = videoStream;
    } // show preview


    if (recordedVideo && !recording) {
      videoProps.muted = false;
      videoProps.controls = true;
      videoProps.src = recordedVideo; // reset srcObject in dom. If not resetted, stream sticks in element

      if (this.videoElement) {
        this.videoElement.srcObject = undefined;
      }
    }

    return h("div", {
      className: "uppy uppy-ScreenCapture-container"
    }, h("div", {
      className: "uppy-ScreenCapture-videoContainer"
    }, h(StreamStatus, this.props), h("video", _extends({
      ref: videoElement => {
        this.videoElement = videoElement;
      },
      className: "uppy-ScreenCapture-video"
    }, videoProps)), h(StopWatch, this.props)), h("div", {
      className: "uppy-ScreenCapture-buttonContainer"
    }, h(RecordButton, this.props), h(SubmitButton, this.props)));
  }

}

module.exports = RecorderScreen;

},{"./RecordButton":122,"./StopWatch":124,"./StreamStatus":125,"./SubmitButton":126,"preact":18}],122:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');
/**
 * Control screen capture recording. Will show record or stop button.
 */


module.exports = function RecordButton({
  recording,
  onStartRecording,
  onStopRecording,
  i18n
}) {
  if (recording) {
    return h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--video uppy-ScreenCapture-button--stop-rec",
      type: "button",
      title: i18n('stopCapturing'),
      "aria-label": i18n('stopCapturing'),
      onClick: onStopRecording,
      "data-uppy-super-focusable": true
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "100",
      height: "100",
      viewBox: "0 0 100 100"
    }, h("rect", {
      x: "15",
      y: "15",
      width: "70",
      height: "70"
    })));
  }

  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--video",
    type: "button",
    title: i18n('startCapturing'),
    "aria-label": i18n('startCapturing'),
    onClick: onStartRecording,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "100",
    height: "100",
    viewBox: "0 0 100 100"
  }, h("circle", {
    cx: "50",
    cy: "50",
    r: "40"
  })));
};

},{"preact":18}],123:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = () => {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("rect", {
    className: "uppy-ProviderIconBg",
    fill: "#2C3E50",
    width: "32",
    height: "32",
    rx: "16"
  }), h("path", {
    d: "M24.182 9H7.818C6.81 9 6 9.742 6 10.667v10c0 .916.81 1.666 1.818 1.666h4.546V24h7.272v-1.667h4.546c1 0 1.809-.75 1.809-1.666l.009-10C26 9.742 25.182 9 24.182 9zM24 21H8V11h16v10z",
    fill: "#FFF",
    fillRule: "nonzero"
  }), h("circle", {
    fill: "#FFF",
    cx: "16",
    cy: "16",
    r: "2"
  })));
};

},{"preact":18}],124:[function(require,module,exports){
"use strict";

const {
  h,
  Component
} = require('preact');

class Stopwatch extends Component {
  constructor(props) {
    super(props);
    this.state = {
      elapsedTime: 0
    };
    this.wrapperStyle = {
      width: '100%',
      height: '100%',
      display: 'flex'
    };
    this.overlayStyle = {
      position: 'absolute',
      width: '100%',
      height: '100%',
      background: 'black',
      opacity: 0.7
    };
    this.infoContainerStyle = {
      marginLeft: 'auto',
      marginRight: 'auto',
      marginTop: 'auto',
      marginBottom: 'auto',
      zIndex: 1,
      color: 'white'
    };
    this.infotextStyle = {
      marginLeft: 'auto',
      marginRight: 'auto',
      marginBottom: '1rem',
      fontSize: '1.5rem'
    };
    this.timeStyle = {
      display: 'block',
      fontWeight: 'bold',
      marginLeft: 'auto',
      marginRight: 'auto',
      fontSize: '3rem',
      fontFamily: 'Courier New'
    };
  }

  startTimer() {
    this.timerTick();
    this.timerRunning = true;
  }

  resetTimer() {
    clearTimeout(this.timer);
    this.setState({
      elapsedTime: 0
    });
    this.timerRunning = false;
  }

  timerTick() {
    this.timer = setTimeout(() => {
      this.setState(state => ({
        elapsedTime: state.elapsedTime + 1
      }));
      this.timerTick();
    }, 1000);
  }

  fmtMSS(s) {
    // eslint-disable-next-line no-return-assign
    return (s - (s %= 60)) / 60 + (s > 9 ? ':' : ':0') + s;
  }

  render() {
    const {
      recording,
      i18n
    } = { ...this.props
    }; // second to minutes and seconds

    const minAndSec = this.fmtMSS(this.state.elapsedTime);

    if (recording && !this.timerRunning) {
      this.startTimer();
    }

    if (!recording && this.timerRunning) {
      this.resetTimer();
    }

    if (recording) {
      return h("div", {
        style: this.wrapperStyle
      }, h("div", {
        style: this.overlayStyle
      }), h("div", {
        style: this.infoContainerStyle
      }, h("div", {
        style: this.infotextStyle
      }, i18n('recording')), h("div", {
        style: this.timeStyle
      }, minAndSec)));
    }

    return null;
  }

}

module.exports = Stopwatch;

},{"preact":18}],125:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = ({
  streamActive,
  i18n
}) => {
  if (streamActive) {
    return h("div", {
      title: i18n('streamActive'),
      "aria-label": i18n('streamActive'),
      className: "uppy-ScreenCapture-icon--stream uppy-ScreenCapture-icon--streamActive"
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0z",
      opacity: ".1",
      fill: "none"
    }), h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), h("path", {
      d: "M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm18-7H5v1.63c3.96 1.28 7.09 4.41 8.37 8.37H19V7zM1 10v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
    })));
  }

  return h("div", {
    title: i18n('streamPassive'),
    "aria-label": i18n('streamPassive'),
    className: "uppy-ScreenCapture-icon--stream"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, h("path", {
    d: "M0 0h24v24H0z",
    opacity: ".1",
    fill: "none"
  }), h("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  }), h("path", {
    d: "M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11z"
  })));
};

},{"preact":18}],126:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');
/**
 * Submit recorded video to uppy. Enabled when file is available
 */


module.exports = function SubmitButton({
  recording,
  recordedVideo,
  onSubmit,
  i18n
}) {
  if (recordedVideo && !recording) {
    return h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--submit",
      type: "button",
      title: i18n('submitRecordedFile'),
      "aria-label": i18n('submitRecordedFile'),
      onClick: onSubmit,
      "data-uppy-super-focusable": true
    }, h("svg", {
      width: "12",
      height: "9",
      viewBox: "0 0 12 9",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon"
    }, h("path", {
      fill: "#fff",
      fillRule: "nonzero",
      d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z"
    })));
  }

  return null;
};

},{"preact":18}],127:[function(require,module,exports){
"use strict";

var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const {
  h
} = require('preact');

const {
  UIPlugin
} = require('./../../core');

const getFileTypeExtension = require('./../../utils/lib/getFileTypeExtension');

const ScreenRecIcon = require('./ScreenRecIcon');

const CaptureScreen = require('./CaptureScreen');

const locale = require('./locale'); // Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia


function getMediaDevices() {
  // check if screen capturing is supported
  return window.MediaRecorder && navigator.mediaDevices; // eslint-disable-line compat/compat
}
/**
 * Screen capture
 */


module.exports = (_temp = _class = class ScreenCapture extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.mediaDevices = getMediaDevices(); // eslint-disable-next-line no-restricted-globals

    this.protocol = location.protocol === 'https:' ? 'https' : 'http';
    this.id = this.opts.id || 'ScreenCapture';
    this.title = this.opts.title || 'Screencast';
    this.type = 'acquirer';
    this.icon = ScreenRecIcon;
    this.defaultLocale = locale; // set default options
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints

    const defaultOptions = {
      // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#Properties_of_shared_screen_tracks
      displayMediaConstraints: {
        video: {
          width: 1280,
          height: 720,
          frameRate: {
            ideal: 3,
            max: 5
          },
          cursor: 'motion',
          displaySurface: 'monitor'
        }
      },
      // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints/audio
      userMediaConstraints: {
        audio: true
      },
      preferredVideoMimeType: 'video/webm'
    }; // merge default options with the ones set by user

    this.opts = { ...defaultOptions,
      ...opts
    }; // i18n

    this.i18nInit(); // uppy plugin class related

    this.install = this.install.bind(this);
    this.setPluginState = this.setPluginState.bind(this);
    this.render = this.render.bind(this); // screen capturer related

    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this.startRecording = this.startRecording.bind(this);
    this.stopRecording = this.stopRecording.bind(this);
    this.submit = this.submit.bind(this);
    this.streamInterrupted = this.streamInactivated.bind(this); // initialize

    this.captureActive = false;
    this.capturedMediaFile = null;
  }

  install() {
    // Return if browser doesnt support getDisplayMedia and
    if (!this.mediaDevices) {
      this.uppy.log('Screen recorder access is not supported', 'error');
      return null;
    }

    this.setPluginState({
      streamActive: false,
      audioStreamActive: false
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    if (this.videoStream) {
      this.stop();
    }

    this.unmount();
  }

  start() {
    if (!this.mediaDevices) {
      return Promise.reject(new Error('Screen recorder access not supported'));
    }

    this.captureActive = true;
    this.selectAudioStreamSource();
    this.selectVideoStreamSource().then(res => {
      // something happened in start -> return
      if (res === false) {
        // Close the Dashboard panel if plugin is installed
        // into Dashboard (could be other parent UI plugin)
        if (this.parent && this.parent.hideAllPanels) {
          this.parent.hideAllPanels();
          this.captureActive = false;
        }
      }
    });
  }

  selectVideoStreamSource() {
    // if active stream available, return it
    if (this.videoStream) {
      return new Promise(resolve => resolve(this.videoStream));
    } // ask user to select source to record and get mediastream from that
    // eslint-disable-next-line compat/compat


    return this.mediaDevices.getDisplayMedia(this.opts.displayMediaConstraints).then(videoStream => {
      this.videoStream = videoStream; // add event listener to stop recording if stream is interrupted

      this.videoStream.addEventListener('inactive', () => {
        this.streamInactivated();
      });
      this.setPluginState({
        streamActive: true
      });
      return videoStream;
    }).catch(err => {
      this.setPluginState({
        screenRecError: err
      });
      this.userDenied = true;
      setTimeout(() => {
        this.userDenied = false;
      }, 1000);
      return false;
    });
  }

  selectAudioStreamSource() {
    // if active stream available, return it
    if (this.audioStream) {
      return new Promise(resolve => resolve(this.audioStream));
    } // ask user to select source to record and get mediastream from that
    // eslint-disable-next-line compat/compat


    return this.mediaDevices.getUserMedia(this.opts.userMediaConstraints).then(audioStream => {
      this.audioStream = audioStream;
      this.setPluginState({
        audioStreamActive: true
      });
      return audioStream;
    }).catch(err => {
      if (err.name === 'NotAllowedError') {
        this.uppy.info(this.i18n('micDisabled'), 'error', 5000);
      }

      return false;
    });
  }

  startRecording() {
    const options = {};
    this.capturedMediaFile = null;
    this.recordingChunks = [];
    const {
      preferredVideoMimeType
    } = this.opts;
    this.selectVideoStreamSource().then(videoStream => {
      // Attempt to use the passed preferredVideoMimeType (if any) during recording.
      // If the browser doesn't support it, we'll fall back to the browser default instead
      if (preferredVideoMimeType && MediaRecorder.isTypeSupported(preferredVideoMimeType) && getFileTypeExtension(preferredVideoMimeType)) {
        options.mimeType = preferredVideoMimeType;
      } // prepare tracks


      const tracks = [videoStream.getVideoTracks()[0]]; // merge audio if exits

      if (this.audioStream) {
        tracks.push(this.audioStream.getAudioTracks()[0]);
      } // create new stream from video and audio
      // eslint-disable-next-line compat/compat


      this.outputStream = new MediaStream(tracks); // initialize mediarecorder
      // eslint-disable-next-line compat/compat

      this.recorder = new MediaRecorder(this.outputStream, options); // push data to buffer when data available

      this.recorder.addEventListener('dataavailable', event => {
        this.recordingChunks.push(event.data);
      }); // start recording

      this.recorder.start(); // set plugin state to recording

      this.setPluginState({
        recording: true
      });
    }).catch(err => {
      this.uppy.log(err, 'error');
    });
  }

  streamInactivated() {
    // get screen recorder state
    const {
      recordedVideo,
      recording
    } = { ...this.getPluginState()
    };

    if (!recordedVideo && !recording) {
      // Close the Dashboard panel if plugin is installed
      // into Dashboard (could be other parent UI plugin)
      if (this.parent && this.parent.hideAllPanels) {
        this.parent.hideAllPanels();
      }
    } else if (recording) {
      // stop recorder if it is active
      this.uppy.log('Capture stream inactive  stop recording');
      this.stopRecording();
    }

    this.videoStream = null;
    this.audioStream = null;
    this.setPluginState({
      streamActive: false,
      audioStreamActive: false
    });
  }

  stopRecording() {
    const stopped = new Promise(resolve => {
      this.recorder.addEventListener('stop', () => {
        resolve();
      });
      this.recorder.stop();
    });
    return stopped.then(() => {
      // recording stopped
      this.setPluginState({
        recording: false
      }); // get video file after recorder stopped

      return this.getVideo();
    }).then(file => {
      // store media file
      this.capturedMediaFile = file; // create object url for capture result preview

      this.setPluginState({
        // eslint-disable-next-line compat/compat
        recordedVideo: URL.createObjectURL(file.data)
      });
    }).then(() => {
      this.recordingChunks = null;
      this.recorder = null;
    }, error => {
      this.recordingChunks = null;
      this.recorder = null;
      throw error;
    });
  }

  submit() {
    try {
      // add recorded file to uppy
      if (this.capturedMediaFile) {
        this.uppy.addFile(this.capturedMediaFile);
      }
    } catch (err) {
      // Logging the error, exept restrictions, which is handled in Core
      if (!err.isRestriction) {
        this.uppy.log(err, 'error');
      }
    }
  }

  stop() {
    // flush video stream
    if (this.videoStream) {
      this.videoStream.getVideoTracks().forEach(track => {
        track.stop();
      });
      this.videoStream.getAudioTracks().forEach(track => {
        track.stop();
      });
      this.videoStream = null;
    } // flush audio stream


    if (this.audioStream) {
      this.audioStream.getAudioTracks().forEach(track => {
        track.stop();
      });
      this.audioStream.getVideoTracks().forEach(track => {
        track.stop();
      });
      this.audioStream = null;
    } // flush output stream


    if (this.outputStream) {
      this.outputStream.getAudioTracks().forEach(track => {
        track.stop();
      });
      this.outputStream.getVideoTracks().forEach(track => {
        track.stop();
      });
      this.outputStream = null;
    } // remove preview video


    this.setPluginState({
      recordedVideo: null
    });
    this.captureActive = false;
  }

  getVideo() {
    const mimeType = this.recordingChunks[0].type;
    const fileExtension = getFileTypeExtension(mimeType);

    if (!fileExtension) {
      return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type "${mimeType}"`));
    }

    const name = `screencap-${Date.now()}.${fileExtension}`;
    const blob = new Blob(this.recordingChunks, {
      type: mimeType
    });
    const file = {
      source: this.id,
      name,
      data: new Blob([blob], {
        type: mimeType
      }),
      type: mimeType
    };
    return Promise.resolve(file);
  }

  render() {
    // get screen recorder state
    const recorderState = this.getPluginState();

    if (!recorderState.streamActive && !this.captureActive && !this.userDenied) {
      this.start();
    }

    return h(CaptureScreen, _extends({}, recorderState, {
      onStartRecording: this.startRecording,
      onStopRecording: this.stopRecording,
      onStop: this.stop,
      onSubmit: this.submit,
      i18n: this.i18n,
      stream: this.videoStream
    }));
  }

}, _class.VERSION = "2.0.4", _temp);

},{"./../../core":48,"./../../utils/lib/getFileTypeExtension":164,"./CaptureScreen":121,"./ScreenRecIcon":123,"./locale":128,"preact":18}],128:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    startCapturing: 'Begin screen capturing',
    stopCapturing: 'Stop screen capturing',
    submitRecordedFile: 'Submit recorded file',
    streamActive: 'Stream active',
    streamPassive: 'Stream passive',
    micDisabled: 'Microphone access denied by user',
    recording: 'Recording'
  }
};

},{}],129:[function(require,module,exports){
"use strict";

const classNames = require('classnames');

const throttle = require('lodash.throttle');

const prettierBytes = require('@transloadit/prettier-bytes');

const prettyETA = require('./../../utils/lib/prettyETA');

const {
  h
} = require('preact');

const statusBarStates = require('./StatusBarStates');

const DOT = `\u00B7`;

const renderDot = () => ` ${DOT} `;

function UploadBtn(props) {
  const {
    newFiles,
    isUploadStarted,
    recoveredState,
    i18n,
    uploadState,
    isSomeGhost,
    startUpload
  } = props;
  const uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--upload', {
    'uppy-c-btn-primary': uploadState === statusBarStates.STATE_WAITING
  }, {
    'uppy-StatusBar-actionBtn--disabled': isSomeGhost
  });
  const uploadBtnText = newFiles && isUploadStarted && !recoveredState ? i18n('uploadXNewFiles', {
    smart_count: newFiles
  }) : i18n('uploadXFiles', {
    smart_count: newFiles
  });
  return h("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": i18n('uploadXFiles', {
      smart_count: newFiles
    }),
    onClick: startUpload,
    disabled: isSomeGhost,
    "data-uppy-super-focusable": true
  }, uploadBtnText);
}

function RetryBtn(props) {
  const {
    i18n,
    uppy
  } = props;
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
    "aria-label": i18n('retryUpload'),
    onClick: () => uppy.retryAll(),
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "8",
    height: "10",
    viewBox: "0 0 8 10"
  }, h("path", {
    d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
  })), i18n('retry'));
}

function CancelBtn(props) {
  const {
    i18n,
    uppy
  } = props;
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    title: i18n('cancel'),
    "aria-label": i18n('cancel'),
    onClick: () => uppy.cancelAll(),
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
  }))));
}

function PauseResumeButton(props) {
  const {
    isAllPaused,
    i18n,
    isAllComplete,
    resumableUploads,
    uppy
  } = props;
  const title = isAllPaused ? i18n('resume') : i18n('pause');

  function togglePauseResume() {
    if (isAllComplete) return null;

    if (!resumableUploads) {
      return uppy.cancelAll();
    }

    if (isAllPaused) {
      return uppy.resumeAll();
    }

    return uppy.pauseAll();
  }

  return h("button", {
    title: title,
    "aria-label": title,
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    type: "button",
    onClick: togglePauseResume,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: isAllPaused ? 'M6 4.25L11.5 8 6 11.75z' : 'M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z'
  }))));
}

function DoneBtn(props) {
  const {
    i18n,
    doneButtonHandler
  } = props;
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done",
    onClick: doneButtonHandler,
    "data-uppy-super-focusable": true
  }, i18n('done'));
}

function LoadingSpinner() {
  return h("svg", {
    className: "uppy-StatusBar-spinner",
    "aria-hidden": "true",
    focusable: "false",
    width: "14",
    height: "14"
  }, h("path", {
    d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
    fillRule: "evenodd"
  }));
}

function ProgressBarProcessing(props) {
  const {
    progress
  } = props;
  const {
    value,
    mode,
    message
  } = progress;
  const roundedValue = Math.round(value * 100);
  const dot = `\u00B7`;
  return h("div", {
    className: "uppy-StatusBar-content"
  }, h(LoadingSpinner, null), mode === 'determinate' ? `${roundedValue}% ${dot} ` : '', message);
}

function ProgressDetails(props) {
  const {
    numUploads,
    complete,
    totalUploadedSize,
    totalSize,
    totalETA,
    i18n
  } = props;
  const ifShowFilesUploadedOfTotal = numUploads > 1;
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, ifShowFilesUploadedOfTotal && i18n('filesUploadedOfTotal', {
    complete,
    smart_count: numUploads
  }), h("span", {
    className: "uppy-StatusBar-additionalInfo"
  }, ifShowFilesUploadedOfTotal && renderDot(), i18n('dataUploadedOfTotal', {
    complete: prettierBytes(totalUploadedSize),
    total: prettierBytes(totalSize)
  }), renderDot(), i18n('xTimeLeft', {
    time: prettyETA(totalETA)
  })));
}

function FileUploadCount(props) {
  const {
    i18n,
    complete,
    numUploads
  } = props;
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, i18n('filesUploadedOfTotal', {
    complete,
    smart_count: numUploads
  }));
}

function UploadNewlyAddedFiles(props) {
  const {
    i18n,
    newFiles,
    startUpload
  } = props;
  const uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--uploadNewlyAdded');
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, h("div", {
    className: "uppy-StatusBar-statusSecondaryHint"
  }, i18n('xMoreFilesAdded', {
    smart_count: newFiles
  })), h("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": i18n('uploadXFiles', {
      smart_count: newFiles
    }),
    onClick: startUpload
  }, i18n('upload')));
}

const ThrottledProgressDetails = throttle(ProgressDetails, 500, {
  leading: true,
  trailing: true
});

function ProgressBarUploading(props) {
  const {
    i18n,
    supportsUploadProgress,
    totalProgress,
    showProgressDetails,
    isUploadStarted,
    isAllComplete,
    isAllPaused,
    newFiles,
    numUploads,
    complete,
    totalUploadedSize,
    totalSize,
    totalETA,
    startUpload
  } = props;
  const showUploadNewlyAddedFiles = newFiles && isUploadStarted;

  if (!isUploadStarted || isAllComplete) {
    return null;
  }

  const title = isAllPaused ? i18n('paused') : i18n('uploading');

  function renderProgressDetails() {
    if (!isAllPaused && !showUploadNewlyAddedFiles && showProgressDetails) {
      if (supportsUploadProgress) {
        return h(ThrottledProgressDetails, {
          numUploads: numUploads,
          complete: complete,
          totalUploadedSize: totalUploadedSize,
          totalSize: totalSize,
          totalETA: totalETA,
          i18n: i18n
        });
      }

      return h(FileUploadCount, {
        i18n: i18n,
        complete: complete,
        numUploads: numUploads
      });
    }

    return null;
  }

  return h("div", {
    className: "uppy-StatusBar-content",
    "aria-label": title,
    title: title
  }, !isAllPaused ? h(LoadingSpinner, null) : null, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, supportsUploadProgress ? `${title}: ${totalProgress}%` : title), renderProgressDetails(), showUploadNewlyAddedFiles ? h(UploadNewlyAddedFiles, {
    i18n: i18n,
    newFiles: newFiles,
    startUpload: startUpload
  }) : null));
}

function ProgressBarComplete(props) {
  const {
    i18n
  } = props;
  return h("div", {
    className: "uppy-StatusBar-content",
    role: "status",
    title: i18n('complete')
  }, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "15",
    height: "11",
    viewBox: "0 0 15 11"
  }, h("path", {
    d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
  })), i18n('complete'))));
}

function ProgressBarError(props) {
  const {
    error,
    i18n,
    complete,
    numUploads
  } = props;

  function displayErrorAlert() {
    const errorMessage = `${i18n('uploadFailed')} \n\n ${error}`; // eslint-disable-next-line no-alert

    alert(errorMessage); // TODO: move to custom alert implementation
  }

  return h("div", {
    className: "uppy-StatusBar-content",
    title: i18n('uploadFailed')
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "11",
    height: "11",
    viewBox: "0 0 11 11"
  }, h("path", {
    d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
  })), h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, i18n('uploadFailed'), h("button", {
    className: "uppy-u-reset uppy-StatusBar-details",
    "aria-label": i18n('showErrorDetails'),
    "data-microtip-position": "top-right",
    "data-microtip-size": "medium",
    onClick: displayErrorAlert,
    type: "button"
  }, "?")), h(FileUploadCount, {
    i18n: i18n,
    complete: complete,
    numUploads: numUploads
  })));
}

module.exports = {
  UploadBtn,
  RetryBtn,
  CancelBtn,
  PauseResumeButton,
  DoneBtn,
  LoadingSpinner,
  ProgressDetails,
  ProgressBarProcessing,
  ProgressBarError,
  ProgressBarUploading,
  ProgressBarComplete
};

},{"./../../utils/lib/prettyETA":176,"./StatusBarStates":131,"@transloadit/prettier-bytes":1,"classnames":4,"lodash.throttle":11,"preact":18}],130:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const classNames = require('classnames');

const statusBarStates = require('./StatusBarStates');

const calculateProcessingProgress = require('./calculateProcessingProgress');

const {
  UploadBtn,
  RetryBtn,
  CancelBtn,
  PauseResumeButton,
  DoneBtn,
  ProgressBarProcessing,
  ProgressBarError,
  ProgressBarUploading,
  ProgressBarComplete
} = require('./Components');

const {
  STATE_ERROR,
  STATE_WAITING,
  STATE_PREPROCESSING,
  STATE_UPLOADING,
  STATE_POSTPROCESSING,
  STATE_COMPLETE
} = statusBarStates;
module.exports = StatusBar;

function StatusBar(props) {
  const {
    newFiles,
    allowNewUpload,
    isUploadInProgress,
    isAllPaused,
    resumableUploads,
    error,
    hideUploadButton,
    hidePauseResumeButton,
    hideCancelButton,
    hideRetryButton,
    recoveredState,
    uploadState,
    totalProgress,
    files,
    supportsUploadProgress,
    hideAfterFinish,
    isSomeGhost,
    isTargetDOMEl,
    doneButtonHandler,
    isUploadStarted,
    i18n,
    startUpload,
    uppy,
    isAllComplete,
    showProgressDetails,
    numUploads,
    complete,
    totalSize,
    totalETA,
    totalUploadedSize
  } = props;

  function getProgressValue() {
    switch (uploadState) {
      case STATE_POSTPROCESSING:
      case STATE_PREPROCESSING:
        {
          const progress = calculateProcessingProgress(files);

          if (progress.mode === 'determinate') {
            return progress.value * 100;
          }

          return totalProgress;
        }

      case STATE_ERROR:
        {
          return null;
        }

      case STATE_UPLOADING:
        {
          if (!supportsUploadProgress) {
            return null;
          }

          return totalProgress;
        }

      default:
        return totalProgress;
    }
  }

  function getIsIndeterminate() {
    switch (uploadState) {
      case STATE_POSTPROCESSING:
      case STATE_PREPROCESSING:
        {
          const {
            mode
          } = calculateProcessingProgress(files);
          return mode === 'indeterminate';
        }

      case STATE_UPLOADING:
        {
          if (!supportsUploadProgress) {
            return true;
          }

          return false;
        }

      default:
        return false;
    }
  }

  function getIsHidden() {
    if (recoveredState) {
      return false;
    }

    switch (uploadState) {
      case STATE_WAITING:
        return hideUploadButton || newFiles === 0;

      case STATE_COMPLETE:
        return hideAfterFinish;

      default:
        return false;
    }
  }

  const progressValue = getProgressValue();
  const isHidden = getIsHidden();
  const width = progressValue != null ? progressValue : 100;
  const showUploadBtn = !error && newFiles && !isUploadInProgress && !isAllPaused && allowNewUpload && !hideUploadButton;
  const showCancelBtn = !hideCancelButton && uploadState !== STATE_WAITING && uploadState !== STATE_COMPLETE;
  const showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState === STATE_UPLOADING;
  const showRetryBtn = error && !isAllComplete && !hideRetryButton;
  const showDoneBtn = doneButtonHandler && uploadState === STATE_COMPLETE;
  const progressClassNames = classNames('uppy-StatusBar-progress', {
    'is-indeterminate': getIsIndeterminate()
  });
  const statusBarClassNames = classNames({
    'uppy-Root': isTargetDOMEl
  }, 'uppy-StatusBar', `is-${uploadState}`, {
    'has-ghosts': isSomeGhost
  });
  return h("div", {
    className: statusBarClassNames,
    "aria-hidden": isHidden
  }, h("div", {
    className: progressClassNames,
    style: {
      width: `${width}%`
    },
    role: "progressbar",
    "aria-label": `${width}%`,
    "aria-valuetext": `${width}%`,
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": progressValue
  }), (() => {
    switch (uploadState) {
      case STATE_PREPROCESSING:
      case STATE_POSTPROCESSING:
        return h(ProgressBarProcessing, {
          progress: calculateProcessingProgress(files)
        });

      case STATE_COMPLETE:
        return h(ProgressBarComplete, {
          i18n: i18n
        });

      case STATE_ERROR:
        return h(ProgressBarError, {
          error: error,
          i18n: i18n,
          numUploads: numUploads,
          complete: complete
        });

      case STATE_UPLOADING:
        return h(ProgressBarUploading, {
          i18n: i18n,
          supportsUploadProgress: supportsUploadProgress,
          totalProgress: totalProgress,
          showProgressDetails: showProgressDetails,
          isUploadStarted: isUploadStarted,
          isAllComplete: isAllComplete,
          isAllPaused: isAllPaused,
          newFiles: newFiles,
          numUploads: numUploads,
          complete: complete,
          totalUploadedSize: totalUploadedSize,
          totalSize: totalSize,
          totalETA: totalETA,
          startUpload: startUpload
        });

      default:
        return null;
    }
  })(), h("div", {
    className: "uppy-StatusBar-actions"
  }, recoveredState || showUploadBtn ? h(UploadBtn, {
    newFiles: newFiles,
    isUploadStarted: isUploadStarted,
    recoveredState: recoveredState,
    i18n: i18n,
    isSomeGhost: isSomeGhost,
    startUpload: startUpload,
    uploadState: uploadState
  }) : null, showRetryBtn ? h(RetryBtn, {
    i18n: i18n,
    uppy: uppy
  }) : null, showPauseResumeBtn ? h(PauseResumeButton, {
    isAllPaused: isAllPaused,
    i18n: i18n,
    isAllComplete: isAllComplete,
    resumableUploads: resumableUploads,
    uppy: uppy
  }) : null, showCancelBtn ? h(CancelBtn, {
    i18n: i18n,
    uppy: uppy
  }) : null, showDoneBtn ? h(DoneBtn, {
    i18n: i18n,
    doneButtonHandler: doneButtonHandler
  }) : null));
}

},{"./Components":129,"./StatusBarStates":131,"./calculateProcessingProgress":132,"classnames":4,"preact":18}],131:[function(require,module,exports){
"use strict";

module.exports = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete'
};

},{}],132:[function(require,module,exports){
"use strict";

module.exports = function calculateProcessingProgress(files) {
  const values = [];
  let mode;
  let message;

  for (const {
    progress
  } of Object.values(files)) {
    const {
      preprocess,
      postprocess
    } = progress; // In the future we should probably do this differently. For now we'll take the
    // mode and message from the first file

    if (message == null && (preprocess || postprocess)) {
      ({
        mode,
        message
      } = preprocess || postprocess);
    }

    if ((preprocess == null ? void 0 : preprocess.mode) === 'determinate') values.push(preprocess.value);
    if ((postprocess == null ? void 0 : postprocess.mode) === 'determinate') values.push(postprocess.value);
  }

  const value = values.reduce((total, progressValue) => {
    return total + progressValue / values.length;
  }, 0);
  return {
    mode,
    message,
    value
  };
};

},{}],133:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const getSpeed = require('./../../utils/lib/getSpeed');

const getBytesRemaining = require('./../../utils/lib/getBytesRemaining');

const getTextDirection = require('./../../utils/lib/getTextDirection');

const statusBarStates = require('./StatusBarStates');

const StatusBarUI = require('./StatusBar');

const locale = require('./locale.js');
/**
 * StatusBar: renders a status bar with upload/pause/resume/cancel/retry buttons,
 * progress percentage and time remaining.
 */


module.exports = (_temp = _class = class StatusBar extends UIPlugin {
  // eslint-disable-next-line global-require
  constructor(uppy, opts) {
    super(uppy, opts);

    this.startUpload = () => {
      const {
        recoveredState
      } = this.uppy.getState();

      if (recoveredState) {
        this.uppy.emit('restore-confirmed');
        return undefined;
      }

      return this.uppy.upload().catch(() => {// Error logged in Core
      });
    };

    this.id = this.opts.id || 'StatusBar';
    this.title = 'StatusBar';
    this.type = 'progressindicator';
    this.defaultLocale = locale; // set default options

    const defaultOptions = {
      target: 'body',
      hideUploadButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideCancelButton: false,
      showProgressDetails: false,
      hideAfterFinish: true,
      doneButtonHandler: null
    };
    this.opts = { ...defaultOptions,
      ...opts
    };
    this.i18nInit();
    this.render = this.render.bind(this);
    this.install = this.install.bind(this);
  }

  render(state) {
    const {
      capabilities,
      files,
      allowNewUpload,
      totalProgress,
      error,
      recoveredState
    } = state;
    const {
      newFiles,
      startedFiles,
      completeFiles,
      inProgressNotPausedFiles,
      isUploadStarted,
      isAllComplete,
      isAllErrored,
      isAllPaused,
      isUploadInProgress,
      isSomeGhost
    } = this.uppy.getObjectOfFilesPerState(); // If some state was recovered, we want to show Upload button/counter
    // for all the files, because in this case its not an Upload button,
    // but Confirm Restore Button

    const newFilesOrRecovered = recoveredState ? Object.values(files) : newFiles;
    const totalETA = getTotalETA(inProgressNotPausedFiles);
    const resumableUploads = !!capabilities.resumableUploads;
    const supportsUploadProgress = capabilities.uploadProgress !== false;
    let totalSize = 0;
    let totalUploadedSize = 0;
    startedFiles.forEach(file => {
      totalSize += file.progress.bytesTotal || 0;
      totalUploadedSize += file.progress.bytesUploaded || 0;
    });
    return StatusBarUI({
      error,
      uploadState: getUploadingState(error, isAllComplete, recoveredState, state.files || {}),
      allowNewUpload,
      totalProgress,
      totalSize,
      totalUploadedSize,
      isAllComplete: false,
      isAllPaused,
      isAllErrored,
      isUploadStarted,
      isUploadInProgress,
      isSomeGhost,
      recoveredState,
      complete: completeFiles.length,
      newFiles: newFilesOrRecovered.length,
      numUploads: startedFiles.length,
      totalETA,
      files,
      i18n: this.i18n,
      uppy: this.uppy,
      startUpload: this.startUpload,
      doneButtonHandler: this.opts.doneButtonHandler,
      resumableUploads,
      supportsUploadProgress,
      showProgressDetails: this.opts.showProgressDetails,
      hideUploadButton: this.opts.hideUploadButton,
      hideRetryButton: this.opts.hideRetryButton,
      hidePauseResumeButton: this.opts.hidePauseResumeButton,
      hideCancelButton: this.opts.hideCancelButton,
      hideAfterFinish: this.opts.hideAfterFinish,
      isTargetDOMEl: this.isTargetDOMEl
    });
  }

  onMount() {
    // Set the text direction if the page has not defined one.
    const element = this.el;
    const direction = getTextDirection(element);

    if (!direction) {
      element.dir = 'ltr';
    }
  }

  install() {
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.unmount();
  }

}, _class.VERSION = "2.1.1", _temp);

function getTotalSpeed(files) {
  let totalSpeed = 0;
  files.forEach(file => {
    totalSpeed += getSpeed(file.progress);
  });
  return totalSpeed;
}

function getTotalETA(files) {
  const totalSpeed = getTotalSpeed(files);

  if (totalSpeed === 0) {
    return 0;
  }

  const totalBytesRemaining = files.reduce((total, file) => {
    return total + getBytesRemaining(file.progress);
  }, 0);
  return Math.round(totalBytesRemaining / totalSpeed * 10) / 10;
}

function getUploadingState(error, isAllComplete, recoveredState, files) {
  if (error && !isAllComplete) {
    return statusBarStates.STATE_ERROR;
  }

  if (isAllComplete) {
    return statusBarStates.STATE_COMPLETE;
  }

  if (recoveredState) {
    return statusBarStates.STATE_WAITING;
  }

  let state = statusBarStates.STATE_WAITING;
  const fileIDs = Object.keys(files);

  for (let i = 0; i < fileIDs.length; i++) {
    const {
      progress
    } = files[fileIDs[i]]; // If ANY files are being uploaded right now, show the uploading state.

    if (progress.uploadStarted && !progress.uploadComplete) {
      return statusBarStates.STATE_UPLOADING;
    } // If files are being preprocessed AND postprocessed at this time, we show the
    // preprocess state. If any files are being uploaded we show uploading.


    if (progress.preprocess && state !== statusBarStates.STATE_UPLOADING) {
      state = statusBarStates.STATE_PREPROCESSING;
    } // If NO files are being preprocessed or uploaded right now, but some files are
    // being postprocessed, show the postprocess state.


    if (progress.postprocess && state !== statusBarStates.STATE_UPLOADING && state !== statusBarStates.STATE_PREPROCESSING) {
      state = statusBarStates.STATE_POSTPROCESSING;
    }
  }

  return state;
}

},{"./../../core":48,"./../../utils/lib/getBytesRemaining":156,"./../../utils/lib/getSpeed":166,"./../../utils/lib/getTextDirection":167,"./StatusBar":130,"./StatusBarStates":131,"./locale.js":134}],134:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    // Shown in the status bar while files are being uploaded.
    uploading: 'Uploading',
    // Shown in the status bar once all files have been uploaded.
    complete: 'Complete',
    // Shown in the status bar if an upload failed.
    uploadFailed: 'Upload failed',
    // Shown in the status bar while the upload is paused.
    paused: 'Paused',
    // Used as the label for the button that retries an upload.
    retry: 'Retry',
    // Used as the label for the button that cancels an upload.
    cancel: 'Cancel',
    // Used as the label for the button that pauses an upload.
    pause: 'Pause',
    // Used as the label for the button that resumes an upload.
    resume: 'Resume',
    // Used as the label for the button that resets the upload state after an upload
    done: 'Done',
    // When `showProgressDetails` is set, shows the number of files that have been fully uploaded so far.
    filesUploadedOfTotal: {
      0: '%{complete} of %{smart_count} file uploaded',
      1: '%{complete} of %{smart_count} files uploaded'
    },
    // When `showProgressDetails` is set, shows the amount of bytes that have been uploaded so far.
    dataUploadedOfTotal: '%{complete} of %{total}',
    // When `showProgressDetails` is set, shows an estimation of how long the upload will take to complete.
    xTimeLeft: '%{time} left',
    // Used as the label for the button that starts an upload.
    uploadXFiles: {
      0: 'Upload %{smart_count} file',
      1: 'Upload %{smart_count} files'
    },
    // Used as the label for the button that starts an upload, if another upload has been started in the past
    // and new files were added later.
    uploadXNewFiles: {
      0: 'Upload +%{smart_count} file',
      1: 'Upload +%{smart_count} files'
    },
    upload: 'Upload',
    retryUpload: 'Retry upload',
    xMoreFilesAdded: {
      0: '%{smart_count} more file added',
      1: '%{smart_count} more files added'
    },
    showErrorDetails: 'Show error details'
  }
};

},{}],135:[function(require,module,exports){
"use strict";

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

var _publish = /*#__PURE__*/_classPrivateFieldLooseKey("publish");

/**
 * Default store that keeps state in a simple object.
 */
class DefaultStore {
  constructor() {
    Object.defineProperty(this, _publish, {
      value: _publish2
    });
    this.state = {};
    this.callbacks = [];
  }

  getState() {
    return this.state;
  }

  setState(patch) {
    const prevState = { ...this.state
    };
    const nextState = { ...this.state,
      ...patch
    };
    this.state = nextState;

    _classPrivateFieldLooseBase(this, _publish)[_publish](prevState, nextState, patch);
  }

  subscribe(listener) {
    this.callbacks.push(listener);
    return () => {
      // Remove the listener.
      this.callbacks.splice(this.callbacks.indexOf(listener), 1);
    };
  }

}

function _publish2(...args) {
  this.callbacks.forEach(listener => {
    listener(...args);
  });
}

DefaultStore.VERSION = "2.0.2";

module.exports = function defaultStore() {
  return new DefaultStore();
};

},{}],136:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const dataURItoBlob = require('./../../utils/lib/dataURItoBlob');

const isObjectURL = require('./../../utils/lib/isObjectURL');

const isPreviewSupported = require('./../../utils/lib/isPreviewSupported');

const exifr = require('exifr/dist/mini.legacy.umd.js');

const locale = require('./locale');
/**
 * The Thumbnail Generator plugin
 */


module.exports = (_temp = _class = class ThumbnailGenerator extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);

    this.onFileAdded = file => {
      if (!file.preview && file.data && isPreviewSupported(file.type) && !file.isRemote) {
        this.addToQueue(file.id);
      }
    };

    this.onCancelRequest = file => {
      const index = this.queue.indexOf(file.id);

      if (index !== -1) {
        this.queue.splice(index, 1);
      }
    };

    this.onFileRemoved = file => {
      const index = this.queue.indexOf(file.id);

      if (index !== -1) {
        this.queue.splice(index, 1);
      } // Clean up object URLs.


      if (file.preview && isObjectURL(file.preview)) {
        URL.revokeObjectURL(file.preview);
      }
    };

    this.onRestored = () => {
      const restoredFiles = this.uppy.getFiles().filter(file => file.isRestored);
      restoredFiles.forEach(file => {
        // Only add blob URLs; they are likely invalid after being restored.
        if (!file.preview || isObjectURL(file.preview)) {
          this.addToQueue(file.id);
        }
      });
    };

    this.waitUntilAllProcessed = fileIDs => {
      fileIDs.forEach(fileID => {
        const file = this.uppy.getFile(fileID);
        this.uppy.emit('preprocess-progress', file, {
          mode: 'indeterminate',
          message: this.i18n('generatingThumbnails')
        });
      });

      const emitPreprocessCompleteForAll = () => {
        fileIDs.forEach(fileID => {
          const file = this.uppy.getFile(fileID);
          this.uppy.emit('preprocess-complete', file);
        });
      };

      return new Promise(resolve => {
        if (this.queueProcessing) {
          this.uppy.once('thumbnail:all-generated', () => {
            emitPreprocessCompleteForAll();
            resolve();
          });
        } else {
          emitPreprocessCompleteForAll();
          resolve();
        }
      });
    };

    this.type = 'modifier';
    this.id = this.opts.id || 'ThumbnailGenerator';
    this.title = 'Thumbnail Generator';
    this.queue = [];
    this.queueProcessing = false;
    this.defaultThumbnailDimension = 200;
    this.thumbnailType = this.opts.thumbnailType || 'image/jpeg';
    this.defaultLocale = locale;
    const defaultOptions = {
      thumbnailWidth: null,
      thumbnailHeight: null,
      waitForThumbnailsBeforeUpload: false,
      lazy: false
    };
    this.opts = { ...defaultOptions,
      ...opts
    };
    this.i18nInit();

    if (this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload) {
      throw new Error('ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.');
    }
  }
  /**
   * Create a thumbnail for the given Uppy file object.
   *
   * @param {{data: Blob}} file
   * @param {number} targetWidth
   * @param {number} targetHeight
   * @returns {Promise}
   */


  createThumbnail(file, targetWidth, targetHeight) {
    const originalUrl = URL.createObjectURL(file.data);
    const onload = new Promise((resolve, reject) => {
      const image = new Image();
      image.src = originalUrl;
      image.addEventListener('load', () => {
        URL.revokeObjectURL(originalUrl);
        resolve(image);
      });
      image.addEventListener('error', event => {
        URL.revokeObjectURL(originalUrl);
        reject(event.error || new Error('Could not create thumbnail'));
      });
    });
    const orientationPromise = exifr.rotation(file.data).catch(() => 1);
    return Promise.all([onload, orientationPromise]).then(([image, orientation]) => {
      const dimensions = this.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);
      const rotatedImage = this.rotateImage(image, orientation);
      const resizedImage = this.resizeImage(rotatedImage, dimensions.width, dimensions.height);
      return this.canvasToBlob(resizedImage, this.thumbnailType, 80);
    }).then(blob => {
      return URL.createObjectURL(blob);
    });
  }
  /**
   * Get the new calculated dimensions for the given image and a target width
   * or height. If both width and height are given, only width is taken into
   * account. If neither width nor height are given, the default dimension
   * is used.
   */


  getProportionalDimensions(img, width, height, rotation) {
    let aspect = img.width / img.height;

    if (rotation === 90 || rotation === 270) {
      aspect = img.height / img.width;
    }

    if (width != null) {
      return {
        width,
        height: Math.round(width / aspect)
      };
    }

    if (height != null) {
      return {
        width: Math.round(height * aspect),
        height
      };
    }

    return {
      width: this.defaultThumbnailDimension,
      height: Math.round(this.defaultThumbnailDimension / aspect)
    };
  }
  /**
   * Make sure the image doesnt exceed browser/device canvas limits.
   * For ios with 256 RAM and ie
   */


  protect(image) {
    // https://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
    const ratio = image.width / image.height;
    const maxSquare = 5000000; // ios max canvas square

    const maxSize = 4096; // ie max canvas dimensions

    let maxW = Math.floor(Math.sqrt(maxSquare * ratio));
    let maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));

    if (maxW > maxSize) {
      maxW = maxSize;
      maxH = Math.round(maxW / ratio);
    }

    if (maxH > maxSize) {
      maxH = maxSize;
      maxW = Math.round(ratio * maxH);
    }

    if (image.width > maxW) {
      const canvas = document.createElement('canvas');
      canvas.width = maxW;
      canvas.height = maxH;
      canvas.getContext('2d').drawImage(image, 0, 0, maxW, maxH);
      image = canvas;
    }

    return image;
  }
  /**
   * Resize an image to the target `width` and `height`.
   *
   * Returns a Canvas with the resized image on it.
   */


  resizeImage(image, targetWidth, targetHeight) {
    // Resizing in steps refactored to use a solution from
    // https://blog.uploadcare.com/image-resize-in-browsers-is-broken-e38eed08df01
    image = this.protect(image);
    let steps = Math.ceil(Math.log2(image.width / targetWidth));

    if (steps < 1) {
      steps = 1;
    }

    let sW = targetWidth * 2 ** (steps - 1);
    let sH = targetHeight * 2 ** (steps - 1);
    const x = 2;

    while (steps--) {
      const canvas = document.createElement('canvas');
      canvas.width = sW;
      canvas.height = sH;
      canvas.getContext('2d').drawImage(image, 0, 0, sW, sH);
      image = canvas;
      sW = Math.round(sW / x);
      sH = Math.round(sH / x);
    }

    return image;
  }

  rotateImage(image, translate) {
    let w = image.width;
    let h = image.height;

    if (translate.deg === 90 || translate.deg === 270) {
      w = image.height;
      h = image.width;
    }

    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const context = canvas.getContext('2d');
    context.translate(w / 2, h / 2);

    if (translate.canvas) {
      context.rotate(translate.rad);
      context.scale(translate.scaleX, translate.scaleY);
    }

    context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
    return canvas;
  }
  /**
   * Save a <canvas> element's content to a Blob object.
   *
   * @param {HTMLCanvasElement} canvas
   * @returns {Promise}
   */


  canvasToBlob(canvas, type, quality) {
    try {
      canvas.getContext('2d').getImageData(0, 0, 1, 1);
    } catch (err) {
      if (err.code === 18) {
        return Promise.reject(new Error('cannot read image, probably an svg with external resources'));
      }
    }

    if (canvas.toBlob) {
      return new Promise(resolve => {
        canvas.toBlob(resolve, type, quality);
      }).then(blob => {
        if (blob === null) {
          throw new Error('cannot read image, probably an svg with external resources');
        }

        return blob;
      });
    }

    return Promise.resolve().then(() => {
      return dataURItoBlob(canvas.toDataURL(type, quality), {});
    }).then(blob => {
      if (blob === null) {
        throw new Error('could not extract blob, probably an old browser');
      }

      return blob;
    });
  }
  /**
   * Set the preview URL for a file.
   */


  setPreviewURL(fileID, preview) {
    this.uppy.setFileState(fileID, {
      preview
    });
  }

  addToQueue(item) {
    this.queue.push(item);

    if (this.queueProcessing === false) {
      this.processQueue();
    }
  }

  processQueue() {
    this.queueProcessing = true;

    if (this.queue.length > 0) {
      const current = this.uppy.getFile(this.queue.shift());

      if (!current) {
        this.uppy.log('[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug', 'error');
        return;
      }

      return this.requestThumbnail(current).catch(() => {}) // eslint-disable-line node/handle-callback-err
      .then(() => this.processQueue());
    }

    this.queueProcessing = false;
    this.uppy.log('[ThumbnailGenerator] Emptied thumbnail queue');
    this.uppy.emit('thumbnail:all-generated');
  }

  requestThumbnail(file) {
    if (isPreviewSupported(file.type) && !file.isRemote) {
      return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then(preview => {
        this.setPreviewURL(file.id, preview);
        this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${file.id}`);
        this.uppy.emit('thumbnail:generated', this.uppy.getFile(file.id), preview);
      }).catch(err => {
        this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${file.id}:`, 'warning');
        this.uppy.log(err, 'warning');
        this.uppy.emit('thumbnail:error', this.uppy.getFile(file.id), err);
      });
    }

    return Promise.resolve();
  }

  install() {
    this.uppy.on('file-removed', this.onFileRemoved);

    if (this.opts.lazy) {
      this.uppy.on('thumbnail:request', this.onFileAdded);
      this.uppy.on('thumbnail:cancel', this.onCancelRequest);
    } else {
      this.uppy.on('file-added', this.onFileAdded);
      this.uppy.on('restored', this.onRestored);
    }

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.addPreProcessor(this.waitUntilAllProcessed);
    }
  }

  uninstall() {
    this.uppy.off('file-removed', this.onFileRemoved);

    if (this.opts.lazy) {
      this.uppy.off('thumbnail:request', this.onFileAdded);
      this.uppy.off('thumbnail:cancel', this.onCancelRequest);
    } else {
      this.uppy.off('file-added', this.onFileAdded);
      this.uppy.off('restored', this.onRestored);
    }

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.removePreProcessor(this.waitUntilAllProcessed);
    }
  }

}, _class.VERSION = "2.0.5", _temp);

},{"./../../core":48,"./../../utils/lib/dataURItoBlob":150,"./../../utils/lib/isObjectURL":173,"./../../utils/lib/isPreviewSupported":174,"./locale":137,"exifr/dist/mini.legacy.umd.js":6}],137:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    generatingThumbnails: 'Generating thumbnails...'
  }
};

},{}],138:[function(require,module,exports){
"use strict";

const tus = require('tus-js-client');

function isCordova() {
  return typeof window !== 'undefined' && (typeof window.PhoneGap !== 'undefined' || typeof window.Cordova !== 'undefined' || typeof window.cordova !== 'undefined');
}

function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
} // We override tus fingerprint to uppys `file.id`, since the `file.id`
// now also includes `relativePath` for files added from folders.
// This means you can add 2 identical files, if one is in folder a,
// the other in folder b  `a/file.jpg` and `b/file.jpg`, when added
// together with a folder, will be treated as 2 separate files.
//
// For React Native and Cordova, we let tus-js-clients default
// fingerprint handling take charge.


module.exports = function getFingerprint(uppyFileObj) {
  return (file, options) => {
    if (isCordova() || isReactNative()) {
      return tus.defaultOptions.fingerprint(file, options);
    }

    const uppyFingerprint = ['tus', uppyFileObj.id, options.endpoint].join('-');
    return Promise.resolve(uppyFingerprint);
  };
};

},{"tus-js-client":25}],139:[function(require,module,exports){
"use strict";

var _class, _temp;

const BasePlugin = require('./../../core/lib/BasePlugin');

const tus = require('tus-js-client');

const {
  Provider,
  RequestClient,
  Socket
} = require('./../../companion-client');

const emitSocketProgress = require('./../../utils/lib/emitSocketProgress');

const getSocketHost = require('./../../utils/lib/getSocketHost');

const settle = require('./../../utils/lib/settle');

const EventTracker = require('./../../utils/lib/EventTracker');

const NetworkError = require('./../../utils/lib/NetworkError');

const isNetworkError = require('./../../utils/lib/isNetworkError');

const {
  RateLimitedQueue
} = require('./../../utils/lib/RateLimitedQueue');

const hasProperty = require('./../../utils/lib/hasProperty');

const getFingerprint = require('./getFingerprint');
/** @typedef {import('..').TusOptions} TusOptions */

/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */

/** @typedef {import('@uppy/core').Uppy} Uppy */

/** @typedef {import('@uppy/core').UppyFile} UppyFile */

/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */

/**
 * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13
 * excepted we removed 'fingerprint' key to avoid adding more dependencies
 *
 * @type {RawTusOptions}
 */


const tusDefaultOptions = {
  endpoint: '',
  uploadUrl: null,
  metadata: {},
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false
};
/**
 * Tus resumable file uploader
 */

module.exports = (_temp = _class = class Tus extends BasePlugin {
  /**
   * @param {Uppy} uppy
   * @param {TusOptions} opts
   */
  constructor(uppy, opts) {
    super(uppy, opts);
    this.type = 'uploader';
    this.id = this.opts.id || 'Tus';
    this.title = 'Tus'; // set default options

    const defaultOptions = {
      useFastRemoteRetry: true,
      limit: 5,
      retryDelays: [0, 1000, 3000, 5000],
      withCredentials: false
    }; // merge default options with the ones set by user

    /** @type {import("..").TusOptions} */

    this.opts = { ...defaultOptions,
      ...opts
    };

    if ('autoRetry' in opts) {
      throw new Error('The `autoRetry` option was deprecated and has been removed.');
    }
    /**
     * Simultaneous upload limiting is shared across all uploads with this plugin.
     *
     * @type {RateLimitedQueue}
     */


    this.requests = new RateLimitedQueue(this.opts.limit);
    this.uploaders = Object.create(null);
    this.uploaderEvents = Object.create(null);
    this.uploaderSockets = Object.create(null);
    this.handleResetProgress = this.handleResetProgress.bind(this);
    this.handleUpload = this.handleUpload.bind(this);
  }

  handleResetProgress() {
    const files = { ...this.uppy.getState().files
    };
    Object.keys(files).forEach(fileID => {
      // Only clone the file object if it has a Tus `uploadUrl` attached.
      if (files[fileID].tus && files[fileID].tus.uploadUrl) {
        const tusState = { ...files[fileID].tus
        };
        delete tusState.uploadUrl;
        files[fileID] = { ...files[fileID],
          tus: tusState
        };
      }
    });
    this.uppy.setState({
      files
    });
  }
  /**
   * Clean up all references for a file's upload: the tus.Upload instance,
   * any events related to the file, and the Companion WebSocket connection.
   *
   * @param {string} fileID
   */


  resetUploaderReferences(fileID, opts = {}) {
    if (this.uploaders[fileID]) {
      const uploader = this.uploaders[fileID];
      uploader.abort();

      if (opts.abort) {
        uploader.abort(true);
      }

      this.uploaders[fileID] = null;
    }

    if (this.uploaderEvents[fileID]) {
      this.uploaderEvents[fileID].remove();
      this.uploaderEvents[fileID] = null;
    }

    if (this.uploaderSockets[fileID]) {
      this.uploaderSockets[fileID].close();
      this.uploaderSockets[fileID] = null;
    }
  }
  /**
   * Create a new Tus upload.
   *
   * A lot can happen during an upload, so this is quite hard to follow!
   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.
   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.
   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners
   *   for pausing, cancellation, removal, etc.
   * - While the upload is in progress, it may be paused or cancelled.
   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is
   *   maintained.
   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload-- the `tus.Upload`
   *   instance is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).
   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from
   *   bypassing the limit.
   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done
   *   in the `this.requests` queue.
   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is
   *   rejected.
   *
   * When working on this function, keep in mind:
   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned
   *    up using this.resetUploaderReferences().
   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using
   *    `queuedRequest.abort()`.
   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using
   *    `queuedRequest.done()`.
   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable
   *    must be updated so the other uses of it are valid.
   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking
   *    up a spot in the queue.
   *
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */


  upload(file) {
    this.resetUploaderReferences(file.id); // Create a new tus upload

    return new Promise((resolve, reject) => {
      this.uppy.emit('upload-started', file);
      const opts = { ...this.opts,
        ...(file.tus || {})
      };

      if (typeof opts.headers === 'function') {
        opts.headers = opts.headers(file);
      }
      /** @type {RawTusOptions} */


      const uploadOptions = { ...tusDefaultOptions,
        ...opts
      }; // We override tus fingerprint to uppys `file.id`, since the `file.id`
      // now also includes `relativePath` for files added from folders.
      // This means you can add 2 identical files, if one is in folder a,
      // the other in folder b.

      uploadOptions.fingerprint = getFingerprint(file);

      uploadOptions.onBeforeRequest = req => {
        const xhr = req.getUnderlyingObject();
        xhr.withCredentials = !!opts.withCredentials;

        if (typeof opts.onBeforeRequest === 'function') {
          opts.onBeforeRequest(req);
        }
      };

      uploadOptions.onError = err => {
        this.uppy.log(err);
        const xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;

        if (isNetworkError(xhr)) {
          err = new NetworkError(err, xhr);
        }

        this.resetUploaderReferences(file.id);
        queuedRequest.done();
        this.uppy.emit('upload-error', file, err);
        reject(err);
      };

      uploadOptions.onProgress = (bytesUploaded, bytesTotal) => {
        this.onReceiveUploadUrl(file, upload.url);
        this.uppy.emit('upload-progress', file, {
          uploader: this,
          bytesUploaded,
          bytesTotal
        });
      };

      uploadOptions.onSuccess = () => {
        const uploadResp = {
          uploadURL: upload.url
        };
        this.resetUploaderReferences(file.id);
        queuedRequest.done();
        this.uppy.emit('upload-success', file, uploadResp);

        if (upload.url) {
          this.uppy.log(`Download ${upload.file.name} from ${upload.url}`);
        }

        resolve(upload);
      };

      const copyProp = (obj, srcProp, destProp) => {
        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {
          obj[destProp] = obj[srcProp];
        }
      };
      /** @type {Record<string, string>} */


      const meta = {};
      const metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.
      : Object.keys(file.meta);
      metaFields.forEach(item => {
        meta[item] = file.meta[item];
      }); // tusd uses metadata fields 'filetype' and 'filename'

      copyProp(meta, 'type', 'filetype');
      copyProp(meta, 'name', 'filename');
      uploadOptions.metadata = meta;
      const upload = new tus.Upload(file.data, uploadOptions);
      this.uploaders[file.id] = upload;
      this.uploaderEvents[file.id] = new EventTracker(this.uppy);
      upload.findPreviousUploads().then(previousUploads => {
        const previousUpload = previousUploads[0];

        if (previousUpload) {
          this.uppy.log(`[Tus] Resuming upload of ${file.id} started at ${previousUpload.creationTime}`);
          upload.resumeFromPreviousUpload(previousUpload);
        }
      });
      let queuedRequest = this.requests.run(() => {
        if (!file.isPaused) {
          upload.start();
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return () => {};
      });
      this.onFileRemove(file.id, targetFileID => {
        queuedRequest.abort();
        this.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });
        resolve(`upload ${targetFileID} was removed`);
      });
      this.onPause(file.id, isPaused => {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          upload.abort();
        } else {
          // Resuming an upload should be queued, else you could pause and then
          // resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = this.requests.run(() => {
            upload.start();
            return () => {};
          });
        }
      });
      this.onPauseAll(file.id, () => {
        queuedRequest.abort();
        upload.abort();
      });
      this.onCancelAll(file.id, () => {
        queuedRequest.abort();
        this.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });
        resolve(`upload ${file.id} was canceled`);
      });
      this.onResumeAll(file.id, () => {
        queuedRequest.abort();

        if (file.error) {
          upload.abort();
        }

        queuedRequest = this.requests.run(() => {
          upload.start();
          return () => {};
        });
      });
    }).catch(err => {
      this.uppy.emit('upload-error', file, err);
      throw err;
    });
  }
  /**
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */


  uploadRemote(file) {
    this.resetUploaderReferences(file.id);
    const opts = { ...this.opts
    };

    if (file.tus) {
      // Install file-specific upload overrides.
      Object.assign(opts, file.tus);
    }

    this.uppy.emit('upload-started', file);
    this.uppy.log(file.remote.url);

    if (file.serverToken) {
      return this.connectToServerSocket(file);
    }

    return new Promise((resolve, reject) => {
      const Client = file.remote.providerOptions.provider ? Provider : RequestClient;
      const client = new Client(this.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet

      client.post(file.remote.url, { ...file.remote.body,
        endpoint: opts.endpoint,
        uploadUrl: opts.uploadUrl,
        protocol: 'tus',
        size: file.data.size,
        headers: opts.headers,
        metadata: file.meta
      }).then(res => {
        this.uppy.setFileState(file.id, {
          serverToken: res.token
        });
        file = this.uppy.getFile(file.id);
        return this.connectToServerSocket(file);
      }).then(() => {
        resolve();
      }).catch(err => {
        this.uppy.emit('upload-error', file, err);
        reject(err);
      });
    });
  }
  /**
   * See the comment on the upload() method.
   *
   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is
   * handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().
   *
   * @param {UppyFile} file
   */


  connectToServerSocket(file) {
    return new Promise((resolve, reject) => {
      const token = file.serverToken;
      const host = getSocketHost(file.remote.companionUrl);
      const socket = new Socket({
        target: `${host}/api/${token}`,
        autoOpen: false
      });
      this.uploaderSockets[file.id] = socket;
      this.uploaderEvents[file.id] = new EventTracker(this.uppy);
      this.onFileRemove(file.id, () => {
        queuedRequest.abort();
        socket.send('cancel', {});
        this.resetUploaderReferences(file.id);
        resolve(`upload ${file.id} was removed`);
      });
      this.onPause(file.id, isPaused => {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          socket.send('pause', {});
        } else {
          // Resuming an upload should be queued, else you could pause and then
          // resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = this.requests.run(() => {
            socket.send('resume', {});
            return () => {};
          });
        }
      });
      this.onPauseAll(file.id, () => {
        queuedRequest.abort();
        socket.send('pause', {});
      });
      this.onCancelAll(file.id, () => {
        queuedRequest.abort();
        socket.send('cancel', {});
        this.resetUploaderReferences(file.id);
        resolve(`upload ${file.id} was canceled`);
      });
      this.onResumeAll(file.id, () => {
        queuedRequest.abort();

        if (file.error) {
          socket.send('pause', {});
        }

        queuedRequest = this.requests.run(() => {
          socket.send('resume', {});
          return () => {};
        });
      });
      this.onRetry(file.id, () => {
        // Only do the retry if the upload is actually in progress;
        // else we could try to send these messages when the upload is still queued.
        // We may need a better check for this since the socket may also be closed
        // for other reasons, like network failures.
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });
      this.onRetryAll(file.id, () => {
        // See the comment in the onRetry() call
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });
      socket.on('progress', progressData => emitSocketProgress(this, progressData, file));
      socket.on('error', errData => {
        const {
          message
        } = errData.error;
        const error = Object.assign(new Error(message), {
          cause: errData.error
        }); // If the remote retry optimisation should not be used,
        // close the socketthis will tell companion to clear state and delete the file.

        if (!this.opts.useFastRemoteRetry) {
          this.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.

          this.uppy.setFileState(file.id, {
            serverToken: null
          });
        } else {
          socket.close();
        }

        this.uppy.emit('upload-error', file, error);
        queuedRequest.done();
        reject(error);
      });
      socket.on('success', data => {
        const uploadResp = {
          uploadURL: data.url
        };
        this.uppy.emit('upload-success', file, uploadResp);
        this.resetUploaderReferences(file.id);
        queuedRequest.done();
        resolve();
      });
      let queuedRequest = this.requests.run(() => {
        socket.open();

        if (file.isPaused) {
          socket.send('pause', {});
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return () => {};
      });
    });
  }
  /**
   * Store the uploadUrl on the file options, so that when Golden Retriever
   * restores state, we will continue uploading to the correct URL.
   *
   * @param {UppyFile} file
   * @param {string} uploadURL
   */


  onReceiveUploadUrl(file, uploadURL) {
    const currentFile = this.uppy.getFile(file.id);
    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.

    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {
      this.uppy.log('[Tus] Storing upload url');
      this.uppy.setFileState(currentFile.id, {
        tus: { ...currentFile.tus,
          uploadUrl: uploadURL
        }
      });
    }
  }
  /**
   * @param {string} fileID
   * @param {function(string): void} cb
   */


  onFileRemove(fileID, cb) {
    this.uploaderEvents[fileID].on('file-removed', file => {
      if (fileID === file.id) cb(file.id);
    });
  }
  /**
   * @param {string} fileID
   * @param {function(boolean): void} cb
   */


  onPause(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-pause', (targetFileID, isPaused) => {
      if (fileID === targetFileID) {
        // const isPaused = this.uppy.pauseResume(fileID)
        cb(isPaused);
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */


  onRetry(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-retry', targetFileID => {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */


  onRetryAll(fileID, cb) {
    this.uploaderEvents[fileID].on('retry-all', () => {
      if (!this.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */


  onPauseAll(fileID, cb) {
    this.uploaderEvents[fileID].on('pause-all', () => {
      if (!this.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */


  onCancelAll(fileID, cb) {
    this.uploaderEvents[fileID].on('cancel-all', () => {
      if (!this.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */


  onResumeAll(fileID, cb) {
    this.uploaderEvents[fileID].on('resume-all', () => {
      if (!this.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {(UppyFile | FailedUppyFile)[]} files
   */


  uploadFiles(files) {
    const promises = files.map((file, i) => {
      const current = i + 1;
      const total = files.length;

      if ('error' in file && file.error) {
        return Promise.reject(new Error(file.error));
      }

      if (file.isRemote) {
        // We emit upload-started here, so that it's also emitted for files
        // that have to wait due to the `limit` option.
        // Don't double-emit upload-started for Golden Retriever-restored files that were already started
        if (!file.progress.uploadStarted || !file.isRestored) {
          this.uppy.emit('upload-started', file);
        }

        return this.uploadRemote(file, current, total);
      } // Don't double-emit upload-started for Golden Retriever-restored files that were already started


      if (!file.progress.uploadStarted || !file.isRestored) {
        this.uppy.emit('upload-started', file);
      }

      return this.upload(file, current, total);
    });
    return settle(promises);
  }
  /**
   * @param {string[]} fileIDs
   */


  handleUpload(fileIDs) {
    if (fileIDs.length === 0) {
      this.uppy.log('[Tus] No files to upload');
      return Promise.resolve();
    }

    if (this.opts.limit === 0) {
      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');
    }

    this.uppy.log('[Tus] Uploading...');
    const filesToUpload = fileIDs.map(fileID => this.uppy.getFile(fileID));
    return this.uploadFiles(filesToUpload).then(() => null);
  }

  install() {
    this.uppy.setState({
      capabilities: { ...this.uppy.getState().capabilities,
        resumableUploads: true
      }
    });
    this.uppy.addUploader(this.handleUpload);
    this.uppy.on('reset-progress', this.handleResetProgress);
  }

  uninstall() {
    this.uppy.setState({
      capabilities: { ...this.uppy.getState().capabilities,
        resumableUploads: false
      }
    });
    this.uppy.removeUploader(this.handleUpload);
  }

}, _class.VERSION = "2.1.1", _temp);

},{"./../../companion-client":42,"./../../core/lib/BasePlugin":44,"./../../utils/lib/EventTracker":144,"./../../utils/lib/NetworkError":146,"./../../utils/lib/RateLimitedQueue":147,"./../../utils/lib/emitSocketProgress":151,"./../../utils/lib/getSocketHost":165,"./../../utils/lib/hasProperty":169,"./../../utils/lib/isNetworkError":172,"./../../utils/lib/settle":179,"./getFingerprint":138,"tus-js-client":25}],140:[function(require,module,exports){
"use strict";

const {
  h,
  Component
} = require('preact');

class UrlUI extends Component {
  constructor(props) {
    super(props);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleClick = this.handleClick.bind(this);
  }

  componentDidMount() {
    this.input.value = '';
  }

  handleKeyPress(ev) {
    if (ev.keyCode === 13) {
      this.props.addFile(this.input.value);
    }
  }

  handleClick() {
    this.props.addFile(this.input.value);
  }

  render() {
    return h("div", {
      className: "uppy-Url"
    }, h("input", {
      className: "uppy-u-reset uppy-c-textInput uppy-Url-input",
      type: "text",
      "aria-label": this.props.i18n('enterUrlToImport'),
      placeholder: this.props.i18n('enterUrlToImport'),
      onKeyUp: this.handleKeyPress,
      ref: input => {
        this.input = input;
      },
      "data-uppy-super-focusable": true
    }), h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Url-importButton",
      type: "button",
      onClick: this.handleClick
    }, this.props.i18n('import')));
  }

}

module.exports = UrlUI;

},{"preact":18}],141:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const {
  h
} = require('preact');

const {
  RequestClient
} = require('./../../companion-client');

const UrlUI = require('./UrlUI.js');

const toArray = require('./../../utils/lib/toArray');

const forEachDroppedOrPastedUrl = require('./utils/forEachDroppedOrPastedUrl');

const locale = require('./locale');

function UrlIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("rect", {
    className: "uppy-ProviderIconBg",
    fill: "#FF753E",
    width: "32",
    height: "32",
    rx: "16"
  }), h("path", {
    d: "M22.788 15.389l-2.199 2.19a3.184 3.184 0 0 1-.513.437c-.806.584-1.686.876-2.638.876a4.378 4.378 0 0 1-3.519-1.752c-.22-.292-.146-.802.147-1.021.293-.22.806-.146 1.026.146.953 1.313 2.785 1.532 4.105.583a.571.571 0 0 0 .293-.292l2.199-2.189c1.1-1.167 1.1-2.992-.073-4.086a2.976 2.976 0 0 0-4.105 0l-1.246 1.24a.71.71 0 0 1-1.026 0 .703.703 0 0 1 0-1.022l1.246-1.24a4.305 4.305 0 0 1 6.083 0c1.833 1.605 1.906 4.451.22 6.13zm-7.183 5.035l-1.246 1.24a2.976 2.976 0 0 1-4.105 0c-1.172-1.094-1.172-2.991-.073-4.086l2.2-2.19.292-.291c.66-.438 1.393-.657 2.2-.584.805.146 1.465.51 1.905 1.168.22.292.733.365 1.026.146.293-.22.367-.73.147-1.022-.733-.949-1.76-1.532-2.859-1.678-1.1-.22-2.272.073-3.225.802l-.44.438-2.199 2.19c-1.686 1.75-1.612 4.524.074 6.202.88.803 1.979 1.241 3.078 1.241 1.1 0 2.199-.438 3.079-1.24l1.246-1.241a.703.703 0 0 0 0-1.022c-.294-.292-.807-.365-1.1-.073z",
    fill: "#FFF",
    fillRule: "nonzero"
  })));
}
/**
 * Url
 *
 */


module.exports = (_temp = _class = class Url extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.id = this.opts.id || 'Url';
    this.title = this.opts.title || 'Link';
    this.type = 'acquirer';

    this.icon = () => h(UrlIcon, null); // Set default options and locale


    this.defaultLocale = locale;
    const defaultOptions = {};
    this.opts = { ...defaultOptions,
      ...opts
    };
    this.i18nInit();
    this.hostname = this.opts.companionUrl;

    if (!this.hostname) {
      throw new Error('Companion hostname is required, please consult https://uppy.io/docs/companion');
    } // Bind all event handlers for referencability


    this.getMeta = this.getMeta.bind(this);
    this.addFile = this.addFile.bind(this);
    this.handleRootDrop = this.handleRootDrop.bind(this);
    this.handleRootPaste = this.handleRootPaste.bind(this);
    this.client = new RequestClient(uppy, {
      companionUrl: this.opts.companionUrl,
      companionHeaders: this.opts.companionHeaders,
      companionCookiesRule: this.opts.companionCookiesRule
    });
  }

  getFileNameFromUrl(url) {
    return url.substring(url.lastIndexOf('/') + 1);
  }

  checkIfCorrectURL(url) {
    if (!url) return false;
    const protocol = url.match(/^([a-z0-9]+):\/\//)[1];

    if (protocol !== 'http' && protocol !== 'https') {
      return false;
    }

    return true;
  }

  addProtocolToURL(url) {
    const protocolRegex = /^[a-z0-9]+:\/\//;
    const defaultProtocol = 'http://';

    if (protocolRegex.test(url)) {
      return url;
    }

    return defaultProtocol + url;
  }

  getMeta(url) {
    return this.client.post('url/meta', {
      url
    }).then(res => {
      if (res.error) {
        this.uppy.log('[URL] Error:');
        this.uppy.log(res.error);
        throw new Error('Failed to fetch the file');
      }

      return res;
    });
  }

  addFile(url) {
    url = this.addProtocolToURL(url);

    if (!this.checkIfCorrectURL(url)) {
      this.uppy.log(`[URL] Incorrect URL entered: ${url}`);
      this.uppy.info(this.i18n('enterCorrectUrl'), 'error', 4000);
      return;
    }

    return this.getMeta(url).then(meta => {
      const tagFile = {
        source: this.id,
        name: this.getFileNameFromUrl(url),
        type: meta.type,
        data: {
          size: meta.size
        },
        isRemote: true,
        body: {
          url
        },
        remote: {
          companionUrl: this.opts.companionUrl,
          url: `${this.hostname}/url/get`,
          body: {
            fileId: url,
            url
          },
          providerOptions: this.client.opts
        }
      };
      return tagFile;
    }).then(tagFile => {
      this.uppy.log('[Url] Adding remote file');

      try {
        return this.uppy.addFile(tagFile);
      } catch (err) {
        if (!err.isRestriction) {
          this.uppy.log(err);
        }

        return err;
      }
    }).catch(err => {
      this.uppy.log(err);
      this.uppy.info({
        message: this.i18n('failedToFetch'),
        details: err
      }, 'error', 4000);
      return err;
    });
  }

  canHandleRootDrop(e) {
    const items = toArray(e.dataTransfer.items);
    const urls = items.filter(item => item.kind === 'string' && item.type === 'text/uri-list');
    return urls.length > 0;
  }

  handleRootDrop(e) {
    forEachDroppedOrPastedUrl(e.dataTransfer, 'drop', url => {
      this.uppy.log(`[URL] Adding file from dropped url: ${url}`);
      this.addFile(url);
    });
  }

  handleRootPaste(e) {
    forEachDroppedOrPastedUrl(e.clipboardData, 'paste', url => {
      this.uppy.log(`[URL] Adding file from pasted url: ${url}`);
      this.addFile(url);
    });
  }

  render() {
    return h(UrlUI, {
      i18n: this.i18n,
      addFile: this.addFile
    });
  }

  install() {
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.unmount();
  }

}, _class.VERSION = "2.0.4", _temp);

},{"./../../companion-client":42,"./../../core":48,"./../../utils/lib/toArray":180,"./UrlUI.js":140,"./locale":142,"./utils/forEachDroppedOrPastedUrl":143,"preact":18}],142:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    // Label for the "Import" button.
    import: 'Import',
    // Placeholder text for the URL input.
    enterUrlToImport: 'Enter URL to import a file',
    // Error message shown if Companion could not load a URL.
    failedToFetch: 'Companion failed to fetch this URL, please make sure its correct',
    // Error message shown if the input does not look like a URL.
    enterCorrectUrl: 'Incorrect URL: Please make sure you are entering a direct link to a file'
  }
};

},{}],143:[function(require,module,exports){
"use strict";

const toArray = require('./../../../utils/lib/toArray');
/*
  SITUATION

    1. Cross-browser dataTransfer.items

      paste in chrome [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      paste in safari [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "string", type: "text/plain"}
      3: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}

      paste in chrome [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      paste in safari [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      1: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}

      drop in chrome [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      drop in safari [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "file", type: "image/png"}
      drop in firefox [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/x-moz-url"}
      2: {kind: "string", type: "text/plain"}

    2. We can determine if it's a 'copypaste' or a 'drop', but we can't discern between [Copy Image] and [Copy Image Address]

  CONCLUSION

    1. 'paste' ([Copy Image] or [Copy Image Address], we can't discern between these two)
      Don't do anything if there is 'file' item. .handlePaste in the DashboardPlugin will deal with all 'file' items.
      If there are no 'file' items - handle 'text/plain' items.

    2. 'drop'
      Take 'text/uri-list' items. Safari has an additional item of .kind === 'file', and you may worry about the item being
      duplicated (first by DashboardPlugin, and then by UrlPlugin, now), but don't. Directory handling code won't pay
      attention to this particular item of kind 'file'.
*/

/**
 * Finds all links dropped/pasted from one browser window to another.
 *
 * @param {object} dataTransfer - DataTransfer instance, e.g. e.clipboardData, or e.dataTransfer
 * @param {string} isDropOrPaste - either 'drop' or 'paste'
 * @param {Function} callback - (urlString) => {}
 */


module.exports = function forEachDroppedOrPastedUrl(dataTransfer, isDropOrPaste, callback) {
  const items = toArray(dataTransfer.items);
  let urlItems;

  switch (isDropOrPaste) {
    case 'paste':
      {
        const atLeastOneFileIsDragged = items.some(item => item.kind === 'file');

        if (atLeastOneFileIsDragged) {
          return;
        }

        urlItems = items.filter(item => item.kind === 'string' && item.type === 'text/plain');
        break;
      }

    case 'drop':
      {
        urlItems = items.filter(item => item.kind === 'string' && item.type === 'text/uri-list');
        break;
      }

    default:
      {
        throw new Error(`isDropOrPaste must be either 'drop' or 'paste', but it's ${isDropOrPaste}`);
      }
  }

  urlItems.forEach(item => {
    item.getAsString(urlString => callback(urlString));
  });
};

},{"./../../../utils/lib/toArray":180}],144:[function(require,module,exports){
"use strict";

var _emitter, _events;

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

/**
 * Create a wrapper around an event emitter with a `remove` method to remove
 * all events that were added using the wrapped emitter.
 */
module.exports = (_emitter = /*#__PURE__*/_classPrivateFieldLooseKey("emitter"), _events = /*#__PURE__*/_classPrivateFieldLooseKey("events"), class EventTracker {
  constructor(emitter) {
    Object.defineProperty(this, _emitter, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _events, {
      writable: true,
      value: []
    });
    _classPrivateFieldLooseBase(this, _emitter)[_emitter] = emitter;
  }

  on(event, fn) {
    _classPrivateFieldLooseBase(this, _events)[_events].push([event, fn]);

    return _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event, fn);
  }

  remove() {
    for (const [event, fn] of _classPrivateFieldLooseBase(this, _events)[_events].splice(0)) {
      _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event, fn);
    }
  }

});

},{}],145:[function(require,module,exports){
"use strict";

module.exports = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'input:not([disabled]):not([inert]):not([aria-hidden])', 'select:not([disabled]):not([inert]):not([aria-hidden])', 'textarea:not([disabled]):not([inert]):not([aria-hidden])', 'button:not([disabled]):not([inert]):not([aria-hidden])', 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'];

},{}],146:[function(require,module,exports){
"use strict";

class NetworkError extends Error {
  constructor(error, xhr = null) {
    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
    this.cause = error;
    this.isNetworkError = true;
    this.request = xhr;
  }

}

module.exports = NetworkError;

},{}],147:[function(require,module,exports){
"use strict";

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

function createCancelError() {
  return new Error('Cancelled');
}

var _activeRequests = /*#__PURE__*/_classPrivateFieldLooseKey("activeRequests");

var _queuedHandlers = /*#__PURE__*/_classPrivateFieldLooseKey("queuedHandlers");

var _call = /*#__PURE__*/_classPrivateFieldLooseKey("call");

var _queueNext = /*#__PURE__*/_classPrivateFieldLooseKey("queueNext");

var _next = /*#__PURE__*/_classPrivateFieldLooseKey("next");

var _queue = /*#__PURE__*/_classPrivateFieldLooseKey("queue");

var _dequeue = /*#__PURE__*/_classPrivateFieldLooseKey("dequeue");

class RateLimitedQueue {
  constructor(limit) {
    Object.defineProperty(this, _dequeue, {
      value: _dequeue2
    });
    Object.defineProperty(this, _queue, {
      value: _queue2
    });
    Object.defineProperty(this, _next, {
      value: _next2
    });
    Object.defineProperty(this, _queueNext, {
      value: _queueNext2
    });
    Object.defineProperty(this, _call, {
      value: _call2
    });
    Object.defineProperty(this, _activeRequests, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _queuedHandlers, {
      writable: true,
      value: []
    });

    if (typeof limit !== 'number' || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }
  }

  run(fn, queueOptions) {
    if (_classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] < this.limit) {
      return _classPrivateFieldLooseBase(this, _call)[_call](fn);
    }

    return _classPrivateFieldLooseBase(this, _queue)[_queue](fn, queueOptions);
  }

  wrapPromiseFunction(fn, queueOptions) {
    return (...args) => {
      let queuedRequest;
      const outerPromise = new Promise((resolve, reject) => {
        queuedRequest = this.run(() => {
          let cancelError;
          let innerPromise;

          try {
            innerPromise = Promise.resolve(fn(...args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }

          innerPromise.then(result => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, err => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return () => {
            cancelError = createCancelError();
          };
        }, queueOptions);
      });

      outerPromise.abort = () => {
        queuedRequest.abort();
      };

      return outerPromise;
    };
  }

}

function _call2(fn) {
  _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] += 1;
  let done = false;
  let cancelActive;

  try {
    cancelActive = fn();
  } catch (err) {
    _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
    throw err;
  }

  return {
    abort: () => {
      if (done) return;
      done = true;
      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
      cancelActive();

      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
    },
    done: () => {
      if (done) return;
      done = true;
      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;

      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
    }
  };
}

function _queueNext2() {
  // Do it soon but not immediately, this allows clearing out the entire queue synchronously
  // one by one without continuously _advancing_ it (and starting new tasks before immediately
  // aborting them)
  queueMicrotask(() => _classPrivateFieldLooseBase(this, _next)[_next]());
}

function _next2() {
  if (_classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] >= this.limit) {
    return;
  }

  if (_classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].length === 0) {
    return;
  } // Dispatch the next request, and update the abort/done handlers
  // so that cancelling it does the Right Thing (and doesn't just try
  // to dequeue an already-running request).


  const next = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].shift();

  const handler = _classPrivateFieldLooseBase(this, _call)[_call](next.fn);

  next.abort = handler.abort;
  next.done = handler.done;
}

function _queue2(fn, options = {}) {
  const handler = {
    fn,
    priority: options.priority || 0,
    abort: () => {
      _classPrivateFieldLooseBase(this, _dequeue)[_dequeue](handler);
    },
    done: () => {
      throw new Error('Cannot mark a queued request as done: this indicates a bug');
    }
  };

  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].findIndex(other => {
    return handler.priority > other.priority;
  });

  if (index === -1) {
    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].push(handler);
  } else {
    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);
  }

  return handler;
}

function _dequeue2(handler) {
  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);

  if (index !== -1) {
    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
  }
}

module.exports = {
  RateLimitedQueue,
  internalRateLimitedQueue: Symbol('__queue')
};

},{}],148:[function(require,module,exports){
"use strict";

var _apply;

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const has = require('./hasProperty');

function insertReplacement(source, rx, replacement) {
  const newParts = [];
  source.forEach(chunk => {
    // When the source contains multiple placeholders for interpolation,
    // we should ignore chunks that are not strings, because those
    // can be JSX objects and will be otherwise incorrectly turned into strings.
    // Without this condition wed get this: [object Object] hello [object Object] my <button>
    if (typeof chunk !== 'string') {
      return newParts.push(chunk);
    }

    return rx[Symbol.split](chunk).forEach((raw, i, list) => {
      if (raw !== '') {
        newParts.push(raw);
      } // Interlace with the `replacement` value


      if (i < list.length - 1) {
        newParts.push(replacement);
      }
    });
  });
  return newParts;
}
/**
 * Takes a string with placeholder variables like `%{smart_count} file selected`
 * and replaces it with values from options `{smart_count: 5}`
 *
 * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
 * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
 *
 * @param {string} phrase that needs interpolation, with placeholders
 * @param {object} options with values that will be used to replace placeholders
 * @returns {any[]} interpolated
 */


function interpolate(phrase, options) {
  const dollarRegex = /\$/g;
  const dollarBillsYall = '$$$$';
  let interpolated = [phrase];
  if (options == null) return interpolated;

  for (const arg of Object.keys(options)) {
    if (arg !== '_') {
      // Ensure replacement value is escaped to prevent special $-prefixed
      // regex replace tokens. the "$$$$" is needed because each "$" needs to
      // be escaped with "$" itself, and we need two in the resulting output.
      let replacement = options[arg];

      if (typeof replacement === 'string') {
        replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);
      } // We create a new `RegExp` each time instead of using a more-efficient
      // string replace so that the same argument can be replaced multiple times
      // in the same phrase.


      interpolated = insertReplacement(interpolated, new RegExp(`%\\{${arg}\\}`, 'g'), replacement);
    }
  }

  return interpolated;
}
/**
 * Translates strings with interpolation & pluralization support.
 * Extensible with custom dictionaries and pluralization functions.
 *
 * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,
 * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded
 * and can be easily added among with dictionaries, nested objects are used for pluralization
 * as opposed to `||||` delimeter
 *
 * Usage example: `translator.translate('files_chosen', {smart_count: 3})`
 */


module.exports = (_apply = /*#__PURE__*/_classPrivateFieldLooseKey("apply"), class Translator {
  /**
   * @param {object|Array<object>} locales - locale or list of locales.
   */
  constructor(locales) {
    Object.defineProperty(this, _apply, {
      value: _apply2
    });
    this.locale = {
      strings: {},

      pluralize(n) {
        if (n === 1) {
          return 0;
        }

        return 1;
      }

    };

    if (Array.isArray(locales)) {
      locales.forEach(_classPrivateFieldLooseBase(this, _apply)[_apply], this);
    } else {
      _classPrivateFieldLooseBase(this, _apply)[_apply](locales);
    }
  }

  /**
   * Public translate method
   *
   * @param {string} key
   * @param {object} options with values that will be used later to replace placeholders in string
   * @returns {string} translated (and interpolated)
   */
  translate(key, options) {
    return this.translateArray(key, options).join('');
  }
  /**
   * Get a translation and return the translated and interpolated parts as an array.
   *
   * @param {string} key
   * @param {object} options with values that will be used to replace placeholders
   * @returns {Array} The translated and interpolated parts, in order.
   */


  translateArray(key, options) {
    if (!has(this.locale.strings, key)) {
      throw new Error(`missing string: ${key}`);
    }

    const string = this.locale.strings[key];
    const hasPluralForms = typeof string === 'object';

    if (hasPluralForms) {
      if (options && typeof options.smart_count !== 'undefined') {
        const plural = this.locale.pluralize(options.smart_count);
        return interpolate(string[plural], options);
      }

      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');
    }

    return interpolate(string, options);
  }

});

function _apply2(locale) {
  if (!(locale != null && locale.strings)) {
    return;
  }

  const prevLocale = this.locale;
  this.locale = { ...prevLocale,
    strings: { ...prevLocale.strings,
      ...locale.strings
    }
  };
  this.locale.pluralize = locale.pluralize || prevLocale.pluralize;
}

},{"./hasProperty":169}],149:[function(require,module,exports){
"use strict";

/**
 * Save a <canvas> element's content to a Blob object.
 *
 * @param {HTMLCanvasElement} canvas
 * @returns {Promise}
 */
module.exports = function canvasToBlob(canvas, type, quality) {
  return new Promise(resolve => {
    canvas.toBlob(resolve, type, quality);
  });
};

},{}],150:[function(require,module,exports){
"use strict";

const DATA_URL_PATTERN = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/;

module.exports = function dataURItoBlob(dataURI, opts, toFile) {
  var _ref, _opts$mimeType;

  // get the base64 data
  const dataURIData = DATA_URL_PATTERN.exec(dataURI); // user may provide mime type, if not get it from data URI

  const mimeType = (_ref = (_opts$mimeType = opts.mimeType) != null ? _opts$mimeType : dataURIData == null ? void 0 : dataURIData[1]) != null ? _ref : 'plain/text';
  let data;

  if (dataURIData[2] != null) {
    const binary = atob(decodeURIComponent(dataURIData[3]));
    const bytes = new Uint8Array(binary.length);

    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }

    data = [bytes];
  } else {
    data = [decodeURIComponent(dataURIData[3])];
  } // Convert to a File?


  if (toFile) {
    return new File(data, opts.name || '', {
      type: mimeType
    });
  }

  return new Blob(data, {
    type: mimeType
  });
};

},{}],151:[function(require,module,exports){
"use strict";

const throttle = require('lodash.throttle');

function emitSocketProgress(uploader, progressData, file) {
  const {
    progress,
    bytesUploaded,
    bytesTotal
  } = progressData;

  if (progress) {
    uploader.uppy.log(`Upload progress: ${progress}`);
    uploader.uppy.emit('upload-progress', file, {
      uploader,
      bytesUploaded,
      bytesTotal
    });
  }
}

module.exports = throttle(emitSocketProgress, 300, {
  leading: true,
  trailing: true
});

},{"lodash.throttle":11}],152:[function(require,module,exports){
"use strict";

const NetworkError = require('./NetworkError');
/**
 * Wrapper around window.fetch that throws a NetworkError when appropriate
 */


module.exports = function fetchWithNetworkError(...options) {
  return fetch(...options).catch(err => {
    if (err.name === 'AbortError') {
      throw err;
    } else {
      throw new NetworkError(err);
    }
  });
};

},{"./NetworkError":146}],153:[function(require,module,exports){
"use strict";

const isDOMElement = require('./isDOMElement');
/**
 * Find one or more DOM elements.
 *
 * @param {string|Node} element
 * @returns {Node[]|null}
 */


module.exports = function findAllDOMElements(element) {
  if (typeof element === 'string') {
    const elements = document.querySelectorAll(element);
    return elements.length === 0 ? null : Array.from(elements);
  }

  if (typeof element === 'object' && isDOMElement(element)) {
    return [element];
  }

  return null;
};

},{"./isDOMElement":170}],154:[function(require,module,exports){
"use strict";

const isDOMElement = require('./isDOMElement');
/**
 * Find a DOM element.
 *
 * @param {Node|string} element
 * @returns {Node|null}
 */


module.exports = function findDOMElement(element, context = document) {
  if (typeof element === 'string') {
    return context.querySelector(element);
  }

  if (isDOMElement(element)) {
    return element;
  }

  return null;
};

},{"./isDOMElement":170}],155:[function(require,module,exports){
"use strict";

function encodeCharacter(character) {
  return character.charCodeAt(0).toString(32);
}

function encodeFilename(name) {
  let suffix = '';
  return name.replace(/[^A-Z0-9]/ig, character => {
    suffix += `-${encodeCharacter(character)}`;
    return '/';
  }) + suffix;
}
/**
 * Takes a file object and turns it into fileID, by converting file.name to lowercase,
 * removing extra characters and adding type, size and lastModified
 *
 * @param {object} file
 * @returns {string} the fileID
 */


module.exports = function generateFileID(file) {
  // It's tempting to do `[items].filter(Boolean).join('-')` here, but that
  // is slower! simple string concatenation is fast
  let id = 'uppy';

  if (typeof file.name === 'string') {
    id += `-${encodeFilename(file.name.toLowerCase())}`;
  }

  if (file.type !== undefined) {
    id += `-${file.type}`;
  }

  if (file.meta && typeof file.meta.relativePath === 'string') {
    id += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;
  }

  if (file.data.size !== undefined) {
    id += `-${file.data.size}`;
  }

  if (file.data.lastModified !== undefined) {
    id += `-${file.data.lastModified}`;
  }

  return id;
};

},{}],156:[function(require,module,exports){
"use strict";

module.exports = function getBytesRemaining(fileProgress) {
  return fileProgress.bytesTotal - fileProgress.bytesUploaded;
};

},{}],157:[function(require,module,exports){
"use strict";

const webkitGetAsEntryApi = require('./utils/webkitGetAsEntryApi/index');

const fallbackApi = require('./utils/fallbackApi');
/**
 * Returns a promise that resolves to the array of dropped files (if a folder is
 * dropped, and browser supports folder parsing - promise resolves to the flat
 * array of all files in all directories).
 * Each file has .relativePath prop appended to it (e.g. "/docs/Prague/ticket_from_prague_to_ufa.pdf")
 * if browser supports it. Otherwise it's undefined.
 *
 * @param {DataTransfer} dataTransfer
 * @param {Function} logDropError - a function that's called every time some
 * folder or some file error out (e.g. because of the folder name being too long
 * on Windows). Notice that resulting promise will always be resolved anyway.
 *
 * @returns {Promise} - Array<File>
 */


module.exports = function getDroppedFiles(dataTransfer, {
  logDropError = () => {}
} = {}) {
  var _dataTransfer$items;

  // Get all files from all subdirs. Works (at least) in Chrome, Mozilla, and Safari
  if ((_dataTransfer$items = dataTransfer.items) != null && _dataTransfer$items[0] && 'webkitGetAsEntry' in dataTransfer.items[0]) {
    return webkitGetAsEntryApi(dataTransfer, logDropError); // Otherwise just return all first-order files
  }

  return fallbackApi(dataTransfer);
};

},{"./utils/fallbackApi":158,"./utils/webkitGetAsEntryApi/index":161}],158:[function(require,module,exports){
"use strict";

const toArray = require('../../toArray'); // .files fallback, should be implemented in any browser


module.exports = function fallbackApi(dataTransfer) {
  const files = toArray(dataTransfer.files);
  return Promise.resolve(files);
};

},{"../../toArray":180}],159:[function(require,module,exports){
"use strict";

/**
 * Recursive function, calls the original callback() when the directory is entirely parsed.
 *
 * @param {FileSystemDirectoryReader} directoryReader
 * @param {Array} oldEntries
 * @param {Function} logDropError
 * @param {Function} callback - called with ([ all files and directories in that directoryReader ])
 */
module.exports = function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, {
  onSuccess
}) {
  directoryReader.readEntries(entries => {
    const newEntries = [...oldEntries, ...entries]; // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory()
    // must be called until it calls the onSuccess with an empty array.

    if (entries.length) {
      setTimeout(() => {
        getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {
          onSuccess
        });
      }, 0); // Done iterating this particular directory
    } else {
      onSuccess(newEntries);
    }
  }, // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
  error => {
    logDropError(error);
    onSuccess(oldEntries);
  });
};

},{}],160:[function(require,module,exports){
"use strict";

/**
 * Get the relative path from the FileEntry#fullPath, because File#webkitRelativePath is always '', at least onDrop.
 *
 * @param {FileEntry} fileEntry
 *
 * @returns {string|null} - if file is not in a folder - return null (this is to
 * be consistent with .relativePath-s of files selected from My Device). If file
 * is in a folder - return its fullPath, e.g. '/simpsons/hi.jpeg'.
 */
module.exports = function getRelativePath(fileEntry) {
  // fileEntry.fullPath - "/simpsons/hi.jpeg" or undefined (for browsers that don't support it)
  // fileEntry.name - "hi.jpeg"
  if (!fileEntry.fullPath || fileEntry.fullPath === `/${fileEntry.name}`) {
    return null;
  }

  return fileEntry.fullPath;
};

},{}],161:[function(require,module,exports){
"use strict";

const toArray = require('../../../toArray');

const getRelativePath = require('./getRelativePath');

const getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');

module.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {
  const files = [];
  const rootPromises = [];
  /**
   * Returns a resolved promise, when :files array is enhanced
   *
   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry
   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file
   */

  const createPromiseToAddFileOrParseDirectory = entry => new Promise(resolve => {
    // This is a base call
    if (entry.isFile) {
      // Creates a new File object which can be used to read the file.
      entry.file(file => {
        // eslint-disable-next-line no-param-reassign
        file.relativePath = getRelativePath(entry);
        files.push(file);
        resolve();
      }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!
      error => {
        logDropError(error);
        resolve();
      }); // This is a recursive call
    } else if (entry.isDirectory) {
      const directoryReader = entry.createReader();
      getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {
        onSuccess: entries => resolve(Promise.all(entries.map(createPromiseToAddFileOrParseDirectory)))
      });
    }
  }); // For each dropped item, - make sure it's a file/directory, and start deepening in!


  toArray(dataTransfer.items).forEach(item => {
    const entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.

    if (entry) {
      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));
    }
  });
  return Promise.all(rootPromises).then(() => files);
};

},{"../../../toArray":180,"./getFilesAndDirectoriesFromDirectory":159,"./getRelativePath":160}],162:[function(require,module,exports){
"use strict";

/**
 * Takes a full filename string and returns an object {name, extension}
 *
 * @param {string} fullFileName
 * @returns {object} {name, extension}
 */
module.exports = function getFileNameAndExtension(fullFileName) {
  const lastDot = fullFileName.lastIndexOf('.'); // these count as no extension: "no-dot", "trailing-dot."

  if (lastDot === -1 || lastDot === fullFileName.length - 1) {
    return {
      name: fullFileName,
      extension: undefined
    };
  }

  return {
    name: fullFileName.slice(0, lastDot),
    extension: fullFileName.slice(lastDot + 1)
  };
};

},{}],163:[function(require,module,exports){
"use strict";

const getFileNameAndExtension = require('./getFileNameAndExtension');

const mimeTypes = require('./mimeTypes');

module.exports = function getFileType(file) {
  var _getFileNameAndExtens;

  if (file.type) return file.type;
  const fileExtension = file.name ? (_getFileNameAndExtens = getFileNameAndExtension(file.name).extension) == null ? void 0 : _getFileNameAndExtens.toLowerCase() : null;

  if (fileExtension && fileExtension in mimeTypes) {
    // else, see if we can map extension to a mime type
    return mimeTypes[fileExtension];
  } // if all fails, fall back to a generic byte stream type


  return 'application/octet-stream';
};

},{"./getFileNameAndExtension":162,"./mimeTypes":175}],164:[function(require,module,exports){
"use strict";

const mimeToExtensions = {
  'audio/mp3': 'mp3',
  'audio/mp4': 'mp4',
  'audio/ogg': 'ogg',
  'audio/webm': 'webm',
  'image/gif': 'gif',
  'image/heic': 'heic',
  'image/heif': 'heif',
  'image/jpeg': 'jpg',
  'image/png': 'png',
  'image/svg+xml': 'svg',
  'video/mp4': 'mp4',
  'video/ogg': 'ogv',
  'video/quicktime': 'mov',
  'video/webm': 'webm',
  'video/x-matroska': 'mkv',
  'video/x-msvideo': 'avi'
};

module.exports = function getFileTypeExtension(mimeType) {
  // Remove the ; bit in 'video/x-matroska;codecs=avc1'
  // eslint-disable-next-line no-param-reassign
  [mimeType] = mimeType.split(';', 1);
  return mimeToExtensions[mimeType] || null;
};

},{}],165:[function(require,module,exports){
"use strict";

module.exports = function getSocketHost(url) {
  // get the host domain
  const regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
  const host = regex.exec(url)[1];
  const socketProtocol = /^http:\/\//i.test(url) ? 'ws' : 'wss';
  return `${socketProtocol}://${host}`;
};

},{}],166:[function(require,module,exports){
"use strict";

module.exports = function getSpeed(fileProgress) {
  if (!fileProgress.bytesUploaded) return 0;
  const timeElapsed = Date.now() - fileProgress.uploadStarted;
  const uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1000);
  return uploadSpeed;
};

},{}],167:[function(require,module,exports){
"use strict";

/**
 * Get the declared text direction for an element.
 *
 * @param {Node} element
 * @returns {string|undefined}
 */
function getTextDirection(element) {
  var _element;

  // There is another way to determine text direction using getComputedStyle(), as done here:
  // https://github.com/pencil-js/text-direction/blob/2a235ce95089b3185acec3b51313cbba921b3811/text-direction.js
  //
  // We do not use that approach because we are interested specifically in the _declared_ text direction.
  // If no text direction is declared, we have to provide our own explicit text direction so our
  // bidirectional CSS style sheets work.
  while (element && !element.dir) {
    // eslint-disable-next-line no-param-reassign
    element = element.parentNode;
  }

  return (_element = element) == null ? void 0 : _element.dir;
}

module.exports = getTextDirection;

},{}],168:[function(require,module,exports){
"use strict";

/**
 * Adds zero to strings shorter than two characters.
 *
 * @param {number} number
 * @returns {string}
 */
function pad(number) {
  return number < 10 ? `0${number}` : number.toString();
}
/**
 * Returns a timestamp in the format of `hours:minutes:seconds`
 */


module.exports = function getTimeStamp() {
  const date = new Date();
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  const seconds = pad(date.getSeconds());
  return `${hours}:${minutes}:${seconds}`;
};

},{}],169:[function(require,module,exports){
"use strict";

module.exports = function has(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
};

},{}],170:[function(require,module,exports){
"use strict";

/**
 * Check if an object is a DOM element. Duck-typing based on `nodeType`.
 *
 * @param {*} obj
 */
module.exports = function isDOMElement(obj) {
  return (obj == null ? void 0 : obj.nodeType) === Node.ELEMENT_NODE;
};

},{}],171:[function(require,module,exports){
"use strict";

/**
 * Checks if the browser supports Drag & Drop (not supported on mobile devices, for example).
 *
 * @returns {boolean}
 */
module.exports = function isDragDropSupported() {
  const div = document.body;

  if (!('draggable' in div) || !('ondragstart' in div && 'ondrop' in div)) {
    return false;
  }

  if (!('FormData' in window)) {
    return false;
  }

  if (!('FileReader' in window)) {
    return false;
  }

  return true;
};

},{}],172:[function(require,module,exports){
"use strict";

function isNetworkError(xhr) {
  if (!xhr) {
    return false;
  }

  return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
}

module.exports = isNetworkError;

},{}],173:[function(require,module,exports){
"use strict";

/**
 * Check if a URL string is an object URL from `URL.createObjectURL`.
 *
 * @param {string} url
 * @returns {boolean}
 */
module.exports = function isObjectURL(url) {
  return url.startsWith('blob:');
};

},{}],174:[function(require,module,exports){
"use strict";

module.exports = function isPreviewSupported(fileType) {
  if (!fileType) return false; // list of images that browsers can preview

  return /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileType);
};

},{}],175:[function(require,module,exports){
"use strict";

// ___Why not add the mime-types package?
//    It's 19.7kB gzipped, and we only need mime types for well-known extensions (for file previews).
// ___Where to take new extensions from?
//    https://github.com/jshttp/mime-db/blob/master/db.json
module.exports = {
  md: 'text/markdown',
  markdown: 'text/markdown',
  mp4: 'video/mp4',
  mp3: 'audio/mp3',
  svg: 'image/svg+xml',
  jpg: 'image/jpeg',
  png: 'image/png',
  gif: 'image/gif',
  heic: 'image/heic',
  heif: 'image/heif',
  yaml: 'text/yaml',
  yml: 'text/yaml',
  csv: 'text/csv',
  tsv: 'text/tab-separated-values',
  tab: 'text/tab-separated-values',
  avi: 'video/x-msvideo',
  mks: 'video/x-matroska',
  mkv: 'video/x-matroska',
  mov: 'video/quicktime',
  doc: 'application/msword',
  docm: 'application/vnd.ms-word.document.macroenabled.12',
  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  dot: 'application/msword',
  dotm: 'application/vnd.ms-word.template.macroenabled.12',
  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
  xla: 'application/vnd.ms-excel',
  xlam: 'application/vnd.ms-excel.addin.macroenabled.12',
  xlc: 'application/vnd.ms-excel',
  xlf: 'application/x-xliff+xml',
  xlm: 'application/vnd.ms-excel',
  xls: 'application/vnd.ms-excel',
  xlsb: 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
  xlsm: 'application/vnd.ms-excel.sheet.macroenabled.12',
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  xlt: 'application/vnd.ms-excel',
  xltm: 'application/vnd.ms-excel.template.macroenabled.12',
  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
  xlw: 'application/vnd.ms-excel',
  txt: 'text/plain',
  text: 'text/plain',
  conf: 'text/plain',
  log: 'text/plain',
  pdf: 'application/pdf',
  zip: 'application/zip',
  '7z': 'application/x-7z-compressed',
  rar: 'application/x-rar-compressed',
  tar: 'application/x-tar',
  gz: 'application/gzip',
  dmg: 'application/x-apple-diskimage'
};

},{}],176:[function(require,module,exports){
"use strict";

const secondsToTime = require('./secondsToTime');

module.exports = function prettyETA(seconds) {
  const time = secondsToTime(seconds); // Only display hours and minutes if they are greater than 0 but always
  // display minutes if hours is being displayed
  // Display a leading zero if the there is a preceding unit: 1m 05s, but 5s

  const hoursStr = time.hours === 0 ? '' : `${time.hours}h`;
  const minutesStr = time.minutes === 0 ? '' : `${time.hours === 0 ? time.minutes : ` ${time.minutes.toString(10).padStart(2, '0')}`}m`;
  const secondsStr = time.hours !== 0 ? '' : `${time.minutes === 0 ? time.seconds : ` ${time.seconds.toString(10).padStart(2, '0')}`}s`;
  return `${hoursStr}${minutesStr}${secondsStr}`;
};

},{"./secondsToTime":178}],177:[function(require,module,exports){
"use strict";

const getFileNameAndExtension = require('./getFileNameAndExtension');

module.exports = function remoteFileObjToLocal(file) {
  return { ...file,
    type: file.mimeType,
    extension: file.name ? getFileNameAndExtension(file.name).extension : null
  };
};

},{"./getFileNameAndExtension":162}],178:[function(require,module,exports){
"use strict";

module.exports = function secondsToTime(rawSeconds) {
  const hours = Math.floor(rawSeconds / 3600) % 24;
  const minutes = Math.floor(rawSeconds / 60) % 60;
  const seconds = Math.floor(rawSeconds % 60);
  return {
    hours,
    minutes,
    seconds
  };
};

},{}],179:[function(require,module,exports){
"use strict";

module.exports = function settle(promises) {
  const resolutions = [];
  const rejections = [];

  function resolved(value) {
    resolutions.push(value);
  }

  function rejected(error) {
    rejections.push(error);
  }

  const wait = Promise.all(promises.map(promise => promise.then(resolved, rejected)));
  return wait.then(() => {
    return {
      successful: resolutions,
      failed: rejections
    };
  });
};

},{}],180:[function(require,module,exports){
"use strict";

/**
 * Converts list into array
 */
module.exports = Array.from;

},{}],181:[function(require,module,exports){
"use strict";

/**
 * Truncates a string to the given number of chars (maxLength) by inserting '...' in the middle of that string.
 * Partially taken from https://stackoverflow.com/a/5723274/3192470.
 *
 * @param {string} string - string to be truncated
 * @param {number} maxLength - maximum size of the resulting string
 * @returns {string}
 */
const separator = '...';

module.exports = function truncateString(string, maxLength) {
  // Return the empty string if maxLength is zero
  if (maxLength === 0) return ''; // Return original string if it's already shorter than maxLength

  if (string.length <= maxLength) return string; // Return truncated substring appended of the ellipsis char if string can't be meaningfully truncated

  if (maxLength <= separator.length + 1) return `${string.slice(0, maxLength - 1)}`;
  const charsToShow = maxLength - separator.length;
  const frontChars = Math.ceil(charsToShow / 2);
  const backChars = Math.floor(charsToShow / 2);
  return string.slice(0, frontChars) + separator + string.slice(-backChars);
};

},{}],182:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = () => {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    fill: "#0097DC",
    width: "66",
    height: "55",
    viewBox: "0 0 66 55"
  }, h("path", {
    d: "M57.3 8.433c4.59 0 8.1 3.51 8.1 8.1v29.7c0 4.59-3.51 8.1-8.1 8.1H8.7c-4.59 0-8.1-3.51-8.1-8.1v-29.7c0-4.59 3.51-8.1 8.1-8.1h9.45l4.59-7.02c.54-.54 1.35-1.08 2.16-1.08h16.2c.81 0 1.62.54 2.16 1.08l4.59 7.02h9.45zM33 14.64c-8.62 0-15.393 6.773-15.393 15.393 0 8.62 6.773 15.393 15.393 15.393 8.62 0 15.393-6.773 15.393-15.393 0-8.62-6.773-15.393-15.393-15.393zM33 40c-5.648 0-9.966-4.319-9.966-9.967 0-5.647 4.318-9.966 9.966-9.966s9.966 4.319 9.966 9.966C42.966 35.681 38.648 40 33 40z",
    fillRule: "evenodd"
  }));
};

},{"preact":18}],183:[function(require,module,exports){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* eslint-disable jsx-a11y/media-has-caption */
const {
  h,
  Component
} = require('preact');

const SnapshotButton = require('./SnapshotButton');

const RecordButton = require('./RecordButton');

const RecordingLength = require('./RecordingLength');

const VideoSourceSelect = require('./VideoSourceSelect');

const SubmitButton = require('./SubmitButton');

const DiscardButton = require('./DiscardButton');

function isModeAvailable(modes, mode) {
  return modes.indexOf(mode) !== -1;
}

class CameraScreen extends Component {
  componentDidMount() {
    const {
      onFocus
    } = this.props;
    onFocus();
  }

  componentWillUnmount() {
    const {
      onStop
    } = this.props;
    onStop();
  }

  render() {
    const {
      src,
      recordedVideo,
      recording,
      modes,
      supportsRecording,
      videoSources,
      showVideoSourceDropdown,
      showRecordingLength,
      onSubmit,
      i18n,
      mirror,
      onSnapshot,
      onStartRecording,
      onStopRecording,
      onDiscardRecordedVideo,
      recordingLengthSeconds
    } = this.props;
    const hasRecordedVideo = !!recordedVideo;
    const shouldShowRecordButton = !hasRecordedVideo && supportsRecording && (isModeAvailable(modes, 'video-only') || isModeAvailable(modes, 'audio-only') || isModeAvailable(modes, 'video-audio'));
    const shouldShowSnapshotButton = !hasRecordedVideo && isModeAvailable(modes, 'picture');
    const shouldShowRecordingLength = supportsRecording && showRecordingLength;
    const shouldShowVideoSourceDropdown = showVideoSourceDropdown && videoSources && videoSources.length > 1;
    const videoProps = {
      playsinline: true
    };

    if (recordedVideo) {
      videoProps.muted = false;
      videoProps.controls = true;
      videoProps.src = recordedVideo; // reset srcObject in dom. If not resetted, stream sticks in element

      if (this.videoElement) {
        this.videoElement.srcObject = undefined;
      }
    } else {
      videoProps.muted = true;
      videoProps.autoplay = true;
      videoProps.srcObject = src;
    }

    return h("div", {
      className: "uppy uppy-Webcam-container"
    }, h("div", {
      className: "uppy-Webcam-videoContainer"
    }, h("video", _extends({
      /* eslint-disable-next-line no-return-assign */
      ref: videoElement => this.videoElement = videoElement,
      className: `uppy-Webcam-video  ${mirror ? 'uppy-Webcam-video--mirrored' : ''}`
      /* eslint-disable-next-line react/jsx-props-no-spreading */

    }, videoProps))), h("div", {
      className: "uppy-Webcam-footer"
    }, h("div", {
      className: "uppy-Webcam-videoSourceContainer"
    }, shouldShowVideoSourceDropdown ? VideoSourceSelect(this.props) : null), h("div", {
      className: "uppy-Webcam-buttonContainer"
    }, shouldShowSnapshotButton && h(SnapshotButton, {
      onSnapshot: onSnapshot,
      i18n: i18n
    }), shouldShowRecordButton && h(RecordButton, {
      recording: recording,
      onStartRecording: onStartRecording,
      onStopRecording: onStopRecording,
      i18n: i18n
    }), hasRecordedVideo && h(SubmitButton, {
      onSubmit: onSubmit,
      i18n: i18n
    }), hasRecordedVideo && h(DiscardButton, {
      onDiscard: onDiscardRecordedVideo,
      i18n: i18n
    })), shouldShowRecordingLength && h("div", {
      className: "uppy-Webcam-recordingLength"
    }, h(RecordingLength, {
      recordingLengthSeconds: recordingLengthSeconds,
      i18n: i18n
    }))));
  }

}

module.exports = CameraScreen;

},{"./DiscardButton":184,"./RecordButton":186,"./RecordingLength":187,"./SnapshotButton":188,"./SubmitButton":189,"./VideoSourceSelect":190,"preact":18}],184:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

function DiscardButton({
  onDiscard,
  i18n
}) {
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--discard",
    type: "button",
    title: i18n('discardRecordedFile'),
    "aria-label": i18n('discardRecordedFile'),
    onClick: onDiscard,
    "data-uppy-super-focusable": true
  }, h("svg", {
    width: "13",
    height: "13",
    viewBox: "0 0 13 13",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon"
  }, h("g", {
    fill: "#FFF",
    fillRule: "evenodd"
  }, h("path", {
    d: "M.496 11.367L11.103.76l1.414 1.414L1.911 12.781z"
  }), h("path", {
    d: "M11.104 12.782L.497 2.175 1.911.76l10.607 10.606z"
  }))));
}

module.exports = DiscardButton;

},{"preact":18}],185:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = props => {
  return h("div", {
    className: "uppy-Webcam-permissons"
  }, h("div", {
    className: "uppy-Webcam-permissonsIcon"
  }, props.icon()), h("h1", {
    className: "uppy-Webcam-title"
  }, props.hasCamera ? props.i18n('allowAccessTitle') : props.i18n('noCameraTitle')), h("p", null, props.hasCamera ? props.i18n('allowAccessDescription') : props.i18n('noCameraDescription')));
};

},{"preact":18}],186:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = function RecordButton({
  recording,
  onStartRecording,
  onStopRecording,
  i18n
}) {
  if (recording) {
    return h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
      type: "button",
      title: i18n('stopRecording'),
      "aria-label": i18n('stopRecording'),
      onClick: onStopRecording,
      "data-uppy-super-focusable": true
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "100",
      height: "100",
      viewBox: "0 0 100 100"
    }, h("rect", {
      x: "15",
      y: "15",
      width: "70",
      height: "70"
    })));
  }

  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
    type: "button",
    title: i18n('startRecording'),
    "aria-label": i18n('startRecording'),
    onClick: onStartRecording,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "100",
    height: "100",
    viewBox: "0 0 100 100"
  }, h("circle", {
    cx: "50",
    cy: "50",
    r: "40"
  })));
};

},{"preact":18}],187:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const formatSeconds = require('./formatSeconds');

module.exports = function RecordingLength({
  recordingLengthSeconds,
  i18n
}) {
  const formattedRecordingLengthSeconds = formatSeconds(recordingLengthSeconds);
  return h("span", {
    "aria-label": i18n('recordingLength', {
      recording_length: formattedRecordingLengthSeconds
    })
  }, formattedRecordingLengthSeconds);
};

},{"./formatSeconds":191,"preact":18}],188:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

const CameraIcon = require('./CameraIcon');

module.exports = ({
  onSnapshot,
  i18n
}) => {
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--picture",
    type: "button",
    title: i18n('takePicture'),
    "aria-label": i18n('takePicture'),
    onClick: onSnapshot,
    "data-uppy-super-focusable": true
  }, CameraIcon());
};

},{"./CameraIcon":182,"preact":18}],189:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

function SubmitButton({
  onSubmit,
  i18n
}) {
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--submit",
    type: "button",
    title: i18n('submitRecordedFile'),
    "aria-label": i18n('submitRecordedFile'),
    onClick: onSubmit,
    "data-uppy-super-focusable": true
  }, h("svg", {
    width: "12",
    height: "9",
    viewBox: "0 0 12 9",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon"
  }, h("path", {
    fill: "#fff",
    fillRule: "nonzero",
    d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z"
  })));
}

module.exports = SubmitButton;

},{"preact":18}],190:[function(require,module,exports){
"use strict";

const {
  h
} = require('preact');

module.exports = ({
  currentDeviceId,
  videoSources,
  onChangeVideoSource
}) => {
  return h("div", {
    className: "uppy-Webcam-videoSource"
  }, h("select", {
    className: "uppy-u-reset uppy-Webcam-videoSource-select",
    onChange: event => {
      onChangeVideoSource(event.target.value);
    }
  }, videoSources.map(videoSource => h("option", {
    key: videoSource.deviceId,
    value: videoSource.deviceId,
    selected: videoSource.deviceId === currentDeviceId
  }, videoSource.label))));
};

},{"preact":18}],191:[function(require,module,exports){
"use strict";

/**
 * Takes an Integer value of seconds (e.g. 83) and converts it into a human-readable formatted string (e.g. '1:23').
 *
 * @param {Integer} seconds
 * @returns {string} the formatted seconds (e.g. '1:23' for 1 minute and 23 seconds)
 *
 */
module.exports = function formatSeconds(seconds) {
  return `${Math.floor(seconds / 60)}:${String(seconds % 60).padStart(2, 0)}`;
};

},{}],192:[function(require,module,exports){
"use strict";

var _class, _enableMirror, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }

var id = 0;

function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }

const {
  h
} = require('preact');

const {
  UIPlugin
} = require('./../../core');

const getFileTypeExtension = require('./../../utils/lib/getFileTypeExtension');

const mimeTypes = require('./../../utils/lib/mimeTypes');

const canvasToBlob = require('./../../utils/lib/canvasToBlob');

const supportsMediaRecorder = require('./supportsMediaRecorder');

const CameraIcon = require('./CameraIcon');

const CameraScreen = require('./CameraScreen');

const PermissionsScreen = require('./PermissionsScreen');

const locale = require('./locale.js');
/**
 * Normalize a MIME type or file extension into a MIME type.
 *
 * @param {string} fileType - MIME type or a file extension prefixed with `.`.
 * @returns {string|undefined} The MIME type or `undefined` if the fileType is an extension and is not known.
 */


function toMimeType(fileType) {
  if (fileType[0] === '.') {
    return mimeTypes[fileType.slice(1)];
  }

  return fileType;
}
/**
 * Is this MIME type a video?
 *
 * @param {string} mimeType - MIME type.
 * @returns {boolean}
 */


function isVideoMimeType(mimeType) {
  return /^video\/[^*]+$/.test(mimeType);
}
/**
 * Is this MIME type an image?
 *
 * @param {string} mimeType - MIME type.
 * @returns {boolean}
 */


function isImageMimeType(mimeType) {
  return /^image\/[^*]+$/.test(mimeType);
}

function getMediaDevices() {
  // bug in the compatibility data
  // eslint-disable-next-line compat/compat
  return navigator.mediaDevices;
}
/**
 * Webcam
 */


module.exports = (_temp = (_enableMirror = /*#__PURE__*/_classPrivateFieldLooseKey("enableMirror"), _class = class Webcam extends UIPlugin {
  // eslint-disable-next-line global-require
  // enableMirror is used to toggle mirroring, for instance when discarding the video,
  // while `opts.mirror` is used to remember the initial user setting
  constructor(uppy, opts) {
    super(uppy, opts);
    Object.defineProperty(this, _enableMirror, {
      writable: true,
      value: void 0
    });
    this.mediaDevices = getMediaDevices();
    this.supportsUserMedia = !!this.mediaDevices; // eslint-disable-next-line no-restricted-globals

    this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';
    this.id = this.opts.id || 'Webcam';
    this.type = 'acquirer';
    this.capturedMediaFile = null;

    this.icon = () => h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, h("g", {
      fill: "none",
      fillRule: "evenodd"
    }, h("rect", {
      className: "uppy-ProviderIconBg",
      fill: "#03BFEF",
      width: "32",
      height: "32",
      rx: "16"
    }), h("path", {
      d: "M22 11c1.133 0 2 .867 2 2v7.333c0 1.134-.867 2-2 2H10c-1.133 0-2-.866-2-2V13c0-1.133.867-2 2-2h2.333l1.134-1.733C13.6 9.133 13.8 9 14 9h4c.2 0 .4.133.533.267L19.667 11H22zm-6 1.533a3.764 3.764 0 0 0-3.8 3.8c0 2.129 1.672 3.801 3.8 3.801s3.8-1.672 3.8-3.8c0-2.13-1.672-3.801-3.8-3.801zm0 6.261c-1.395 0-2.46-1.066-2.46-2.46 0-1.395 1.065-2.461 2.46-2.461s2.46 1.066 2.46 2.46c0 1.395-1.065 2.461-2.46 2.461z",
      fill: "#FFF",
      fillRule: "nonzero"
    })));

    this.defaultLocale = locale; // set default options

    const defaultOptions = {
      onBeforeSnapshot: () => Promise.resolve(),
      countdown: false,
      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],
      mirror: true,
      showVideoSourceDropdown: false,
      facingMode: 'user',
      preferredImageMimeType: null,
      preferredVideoMimeType: null,
      showRecordingLength: false
    };
    this.opts = { ...defaultOptions,
      ...opts
    };
    this.i18nInit();
    this.title = this.i18n('pluginNameCamera');
    _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = this.opts.mirror;
    this.install = this.install.bind(this);
    this.setPluginState = this.setPluginState.bind(this);
    this.render = this.render.bind(this); // Camera controls

    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this.takeSnapshot = this.takeSnapshot.bind(this);
    this.startRecording = this.startRecording.bind(this);
    this.stopRecording = this.stopRecording.bind(this);
    this.discardRecordedVideo = this.discardRecordedVideo.bind(this);
    this.submit = this.submit.bind(this);
    this.oneTwoThreeSmile = this.oneTwoThreeSmile.bind(this);
    this.focus = this.focus.bind(this);
    this.changeVideoSource = this.changeVideoSource.bind(this);
    this.webcamActive = false;

    if (this.opts.countdown) {
      this.opts.onBeforeSnapshot = this.oneTwoThreeSmile;
    }

    this.setPluginState({
      hasCamera: false,
      cameraReady: false,
      cameraError: null,
      recordingLengthSeconds: 0,
      videoSources: [],
      currentDeviceId: null
    });
  }

  setOptions(newOpts) {
    super.setOptions({ ...newOpts,
      videoConstraints: { // May be undefined but ... handles that
        ...this.opts.videoConstraints,
        ...(newOpts == null ? void 0 : newOpts.videoConstraints)
      }
    });
  }

  hasCameraCheck() {
    if (!this.mediaDevices) {
      return Promise.resolve(false);
    }

    return this.mediaDevices.enumerateDevices().then(devices => {
      return devices.some(device => device.kind === 'videoinput');
    });
  }

  isAudioOnly() {
    return this.opts.modes.length === 1 && this.opts.modes[0] === 'audio-only';
  }

  getConstraints(deviceId = null) {
    const acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;
    const acceptsVideo = !this.isAudioOnly() && (this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1);
    const videoConstraints = { ...(this.opts.videoConstraints || {
        facingMode: this.opts.facingMode
      }),
      // facingMode takes precedence over deviceId, and not needed
      // when specific device is selected
      ...(deviceId ? {
        deviceId,
        facingMode: null
      } : {})
    };
    return {
      audio: acceptsAudio,
      video: acceptsVideo ? videoConstraints : false
    };
  } // eslint-disable-next-line consistent-return


  start(options = null) {
    if (!this.supportsUserMedia) {
      return Promise.reject(new Error('Webcam access not supported'));
    }

    this.webcamActive = true;

    if (this.opts.mirror) {
      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;
    }

    const constraints = this.getConstraints(options && options.deviceId ? options.deviceId : null);
    this.hasCameraCheck().then(hasCamera => {
      this.setPluginState({
        hasCamera
      }); // ask user for access to their camera

      return this.mediaDevices.getUserMedia(constraints).then(stream => {
        this.stream = stream;
        let currentDeviceId = null;
        const tracks = this.isAudioOnly() ? stream.getAudioTracks() : stream.getVideoTracks();

        if (!options || !options.deviceId) {
          currentDeviceId = tracks[0].getSettings().deviceId;
        } else {
          tracks.forEach(track => {
            if (track.getSettings().deviceId === options.deviceId) {
              currentDeviceId = track.getSettings().deviceId;
            }
          });
        } // Update the sources now, so we can access the names.


        this.updateVideoSources();
        this.setPluginState({
          currentDeviceId,
          cameraReady: true
        });
      }).catch(err => {
        this.setPluginState({
          cameraReady: false,
          cameraError: err
        });
        this.uppy.info(err.message, 'error');
      });
    });
  }
  /**
   * @returns {object}
   */


  getMediaRecorderOptions() {
    const options = {}; // Try to use the `opts.preferredVideoMimeType` or one of the `allowedFileTypes` for the recording.
    // If the browser doesn't support it, we'll fall back to the browser default instead.
    // Safari doesn't have the `isTypeSupported` API.

    if (MediaRecorder.isTypeSupported) {
      const {
        restrictions
      } = this.uppy.opts;
      let preferredVideoMimeTypes = [];

      if (this.opts.preferredVideoMimeType) {
        preferredVideoMimeTypes = [this.opts.preferredVideoMimeType];
      } else if (restrictions.allowedFileTypes) {
        preferredVideoMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isVideoMimeType);
      }

      const filterSupportedTypes = candidateType => MediaRecorder.isTypeSupported(candidateType) && getFileTypeExtension(candidateType);

      const acceptableMimeTypes = preferredVideoMimeTypes.filter(filterSupportedTypes);

      if (acceptableMimeTypes.length > 0) {
        // eslint-disable-next-line prefer-destructuring
        options.mimeType = acceptableMimeTypes[0];
      }
    }

    return options;
  }

  startRecording() {
    // only used if supportsMediaRecorder() returned true
    // eslint-disable-next-line compat/compat
    this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions());
    this.recordingChunks = [];
    let stoppingBecauseOfMaxSize = false;
    this.recorder.addEventListener('dataavailable', event => {
      this.recordingChunks.push(event.data);
      const {
        restrictions
      } = this.uppy.opts;

      if (this.recordingChunks.length > 1 && restrictions.maxFileSize != null && !stoppingBecauseOfMaxSize) {
        const totalSize = this.recordingChunks.reduce((acc, chunk) => acc + chunk.size, 0); // Exclude the initial chunk from the average size calculation because it is likely to be a very small outlier

        const averageChunkSize = (totalSize - this.recordingChunks[0].size) / (this.recordingChunks.length - 1);
        const expectedEndChunkSize = averageChunkSize * 3;
        const maxSize = Math.max(0, restrictions.maxFileSize - expectedEndChunkSize);

        if (totalSize > maxSize) {
          stoppingBecauseOfMaxSize = true;
          this.uppy.info(this.i18n('recordingStoppedMaxSize'), 'warning', 4000);
          this.stopRecording();
        }
      }
    }); // use a "time slice" of 500ms: ondataavailable will be called each 500ms
    // smaller time slices mean we can more accurately check the max file size restriction

    this.recorder.start(500);

    if (this.opts.showRecordingLength) {
      // Start the recordingLengthTimer if we are showing the recording length.
      this.recordingLengthTimer = setInterval(() => {
        const currentRecordingLength = this.getPluginState().recordingLengthSeconds;
        this.setPluginState({
          recordingLengthSeconds: currentRecordingLength + 1
        });
      }, 1000);
    }

    this.setPluginState({
      isRecording: true
    });
  }

  stopRecording() {
    const stopped = new Promise(resolve => {
      this.recorder.addEventListener('stop', () => {
        resolve();
      });
      this.recorder.stop();

      if (this.opts.showRecordingLength) {
        // Stop the recordingLengthTimer if we are showing the recording length.
        clearInterval(this.recordingLengthTimer);
        this.setPluginState({
          recordingLengthSeconds: 0
        });
      }
    });
    return stopped.then(() => {
      this.setPluginState({
        isRecording: false
      });
      return this.getVideo();
    }).then(file => {
      try {
        this.capturedMediaFile = file; // create object url for capture result preview

        this.setPluginState({
          // eslint-disable-next-line compat/compat
          recordedVideo: URL.createObjectURL(file.data)
        });
        _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = false;
      } catch (err) {
        // Logging the error, exept restrictions, which is handled in Core
        if (!err.isRestriction) {
          this.uppy.log(err);
        }
      }
    }).then(() => {
      this.recordingChunks = null;
      this.recorder = null;
    }, error => {
      this.recordingChunks = null;
      this.recorder = null;
      throw error;
    });
  }

  discardRecordedVideo() {
    this.setPluginState({
      recordedVideo: null
    });

    if (this.opts.mirror) {
      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;
    }

    this.capturedMediaFile = null;
  }

  submit() {
    try {
      if (this.capturedMediaFile) {
        this.uppy.addFile(this.capturedMediaFile);
      }
    } catch (err) {
      // Logging the error, exept restrictions, which is handled in Core
      if (!err.isRestriction) {
        this.uppy.log(err, 'error');
      }
    }
  }

  async stop() {
    if (this.stream) {
      const audioTracks = this.stream.getAudioTracks();
      const videoTracks = this.stream.getVideoTracks();
      audioTracks.concat(videoTracks).forEach(track => track.stop());
    }

    if (this.recorder) {
      await new Promise(resolve => {
        this.recorder.addEventListener('stop', resolve, {
          once: true
        });
        this.recorder.stop();

        if (this.opts.showRecordingLength) {
          clearInterval(this.recordingLengthTimer);
        }
      });
    }

    this.recordingChunks = null;
    this.recorder = null;
    this.webcamActive = false;
    this.stream = null;
    this.setPluginState({
      recordedVideo: null,
      isRecording: false,
      recordingLengthSeconds: 0
    });
  }

  getVideoElement() {
    return this.el.querySelector('.uppy-Webcam-video');
  }

  oneTwoThreeSmile() {
    return new Promise((resolve, reject) => {
      let count = this.opts.countdown; // eslint-disable-next-line consistent-return

      const countDown = setInterval(() => {
        if (!this.webcamActive) {
          clearInterval(countDown);
          this.captureInProgress = false;
          return reject(new Error('Webcam is not active'));
        }

        if (count > 0) {
          this.uppy.info(`${count}...`, 'warning', 800);
          count--;
        } else {
          clearInterval(countDown);
          this.uppy.info(this.i18n('smile'), 'success', 1500);
          setTimeout(() => resolve(), 1500);
        }
      }, 1000);
    });
  }

  takeSnapshot() {
    if (this.captureInProgress) return;
    this.captureInProgress = true;
    this.opts.onBeforeSnapshot().catch(err => {
      const message = typeof err === 'object' ? err.message : err;
      this.uppy.info(message, 'error', 5000);
      return Promise.reject(new Error(`onBeforeSnapshot: ${message}`));
    }).then(() => {
      return this.getImage();
    }).then(tagFile => {
      this.captureInProgress = false;

      try {
        this.uppy.addFile(tagFile);
      } catch (err) {
        // Logging the error, except restrictions, which is handled in Core
        if (!err.isRestriction) {
          this.uppy.log(err);
        }
      }
    }, error => {
      this.captureInProgress = false;
      throw error;
    });
  }

  getImage() {
    const video = this.getVideoElement();

    if (!video) {
      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));
    }

    const width = video.videoWidth;
    const height = video.videoHeight;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    const {
      restrictions
    } = this.uppy.opts;
    let preferredImageMimeTypes = [];

    if (this.opts.preferredImageMimeType) {
      preferredImageMimeTypes = [this.opts.preferredImageMimeType];
    } else if (restrictions.allowedFileTypes) {
      preferredImageMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isImageMimeType);
    }

    const mimeType = preferredImageMimeTypes[0] || 'image/jpeg';
    const ext = getFileTypeExtension(mimeType) || 'jpg';
    const name = `cam-${Date.now()}.${ext}`;
    return canvasToBlob(canvas, mimeType).then(blob => {
      return {
        source: this.id,
        name,
        data: new Blob([blob], {
          type: mimeType
        }),
        type: mimeType
      };
    });
  }

  getVideo() {
    // Sometimes in iOS Safari, Blobs (especially the first Blob in the recordingChunks Array)
    // have empty 'type' attributes (e.g. '') so we need to find a Blob that has a defined 'type'
    // attribute in order to determine the correct MIME type.
    const mimeType = this.recordingChunks.find(blob => {
      var _blob$type;

      return ((_blob$type = blob.type) == null ? void 0 : _blob$type.length) > 0;
    }).type;
    const fileExtension = getFileTypeExtension(mimeType);

    if (!fileExtension) {
      return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type "${mimeType}"`));
    }

    const name = `webcam-${Date.now()}.${fileExtension}`;
    const blob = new Blob(this.recordingChunks, {
      type: mimeType
    });
    const file = {
      source: this.id,
      name,
      data: new Blob([blob], {
        type: mimeType
      }),
      type: mimeType
    };
    return Promise.resolve(file);
  }

  focus() {
    if (!this.opts.countdown) return;
    setTimeout(() => {
      this.uppy.info(this.i18n('smile'), 'success', 1500);
    }, 1000);
  }

  changeVideoSource(deviceId) {
    this.stop();
    this.start({
      deviceId
    });
  }

  updateVideoSources() {
    this.mediaDevices.enumerateDevices().then(devices => {
      this.setPluginState({
        videoSources: devices.filter(device => device.kind === 'videoinput')
      });
    });
  }

  render() {
    if (!this.webcamActive) {
      this.start();
    }

    const webcamState = this.getPluginState();

    if (!webcamState.cameraReady || !webcamState.hasCamera) {
      return h(PermissionsScreen, {
        icon: CameraIcon,
        i18n: this.i18n,
        hasCamera: webcamState.hasCamera
      });
    }

    return h(CameraScreen // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, webcamState, {
      onChangeVideoSource: this.changeVideoSource,
      onSnapshot: this.takeSnapshot,
      onStartRecording: this.startRecording,
      onStopRecording: this.stopRecording,
      onDiscardRecordedVideo: this.discardRecordedVideo,
      onSubmit: this.submit,
      onFocus: this.focus,
      onStop: this.stop,
      i18n: this.i18n,
      modes: this.opts.modes,
      showRecordingLength: this.opts.showRecordingLength,
      showVideoSourceDropdown: this.opts.showVideoSourceDropdown,
      supportsRecording: supportsMediaRecorder(),
      recording: webcamState.isRecording,
      mirror: _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror],
      src: this.stream
    }));
  }

  install() {
    this.setPluginState({
      cameraReady: false,
      recordingLengthSeconds: 0
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }

    if (this.mediaDevices) {
      this.updateVideoSources();

      this.mediaDevices.ondevicechange = () => {
        this.updateVideoSources();

        if (this.stream) {
          let restartStream = true;
          const {
            videoSources,
            currentDeviceId
          } = this.getPluginState();
          videoSources.forEach(videoSource => {
            if (currentDeviceId === videoSource.deviceId) {
              restartStream = false;
            }
          });

          if (restartStream) {
            this.stop();
            this.start();
          }
        }
      };
    }
  }

  uninstall() {
    this.stop();
    this.unmount();
  }

  onUnmount() {
    this.stop();
  }

}), _class.VERSION = "2.0.4", _temp);

},{"./../../core":48,"./../../utils/lib/canvasToBlob":149,"./../../utils/lib/getFileTypeExtension":164,"./../../utils/lib/mimeTypes":175,"./CameraIcon":182,"./CameraScreen":183,"./PermissionsScreen":185,"./locale.js":193,"./supportsMediaRecorder":194,"preact":18}],193:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    pluginNameCamera: 'Camera',
    noCameraTitle: 'Camera Not Available',
    noCameraDescription: 'In order to take pictures or record video, please connect a camera device',
    recordingStoppedMaxSize: 'Recording stopped because the file size is about to exceed the limit',
    submitRecordedFile: 'Submit recorded file',
    discardRecordedFile: 'Discard recorded file',
    // Shown before a picture is taken when the `countdown` option is set.
    smile: 'Smile!',
    // Used as the label for the button that takes a picture.
    // This is not visibly rendered but is picked up by screen readers.
    takePicture: 'Take a picture',
    // Used as the label for the button that starts a video recording.
    // This is not visibly rendered but is picked up by screen readers.
    startRecording: 'Begin video recording',
    // Used as the label for the button that stops a video recording.
    // This is not visibly rendered but is picked up by screen readers.
    stopRecording: 'Stop video recording',
    // Used as the label for the recording length counter. See the showRecordingLength option.
    // This is not visibly rendered but is picked up by screen readers.
    recordingLength: 'Recording length %{recording_length}',
    // Title on the allow access screen
    allowAccessTitle: 'Please allow access to your camera',
    // Description on the allow access screen
    allowAccessDescription: 'In order to take pictures or record video with your camera, please allow camera access for this site.'
  }
};

},{}],194:[function(require,module,exports){
"use strict";

module.exports = function supportsMediaRecorder() {
  /* eslint-disable compat/compat */
  return typeof MediaRecorder === 'function' && !!MediaRecorder.prototype && typeof MediaRecorder.prototype.start === 'function';
  /* eslint-enable compat/compat */
};

},{}],195:[function(require,module,exports){
"use strict";

var _class, _temp;

const {
  UIPlugin
} = require('./../../core');

const {
  Provider
} = require('./../../companion-client');

const {
  ProviderViews
} = require('./../../provider-views');

const {
  h
} = require('preact');

const locale = require('./locale');

module.exports = (_temp = _class = class Zoom extends UIPlugin {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.id = this.opts.id || 'Zoom';
    Provider.initPlugin(this, opts);
    this.title = this.opts.title || 'Zoom';

    this.icon = () => h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    }, h("rect", {
      className: "uppy-ProviderIconBg",
      width: "32",
      height: "32",
      rx: "16",
      fill: "#0E71EB"
    }), h("g", {
      fill: "none",
      fillRule: "evenodd"
    }, h("path", {
      fill: "#fff",
      d: "M29,31H14c-1.657,0-3-1.343-3-3V17h15c1.657,0,3,1.343,3,3V31z",
      style: {
        transform: 'translate(-5px, -5px) scale(0.9)'
      }
    }), h("polygon", {
      fill: "#fff",
      points: "37,31 31,27 31,21 37,17",
      style: {
        transform: 'translate(-5px, -5px) scale(0.9)'
      }
    })));

    this.provider = new Provider(uppy, {
      companionUrl: this.opts.companionUrl,
      companionHeaders: this.opts.companionHeaders,
      companionKeysParams: this.opts.companionKeysParams,
      companionCookiesRule: this.opts.companionCookiesRule,
      provider: 'zoom',
      pluginId: this.id
    });
    this.defaultLocale = locale;
    this.i18nInit();
    this.title = this.i18n('pluginNameZoom');
    this.onFirstRender = this.onFirstRender.bind(this);
    this.render = this.render.bind(this);
  }

  install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    const {
      target
    } = this.opts;

    if (target) {
      this.mount(target, this);
    }
  }

  uninstall() {
    this.view.tearDown();
    this.unmount();
  }

  onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  }

  render(state) {
    return this.view.render(state);
  }

}, _class.VERSION = "1.0.4", _temp);

},{"./../../companion-client":42,"./../../core":48,"./../../provider-views":120,"./locale":196,"preact":18}],196:[function(require,module,exports){
"use strict";

module.exports = {
  strings: {
    pluginNameZoom: 'Zoom'
  }
};

},{}],197:[function(require,module,exports){
"use strict";

const Uppy = require('./../../../../packages/@uppy/core');

const Dashboard = require('./../../../../packages/@uppy/dashboard');

const GoogleDrive = require('./../../../../packages/@uppy/google-drive');

const Dropbox = require('./../../../../packages/@uppy/dropbox');

const Instagram = require('./../../../../packages/@uppy/instagram');

const Facebook = require('./../../../../packages/@uppy/facebook');

const OneDrive = require('./../../../../packages/@uppy/onedrive');

const Zoom = require('./../../../../packages/@uppy/zoom'); // const Box = require('@uppy/box')


const ImageEditor = require('./../../../../packages/@uppy/image-editor');

const Url = require('./../../../../packages/@uppy/url');

const Webcam = require('./../../../../packages/@uppy/webcam');

const ScreenCapture = require('./../../../../packages/@uppy/screen-capture');

const Tus = require('./../../../../packages/@uppy/tus');

const DropTarget = require('./../../../../packages/@uppy/drop-target');

const GoldenRetriever = require('./../../../../packages/@uppy/golden-retriever');

const localeList = require('../locale_list.json');

const COMPANION = require('../env');

const RTL_LOCALES = ['ar_SA', 'fa_IR', 'he_IL'];

if (typeof window !== 'undefined' && typeof window.Uppy === 'undefined') {
  window.Uppy = {
    locales: {}
  };
}

function uppyInit() {
  if (window.uppy) {
    window.uppy.close();
  }

  const opts = window.uppyOptions;
  const uppy = new Uppy({
    logger: Uppy.debugLogger
  });
  uppy.use(Tus, {
    endpoint: 'https://tusd.tusdemo.net/files/'
  });
  uppy.on('complete', result => {
    console.log('successful files:');
    console.log(result.successful);
    console.log('failed files:');
    console.log(result.failed);
  });
  uppy.use(Dashboard, {
    trigger: '.UppyModalOpenerBtn',
    target: opts.DashboardInline ? '.DashboardContainer' : 'body',
    inline: opts.DashboardInline,
    height: 470,
    showProgressDetails: true,
    metaFields: [{
      id: 'name',
      name: 'Name',
      placeholder: 'file name'
    }, {
      id: 'caption',
      name: 'Caption',
      placeholder: 'add description'
    }]
  });
  window.uppy = uppy;
}

function uppySetOptions() {
  const opts = window.uppyOptions;
  const defaultNullRestrictions = {
    maxFileSize: null,
    minFileSize: null,
    maxNumberOfFiles: null,
    minNumberOfFiles: null,
    allowedFileTypes: null
  };
  const restrictions = {
    maxFileSize: 1000000,
    maxNumberOfFiles: 3,
    minNumberOfFiles: 2,
    allowedFileTypes: ['image/*', 'video/*'],
    requiredMetaFields: ['caption']
  };
  window.uppy.setOptions({
    autoProceed: opts.autoProceed,
    restrictions: opts.restrictions ? restrictions : defaultNullRestrictions
  });
  window.uppy.getPlugin('Dashboard').setOptions({
    note: opts.restrictions ? 'Images and video only, 23 files, up to 1 MB' : '',
    theme: opts.darkMode ? 'dark' : 'light',
    disabled: opts.disabled
  });
  const googleDriveInstance = window.uppy.getPlugin('GoogleDrive');

  if (opts.GoogleDrive && !googleDriveInstance) {
    window.uppy.use(GoogleDrive, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.GoogleDrive && googleDriveInstance) {
    window.uppy.removePlugin(googleDriveInstance);
  }

  const dropboxInstance = window.uppy.getPlugin('Dropbox');

  if (opts.Dropbox && !dropboxInstance) {
    window.uppy.use(Dropbox, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Dropbox && dropboxInstance) {
    window.uppy.removePlugin(dropboxInstance);
  }

  const instagramInstance = window.uppy.getPlugin('Instagram');

  if (opts.Instagram && !instagramInstance) {
    window.uppy.use(Instagram, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Instagram && instagramInstance) {
    window.uppy.removePlugin(instagramInstance);
  }

  const urlInstance = window.uppy.getPlugin('Url');

  if (opts.Url && !urlInstance) {
    window.uppy.use(Url, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Url && urlInstance) {
    window.uppy.removePlugin(urlInstance);
  }

  const facebookInstance = window.uppy.getPlugin('Facebook');

  if (opts.Facebook && !facebookInstance) {
    window.uppy.use(Facebook, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Facebook && facebookInstance) {
    window.uppy.removePlugin(facebookInstance);
  }

  const oneDriveInstance = window.uppy.getPlugin('OneDrive');

  if (opts.OneDrive && !oneDriveInstance) {
    window.uppy.use(OneDrive, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.OneDrive && oneDriveInstance) {
    window.uppy.removePlugin(oneDriveInstance);
  }

  const zoomInstance = window.uppy.getPlugin('Zoom');

  if (opts.Zoom && !zoomInstance) {
    window.uppy.use(Zoom, {
      target: Dashboard,
      companionUrl: 'https://intense-meadow-61813.herokuapp.com/'
    });
  }

  if (!opts.Zoom && zoomInstance) {
    window.uppy.removePlugin(zoomInstance);
  } //   const boxInstance = window.uppy.getPlugin('Box')
  //   if (opts.Box && !boxInstance) {
  //     window.uppy.use(Box, { target: Dashboard, companionUrl: COMPANION })
  //   }
  //   if (!opts.Box && boxInstance) {
  //     window.uppy.removePlugin(boxInstance)
  //   }


  const webcamInstance = window.uppy.getPlugin('Webcam');

  if (opts.Webcam && !webcamInstance) {
    window.uppy.use(Webcam, {
      target: Dashboard,
      showVideoSourceDropdown: true
    });
  }

  if (!opts.Webcam && webcamInstance) {
    window.uppy.removePlugin(webcamInstance);
  }

  const screenCaptureInstance = window.uppy.getPlugin('ScreenCapture');

  if (opts.ScreenCapture && !screenCaptureInstance) {
    window.uppy.use(ScreenCapture, {
      target: Dashboard
    });
  }

  if (!opts.ScreenCapture && screenCaptureInstance) {
    window.uppy.removePlugin(screenCaptureInstance);
  }

  const imageEditorInstance = window.uppy.getPlugin('ImageEditor');

  if (opts.imageEditor && !imageEditorInstance) {
    window.uppy.use(ImageEditor, {
      target: Dashboard
    });
  }

  if (!opts.imageEditor && imageEditorInstance) {
    window.uppy.removePlugin(imageEditorInstance);
  }

  const dropTargetInstance = window.uppy.getPlugin('DropTarget');

  if (opts.DropTarget && !dropTargetInstance) {
    window.uppy.use(DropTarget, {
      target: document.body
    });
  }

  if (!opts.DropTarget && dropTargetInstance) {
    window.uppy.removePlugin(dropTargetInstance);
  }

  const goldenRetrieverInstance = window.uppy.getPlugin('GoldenRetriever');

  if (opts.GoldenRetriever && !goldenRetrieverInstance) {
    window.uppy.use(GoldenRetriever);
  }

  if (!opts.GoldenRetriever && goldenRetrieverInstance) {
    window.uppy.removePlugin(goldenRetrieverInstance);
  }
}

function whenLocaleAvailable(localeName, callback) {
  const interval = 100; // ms

  const loop = setInterval(() => {
    if (window.Uppy && window.Uppy.locales && window.Uppy.locales[localeName]) {
      clearInterval(loop);
      callback(window.Uppy.locales[localeName]);
    }
  }, interval);
}

function loadLocaleFromCDN(localeName) {
  const head = document.getElementsByTagName('head')[0];
  const js = document.createElement('script');
  js.type = 'text/javascript';
  js.src = `https://releases.transloadit.com/uppy/locales/v2.0.3/${localeName}.min.js`;
  head.appendChild(js);
}

function setLocale(localeName) {
  if (typeof window.Uppy.locales[localeName] === 'undefined') {
    loadLocaleFromCDN(localeName);
  }

  whenLocaleAvailable(localeName, localeObj => {
    const direction = RTL_LOCALES.indexOf(localeName) !== -1 ? 'rtl' : 'ltr';
    window.uppy.setOptions({
      locale: localeObj
    });
    window.uppy.getPlugin('Dashboard').setOptions({
      direction
    });
  });
}

function populateLocaleSelect() {
  const localeSelect = document.getElementById('localeList');
  Object.keys(localeList).forEach(localeName => {
    if (localeName === 'en_US') return;
    localeSelect.innerHTML += `<option value="${localeName}">${localeList[localeName]}  (${localeName})</option>`;
  });
  localeSelect.addEventListener('change', event => {
    const localeName = event.target.value;
    setLocale(localeName);
  });
}

window.uppySetOptions = uppySetOptions;
window.uppyInit = uppyInit;
window.uppySetLocale = setLocale;
populateLocaleSelect();
uppyInit();
uppySetOptions();

},{"../env":198,"../locale_list.json":199,"./../../../../packages/@uppy/core":48,"./../../../../packages/@uppy/dashboard":69,"./../../../../packages/@uppy/drop-target":77,"./../../../../packages/@uppy/dropbox":78,"./../../../../packages/@uppy/facebook":80,"./../../../../packages/@uppy/golden-retriever":85,"./../../../../packages/@uppy/google-drive":87,"./../../../../packages/@uppy/image-editor":90,"./../../../../packages/@uppy/instagram":95,"./../../../../packages/@uppy/onedrive":97,"./../../../../packages/@uppy/screen-capture":127,"./../../../../packages/@uppy/tus":139,"./../../../../packages/@uppy/url":141,"./../../../../packages/@uppy/webcam":192,"./../../../../packages/@uppy/zoom":195}],198:[function(require,module,exports){
"use strict";

let companionEndpoint = 'http://localhost:3020'; // eslint-disable-next-line no-restricted-globals

if (location.hostname === 'uppy.io' || /--uppy\.netlify\.app$/.test(location.hostname)) {
  companionEndpoint = '//companion.uppy.io';
}

const COMPANION = companionEndpoint;
module.exports = COMPANION;

},{}],199:[function(require,module,exports){
module.exports={"ar_SA":"Arabic (Saudi Arabia)","bg_BG":"Bulgarian (Bulgaria)","cs_CZ":"Czech (Czechia)","da_DK":"Danish (Denmark)","de_DE":"German (Germany)","el_GR":"Greek (Greece)","en_US":"English (United States)","es_ES":"Spanish (Spain)","fa_IR":"Persian (Iran)","fi_FI":"Finnish (Finland)","fr_FR":"French (France)","gl_ES":"Galician (Spain)","he_IL":"Hebrew (Israel)","hr_HR":"Croatian (Croatia)","hu_HU":"Hungarian (Hungary)","id_ID":"Indonesian (Indonesia)","is_IS":"Icelandic (Iceland)","it_IT":"Italian (Italy)","ja_JP":"Japanese (Japan)","ko_KR":"Korean (South Korea)","nb_NO":"Norwegian Bokml (Norway)","nl_NL":"Dutch (Netherlands)","pl_PL":"Polish (Poland)","pt_BR":"Portuguese (Brazil)","pt_PT":"Portuguese (Portugal)","ro_RO":"Romanian (Romania)","ru_RU":"Russian (Russia)","sk_SK":"Slovak (Slovakia)","sr_RS_Cyrillic":"Serbian (Serbia, Cyrillic)","sr_RS_Latin":"Serbian (Serbia, Latin)","sv_SE":"Swedish (Sweden)","th_TH":"Thai (Thailand)","tr_TR":"Turkish (Turkey)","uk_UA":"Ukrainian (Ukraine)","vi_VN":"Vietnamese (Vietnam)","zh_CN":"Chinese (China)","zh_TW":"Chinese (Taiwan)"}
},{}]},{},[197])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzL3ByZXR0aWVyQnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Nyb3BwZXJqcy9kaXN0L2Nyb3BwZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXhpZnIvZGlzdC9taW5pLmxlZ2FjeS51bWQuanMiLCIuLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9pcy1zaGFsbG93LWVxdWFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2pzLWJhc2U2NC9iYXNlNjQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tZW1vaXplLW9uZS9kaXN0L21lbW9pemUtb25lLmNqcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9taW1lLW1hdGNoL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21pbWUtbWF0Y2gvbm9kZV9tb2R1bGVzL3dpbGRjYXJkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL25hbWVzcGFjZS1lbWl0dGVyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL25hbm9pZC9pbmRleC5icm93c2VyLmNqcyIsIi4uL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmNqcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5naWZ5L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvZmlsZVJlYWRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9maW5nZXJwcmludC5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9odHRwU3RhY2suanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvaXNDb3Jkb3ZhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL2lzUmVhY3ROYXRpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvcmVhZEFzQnl0ZUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL3VyaVRvQmxvYi5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci91cmxTdG9yYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvbG9nZ2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9ub29wVXJsU3RvcmFnZS5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvdXBsb2FkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS91dWlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VybC1wYXJzZS9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL0F1dGhFcnJvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL1Byb3ZpZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvUmVxdWVzdENsaWVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL1NlYXJjaFByb3ZpZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvU29ja2V0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy90b2tlblN0b3JhZ2UuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb3JlL3NyYy9CYXNlUGx1Z2luLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvVUlQbHVnaW4uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb3JlL3NyYy9VcHB5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvZ2V0RmlsZU5hbWUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb3JlL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvc3JjL2xvY2FsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvc3JjL2xvZ2dlcnMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb3JlL3NyYy9zdXBwb3J0c1VwbG9hZFByb2dyZXNzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0FkZEZpbGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0FkZEZpbGVzUGFuZWwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRGFzaGJvYXJkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0VkaXRvclBhbmVsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVDYXJkL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVJdGVtL0J1dHRvbnMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vRmlsZUluZm8vaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vRmlsZVByZXZpZXdBbmRMaW5rL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVJdGVtL0ZpbGVQcm9ncmVzcy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9NZXRhRXJyb3JNZXNzYWdlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVJdGVtL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVMaXN0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVQcmV2aWV3LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL1BpY2tlclBhbmVsQ29udGVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9QaWNrZXJQYW5lbFRvcEJhci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9TbGlkZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9WaXJ0dWFsTGlzdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2xvY2FsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvY29weVRvQ2xpcGJvYXJkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy9jcmVhdGVTdXBlckZvY3VzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy9nZXRBY3RpdmVPdmVybGF5RWwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL2dldEZpbGVUeXBlSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvaWdub3JlRXZlbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL3RyYXBGb2N1cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Ryb3AtdGFyZ2V0L3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Ryb3Bib3gvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZHJvcGJveC9zcmMvbG9jYWxlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZmFjZWJvb2svc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZmFjZWJvb2svc3JjL2xvY2FsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvbGRlbi1yZXRyaWV2ZXIvc3JjL0luZGV4ZWREQlN0b3JlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZ29sZGVuLXJldHJpZXZlci9zcmMvTWV0YURhdGFTdG9yZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvbGRlbi1yZXRyaWV2ZXIvc3JjL1NlcnZpY2VXb3JrZXJTdG9yZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvbGRlbi1yZXRyaWV2ZXIvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZ29vZ2xlLWRyaXZlL3NyYy9Ecml2ZVByb3ZpZGVyVmlld3MuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9nb29nbGUtZHJpdmUvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZ29vZ2xlLWRyaXZlL3NyYy9sb2NhbGUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9pbWFnZS1lZGl0b3Ivc3JjL0VkaXRvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2ltYWdlLWVkaXRvci9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9pbWFnZS1lZGl0b3Ivc3JjL2xvY2FsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2luZm9ybWVyL3NyYy9GYWRlSW4uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9pbmZvcm1lci9zcmMvVHJhbnNpdGlvbkdyb3VwLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5mb3JtZXIvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5zdGFncmFtL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2luc3RhZ3JhbS9zcmMvbG9jYWxlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvb25lZHJpdmUvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvb25lZHJpdmUvc3JjL2xvY2FsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9CcmVhZGNydW1icy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9Ccm93c2VyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0Nsb3NlV3JhcHBlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9GaWx0ZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvRm9vdGVyQWN0aW9ucy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2NvbXBvbmVudHMvR3JpZExpLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0l0ZW0vY29tcG9uZW50cy9JdGVtSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2NvbXBvbmVudHMvTGlzdExpLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0l0ZW0vaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvTG9hZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1Byb3ZpZGVyVmlldy9BdXRoVmlldy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9Qcm92aWRlclZpZXcvSGVhZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1Byb3ZpZGVyVmlldy9Qcm92aWRlclZpZXcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvUHJvdmlkZXJWaWV3L1VzZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvUHJvdmlkZXJWaWV3L2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1NlYXJjaFByb3ZpZGVyVmlldy9IZWFkZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvU2VhcmNoUHJvdmlkZXJWaWV3L0lucHV0Vmlldy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9TZWFyY2hQcm92aWRlclZpZXcvU2VhcmNoUHJvdmlkZXJWaWV3LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1NlYXJjaFByb3ZpZGVyVmlldy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9TaGFyZWRIYW5kbGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1ZpZXcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zY3JlZW4tY2FwdHVyZS9zcmMvQ2FwdHVyZVNjcmVlbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3NjcmVlbi1jYXB0dXJlL3NyYy9SZWNvcmRCdXR0b24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zY3JlZW4tY2FwdHVyZS9zcmMvU2NyZWVuUmVjSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3NjcmVlbi1jYXB0dXJlL3NyYy9TdG9wV2F0Y2guanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zY3JlZW4tY2FwdHVyZS9zcmMvU3RyZWFtU3RhdHVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc2NyZWVuLWNhcHR1cmUvc3JjL1N1Ym1pdEJ1dHRvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3NjcmVlbi1jYXB0dXJlL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3NjcmVlbi1jYXB0dXJlL3NyYy9sb2NhbGUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zdGF0dXMtYmFyL3NyYy9Db21wb25lbnRzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvU3RhdHVzQmFyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvU3RhdHVzQmFyU3RhdGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvY2FsY3VsYXRlUHJvY2Vzc2luZ1Byb2dyZXNzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zdGF0dXMtYmFyL3NyYy9sb2NhbGUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zdG9yZS1kZWZhdWx0L3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RodW1ibmFpbC1nZW5lcmF0b3Ivc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvci9zcmMvbG9jYWxlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHVzL3NyYy9nZXRGaW5nZXJwcmludC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3R1cy9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91cmwvc3JjL1VybFVJLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXJsL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3VybC9zcmMvbG9jYWxlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXJsL3NyYy91dGlscy9mb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL0V2ZW50VHJhY2tlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9GT0NVU0FCTEVfRUxFTUVOVFMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvTmV0d29ya0Vycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL1JhdGVMaW1pdGVkUXVldWUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvVHJhbnNsYXRvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9jYW52YXNUb0Jsb2IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZGF0YVVSSXRvQmxvYi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9lbWl0U29ja2V0UHJvZ3Jlc3MuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZmV0Y2hXaXRoTmV0d29ya0Vycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2ZpbmRBbGxET01FbGVtZW50cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9maW5kRE9NRWxlbWVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZW5lcmF0ZUZpbGVJRC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRCeXRlc1JlbWFpbmluZy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RHJvcHBlZEZpbGVzL3V0aWxzL2ZhbGxiYWNrQXBpLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldERyb3BwZWRGaWxlcy91dGlscy93ZWJraXRHZXRBc0VudHJ5QXBpL2dldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldERyb3BwZWRGaWxlcy91dGlscy93ZWJraXRHZXRBc0VudHJ5QXBpL2dldFJlbGF0aXZlUGF0aC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvdXRpbHMvd2Via2l0R2V0QXNFbnRyeUFwaS9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRGaWxlTmFtZUFuZEV4dGVuc2lvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRGaWxlVHlwZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRGaWxlVHlwZUV4dGVuc2lvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRTb2NrZXRIb3N0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldFNwZWVkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldFRleHREaXJlY3Rpb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0VGltZVN0YW1wLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2hhc1Byb3BlcnR5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2lzRE9NRWxlbWVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc0RyYWdEcm9wU3VwcG9ydGVkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2lzTmV0d29ya0Vycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2lzT2JqZWN0VVJMLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2lzUHJldmlld1N1cHBvcnRlZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9taW1lVHlwZXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvcHJldHR5RVRBLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3JlbW90ZUZpbGVPYmpUb0xvY2FsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3NlY29uZHNUb1RpbWUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvc2V0dGxlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3RvQXJyYXkuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvdHJ1bmNhdGVTdHJpbmcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL0NhbWVyYUljb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL0NhbWVyYVNjcmVlbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvRGlzY2FyZEJ1dHRvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvUGVybWlzc2lvbnNTY3JlZW4uanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL1JlY29yZEJ1dHRvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvUmVjb3JkaW5nTGVuZ3RoLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9TbmFwc2hvdEJ1dHRvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvU3VibWl0QnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9WaWRlb1NvdXJjZVNlbGVjdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvZm9ybWF0U2Vjb25kcy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL2xvY2FsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvc3VwcG9ydHNNZWRpYVJlY29yZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvem9vbS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS96b29tL3NyYy9sb2NhbGUuanMiLCJzcmMvZXhhbXBsZXMvZGFzaGJvYXJkL2FwcC5lczYiLCJzcmMvZXhhbXBsZXMvZW52LmpzIiwic3JjL2V4YW1wbGVzL2xvY2FsZV9saXN0Lmpzb24iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hpSEE7QUFDQTs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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TSxDQUFDLGFBQVAsR0FBdUIsU0FBdkI7QUFFQSxvQkFBb0I7QUFDcEIsUUFBUTtBQUNSLGNBQWM7Ozs7O0FDblFkLElBQUksaUJBQWlCLEdBQUcsdUJBQXhCLEMsQ0FFQTs7QUFDQSxJQUFJLFFBQVEsQ0FBQyxRQUFULEtBQXNCLFNBQXRCLElBQW1DLHdCQUF3QixJQUF4QixDQUE2QixRQUFRLENBQUMsUUFBdEMsQ0FBdkMsRUFBd0Y7QUFDdEYsRUFBQSxpQkFBaUIsR0FBRyxxQkFBcEI7QUFDRDs7QUFFRCxNQUFNLFNBQVMsR0FBRyxpQkFBbEI7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFqQjs7O0FDUkEiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0ZsZXQvcHJldHRpZXItYnl0ZXMvXG4vLyBDaGFuZ2luZyAxMDAwIGJ5dGVzIHRvIDEwMjQsIHNvIHdlIGNhbiBrZWVwIHVwcGVyY2FzZSBLQiB2cyBrQlxuLy8gSVNDIExpY2Vuc2UgKGMpIERhbiBGbGV0dHJlIGh0dHBzOi8vZ2l0aHViLmNvbS9GbGV0L3ByZXR0aWVyLWJ5dGVzL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJldHRpZXJCeXRlcyAobnVtKSB7XG4gIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyB8fCBpc05hTihudW0pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBudW1iZXIsIGdvdCAnICsgdHlwZW9mIG51bSlcbiAgfVxuXG4gIHZhciBuZWcgPSBudW0gPCAwXG4gIHZhciB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddXG5cbiAgaWYgKG5lZykge1xuICAgIG51bSA9IC1udW1cbiAgfVxuXG4gIGlmIChudW0gPCAxKSB7XG4gICAgcmV0dXJuIChuZWcgPyAnLScgOiAnJykgKyBudW0gKyAnIEInXG4gIH1cblxuICB2YXIgZXhwb25lbnQgPSBNYXRoLm1pbihNYXRoLmZsb29yKE1hdGgubG9nKG51bSkgLyBNYXRoLmxvZygxMDI0KSksIHVuaXRzLmxlbmd0aCAtIDEpXG4gIG51bSA9IE51bWJlcihudW0gLyBNYXRoLnBvdygxMDI0LCBleHBvbmVudCkpXG4gIHZhciB1bml0ID0gdW5pdHNbZXhwb25lbnRdXG5cbiAgaWYgKG51bSA+PSAxMCB8fCBudW0gJSAxID09PSAwKSB7XG4gICAgLy8gRG8gbm90IHNob3cgZGVjaW1hbHMgd2hlbiB0aGUgbnVtYmVyIGlzIHR3by1kaWdpdCwgb3IgaWYgdGhlIG51bWJlciBoYXMgbm9cbiAgICAvLyBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICByZXR1cm4gKG5lZyA/ICctJyA6ICcnKSArIG51bS50b0ZpeGVkKDApICsgJyAnICsgdW5pdFxuICB9IGVsc2Uge1xuICAgIHJldHVybiAobmVnID8gJy0nIDogJycpICsgbnVtLnRvRml4ZWQoMSkgKyAnICcgKyB1bml0XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTggSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRpZiAoYXJnLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmIChhcmcudG9TdHJpbmcgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiLyohXG4gKiBDcm9wcGVyLmpzIHYxLjUuN1xuICogaHR0cHM6Ly9mZW5neXVhbmNoZW4uZ2l0aHViLmlvL2Nyb3BwZXJqc1xuICpcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQgQ2hlbiBGZW5neXVhblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMC0wNS0yM1QwNToyMzowMC4wODFaXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Dcm9wcGVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBXSU5ET1cgPSBJU19CUk9XU0VSID8gd2luZG93IDoge307XG4gIHZhciBJU19UT1VDSF9ERVZJQ0UgPSBJU19CUk9XU0VSICYmIFdJTkRPVy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAnb250b3VjaHN0YXJ0JyBpbiBXSU5ET1cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZmFsc2U7XG4gIHZhciBIQVNfUE9JTlRFUl9FVkVOVCA9IElTX0JST1dTRVIgPyAnUG9pbnRlckV2ZW50JyBpbiBXSU5ET1cgOiBmYWxzZTtcbiAgdmFyIE5BTUVTUEFDRSA9ICdjcm9wcGVyJzsgLy8gQWN0aW9uc1xuXG4gIHZhciBBQ1RJT05fQUxMID0gJ2FsbCc7XG4gIHZhciBBQ1RJT05fQ1JPUCA9ICdjcm9wJztcbiAgdmFyIEFDVElPTl9NT1ZFID0gJ21vdmUnO1xuICB2YXIgQUNUSU9OX1pPT00gPSAnem9vbSc7XG4gIHZhciBBQ1RJT05fRUFTVCA9ICdlJztcbiAgdmFyIEFDVElPTl9XRVNUID0gJ3cnO1xuICB2YXIgQUNUSU9OX1NPVVRIID0gJ3MnO1xuICB2YXIgQUNUSU9OX05PUlRIID0gJ24nO1xuICB2YXIgQUNUSU9OX05PUlRIX0VBU1QgPSAnbmUnO1xuICB2YXIgQUNUSU9OX05PUlRIX1dFU1QgPSAnbncnO1xuICB2YXIgQUNUSU9OX1NPVVRIX0VBU1QgPSAnc2UnO1xuICB2YXIgQUNUSU9OX1NPVVRIX1dFU1QgPSAnc3cnOyAvLyBDbGFzc2VzXG5cbiAgdmFyIENMQVNTX0NST1AgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNyb3BcIik7XG4gIHZhciBDTEFTU19ESVNBQkxFRCA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItZGlzYWJsZWRcIik7XG4gIHZhciBDTEFTU19ISURERU4gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGRlblwiKTtcbiAgdmFyIENMQVNTX0hJREUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGVcIik7XG4gIHZhciBDTEFTU19JTlZJU0lCTEUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWludmlzaWJsZVwiKTtcbiAgdmFyIENMQVNTX01PREFMID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1tb2RhbFwiKTtcbiAgdmFyIENMQVNTX01PVkUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLW1vdmVcIik7IC8vIERhdGEga2V5c1xuXG4gIHZhciBEQVRBX0FDVElPTiA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCJBY3Rpb25cIik7XG4gIHZhciBEQVRBX1BSRVZJRVcgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiUHJldmlld1wiKTsgLy8gRHJhZyBtb2Rlc1xuXG4gIHZhciBEUkFHX01PREVfQ1JPUCA9ICdjcm9wJztcbiAgdmFyIERSQUdfTU9ERV9NT1ZFID0gJ21vdmUnO1xuICB2YXIgRFJBR19NT0RFX05PTkUgPSAnbm9uZSc7IC8vIEV2ZW50c1xuXG4gIHZhciBFVkVOVF9DUk9QID0gJ2Nyb3AnO1xuICB2YXIgRVZFTlRfQ1JPUF9FTkQgPSAnY3JvcGVuZCc7XG4gIHZhciBFVkVOVF9DUk9QX01PVkUgPSAnY3JvcG1vdmUnO1xuICB2YXIgRVZFTlRfQ1JPUF9TVEFSVCA9ICdjcm9wc3RhcnQnO1xuICB2YXIgRVZFTlRfREJMQ0xJQ0sgPSAnZGJsY2xpY2snO1xuICB2YXIgRVZFTlRfVE9VQ0hfU1RBUlQgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2hzdGFydCcgOiAnbW91c2Vkb3duJztcbiAgdmFyIEVWRU5UX1RPVUNIX01PVkUgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2htb3ZlJyA6ICdtb3VzZW1vdmUnO1xuICB2YXIgRVZFTlRfVE9VQ0hfRU5EID0gSVNfVE9VQ0hfREVWSUNFID8gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJyA6ICdtb3VzZXVwJztcbiAgdmFyIEVWRU5UX1BPSU5URVJfRE9XTiA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJkb3duJyA6IEVWRU5UX1RPVUNIX1NUQVJUO1xuICB2YXIgRVZFTlRfUE9JTlRFUl9NT1ZFID0gSEFTX1BPSU5URVJfRVZFTlQgPyAncG9pbnRlcm1vdmUnIDogRVZFTlRfVE9VQ0hfTU9WRTtcbiAgdmFyIEVWRU5UX1BPSU5URVJfVVAgPSBIQVNfUE9JTlRFUl9FVkVOVCA/ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCcgOiBFVkVOVF9UT1VDSF9FTkQ7XG4gIHZhciBFVkVOVF9SRUFEWSA9ICdyZWFkeSc7XG4gIHZhciBFVkVOVF9SRVNJWkUgPSAncmVzaXplJztcbiAgdmFyIEVWRU5UX1dIRUVMID0gJ3doZWVsJztcbiAgdmFyIEVWRU5UX1pPT00gPSAnem9vbSc7IC8vIE1pbWUgdHlwZXNcblxuICB2YXIgTUlNRV9UWVBFX0pQRUcgPSAnaW1hZ2UvanBlZyc7IC8vIFJlZ0V4cHNcblxuICB2YXIgUkVHRVhQX0FDVElPTlMgPSAvXmV8d3xzfG58c2V8c3d8bmV8bnd8YWxsfGNyb3B8bW92ZXx6b29tJC87XG4gIHZhciBSRUdFWFBfREFUQV9VUkwgPSAvXmRhdGE6LztcbiAgdmFyIFJFR0VYUF9EQVRBX1VSTF9KUEVHID0gL15kYXRhOmltYWdlXFwvanBlZztiYXNlNjQsLztcbiAgdmFyIFJFR0VYUF9UQUdfTkFNRSA9IC9eaW1nfGNhbnZhcyQvaTsgLy8gTWlzY1xuXG4gIHZhciBERUZBVUxUUyA9IHtcbiAgICAvLyBEZWZpbmUgdGhlIHZpZXcgbW9kZSBvZiB0aGUgY3JvcHBlclxuICAgIHZpZXdNb2RlOiAwLFxuICAgIC8vIDAsIDEsIDIsIDNcbiAgICAvLyBEZWZpbmUgdGhlIGRyYWdnaW5nIG1vZGUgb2YgdGhlIGNyb3BwZXJcbiAgICBkcmFnTW9kZTogRFJBR19NT0RFX0NST1AsXG4gICAgLy8gJ2Nyb3AnLCAnbW92ZScgb3IgJ25vbmUnXG4gICAgLy8gRGVmaW5lIHRoZSBpbml0aWFsIGFzcGVjdCByYXRpbyBvZiB0aGUgY3JvcCBib3hcbiAgICBpbml0aWFsQXNwZWN0UmF0aW86IE5hTixcbiAgICAvLyBEZWZpbmUgdGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgY3JvcCBib3hcbiAgICBhc3BlY3RSYXRpbzogTmFOLFxuICAgIC8vIEFuIG9iamVjdCB3aXRoIHRoZSBwcmV2aW91cyBjcm9wcGluZyByZXN1bHQgZGF0YVxuICAgIGRhdGE6IG51bGwsXG4gICAgLy8gQSBzZWxlY3RvciBmb3IgYWRkaW5nIGV4dHJhIGNvbnRhaW5lcnMgdG8gcHJldmlld1xuICAgIHByZXZpZXc6ICcnLFxuICAgIC8vIFJlLXJlbmRlciB0aGUgY3JvcHBlciB3aGVuIHJlc2l6ZSB0aGUgd2luZG93XG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAvLyBSZXN0b3JlIHRoZSBjcm9wcGVkIGFyZWEgYWZ0ZXIgcmVzaXplIHRoZSB3aW5kb3dcbiAgICByZXN0b3JlOiB0cnVlLFxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGltYWdlIGlzIGEgY3Jvc3Mtb3JpZ2luIGltYWdlXG4gICAgY2hlY2tDcm9zc09yaWdpbjogdHJ1ZSxcbiAgICAvLyBDaGVjayB0aGUgY3VycmVudCBpbWFnZSdzIEV4aWYgT3JpZW50YXRpb24gaW5mb3JtYXRpb25cbiAgICBjaGVja09yaWVudGF0aW9uOiB0cnVlLFxuICAgIC8vIFNob3cgdGhlIGJsYWNrIG1vZGFsXG4gICAgbW9kYWw6IHRydWUsXG4gICAgLy8gU2hvdyB0aGUgZGFzaGVkIGxpbmVzIGZvciBndWlkaW5nXG4gICAgZ3VpZGVzOiB0cnVlLFxuICAgIC8vIFNob3cgdGhlIGNlbnRlciBpbmRpY2F0b3IgZm9yIGd1aWRpbmdcbiAgICBjZW50ZXI6IHRydWUsXG4gICAgLy8gU2hvdyB0aGUgd2hpdGUgbW9kYWwgdG8gaGlnaGxpZ2h0IHRoZSBjcm9wIGJveFxuICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAvLyBTaG93IHRoZSBncmlkIGJhY2tncm91bmRcbiAgICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAgIC8vIEVuYWJsZSB0byBjcm9wIHRoZSBpbWFnZSBhdXRvbWF0aWNhbGx5IHdoZW4gaW5pdGlhbGl6ZVxuICAgIGF1dG9Dcm9wOiB0cnVlLFxuICAgIC8vIERlZmluZSB0aGUgcGVyY2VudGFnZSBvZiBhdXRvbWF0aWMgY3JvcHBpbmcgYXJlYSB3aGVuIGluaXRpYWxpemVzXG4gICAgYXV0b0Nyb3BBcmVhOiAwLjgsXG4gICAgLy8gRW5hYmxlIHRvIG1vdmUgdGhlIGltYWdlXG4gICAgbW92YWJsZTogdHJ1ZSxcbiAgICAvLyBFbmFibGUgdG8gcm90YXRlIHRoZSBpbWFnZVxuICAgIHJvdGF0YWJsZTogdHJ1ZSxcbiAgICAvLyBFbmFibGUgdG8gc2NhbGUgdGhlIGltYWdlXG4gICAgc2NhbGFibGU6IHRydWUsXG4gICAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlXG4gICAgem9vbWFibGU6IHRydWUsXG4gICAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlIGJ5IGRyYWdnaW5nIHRvdWNoXG4gICAgem9vbU9uVG91Y2g6IHRydWUsXG4gICAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlIGJ5IHdoZWVsaW5nIG1vdXNlXG4gICAgem9vbU9uV2hlZWw6IHRydWUsXG4gICAgLy8gRGVmaW5lIHpvb20gcmF0aW8gd2hlbiB6b29tIHRoZSBpbWFnZSBieSB3aGVlbGluZyBtb3VzZVxuICAgIHdoZWVsWm9vbVJhdGlvOiAwLjEsXG4gICAgLy8gRW5hYmxlIHRvIG1vdmUgdGhlIGNyb3AgYm94XG4gICAgY3JvcEJveE1vdmFibGU6IHRydWUsXG4gICAgLy8gRW5hYmxlIHRvIHJlc2l6ZSB0aGUgY3JvcCBib3hcbiAgICBjcm9wQm94UmVzaXphYmxlOiB0cnVlLFxuICAgIC8vIFRvZ2dsZSBkcmFnIG1vZGUgYmV0d2VlbiBcImNyb3BcIiBhbmQgXCJtb3ZlXCIgd2hlbiBjbGljayB0d2ljZSBvbiB0aGUgY3JvcHBlclxuICAgIHRvZ2dsZURyYWdNb2RlT25EYmxjbGljazogdHJ1ZSxcbiAgICAvLyBTaXplIGxpbWl0YXRpb25cbiAgICBtaW5DYW52YXNXaWR0aDogMCxcbiAgICBtaW5DYW52YXNIZWlnaHQ6IDAsXG4gICAgbWluQ3JvcEJveFdpZHRoOiAwLFxuICAgIG1pbkNyb3BCb3hIZWlnaHQ6IDAsXG4gICAgbWluQ29udGFpbmVyV2lkdGg6IDIwMCxcbiAgICBtaW5Db250YWluZXJIZWlnaHQ6IDEwMCxcbiAgICAvLyBTaG9ydGN1dHMgb2YgZXZlbnRzXG4gICAgcmVhZHk6IG51bGwsXG4gICAgY3JvcHN0YXJ0OiBudWxsLFxuICAgIGNyb3Btb3ZlOiBudWxsLFxuICAgIGNyb3BlbmQ6IG51bGwsXG4gICAgY3JvcDogbnVsbCxcbiAgICB6b29tOiBudWxsXG4gIH07XG5cbiAgdmFyIFRFTVBMQVRFID0gJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNvbnRhaW5lclwiIHRvdWNoLWFjdGlvbj1cIm5vbmVcIj4nICsgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLXdyYXAtYm94XCI+JyArICc8ZGl2IGNsYXNzPVwiY3JvcHBlci1jYW52YXNcIj48L2Rpdj4nICsgJzwvZGl2PicgKyAnPGRpdiBjbGFzcz1cImNyb3BwZXItZHJhZy1ib3hcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNyb3AtYm94XCI+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItdmlldy1ib3hcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZGFzaGVkIGRhc2hlZC1oXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWRhc2hlZCBkYXNoZWQtdlwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1jZW50ZXJcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZmFjZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJlXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS1uXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm5cIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItbGluZSBsaW5lLXdcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwid1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtc1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LWVcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwiZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1uXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm5cIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtd1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJ3XCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LXNcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwic1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1uZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJuZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1ud1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJud1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zd1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzd1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzZVwiPjwvc3Bhbj4nICsgJzwvZGl2PicgKyAnPC9kaXY+JztcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cbiAgICovXG5cbiAgdmFyIGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IFdJTkRPVy5pc05hTjtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlci5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBvc2l0aXZlIG51bWJlci5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBvc2l0aXZlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICB2YXIgaXNQb3NpdGl2ZU51bWJlciA9IGZ1bmN0aW9uIGlzUG9zaXRpdmVOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPiAwICYmIHZhbHVlIDwgSW5maW5pdHk7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHVuZGVmaW5lZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG4gIH1cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIF9jb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgICAgdmFyIHByb3RvdHlwZSA9IF9jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdG9yICYmIHByb3RvdHlwZSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIC8qKlxuICAgKiBDb252ZXJ0IGFycmF5LWxpa2Ugb3IgaXRlcmFibGUgb2JqZWN0IHRvIGFuIGFycmF5LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tID8gQXJyYXkuZnJvbSh2YWx1ZSkgOiBzbGljZS5jYWxsKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogSXRlcmF0ZSB0aGUgZ2l2ZW4gZGF0YS5cbiAgICogQHBhcmFtIHsqfSBkYXRhIC0gVGhlIGRhdGEgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcHJvY2VzcyBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIG9yaWdpbmFsIGRhdGEuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZvckVhY2goZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZGF0YSAmJiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNOdW1iZXIoZGF0YS5sZW5ndGgpXG4gICAgICAvKiBhcnJheS1saWtlICovXG4gICAgICApIHtcbiAgICAgICAgICB0b0FycmF5KGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoZGF0YSwgdmFsdWUsIGtleSwgZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChkYXRhLCBkYXRhW2tleV0sIGtleSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBFeHRlbmQgdGhlIGdpdmVuIG9iamVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byBleHRlbmQuXG4gICAqIEBwYXJhbSB7Kn0gYXJncyAtIFRoZSByZXN0IG9iamVjdHMgZm9yIG1lcmdpbmcgdG8gdGhlIHRhcmdldCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBleHRlbmRlZCBvYmplY3QuXG4gICAqL1xuXG4gIHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChpc09iamVjdChhcmcpKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gYXJnW2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHZhciBSRUdFWFBfREVDSU1BTFMgPSAvXFwuXFxkKig/OjB8OSl7MTJ9XFxkKiQvO1xuICAvKipcbiAgICogTm9ybWFsaXplIGRlY2ltYWwgbnVtYmVyLlxuICAgKiBDaGVjayBvdXQge0BsaW5rIGh0dHBzOi8vMC4zMDAwMDAwMDAwMDAwMDAwNC5jb20vfVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gbm9ybWFsaXplLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVzPTEwMDAwMDAwMDAwMF0gLSBUaGUgdGltZXMgZm9yIG5vcm1hbGl6aW5nLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG51bWJlci5cbiAgICovXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplRGVjaW1hbE51bWJlcih2YWx1ZSkge1xuICAgIHZhciB0aW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDAwMDAwMDAwO1xuICAgIHJldHVybiBSRUdFWFBfREVDSU1BTFMudGVzdCh2YWx1ZSkgPyBNYXRoLnJvdW5kKHZhbHVlICogdGltZXMpIC8gdGltZXMgOiB2YWx1ZTtcbiAgfVxuICB2YXIgUkVHRVhQX1NVRkZJWCA9IC9ed2lkdGh8aGVpZ2h0fGxlZnR8dG9wfG1hcmdpbkxlZnR8bWFyZ2luVG9wJC87XG4gIC8qKlxuICAgKiBBcHBseSBzdHlsZXMgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyAtIFRoZSBzdHlsZXMgZm9yIGFwcGx5aW5nLlxuICAgKi9cblxuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGZvckVhY2goc3R5bGVzLCBmdW5jdGlvbiAodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgICBpZiAoUkVHRVhQX1NVRkZJWC50ZXN0KHByb3BlcnR5KSAmJiBpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGhhcyBhIHNwZWNpYWwgY2xhc3MuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3MgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpYWwgY2xhc3Mgd2FzIGZvdW5kLlxuICAgKi9cblxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdCA/IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHZhbHVlKSA6IGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpID4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjbGFzc2VzIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIGFkZGVkLlxuICAgKi9cblxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGFkZENsYXNzKGVsZW0sIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUudHJpbSgpO1xuXG4gICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChjbGFzc05hbWUuaW5kZXhPZih2YWx1ZSkgPCAwKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2xhc3NlcyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICAgIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UodmFsdWUsICcnKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBvciByZW1vdmUgY2xhc3NlcyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHRvZ2dsZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWRkZWQgLSBBZGQgb25seS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgdmFsdWUsIGFkZGVkKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICAgIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWxlbSwgdmFsdWUsIGFkZGVkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSUUxMC0xMSBkb2Vzbid0IHN1cHBvcnQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgYGNsYXNzTGlzdC50b2dnbGVgXG5cblxuICAgIGlmIChhZGRlZCkge1xuICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHZhciBSRUdFWFBfQ0FNRUxfQ0FTRSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nO1xuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBnaXZlbiBzdHJpbmcgZnJvbSBjYW1lbENhc2UgdG8ga2ViYWItY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvUGFyYW1DYXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoUkVHRVhQX0NBTUVMX0NBU0UsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBkYXRhIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGF0YSBrZXkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGF0YSB2YWx1ZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0RGF0YShlbGVtZW50LCBuYW1lKSB7XG4gICAgaWYgKGlzT2JqZWN0KGVsZW1lbnRbbmFtZV0pKSB7XG4gICAgICByZXR1cm4gZWxlbWVudFtuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhc2V0W25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KHRvUGFyYW1DYXNlKG5hbWUpKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBkYXRhIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRhdGEga2V5IHRvIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZGF0YSB2YWx1ZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gc2V0RGF0YShlbGVtZW50LCBuYW1lLCBkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBlbGVtZW50W25hbWVdID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuZGF0YXNldCkge1xuICAgICAgZWxlbWVudC5kYXRhc2V0W25hbWVdID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdCh0b1BhcmFtQ2FzZShuYW1lKSksIGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGRhdGEgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBkYXRhIGtleSB0byByZW1vdmUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZURhdGEoZWxlbWVudCwgbmFtZSkge1xuICAgIGlmIChpc09iamVjdChlbGVtZW50W25hbWVdKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVsZXRlIGVsZW1lbnRbbmFtZV07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlbGVtZW50W25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICAvLyAjMTI4IFNhZmFyaSBub3QgYWxsb3dzIHRvIGRlbGV0ZSBkYXRhc2V0IHByb3BlcnR5XG4gICAgICB0cnkge1xuICAgICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0W25hbWVdO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZWxlbWVudC5kYXRhc2V0W25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KHRvUGFyYW1DYXNlKG5hbWUpKSk7XG4gICAgfVxuICB9XG4gIHZhciBSRUdFWFBfU1BBQ0VTID0gL1xcc1xccyovO1xuXG4gIHZhciBvbmNlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChJU19CUk9XU0VSKSB7XG4gICAgICB2YXIgb25jZSA9IGZhbHNlO1xuXG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHt9O1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ29uY2UnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG9uY2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgc2V0dGVyIGNhbiBmaXggYSBgVHlwZUVycm9yYCBpbiBzdHJpY3QgbW9kZVxuICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0dldHRlcl9vbmx5fVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBvbmNlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgV0lORE9XLmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xuICB9KCk7XG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUocykuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBldmVudCBvcHRpb25zLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIHZhciBoYW5kbGVyID0gbGlzdGVuZXI7XG4gICAgdHlwZS50cmltKCkuc3BsaXQoUkVHRVhQX1NQQUNFUykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghb25jZVN1cHBvcnRlZCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gZWxlbWVudC5saXN0ZW5lcnM7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbZXZlbnRdICYmIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XG4gICAgICAgICAgaGFuZGxlciA9IGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdO1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXTtcblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lcnNbZXZlbnRdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQubGlzdGVuZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlKHMpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBsaXN0ZW5lci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgZXZlbnQgb3B0aW9ucy5cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgdmFyIF9oYW5kbGVyID0gbGlzdGVuZXI7XG4gICAgdHlwZS50cmltKCkuc3BsaXQoUkVHRVhQX1NQQUNFUykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChvcHRpb25zLm9uY2UgJiYgIW9uY2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdmFyIF9lbGVtZW50JGxpc3RlbmVycyA9IGVsZW1lbnQubGlzdGVuZXJzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gX2VsZW1lbnQkbGlzdGVuZXJzID09PSB2b2lkIDAgPyB7fSA6IF9lbGVtZW50JGxpc3RlbmVycztcblxuICAgICAgICBfaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdO1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX2hhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXIuYXBwbHkoZWxlbWVudCwgYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSA9IF9oYW5kbGVyO1xuICAgICAgICBlbGVtZW50Lmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoIGV2ZW50IG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZShzKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgYWRkaXRpb25hbCBldmVudCBkYXRhLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW5kaWNhdGUgaWYgdGhlIGV2ZW50IGlzIGRlZmF1bHQgcHJldmVudGVkIG9yIG5vdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChlbGVtZW50LCB0eXBlLCBkYXRhKSB7XG4gICAgdmFyIGV2ZW50OyAvLyBFdmVudCBhbmQgQ3VzdG9tRXZlbnQgb24gSUU5LTExIGFyZSBnbG9iYWwgb2JqZWN0cywgbm90IGNvbnN0cnVjdG9yc1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oRXZlbnQpICYmIGlzRnVuY3Rpb24oQ3VzdG9tRXZlbnQpKSB7XG4gICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7XG4gICAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgb2Zmc2V0IGJhc2Ugb24gdGhlIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvZmZzZXQgZGF0YS5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICB2YXIgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogYm94LmxlZnQgKyAod2luZG93LnBhZ2VYT2Zmc2V0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudExlZnQpLFxuICAgICAgdG9wOiBib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3ApXG4gICAgfTtcbiAgfVxuICB2YXIgbG9jYXRpb24gPSBXSU5ET1cubG9jYXRpb247XG4gIHZhciBSRUdFWFBfT1JJR0lOUyA9IC9eKFxcdys6KVxcL1xcLyhbXjovPyNdKik6PyhcXGQqKS9pO1xuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIFVSTCBpcyBhIGNyb3NzIG9yaWdpbiBVUkwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdGFyZ2V0IFVSTC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBVUkwgaXMgYSBjcm9zcyBvcmlnaW4gVVJMLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzQ3Jvc3NPcmlnaW5VUkwodXJsKSB7XG4gICAgdmFyIHBhcnRzID0gdXJsLm1hdGNoKFJFR0VYUF9PUklHSU5TKTtcbiAgICByZXR1cm4gcGFydHMgIT09IG51bGwgJiYgKHBhcnRzWzFdICE9PSBsb2NhdGlvbi5wcm90b2NvbCB8fCBwYXJ0c1syXSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcGFydHNbM10gIT09IGxvY2F0aW9uLnBvcnQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgdGltZXN0YW1wIHRvIHRoZSBnaXZlbiBVUkwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdGFyZ2V0IFVSTC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdCBVUkwuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFkZFRpbWVzdGFtcCh1cmwpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gXCJ0aW1lc3RhbXA9XCIuY29uY2F0KG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHRpbWVzdGFtcDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRyYW5zZm9ybXMgYmFzZSBvbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIHRhcmdldCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIGNvbnRhaW5zIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFRyYW5zZm9ybXMoX3JlZikge1xuICAgIHZhciByb3RhdGUgPSBfcmVmLnJvdGF0ZSxcbiAgICAgICAgc2NhbGVYID0gX3JlZi5zY2FsZVgsXG4gICAgICAgIHNjYWxlWSA9IF9yZWYuc2NhbGVZLFxuICAgICAgICB0cmFuc2xhdGVYID0gX3JlZi50cmFuc2xhdGVYLFxuICAgICAgICB0cmFuc2xhdGVZID0gX3JlZi50cmFuc2xhdGVZO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmIChpc051bWJlcih0cmFuc2xhdGVYKSAmJiB0cmFuc2xhdGVYICE9PSAwKSB7XG4gICAgICB2YWx1ZXMucHVzaChcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHRyYW5zbGF0ZVgsIFwicHgpXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIodHJhbnNsYXRlWSkgJiYgdHJhbnNsYXRlWSAhPT0gMCkge1xuICAgICAgdmFsdWVzLnB1c2goXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdCh0cmFuc2xhdGVZLCBcInB4KVwiKSk7XG4gICAgfSAvLyBSb3RhdGUgc2hvdWxkIGNvbWUgZmlyc3QgYmVmb3JlIHNjYWxlIHRvIG1hdGNoIG9yaWVudGF0aW9uIHRyYW5zZm9ybVxuXG5cbiAgICBpZiAoaXNOdW1iZXIocm90YXRlKSAmJiByb3RhdGUgIT09IDApIHtcbiAgICAgIHZhbHVlcy5wdXNoKFwicm90YXRlKFwiLmNvbmNhdChyb3RhdGUsIFwiZGVnKVwiKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHNjYWxlWCkgJiYgc2NhbGVYICE9PSAxKSB7XG4gICAgICB2YWx1ZXMucHVzaChcInNjYWxlWChcIi5jb25jYXQoc2NhbGVYLCBcIilcIikpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihzY2FsZVkpICYmIHNjYWxlWSAhPT0gMSkge1xuICAgICAgdmFsdWVzLnB1c2goXCJzY2FsZVkoXCIuY29uY2F0KHNjYWxlWSwgXCIpXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5qb2luKCcgJykgOiAnbm9uZSc7XG4gICAgcmV0dXJuIHtcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgbXNUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtYXggcmF0aW8gb2YgYSBncm91cCBvZiBwb2ludGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXJzIC0gVGhlIHRhcmdldCBwb2ludGVycy5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJlc3VsdCByYXRpby5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0TWF4Wm9vbVJhdGlvKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzMiA9IF9vYmplY3RTcHJlYWQyKHt9LCBwb2ludGVycyk7XG5cbiAgICB2YXIgcmF0aW9zID0gW107XG4gICAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKHBvaW50ZXIsIHBvaW50ZXJJZCkge1xuICAgICAgZGVsZXRlIHBvaW50ZXJzMltwb2ludGVySWRdO1xuICAgICAgZm9yRWFjaChwb2ludGVyczIsIGZ1bmN0aW9uIChwb2ludGVyMikge1xuICAgICAgICB2YXIgeDEgPSBNYXRoLmFicyhwb2ludGVyLnN0YXJ0WCAtIHBvaW50ZXIyLnN0YXJ0WCk7XG4gICAgICAgIHZhciB5MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRZIC0gcG9pbnRlcjIuc3RhcnRZKTtcbiAgICAgICAgdmFyIHgyID0gTWF0aC5hYnMocG9pbnRlci5lbmRYIC0gcG9pbnRlcjIuZW5kWCk7XG4gICAgICAgIHZhciB5MiA9IE1hdGguYWJzKHBvaW50ZXIuZW5kWSAtIHBvaW50ZXIyLmVuZFkpO1xuICAgICAgICB2YXIgejEgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpO1xuICAgICAgICB2YXIgejIgPSBNYXRoLnNxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuICAgICAgICB2YXIgcmF0aW8gPSAoejIgLSB6MSkgLyB6MTtcbiAgICAgICAgcmF0aW9zLnB1c2gocmF0aW8pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmF0aW9zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhhKSA8IE1hdGguYWJzKGIpO1xuICAgIH0pO1xuICAgIHJldHVybiByYXRpb3NbMF07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHBvaW50ZXIgZnJvbSBhbiBldmVudCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSB0YXJnZXQgZXZlbnQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuZE9ubHkgLSBJbmRpY2F0ZXMgaWYgb25seSByZXR1cm5zIHRoZSBlbmQgcG9pbnQgY29vcmRpbmF0ZSBvciBub3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgcG9pbnRlciBjb250YWlucyBzdGFydCBhbmQvb3IgZW5kIHBvaW50IGNvb3JkaW5hdGVzLlxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRQb2ludGVyKF9yZWYyLCBlbmRPbmx5KSB7XG4gICAgdmFyIHBhZ2VYID0gX3JlZjIucGFnZVgsXG4gICAgICAgIHBhZ2VZID0gX3JlZjIucGFnZVk7XG4gICAgdmFyIGVuZCA9IHtcbiAgICAgIGVuZFg6IHBhZ2VYLFxuICAgICAgZW5kWTogcGFnZVlcbiAgICB9O1xuICAgIHJldHVybiBlbmRPbmx5ID8gZW5kIDogX29iamVjdFNwcmVhZDIoe1xuICAgICAgc3RhcnRYOiBwYWdlWCxcbiAgICAgIHN0YXJ0WTogcGFnZVlcbiAgICB9LCBlbmQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNlbnRlciBwb2ludCBjb29yZGluYXRlIG9mIGEgZ3JvdXAgb2YgcG9pbnRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVycyAtIFRoZSB0YXJnZXQgcG9pbnRlcnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcGFnZVggPSAwO1xuICAgIHZhciBwYWdlWSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3JFYWNoKHBvaW50ZXJzLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBzdGFydFggPSBfcmVmMy5zdGFydFgsXG4gICAgICAgICAgc3RhcnRZID0gX3JlZjMuc3RhcnRZO1xuICAgICAgcGFnZVggKz0gc3RhcnRYO1xuICAgICAgcGFnZVkgKz0gc3RhcnRZO1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9KTtcbiAgICBwYWdlWCAvPSBjb3VudDtcbiAgICBwYWdlWSAvPSBjb3VudDtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgcGFnZVk6IHBhZ2VZXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtYXggc2l6ZXMgaW4gYSByZWN0YW5nbGUgdW5kZXIgdGhlIGdpdmVuIGFzcGVjdCByYXRpby5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgb3JpZ2luYWwgc2l6ZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT0nY29udGFpbiddIC0gVGhlIGFkanVzdCB0eXBlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IHNpemVzLlxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRBZGp1c3RlZFNpemVzKF9yZWY0KSAvLyBvciAnY292ZXInXG4gIHtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSBfcmVmNC5hc3BlY3RSYXRpbyxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjQuaGVpZ2h0LFxuICAgICAgICB3aWR0aCA9IF9yZWY0LndpZHRoO1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnY29udGFpbic7XG4gICAgdmFyIGlzVmFsaWRXaWR0aCA9IGlzUG9zaXRpdmVOdW1iZXIod2lkdGgpO1xuICAgIHZhciBpc1ZhbGlkSGVpZ2h0ID0gaXNQb3NpdGl2ZU51bWJlcihoZWlnaHQpO1xuXG4gICAgaWYgKGlzVmFsaWRXaWR0aCAmJiBpc1ZhbGlkSGVpZ2h0KSB7XG4gICAgICB2YXIgYWRqdXN0ZWRXaWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbnRhaW4nICYmIGFkanVzdGVkV2lkdGggPiB3aWR0aCB8fCB0eXBlID09PSAnY292ZXInICYmIGFkanVzdGVkV2lkdGggPCB3aWR0aCkge1xuICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRXaWR0aCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRIZWlnaHQpIHtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBuZXcgc2l6ZXMgb2YgYSByZWN0YW5nbGUgYWZ0ZXIgcm90YXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgb3JpZ2luYWwgc2l6ZXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgc2l6ZXMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFJvdGF0ZWRTaXplcyhfcmVmNSkge1xuICAgIHZhciB3aWR0aCA9IF9yZWY1LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmNS5oZWlnaHQsXG4gICAgICAgIGRlZ3JlZSA9IF9yZWY1LmRlZ3JlZTtcbiAgICBkZWdyZWUgPSBNYXRoLmFicyhkZWdyZWUpICUgMTgwO1xuXG4gICAgaWYgKGRlZ3JlZSA9PT0gOTApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBoZWlnaHQsXG4gICAgICAgIGhlaWdodDogd2lkdGhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFyYyA9IGRlZ3JlZSAlIDkwICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgc2luQXJjID0gTWF0aC5zaW4oYXJjKTtcbiAgICB2YXIgY29zQXJjID0gTWF0aC5jb3MoYXJjKTtcbiAgICB2YXIgbmV3V2lkdGggPSB3aWR0aCAqIGNvc0FyYyArIGhlaWdodCAqIHNpbkFyYztcbiAgICB2YXIgbmV3SGVpZ2h0ID0gd2lkdGggKiBzaW5BcmMgKyBoZWlnaHQgKiBjb3NBcmM7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IDkwID8ge1xuICAgICAgd2lkdGg6IG5ld0hlaWdodCxcbiAgICAgIGhlaWdodDogbmV3V2lkdGhcbiAgICB9IDoge1xuICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgaGVpZ2h0OiBuZXdIZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBjYW52YXMgd2hpY2ggZHJldyB0aGUgZ2l2ZW4gaW1hZ2UuXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgLSBUaGUgaW1hZ2UgZm9yIGRyYXdpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGEgLSBUaGUgaW1hZ2UgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0RhdGEgLSBUaGUgY2FudmFzIGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHJlc3VsdCBjYW52YXMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFNvdXJjZUNhbnZhcyhpbWFnZSwgX3JlZjYsIF9yZWY3LCBfcmVmOCkge1xuICAgIHZhciBpbWFnZUFzcGVjdFJhdGlvID0gX3JlZjYuYXNwZWN0UmF0aW8sXG4gICAgICAgIGltYWdlTmF0dXJhbFdpZHRoID0gX3JlZjYubmF0dXJhbFdpZHRoLFxuICAgICAgICBpbWFnZU5hdHVyYWxIZWlnaHQgPSBfcmVmNi5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICBfcmVmNiRyb3RhdGUgPSBfcmVmNi5yb3RhdGUsXG4gICAgICAgIHJvdGF0ZSA9IF9yZWY2JHJvdGF0ZSA9PT0gdm9pZCAwID8gMCA6IF9yZWY2JHJvdGF0ZSxcbiAgICAgICAgX3JlZjYkc2NhbGVYID0gX3JlZjYuc2NhbGVYLFxuICAgICAgICBzY2FsZVggPSBfcmVmNiRzY2FsZVggPT09IHZvaWQgMCA/IDEgOiBfcmVmNiRzY2FsZVgsXG4gICAgICAgIF9yZWY2JHNjYWxlWSA9IF9yZWY2LnNjYWxlWSxcbiAgICAgICAgc2NhbGVZID0gX3JlZjYkc2NhbGVZID09PSB2b2lkIDAgPyAxIDogX3JlZjYkc2NhbGVZO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IF9yZWY3LmFzcGVjdFJhdGlvLFxuICAgICAgICBuYXR1cmFsV2lkdGggPSBfcmVmNy5uYXR1cmFsV2lkdGgsXG4gICAgICAgIG5hdHVyYWxIZWlnaHQgPSBfcmVmNy5uYXR1cmFsSGVpZ2h0O1xuICAgIHZhciBfcmVmOCRmaWxsQ29sb3IgPSBfcmVmOC5maWxsQ29sb3IsXG4gICAgICAgIGZpbGxDb2xvciA9IF9yZWY4JGZpbGxDb2xvciA9PT0gdm9pZCAwID8gJ3RyYW5zcGFyZW50JyA6IF9yZWY4JGZpbGxDb2xvcixcbiAgICAgICAgX3JlZjgkaW1hZ2VTbW9vdGhpbmdFID0gX3JlZjguaW1hZ2VTbW9vdGhpbmdFbmFibGVkLFxuICAgICAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQgPSBfcmVmOCRpbWFnZVNtb290aGluZ0UgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmOCRpbWFnZVNtb290aGluZ0UsXG4gICAgICAgIF9yZWY4JGltYWdlU21vb3RoaW5nUSA9IF9yZWY4LmltYWdlU21vb3RoaW5nUXVhbGl0eSxcbiAgICAgICAgaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gX3JlZjgkaW1hZ2VTbW9vdGhpbmdRID09PSB2b2lkIDAgPyAnbG93JyA6IF9yZWY4JGltYWdlU21vb3RoaW5nUSxcbiAgICAgICAgX3JlZjgkbWF4V2lkdGggPSBfcmVmOC5tYXhXaWR0aCxcbiAgICAgICAgbWF4V2lkdGggPSBfcmVmOCRtYXhXaWR0aCA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfcmVmOCRtYXhXaWR0aCxcbiAgICAgICAgX3JlZjgkbWF4SGVpZ2h0ID0gX3JlZjgubWF4SGVpZ2h0LFxuICAgICAgICBtYXhIZWlnaHQgPSBfcmVmOCRtYXhIZWlnaHQgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX3JlZjgkbWF4SGVpZ2h0LFxuICAgICAgICBfcmVmOCRtaW5XaWR0aCA9IF9yZWY4Lm1pbldpZHRoLFxuICAgICAgICBtaW5XaWR0aCA9IF9yZWY4JG1pbldpZHRoID09PSB2b2lkIDAgPyAwIDogX3JlZjgkbWluV2lkdGgsXG4gICAgICAgIF9yZWY4JG1pbkhlaWdodCA9IF9yZWY4Lm1pbkhlaWdodCxcbiAgICAgICAgbWluSGVpZ2h0ID0gX3JlZjgkbWluSGVpZ2h0ID09PSB2b2lkIDAgPyAwIDogX3JlZjgkbWluSGVpZ2h0O1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBtYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgaGVpZ2h0OiBtYXhIZWlnaHRcbiAgICB9KTtcbiAgICB2YXIgbWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgIHdpZHRoOiBtaW5XaWR0aCxcbiAgICAgIGhlaWdodDogbWluSGVpZ2h0XG4gICAgfSwgJ2NvdmVyJyk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5taW4obWF4U2l6ZXMud2lkdGgsIE1hdGgubWF4KG1pblNpemVzLndpZHRoLCBuYXR1cmFsV2lkdGgpKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5taW4obWF4U2l6ZXMuaGVpZ2h0LCBNYXRoLm1heChtaW5TaXplcy5oZWlnaHQsIG5hdHVyYWxIZWlnaHQpKTsgLy8gTm90ZTogc2hvdWxkIGFsd2F5cyB1c2UgaW1hZ2UncyBuYXR1cmFsIHNpemVzIGZvciBkcmF3aW5nIGFzXG4gICAgLy8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA9PT0gY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0IHdoZW4gcm90YXRlICUgMTgwID09PSA5MFxuXG4gICAgdmFyIGRlc3RNYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgYXNwZWN0UmF0aW86IGltYWdlQXNwZWN0UmF0aW8sXG4gICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICBoZWlnaHQ6IG1heEhlaWdodFxuICAgIH0pO1xuICAgIHZhciBkZXN0TWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgIGFzcGVjdFJhdGlvOiBpbWFnZUFzcGVjdFJhdGlvLFxuICAgICAgd2lkdGg6IG1pbldpZHRoLFxuICAgICAgaGVpZ2h0OiBtaW5IZWlnaHRcbiAgICB9LCAnY292ZXInKTtcbiAgICB2YXIgZGVzdFdpZHRoID0gTWF0aC5taW4oZGVzdE1heFNpemVzLndpZHRoLCBNYXRoLm1heChkZXN0TWluU2l6ZXMud2lkdGgsIGltYWdlTmF0dXJhbFdpZHRoKSk7XG4gICAgdmFyIGRlc3RIZWlnaHQgPSBNYXRoLm1pbihkZXN0TWF4U2l6ZXMuaGVpZ2h0LCBNYXRoLm1heChkZXN0TWluU2l6ZXMuaGVpZ2h0LCBpbWFnZU5hdHVyYWxIZWlnaHQpKTtcbiAgICB2YXIgcGFyYW1zID0gWy1kZXN0V2lkdGggLyAyLCAtZGVzdEhlaWdodCAvIDIsIGRlc3RXaWR0aCwgZGVzdEhlaWdodF07XG4gICAgY2FudmFzLndpZHRoID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcih3aWR0aCk7XG4gICAgY2FudmFzLmhlaWdodCA9IG5vcm1hbGl6ZURlY2ltYWxOdW1iZXIoaGVpZ2h0KTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxDb2xvcjtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5yb3RhdGUocm90YXRlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ1F1YWxpdHkgPSBpbWFnZVNtb290aGluZ1F1YWxpdHk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgW2ltYWdlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKHBhcmFtKSk7XG4gICAgfSkpKSk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgZnJvbSBjaGFyIGNvZGUgaW4gZGF0YSB2aWV3LlxuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyAtIFRoZSBkYXRhIHZpZXcgZm9yIHJlYWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIFRoZSByZWFkIGxlbmd0aC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlYWQgcmVzdWx0LlxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRTdHJpbmdGcm9tQ2hhckNvZGUoZGF0YVZpZXcsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgbGVuZ3RoICs9IHN0YXJ0O1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHN0ciArPSBmcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyIFJFR0VYUF9EQVRBX1VSTF9IRUFEID0gL15kYXRhOi4qLC87XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gRGF0YSBVUkwgdG8gYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVSTCAtIFRoZSBEYXRhIFVSTCB0byB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gVGhlIHJlc3VsdCBhcnJheSBidWZmZXIuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGRhdGFVUkxUb0FycmF5QnVmZmVyKGRhdGFVUkwpIHtcbiAgICB2YXIgYmFzZTY0ID0gZGF0YVVSTC5yZXBsYWNlKFJFR0VYUF9EQVRBX1VSTF9IRUFELCAnJyk7XG4gICAgdmFyIGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgICB2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYmluYXJ5Lmxlbmd0aCk7XG4gICAgdmFyIHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIGZvckVhY2godWludDgsIGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgdWludDhbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBhcnJheSBidWZmZXIgdG8gRGF0YSBVUkwuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIC0gVGhlIGFycmF5IGJ1ZmZlciB0byB0cmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIFRoZSBtaW1lIHR5cGUgb2YgdGhlIERhdGEgVVJMLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmVzdWx0IERhdGEgVVJMLlxuICAgKi9cblxuICBmdW5jdGlvbiBhcnJheUJ1ZmZlclRvRGF0YVVSTChhcnJheUJ1ZmZlciwgbWltZVR5cGUpIHtcbiAgICB2YXIgY2h1bmtzID0gW107IC8vIENodW5rIFR5cGVkIEFycmF5IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UgKCM0MzUpXG5cbiAgICB2YXIgY2h1bmtTaXplID0gODE5MjtcbiAgICB2YXIgdWludDggPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG5cbiAgICB3aGlsZSAodWludDgubGVuZ3RoID4gMCkge1xuICAgICAgLy8gWFhYOiBCYWJlbCdzIGB0b0NvbnN1bWFibGVBcnJheWAgaGVscGVyIHdpbGwgdGhyb3cgZXJyb3IgaW4gSUUgb3IgU2FmYXJpIDlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICBjaHVua3MucHVzaChmcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdG9BcnJheSh1aW50OC5zdWJhcnJheSgwLCBjaHVua1NpemUpKSkpO1xuICAgICAgdWludDggPSB1aW50OC5zdWJhcnJheShjaHVua1NpemUpO1xuICAgIH1cblxuICAgIHJldHVybiBcImRhdGE6XCIuY29uY2F0KG1pbWVUeXBlLCBcIjtiYXNlNjQsXCIpLmNvbmNhdChidG9hKGNodW5rcy5qb2luKCcnKSkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb3JpZW50YXRpb24gdmFsdWUgZnJvbSBnaXZlbiBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIC0gVGhlIGFycmF5IGJ1ZmZlciB0byByZWFkLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVhZCBvcmllbnRhdGlvbiB2YWx1ZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzZXRBbmRHZXRPcmllbnRhdGlvbihhcnJheUJ1ZmZlcikge1xuICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdmFyIG9yaWVudGF0aW9uOyAvLyBJZ25vcmVzIHJhbmdlIGVycm9yIHdoZW4gdGhlIGltYWdlIGRvZXMgbm90IGhhdmUgY29ycmVjdCBFeGlmIGluZm9ybWF0aW9uXG5cbiAgICB0cnkge1xuICAgICAgdmFyIGxpdHRsZUVuZGlhbjtcbiAgICAgIHZhciBhcHAxU3RhcnQ7XG4gICAgICB2YXIgaWZkU3RhcnQ7IC8vIE9ubHkgaGFuZGxlIEpQRUcgaW1hZ2UgKHN0YXJ0IGJ5IDB4RkZEOClcblxuICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KDApID09PSAweEZGICYmIGRhdGFWaWV3LmdldFVpbnQ4KDEpID09PSAweEQ4KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMjtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0ICsgMSA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpID09PSAweEZGICYmIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpID09PSAweEUxKSB7XG4gICAgICAgICAgICBhcHAxU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXBwMVN0YXJ0KSB7XG4gICAgICAgIHZhciBleGlmSURDb2RlID0gYXBwMVN0YXJ0ICsgNDtcbiAgICAgICAgdmFyIHRpZmZPZmZzZXQgPSBhcHAxU3RhcnQgKyAxMDtcblxuICAgICAgICBpZiAoZ2V0U3RyaW5nRnJvbUNoYXJDb2RlKGRhdGFWaWV3LCBleGlmSURDb2RlLCA0KSA9PT0gJ0V4aWYnKSB7XG4gICAgICAgICAgdmFyIGVuZGlhbm5lc3MgPSBkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCk7XG4gICAgICAgICAgbGl0dGxlRW5kaWFuID0gZW5kaWFubmVzcyA9PT0gMHg0OTQ5O1xuXG4gICAgICAgICAgaWYgKGxpdHRsZUVuZGlhbiB8fCBlbmRpYW5uZXNzID09PSAweDRENERcbiAgICAgICAgICAvKiBiaWdFbmRpYW4gKi9cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgbGl0dGxlRW5kaWFuKSA9PT0gMHgwMDJBKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0SUZET2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHRpZmZPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0SUZET2Zmc2V0ID49IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgICAgICAgICAgIGlmZFN0YXJ0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpZmRTdGFydCkge1xuICAgICAgICB2YXIgX2xlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihpZmRTdGFydCwgbGl0dGxlRW5kaWFuKTtcblxuICAgICAgICB2YXIgX29mZnNldDtcblxuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX2xlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgX29mZnNldCA9IGlmZFN0YXJ0ICsgaSAqIDEyICsgMjtcblxuICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYoX29mZnNldCwgbGl0dGxlRW5kaWFuKSA9PT0gMHgwMTEyXG4gICAgICAgICAgLyogT3JpZW50YXRpb24gKi9cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gOCBpcyB0aGUgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IHRhZydzIHZhbHVlXG4gICAgICAgICAgICAgIF9vZmZzZXQgKz0gODsgLy8gR2V0IHRoZSBvcmlnaW5hbCBvcmllbnRhdGlvbiB2YWx1ZVxuXG4gICAgICAgICAgICAgIG9yaWVudGF0aW9uID0gZGF0YVZpZXcuZ2V0VWludDE2KF9vZmZzZXQsIGxpdHRsZUVuZGlhbik7IC8vIE92ZXJyaWRlIHRoZSBvcmllbnRhdGlvbiB3aXRoIGl0cyBkZWZhdWx0IHZhbHVlXG5cbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KF9vZmZzZXQsIDEsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9yaWVudGF0aW9uID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZW50YXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIEV4aWYgT3JpZW50YXRpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmllbnRhdGlvbiAtIFRoZSBvcmllbnRhdGlvbiB0byBwYXJzZS5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHBhcnNlZCByZXN1bHQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlT3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICB2YXIgcm90YXRlID0gMDtcbiAgICB2YXIgc2NhbGVYID0gMTtcbiAgICB2YXIgc2NhbGVZID0gMTtcblxuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIC8vIEZsaXAgaG9yaXpvbnRhbFxuICAgICAgY2FzZSAyOlxuICAgICAgICBzY2FsZVggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBSb3RhdGUgbGVmdCAxODDCsFxuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJvdGF0ZSA9IC0xODA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRmxpcCB2ZXJ0aWNhbFxuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIEZsaXAgdmVydGljYWwgYW5kIHJvdGF0ZSByaWdodCA5MMKwXG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcm90YXRlID0gOTA7XG4gICAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFJvdGF0ZSByaWdodCA5MMKwXG5cbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcm90YXRlID0gOTA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRmxpcCBob3Jpem9udGFsIGFuZCByb3RhdGUgcmlnaHQgOTDCsFxuXG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJvdGF0ZSA9IDkwO1xuICAgICAgICBzY2FsZVggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBSb3RhdGUgbGVmdCA5MMKwXG5cbiAgICAgIGNhc2UgODpcbiAgICAgICAgcm90YXRlID0gLTkwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRlOiByb3RhdGUsXG4gICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgIHNjYWxlWTogc2NhbGVZXG4gICAgfTtcbiAgfVxuXG4gIHZhciByZW5kZXIgPSB7XG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmluaXRDb250YWluZXIoKTtcbiAgICAgIHRoaXMuaW5pdENhbnZhcygpO1xuICAgICAgdGhpcy5pbml0Q3JvcEJveCgpO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoKTtcblxuICAgICAgaWYgKHRoaXMuY3JvcHBlZCkge1xuICAgICAgICB0aGlzLnJlbmRlckNyb3BCb3goKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXRDb250YWluZXI6IGZ1bmN0aW9uIGluaXRDb250YWluZXIoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgIGNyb3BwZXIgPSB0aGlzLmNyb3BwZXI7XG4gICAgICBhZGRDbGFzcyhjcm9wcGVyLCBDTEFTU19ISURERU4pO1xuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgQ0xBU1NfSElEREVOKTtcbiAgICAgIHZhciBjb250YWluZXJEYXRhID0ge1xuICAgICAgICB3aWR0aDogTWF0aC5tYXgoY29udGFpbmVyLm9mZnNldFdpZHRoLCBOdW1iZXIob3B0aW9ucy5taW5Db250YWluZXJXaWR0aCkgfHwgMjAwKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChjb250YWluZXIub2Zmc2V0SGVpZ2h0LCBOdW1iZXIob3B0aW9ucy5taW5Db250YWluZXJIZWlnaHQpIHx8IDEwMClcbiAgICAgIH07XG4gICAgICB0aGlzLmNvbnRhaW5lckRhdGEgPSBjb250YWluZXJEYXRhO1xuICAgICAgc2V0U3R5bGUoY3JvcHBlciwge1xuICAgICAgICB3aWR0aDogY29udGFpbmVyRGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjb250YWluZXJEYXRhLmhlaWdodFxuICAgICAgfSk7XG4gICAgICBhZGRDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pO1xuICAgICAgcmVtb3ZlQ2xhc3MoY3JvcHBlciwgQ0xBU1NfSElEREVOKTtcbiAgICB9LFxuICAgIC8vIENhbnZhcyAoaW1hZ2Ugd3JhcHBlcilcbiAgICBpbml0Q2FudmFzOiBmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgICAgdmFyIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgICB2YXIgdmlld01vZGUgPSB0aGlzLm9wdGlvbnMudmlld01vZGU7XG4gICAgICB2YXIgcm90YXRlZCA9IE1hdGguYWJzKGltYWdlRGF0YS5yb3RhdGUpICUgMTgwID09PSA5MDtcbiAgICAgIHZhciBuYXR1cmFsV2lkdGggPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgOiBpbWFnZURhdGEubmF0dXJhbFdpZHRoO1xuICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA6IGltYWdlRGF0YS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodDtcbiAgICAgIHZhciBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG5cbiAgICAgIGlmIChjb250YWluZXJEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvID4gY29udGFpbmVyRGF0YS53aWR0aCkge1xuICAgICAgICBpZiAodmlld01vZGUgPT09IDMpIHtcbiAgICAgICAgICBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZpZXdNb2RlID09PSAzKSB7XG4gICAgICAgIGNhbnZhc0hlaWdodCA9IGNvbnRhaW5lckRhdGEud2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhc1dpZHRoID0gY29udGFpbmVyRGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB7XG4gICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgICAgbmF0dXJhbFdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHQsXG4gICAgICAgIHdpZHRoOiBjYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXNIZWlnaHRcbiAgICAgIH07XG4gICAgICBjYW52YXNEYXRhLmxlZnQgPSAoY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc1dpZHRoKSAvIDI7XG4gICAgICBjYW52YXNEYXRhLnRvcCA9IChjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0hlaWdodCkgLyAyO1xuICAgICAgY2FudmFzRGF0YS5vbGRMZWZ0ID0gY2FudmFzRGF0YS5sZWZ0O1xuICAgICAgY2FudmFzRGF0YS5vbGRUb3AgPSBjYW52YXNEYXRhLnRvcDtcbiAgICAgIHRoaXMuY2FudmFzRGF0YSA9IGNhbnZhc0RhdGE7XG4gICAgICB0aGlzLmxpbWl0ZWQgPSB2aWV3TW9kZSA9PT0gMSB8fCB2aWV3TW9kZSA9PT0gMjtcbiAgICAgIHRoaXMubGltaXRDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmluaXRpYWxJbWFnZURhdGEgPSBhc3NpZ24oe30sIGltYWdlRGF0YSk7XG4gICAgICB0aGlzLmluaXRpYWxDYW52YXNEYXRhID0gYXNzaWduKHt9LCBjYW52YXNEYXRhKTtcbiAgICB9LFxuICAgIGxpbWl0Q2FudmFzOiBmdW5jdGlvbiBsaW1pdENhbnZhcyhzaXplTGltaXRlZCwgcG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xuICAgICAgdmFyIHZpZXdNb2RlID0gb3B0aW9ucy52aWV3TW9kZTtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGNhbnZhc0RhdGEuYXNwZWN0UmF0aW87XG4gICAgICB2YXIgY3JvcHBlZCA9IHRoaXMuY3JvcHBlZCAmJiBjcm9wQm94RGF0YTtcblxuICAgICAgaWYgKHNpemVMaW1pdGVkKSB7XG4gICAgICAgIHZhciBtaW5DYW52YXNXaWR0aCA9IE51bWJlcihvcHRpb25zLm1pbkNhbnZhc1dpZHRoKSB8fCAwO1xuICAgICAgICB2YXIgbWluQ2FudmFzSGVpZ2h0ID0gTnVtYmVyKG9wdGlvbnMubWluQ2FudmFzSGVpZ2h0KSB8fCAwO1xuXG4gICAgICAgIGlmICh2aWV3TW9kZSA+IDEpIHtcbiAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IE1hdGgubWF4KG1pbkNhbnZhc1dpZHRoLCBjb250YWluZXJEYXRhLndpZHRoKTtcbiAgICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBNYXRoLm1heChtaW5DYW52YXNIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcblxuICAgICAgICAgIGlmICh2aWV3TW9kZSA9PT0gMykge1xuICAgICAgICAgICAgaWYgKG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvID4gbWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1pbkNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZpZXdNb2RlID4gMCkge1xuICAgICAgICAgIGlmIChtaW5DYW52YXNXaWR0aCkge1xuICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBNYXRoLm1heChtaW5DYW52YXNXaWR0aCwgY3JvcHBlZCA/IGNyb3BCb3hEYXRhLndpZHRoIDogMCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5DYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IE1hdGgubWF4KG1pbkNhbnZhc0hlaWdodCwgY3JvcHBlZCA/IGNyb3BCb3hEYXRhLmhlaWdodCA6IDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3JvcHBlZCkge1xuICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBjcm9wQm94RGF0YS53aWR0aDtcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvID4gbWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1pbkNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9nZXRBZGp1c3RlZFNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiBtaW5DYW52YXNXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IG1pbkNhbnZhc0hlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICBtaW5DYW52YXNXaWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzLndpZHRoO1xuICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplcy5oZWlnaHQ7XG4gICAgICAgIGNhbnZhc0RhdGEubWluV2lkdGggPSBtaW5DYW52YXNXaWR0aDtcbiAgICAgICAgY2FudmFzRGF0YS5taW5IZWlnaHQgPSBtaW5DYW52YXNIZWlnaHQ7XG4gICAgICAgIGNhbnZhc0RhdGEubWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgICAgY2FudmFzRGF0YS5tYXhIZWlnaHQgPSBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uTGltaXRlZCkge1xuICAgICAgICBpZiAodmlld01vZGUgPiAoY3JvcHBlZCA/IDAgOiAxKSkge1xuICAgICAgICAgIHZhciBuZXdDYW52YXNMZWZ0ID0gY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc0RhdGEud2lkdGg7XG4gICAgICAgICAgdmFyIG5ld0NhbnZhc1RvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzTGVmdCk7XG4gICAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNUb3ApO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IE1hdGgubWF4KDAsIG5ld0NhbnZhc0xlZnQpO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gTWF0aC5tYXgoMCwgbmV3Q2FudmFzVG9wKTtcblxuICAgICAgICAgIGlmIChjcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xuICAgICAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gTWF0aC5taW4oY3JvcEJveERhdGEubGVmdCwgY3JvcEJveERhdGEubGVmdCArIChjcm9wQm94RGF0YS53aWR0aCAtIGNhbnZhc0RhdGEud2lkdGgpKTtcbiAgICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oY3JvcEJveERhdGEudG9wLCBjcm9wQm94RGF0YS50b3AgKyAoY3JvcEJveERhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpKTtcbiAgICAgICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQ7XG4gICAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcblxuICAgICAgICAgICAgaWYgKHZpZXdNb2RlID09PSAyKSB7XG4gICAgICAgICAgICAgIGlmIChjYW52YXNEYXRhLndpZHRoID49IGNvbnRhaW5lckRhdGEud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNMZWZ0KTtcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1heExlZnQgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNMZWZ0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjYW52YXNEYXRhLmhlaWdodCA+PSBjb250YWluZXJEYXRhLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzVG9wKTtcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IE1hdGgubWF4KDAsIG5ld0NhbnZhc1RvcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gLWNhbnZhc0RhdGEud2lkdGg7XG4gICAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSAtY2FudmFzRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgY2FudmFzRGF0YS5tYXhMZWZ0ID0gY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJDYW52YXM6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhjaGFuZ2VkLCB0cmFuc2Zvcm1lZCkge1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICB2YXIgX2dldFJvdGF0ZWRTaXplcyA9IGdldFJvdGF0ZWRTaXplcyh7XG4gICAgICAgICAgd2lkdGg6IGltYWdlRGF0YS5uYXR1cmFsV2lkdGggKiBNYXRoLmFicyhpbWFnZURhdGEuc2NhbGVYIHx8IDEpLFxuICAgICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgKiBNYXRoLmFicyhpbWFnZURhdGEuc2NhbGVZIHx8IDEpLFxuICAgICAgICAgIGRlZ3JlZTogaW1hZ2VEYXRhLnJvdGF0ZSB8fCAwXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgbmF0dXJhbFdpZHRoID0gX2dldFJvdGF0ZWRTaXplcy53aWR0aCxcbiAgICAgICAgICAgIG5hdHVyYWxIZWlnaHQgPSBfZ2V0Um90YXRlZFNpemVzLmhlaWdodDtcblxuICAgICAgICB2YXIgd2lkdGggPSBjYW52YXNEYXRhLndpZHRoICogKG5hdHVyYWxXaWR0aCAvIGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNhbnZhc0RhdGEuaGVpZ2h0ICogKG5hdHVyYWxIZWlnaHQgLyBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQpO1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKHdpZHRoIC0gY2FudmFzRGF0YS53aWR0aCkgLyAyO1xuICAgICAgICBjYW52YXNEYXRhLnRvcCAtPSAoaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpIC8gMjtcbiAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXNEYXRhLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgY2FudmFzRGF0YS5hc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoID0gbmF0dXJhbFdpZHRoO1xuICAgICAgICBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQgPSBuYXR1cmFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbWl0Q2FudmFzKHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbnZhc0RhdGEud2lkdGggPiBjYW52YXNEYXRhLm1heFdpZHRoIHx8IGNhbnZhc0RhdGEud2lkdGggPCBjYW52YXNEYXRhLm1pbldpZHRoKSB7XG4gICAgICAgIGNhbnZhc0RhdGEubGVmdCA9IGNhbnZhc0RhdGEub2xkTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbnZhc0RhdGEuaGVpZ2h0ID4gY2FudmFzRGF0YS5tYXhIZWlnaHQgfHwgY2FudmFzRGF0YS5oZWlnaHQgPCBjYW52YXNEYXRhLm1pbkhlaWdodCkge1xuICAgICAgICBjYW52YXNEYXRhLnRvcCA9IGNhbnZhc0RhdGEub2xkVG9wO1xuICAgICAgfVxuXG4gICAgICBjYW52YXNEYXRhLndpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS5taW5XaWR0aCksIGNhbnZhc0RhdGEubWF4V2lkdGgpO1xuICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS5taW5IZWlnaHQpLCBjYW52YXNEYXRhLm1heEhlaWdodCk7XG4gICAgICB0aGlzLmxpbWl0Q2FudmFzKGZhbHNlLCB0cnVlKTtcbiAgICAgIGNhbnZhc0RhdGEubGVmdCA9IE1hdGgubWluKE1hdGgubWF4KGNhbnZhc0RhdGEubGVmdCwgY2FudmFzRGF0YS5taW5MZWZ0KSwgY2FudmFzRGF0YS5tYXhMZWZ0KTtcbiAgICAgIGNhbnZhc0RhdGEudG9wID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS50b3AsIGNhbnZhc0RhdGEubWluVG9wKSwgY2FudmFzRGF0YS5tYXhUb3ApO1xuICAgICAgY2FudmFzRGF0YS5vbGRMZWZ0ID0gY2FudmFzRGF0YS5sZWZ0O1xuICAgICAgY2FudmFzRGF0YS5vbGRUb3AgPSBjYW52YXNEYXRhLnRvcDtcbiAgICAgIHNldFN0eWxlKHRoaXMuY2FudmFzLCBhc3NpZ24oe1xuICAgICAgICB3aWR0aDogY2FudmFzRGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXNEYXRhLmhlaWdodFxuICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyh7XG4gICAgICAgIHRyYW5zbGF0ZVg6IGNhbnZhc0RhdGEubGVmdCxcbiAgICAgICAgdHJhbnNsYXRlWTogY2FudmFzRGF0YS50b3BcbiAgICAgIH0pKSk7XG4gICAgICB0aGlzLnJlbmRlckltYWdlKGNoYW5nZWQpO1xuXG4gICAgICBpZiAodGhpcy5jcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xuICAgICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckltYWdlOiBmdW5jdGlvbiByZW5kZXJJbWFnZShjaGFuZ2VkKSB7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICAgIHZhciB3aWR0aCA9IGltYWdlRGF0YS5uYXR1cmFsV2lkdGggKiAoY2FudmFzRGF0YS53aWR0aCAvIGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWFnZURhdGEubmF0dXJhbEhlaWdodCAqIChjYW52YXNEYXRhLmhlaWdodCAvIGNhbnZhc0RhdGEubmF0dXJhbEhlaWdodCk7XG4gICAgICBhc3NpZ24oaW1hZ2VEYXRhLCB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGxlZnQ6IChjYW52YXNEYXRhLndpZHRoIC0gd2lkdGgpIC8gMixcbiAgICAgICAgdG9wOiAoY2FudmFzRGF0YS5oZWlnaHQgLSBoZWlnaHQpIC8gMlxuICAgICAgfSk7XG4gICAgICBzZXRTdHlsZSh0aGlzLmltYWdlLCBhc3NpZ24oe1xuICAgICAgICB3aWR0aDogaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltYWdlRGF0YS5oZWlnaHRcbiAgICAgIH0sIGdldFRyYW5zZm9ybXMoYXNzaWduKHtcbiAgICAgICAgdHJhbnNsYXRlWDogaW1hZ2VEYXRhLmxlZnQsXG4gICAgICAgIHRyYW5zbGF0ZVk6IGltYWdlRGF0YS50b3BcbiAgICAgIH0sIGltYWdlRGF0YSkpKSk7XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub3V0cHV0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0Q3JvcEJveDogZnVuY3Rpb24gaW5pdENyb3BCb3goKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbyB8fCBvcHRpb25zLmluaXRpYWxBc3BlY3RSYXRpbztcbiAgICAgIHZhciBhdXRvQ3JvcEFyZWEgPSBOdW1iZXIob3B0aW9ucy5hdXRvQ3JvcEFyZWEpIHx8IDAuODtcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IHtcbiAgICAgICAgd2lkdGg6IGNhbnZhc0RhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzRGF0YS5oZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoY2FudmFzRGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbyA+IGNhbnZhc0RhdGEud2lkdGgpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gY3JvcEJveERhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jcm9wQm94RGF0YSA9IGNyb3BCb3hEYXRhO1xuICAgICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7IC8vIEluaXRpYWxpemUgYXV0byBjcm9wIGFyZWFcblxuICAgICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS53aWR0aCwgY3JvcEJveERhdGEubWluV2lkdGgpLCBjcm9wQm94RGF0YS5tYXhXaWR0aCk7XG4gICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS5oZWlnaHQsIGNyb3BCb3hEYXRhLm1pbkhlaWdodCksIGNyb3BCb3hEYXRhLm1heEhlaWdodCk7IC8vIFRoZSB3aWR0aC9oZWlnaHQgb2YgYXV0byBjcm9wIGFyZWEgbXVzdCBsYXJnZSB0aGFuIFwibWluV2lkdGgvSGVpZ2h0XCJcblxuICAgICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1heChjcm9wQm94RGF0YS5taW5XaWR0aCwgY3JvcEJveERhdGEud2lkdGggKiBhdXRvQ3JvcEFyZWEpO1xuICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gTWF0aC5tYXgoY3JvcEJveERhdGEubWluSGVpZ2h0LCBjcm9wQm94RGF0YS5oZWlnaHQgKiBhdXRvQ3JvcEFyZWEpO1xuICAgICAgY3JvcEJveERhdGEubGVmdCA9IGNhbnZhc0RhdGEubGVmdCArIChjYW52YXNEYXRhLndpZHRoIC0gY3JvcEJveERhdGEud2lkdGgpIC8gMjtcbiAgICAgIGNyb3BCb3hEYXRhLnRvcCA9IGNhbnZhc0RhdGEudG9wICsgKGNhbnZhc0RhdGEuaGVpZ2h0IC0gY3JvcEJveERhdGEuaGVpZ2h0KSAvIDI7XG4gICAgICBjcm9wQm94RGF0YS5vbGRMZWZ0ID0gY3JvcEJveERhdGEubGVmdDtcbiAgICAgIGNyb3BCb3hEYXRhLm9sZFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcbiAgICAgIHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhID0gYXNzaWduKHt9LCBjcm9wQm94RGF0YSk7XG4gICAgfSxcbiAgICBsaW1pdENyb3BCb3g6IGZ1bmN0aW9uIGxpbWl0Q3JvcEJveChzaXplTGltaXRlZCwgcG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhLFxuICAgICAgICAgIGxpbWl0ZWQgPSB0aGlzLmxpbWl0ZWQ7XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBvcHRpb25zLmFzcGVjdFJhdGlvO1xuXG4gICAgICBpZiAoc2l6ZUxpbWl0ZWQpIHtcbiAgICAgICAgdmFyIG1pbkNyb3BCb3hXaWR0aCA9IE51bWJlcihvcHRpb25zLm1pbkNyb3BCb3hXaWR0aCkgfHwgMDtcbiAgICAgICAgdmFyIG1pbkNyb3BCb3hIZWlnaHQgPSBOdW1iZXIob3B0aW9ucy5taW5Dcm9wQm94SGVpZ2h0KSB8fCAwO1xuICAgICAgICB2YXIgbWF4Q3JvcEJveFdpZHRoID0gbGltaXRlZCA/IE1hdGgubWluKGNvbnRhaW5lckRhdGEud2lkdGgsIGNhbnZhc0RhdGEud2lkdGgsIGNhbnZhc0RhdGEud2lkdGggKyBjYW52YXNEYXRhLmxlZnQsIGNvbnRhaW5lckRhdGEud2lkdGggLSBjYW52YXNEYXRhLmxlZnQpIDogY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICAgICAgdmFyIG1heENyb3BCb3hIZWlnaHQgPSBsaW1pdGVkID8gTWF0aC5taW4oY29udGFpbmVyRGF0YS5oZWlnaHQsIGNhbnZhc0RhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLmhlaWdodCArIGNhbnZhc0RhdGEudG9wLCBjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0RhdGEudG9wKSA6IGNvbnRhaW5lckRhdGEuaGVpZ2h0OyAvLyBUaGUgbWluL21heENyb3BCb3hXaWR0aC9IZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gY29udGFpbmVyJ3Mgd2lkdGgvaGVpZ2h0XG5cbiAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gTWF0aC5taW4obWluQ3JvcEJveFdpZHRoLCBjb250YWluZXJEYXRhLndpZHRoKTtcbiAgICAgICAgbWluQ3JvcEJveEhlaWdodCA9IE1hdGgubWluKG1pbkNyb3BCb3hIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBpZiAobWluQ3JvcEJveFdpZHRoICYmIG1pbkNyb3BCb3hIZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtaW5Dcm9wQm94V2lkdGgpIHtcbiAgICAgICAgICAgICAgbWluQ3JvcEJveEhlaWdodCA9IG1pbkNyb3BCb3hXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gbWluQ3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWluQ3JvcEJveFdpZHRoKSB7XG4gICAgICAgICAgICBtaW5Dcm9wQm94SGVpZ2h0ID0gbWluQ3JvcEJveFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5Dcm9wQm94SGVpZ2h0KSB7XG4gICAgICAgICAgICBtaW5Dcm9wQm94V2lkdGggPSBtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1heENyb3BCb3hIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IG1heENyb3BCb3hXaWR0aCkge1xuICAgICAgICAgICAgbWF4Q3JvcEJveEhlaWdodCA9IG1heENyb3BCb3hXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhDcm9wQm94V2lkdGggPSBtYXhDcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRoZSBtaW5XaWR0aC9IZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gbWF4V2lkdGgvSGVpZ2h0XG5cblxuICAgICAgICBjcm9wQm94RGF0YS5taW5XaWR0aCA9IE1hdGgubWluKG1pbkNyb3BCb3hXaWR0aCwgbWF4Q3JvcEJveFdpZHRoKTtcbiAgICAgICAgY3JvcEJveERhdGEubWluSGVpZ2h0ID0gTWF0aC5taW4obWluQ3JvcEJveEhlaWdodCwgbWF4Q3JvcEJveEhlaWdodCk7XG4gICAgICAgIGNyb3BCb3hEYXRhLm1heFdpZHRoID0gbWF4Q3JvcEJveFdpZHRoO1xuICAgICAgICBjcm9wQm94RGF0YS5tYXhIZWlnaHQgPSBtYXhDcm9wQm94SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICAgIGlmIChsaW1pdGVkKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEubWluTGVmdCA9IE1hdGgubWF4KDAsIGNhbnZhc0RhdGEubGVmdCk7XG4gICAgICAgICAgY3JvcEJveERhdGEubWluVG9wID0gTWF0aC5tYXgoMCwgY2FudmFzRGF0YS50b3ApO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heExlZnQgPSBNYXRoLm1pbihjb250YWluZXJEYXRhLndpZHRoLCBjYW52YXNEYXRhLmxlZnQgKyBjYW52YXNEYXRhLndpZHRoKSAtIGNyb3BCb3hEYXRhLndpZHRoO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heFRvcCA9IE1hdGgubWluKGNvbnRhaW5lckRhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLnRvcCArIGNhbnZhc0RhdGEuaGVpZ2h0KSAtIGNyb3BCb3hEYXRhLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS5taW5MZWZ0ID0gMDtcbiAgICAgICAgICBjcm9wQm94RGF0YS5taW5Ub3AgPSAwO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heExlZnQgPSBjb250YWluZXJEYXRhLndpZHRoIC0gY3JvcEJveERhdGEud2lkdGg7XG4gICAgICAgICAgY3JvcEJveERhdGEubWF4VG9wID0gY29udGFpbmVyRGF0YS5oZWlnaHQgLSBjcm9wQm94RGF0YS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckNyb3BCb3g6IGZ1bmN0aW9uIHJlbmRlckNyb3BCb3goKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcblxuICAgICAgaWYgKGNyb3BCb3hEYXRhLndpZHRoID4gY3JvcEJveERhdGEubWF4V2lkdGggfHwgY3JvcEJveERhdGEud2lkdGggPCBjcm9wQm94RGF0YS5taW5XaWR0aCkge1xuICAgICAgICBjcm9wQm94RGF0YS5sZWZ0ID0gY3JvcEJveERhdGEub2xkTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNyb3BCb3hEYXRhLmhlaWdodCA+IGNyb3BCb3hEYXRhLm1heEhlaWdodCB8fCBjcm9wQm94RGF0YS5oZWlnaHQgPCBjcm9wQm94RGF0YS5taW5IZWlnaHQpIHtcbiAgICAgICAgY3JvcEJveERhdGEudG9wID0gY3JvcEJveERhdGEub2xkVG9wO1xuICAgICAgfVxuXG4gICAgICBjcm9wQm94RGF0YS53aWR0aCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLndpZHRoLCBjcm9wQm94RGF0YS5taW5XaWR0aCksIGNyb3BCb3hEYXRhLm1heFdpZHRoKTtcbiAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLmhlaWdodCwgY3JvcEJveERhdGEubWluSGVpZ2h0KSwgY3JvcEJveERhdGEubWF4SGVpZ2h0KTtcbiAgICAgIHRoaXMubGltaXRDcm9wQm94KGZhbHNlLCB0cnVlKTtcbiAgICAgIGNyb3BCb3hEYXRhLmxlZnQgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS5sZWZ0LCBjcm9wQm94RGF0YS5taW5MZWZ0KSwgY3JvcEJveERhdGEubWF4TGVmdCk7XG4gICAgICBjcm9wQm94RGF0YS50b3AgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS50b3AsIGNyb3BCb3hEYXRhLm1pblRvcCksIGNyb3BCb3hEYXRhLm1heFRvcCk7XG4gICAgICBjcm9wQm94RGF0YS5vbGRMZWZ0ID0gY3JvcEJveERhdGEubGVmdDtcbiAgICAgIGNyb3BCb3hEYXRhLm9sZFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcblxuICAgICAgaWYgKG9wdGlvbnMubW92YWJsZSAmJiBvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XG4gICAgICAgIC8vIFR1cm4gdG8gbW92ZSB0aGUgY2FudmFzIHdoZW4gdGhlIGNyb3AgYm94IGlzIGVxdWFsIHRvIHRoZSBjb250YWluZXJcbiAgICAgICAgc2V0RGF0YSh0aGlzLmZhY2UsIERBVEFfQUNUSU9OLCBjcm9wQm94RGF0YS53aWR0aCA+PSBjb250YWluZXJEYXRhLndpZHRoICYmIGNyb3BCb3hEYXRhLmhlaWdodCA+PSBjb250YWluZXJEYXRhLmhlaWdodCA/IEFDVElPTl9NT1ZFIDogQUNUSU9OX0FMTCk7XG4gICAgICB9XG5cbiAgICAgIHNldFN0eWxlKHRoaXMuY3JvcEJveCwgYXNzaWduKHtcbiAgICAgICAgd2lkdGg6IGNyb3BCb3hEYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNyb3BCb3hEYXRhLmhlaWdodFxuICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyh7XG4gICAgICAgIHRyYW5zbGF0ZVg6IGNyb3BCb3hEYXRhLmxlZnQsXG4gICAgICAgIHRyYW5zbGF0ZVk6IGNyb3BCb3hEYXRhLnRvcFxuICAgICAgfSkpKTtcblxuICAgICAgaWYgKHRoaXMuY3JvcHBlZCAmJiB0aGlzLmxpbWl0ZWQpIHtcbiAgICAgICAgdGhpcy5saW1pdENhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMub3V0cHV0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvdXRwdXQ6IGZ1bmN0aW9uIG91dHB1dCgpIHtcbiAgICAgIHRoaXMucHJldmlldygpO1xuICAgICAgZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX0NST1AsIHRoaXMuZ2V0RGF0YSgpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHByZXZpZXcgPSB7XG4gICAgaW5pdFByZXZpZXc6IGZ1bmN0aW9uIGluaXRQcmV2aWV3KCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgdmFyIHByZXZpZXcgPSB0aGlzLm9wdGlvbnMucHJldmlldztcbiAgICAgIHZhciB1cmwgPSBjcm9zc09yaWdpbiA/IHRoaXMuY3Jvc3NPcmlnaW5VcmwgOiB0aGlzLnVybDtcbiAgICAgIHZhciBhbHQgPSBlbGVtZW50LmFsdCB8fCAnVGhlIGltYWdlIHRvIHByZXZpZXcnO1xuICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgICBpbWFnZS5hbHQgPSBhbHQ7XG4gICAgICB0aGlzLnZpZXdCb3guYXBwZW5kQ2hpbGQoaW1hZ2UpO1xuICAgICAgdGhpcy52aWV3Qm94SW1hZ2UgPSBpbWFnZTtcblxuICAgICAgaWYgKCFwcmV2aWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZpZXdzID0gcHJldmlldztcblxuICAgICAgaWYgKHR5cGVvZiBwcmV2aWV3ID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcmV2aWV3cyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHByZXZpZXcpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aWV3LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgcHJldmlld3MgPSBbcHJldmlld107XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJldmlld3MgPSBwcmV2aWV3cztcbiAgICAgIGZvckVhY2gocHJldmlld3MsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7IC8vIFNhdmUgdGhlIG9yaWdpbmFsIHNpemUgZm9yIHJlY292ZXJcblxuICAgICAgICBzZXREYXRhKGVsLCBEQVRBX1BSRVZJRVcsIHtcbiAgICAgICAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBlbC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgaHRtbDogZWwuaW5uZXJIVE1MXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgaW1nLmFsdCA9IGFsdDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIGltZyBlbGVtZW50IHN0eWxlc1xuICAgICAgICAgKiBBZGQgYGRpc3BsYXk6YmxvY2tgIHRvIGF2b2lkIG1hcmdpbiB0b3AgaXNzdWVcbiAgICAgICAgICogQWRkIGBoZWlnaHQ6YXV0b2AgdG8gb3ZlcnJpZGUgYGhlaWdodGAgYXR0cmlidXRlIG9uIElFOFxuICAgICAgICAgKiAoT2NjdXIgb25seSB3aGVuIG1hcmdpbi10b3AgPD0gLWhlaWdodClcbiAgICAgICAgICovXG5cbiAgICAgICAgaW1nLnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTpibG9jazsnICsgJ3dpZHRoOjEwMCU7JyArICdoZWlnaHQ6YXV0bzsnICsgJ21pbi13aWR0aDowIWltcG9ydGFudDsnICsgJ21pbi1oZWlnaHQ6MCFpbXBvcnRhbnQ7JyArICdtYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnQ7JyArICdtYXgtaGVpZ2h0Om5vbmUhaW1wb3J0YW50OycgKyAnaW1hZ2Utb3JpZW50YXRpb246MGRlZyFpbXBvcnRhbnQ7XCInO1xuICAgICAgICBlbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVzZXRQcmV2aWV3OiBmdW5jdGlvbiByZXNldFByZXZpZXcoKSB7XG4gICAgICBmb3JFYWNoKHRoaXMucHJldmlld3MsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtZW50LCBEQVRBX1BSRVZJRVcpO1xuICAgICAgICBzZXRTdHlsZShlbGVtZW50LCB7XG4gICAgICAgICAgd2lkdGg6IGRhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBkYXRhLmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBkYXRhLmh0bWw7XG4gICAgICAgIHJlbW92ZURhdGEoZWxlbWVudCwgREFUQV9QUkVWSUVXKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHJldmlldzogZnVuY3Rpb24gcHJldmlldygpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YSxcbiAgICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcbiAgICAgIHZhciBjcm9wQm94V2lkdGggPSBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgICBjcm9wQm94SGVpZ2h0ID0gY3JvcEJveERhdGEuaGVpZ2h0O1xuICAgICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgbGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQgLSBjYW52YXNEYXRhLmxlZnQgLSBpbWFnZURhdGEubGVmdDtcbiAgICAgIHZhciB0b3AgPSBjcm9wQm94RGF0YS50b3AgLSBjYW52YXNEYXRhLnRvcCAtIGltYWdlRGF0YS50b3A7XG5cbiAgICAgIGlmICghdGhpcy5jcm9wcGVkIHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRTdHlsZSh0aGlzLnZpZXdCb3hJbWFnZSwgYXNzaWduKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyhhc3NpZ24oe1xuICAgICAgICB0cmFuc2xhdGVYOiAtbGVmdCxcbiAgICAgICAgdHJhbnNsYXRlWTogLXRvcFxuICAgICAgfSwgaW1hZ2VEYXRhKSkpKTtcbiAgICAgIGZvckVhY2godGhpcy5wcmV2aWV3cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKGVsZW1lbnQsIERBVEFfUFJFVklFVyk7XG4gICAgICAgIHZhciBvcmlnaW5hbFdpZHRoID0gZGF0YS53aWR0aDtcbiAgICAgICAgdmFyIG9yaWdpbmFsSGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IG9yaWdpbmFsV2lkdGg7XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgICAgdmFyIHJhdGlvID0gMTtcblxuICAgICAgICBpZiAoY3JvcEJveFdpZHRoKSB7XG4gICAgICAgICAgcmF0aW8gPSBvcmlnaW5hbFdpZHRoIC8gY3JvcEJveFdpZHRoO1xuICAgICAgICAgIG5ld0hlaWdodCA9IGNyb3BCb3hIZWlnaHQgKiByYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcm9wQm94SGVpZ2h0ICYmIG5ld0hlaWdodCA+IG9yaWdpbmFsSGVpZ2h0KSB7XG4gICAgICAgICAgcmF0aW8gPSBvcmlnaW5hbEhlaWdodCAvIGNyb3BCb3hIZWlnaHQ7XG4gICAgICAgICAgbmV3V2lkdGggPSBjcm9wQm94V2lkdGggKiByYXRpbztcbiAgICAgICAgICBuZXdIZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFN0eWxlKGVsZW1lbnQsIHtcbiAgICAgICAgICB3aWR0aDogbmV3V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFN0eWxlKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpWzBdLCBhc3NpZ24oe1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAqIHJhdGlvLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICogcmF0aW9cbiAgICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyhhc3NpZ24oe1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IC1sZWZ0ICogcmF0aW8sXG4gICAgICAgICAgdHJhbnNsYXRlWTogLXRvcCAqIHJhdGlvXG4gICAgICAgIH0sIGltYWdlRGF0YSkpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGV2ZW50cyA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjcm9wcGVyID0gdGhpcy5jcm9wcGVyO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BzdGFydCkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9TVEFSVCwgb3B0aW9ucy5jcm9wc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3Btb3ZlKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIG9wdGlvbnMuY3JvcG1vdmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BlbmQpKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfRU5ELCBvcHRpb25zLmNyb3BlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3ApKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1AsIG9wdGlvbnMuY3JvcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuem9vbSkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfWk9PTSwgb3B0aW9ucy56b29tKTtcbiAgICAgIH1cblxuICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfUE9JTlRFUl9ET1dOLCB0aGlzLm9uQ3JvcFN0YXJ0ID0gdGhpcy5jcm9wU3RhcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uV2hlZWwpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfV0hFRUwsIHRoaXMub25XaGVlbCA9IHRoaXMud2hlZWwuYmluZCh0aGlzKSwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvZ2dsZURyYWdNb2RlT25EYmxjbGljaykge1xuICAgICAgICBhZGRMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9EQkxDTElDSywgdGhpcy5vbkRibGNsaWNrID0gdGhpcy5kYmxjbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudC5vd25lckRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX01PVkUsIHRoaXMub25Dcm9wTW92ZSA9IHRoaXMuY3JvcE1vdmUuYmluZCh0aGlzKSk7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50Lm93bmVyRG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Dcm9wRW5kID0gdGhpcy5jcm9wRW5kLmJpbmQodGhpcykpO1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKHdpbmRvdywgRVZFTlRfUkVTSVpFLCB0aGlzLm9uUmVzaXplID0gdGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY3JvcHBlciA9IHRoaXMuY3JvcHBlcjtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wc3RhcnQpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfU1RBUlQsIG9wdGlvbnMuY3JvcHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wbW92ZSkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9NT1ZFLCBvcHRpb25zLmNyb3Btb3ZlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wZW5kKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX0VORCwgb3B0aW9ucy5jcm9wZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QLCBvcHRpb25zLmNyb3ApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnpvb20pKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1pPT00sIG9wdGlvbnMuem9vbSk7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKGNyb3BwZXIsIEVWRU5UX1BPSU5URVJfRE9XTiwgdGhpcy5vbkNyb3BTdGFydCk7XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uV2hlZWwpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfV0hFRUwsIHRoaXMub25XaGVlbCwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvZ2dsZURyYWdNb2RlT25EYmxjbGljaykge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9EQkxDTElDSywgdGhpcy5vbkRibGNsaWNrKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudC5vd25lckRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX01PVkUsIHRoaXMub25Dcm9wTW92ZSk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50Lm93bmVyRG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Dcm9wRW5kKTtcblxuICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcih3aW5kb3csIEVWRU5UX1JFU0laRSwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVycyA9IHtcbiAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YTtcbiAgICAgIHZhciByYXRpbyA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIGNvbnRhaW5lckRhdGEud2lkdGg7IC8vIFJlc2l6ZSB3aGVuIHdpZHRoIGNoYW5nZWQgb3IgaGVpZ2h0IGNoYW5nZWRcblxuICAgICAgaWYgKHJhdGlvICE9PSAxIHx8IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgIT09IGNvbnRhaW5lckRhdGEuaGVpZ2h0KSB7XG4gICAgICAgIHZhciBjYW52YXNEYXRhO1xuICAgICAgICB2YXIgY3JvcEJveERhdGE7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzdG9yZSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmdldENhbnZhc0RhdGEoKTtcbiAgICAgICAgICBjcm9wQm94RGF0YSA9IHRoaXMuZ2V0Q3JvcEJveERhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzdG9yZSkge1xuICAgICAgICAgIHRoaXMuc2V0Q2FudmFzRGF0YShmb3JFYWNoKGNhbnZhc0RhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICBjYW52YXNEYXRhW2ldID0gbiAqIHJhdGlvO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKGZvckVhY2goY3JvcEJveERhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICBjcm9wQm94RGF0YVtpXSA9IG4gKiByYXRpbztcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRibGNsaWNrOiBmdW5jdGlvbiBkYmxjbGljaygpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMub3B0aW9ucy5kcmFnTW9kZSA9PT0gRFJBR19NT0RFX05PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldERyYWdNb2RlKGhhc0NsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfQ1JPUCkgPyBEUkFHX01PREVfTU9WRSA6IERSQUdfTU9ERV9DUk9QKTtcbiAgICB9LFxuICAgIHdoZWVsOiBmdW5jdGlvbiB3aGVlbChldmVudCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJhdGlvID0gTnVtYmVyKHRoaXMub3B0aW9ucy53aGVlbFpvb21SYXRpbykgfHwgMC4xO1xuICAgICAgdmFyIGRlbHRhID0gMTtcblxuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBMaW1pdCB3aGVlbCBzcGVlZCB0byBwcmV2ZW50IHpvb20gdG9vIGZhc3QgKCMyMSlcblxuICAgICAgaWYgKHRoaXMud2hlZWxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndoZWVsaW5nID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy53aGVlbGluZyA9IGZhbHNlO1xuICAgICAgfSwgNTApO1xuXG4gICAgICBpZiAoZXZlbnQuZGVsdGFZKSB7XG4gICAgICAgIGRlbHRhID0gZXZlbnQuZGVsdGFZID4gMCA/IDEgOiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgICBkZWx0YSA9IC1ldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcbiAgICAgICAgZGVsdGEgPSBldmVudC5kZXRhaWwgPiAwID8gMSA6IC0xO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnpvb20oLWRlbHRhICogcmF0aW8sIGV2ZW50KTtcbiAgICB9LFxuICAgIGNyb3BTdGFydDogZnVuY3Rpb24gY3JvcFN0YXJ0KGV2ZW50KSB7XG4gICAgICB2YXIgYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnMsXG4gICAgICAgICAgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCAvLyBIYW5kbGUgbW91c2UgZXZlbnQgYW5kIHBvaW50ZXIgZXZlbnQgYW5kIGlnbm9yZSB0b3VjaCBldmVudFxuICAgICAgfHwgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdwb2ludGVyZG93bicgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmICggLy8gTm8gcHJpbWFyeSBidXR0b24gKFVzdWFsbHkgdGhlIGxlZnQgYnV0dG9uKVxuICAgICAgaXNOdW1iZXIoYnV0dG9ucykgJiYgYnV0dG9ucyAhPT0gMSB8fCBpc051bWJlcihidXR0b24pICYmIGJ1dHRvbiAhPT0gMCAvLyBPcGVuIGNvbnRleHQgbWVudVxuICAgICAgfHwgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgICB2YXIgYWN0aW9uO1xuXG4gICAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRvdWNoIGV2ZW50XG4gICAgICAgIGZvckVhY2goZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICAgIHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdID0gZ2V0UG9pbnRlcih0b3VjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIG1vdXNlIGV2ZW50IGFuZCBwb2ludGVyIGV2ZW50XG4gICAgICAgIHBvaW50ZXJzW2V2ZW50LnBvaW50ZXJJZCB8fCAwXSA9IGdldFBvaW50ZXIoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LmtleXMocG9pbnRlcnMpLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy56b29tYWJsZSAmJiBvcHRpb25zLnpvb21PblRvdWNoKSB7XG4gICAgICAgIGFjdGlvbiA9IEFDVElPTl9aT09NO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uID0gZ2V0RGF0YShldmVudC50YXJnZXQsIERBVEFfQUNUSU9OKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFSRUdFWFBfQUNUSU9OUy50ZXN0KGFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX0NST1BfU1RBUlQsIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGlzIGxpbmUgaXMgcmVxdWlyZWQgZm9yIHByZXZlbnRpbmcgcGFnZSB6b29taW5nIGluIGlPUyBicm93c2Vyc1xuXG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgIHRoaXMuY3JvcHBpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKGFjdGlvbiA9PT0gQUNUSU9OX0NST1ApIHtcbiAgICAgICAgdGhpcy5jcm9wcGluZyA9IHRydWU7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JvcE1vdmU6IGZ1bmN0aW9uIGNyb3BNb3ZlKGV2ZW50KSB7XG4gICAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG5cbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICFhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKGRpc3BhdGNoRXZlbnQodGhpcy5lbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgZm9yRWFjaChldmVudC5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgbm90IGJlIHVuZGVmaW5lZCAoIzQzMilcbiAgICAgICAgICBhc3NpZ24ocG9pbnRlcnNbdG91Y2guaWRlbnRpZmllcl0gfHwge30sIGdldFBvaW50ZXIodG91Y2gsIHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ24ocG9pbnRlcnNbZXZlbnQucG9pbnRlcklkIHx8IDBdIHx8IHt9LCBnZXRQb2ludGVyKGV2ZW50LCB0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hhbmdlKGV2ZW50KTtcbiAgICB9LFxuICAgIGNyb3BFbmQ6IGZ1bmN0aW9uIGNyb3BFbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uLFxuICAgICAgICAgIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcblxuICAgICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIGZvckVhY2goZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICAgIGRlbGV0ZSBwb2ludGVyc1t0b3VjaC5pZGVudGlmaWVyXTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcG9pbnRlcnNbZXZlbnQucG9pbnRlcklkIHx8IDBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmICghT2JqZWN0LmtleXMocG9pbnRlcnMpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFjdGlvbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jcm9wcGluZykge1xuICAgICAgICB0aGlzLmNyb3BwaW5nID0gZmFsc2U7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwsIHRoaXMuY3JvcHBlZCAmJiB0aGlzLm9wdGlvbnMubW9kYWwpO1xuICAgICAgfVxuXG4gICAgICBkaXNwYXRjaEV2ZW50KHRoaXMuZWxlbWVudCwgRVZFTlRfQ1JPUF9FTkQsIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNoYW5nZSA9IHtcbiAgICBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShldmVudCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YSxcbiAgICAgICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBvcHRpb25zLmFzcGVjdFJhdGlvO1xuICAgICAgdmFyIGxlZnQgPSBjcm9wQm94RGF0YS5sZWZ0LFxuICAgICAgICAgIHRvcCA9IGNyb3BCb3hEYXRhLnRvcCxcbiAgICAgICAgICB3aWR0aCA9IGNyb3BCb3hEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcbiAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICB2YXIgbWluTGVmdCA9IDA7XG4gICAgICB2YXIgbWluVG9wID0gMDtcbiAgICAgIHZhciBtYXhXaWR0aCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgcmVuZGVyYWJsZSA9IHRydWU7XG4gICAgICB2YXIgb2Zmc2V0OyAvLyBMb2NraW5nIGFzcGVjdCByYXRpbyBpbiBcImZyZWUgbW9kZVwiIGJ5IGhvbGRpbmcgc2hpZnQga2V5XG5cbiAgICAgIGlmICghYXNwZWN0UmF0aW8gJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgYXNwZWN0UmF0aW8gPSB3aWR0aCAmJiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxpbWl0ZWQpIHtcbiAgICAgICAgbWluTGVmdCA9IGNyb3BCb3hEYXRhLm1pbkxlZnQ7XG4gICAgICAgIG1pblRvcCA9IGNyb3BCb3hEYXRhLm1pblRvcDtcbiAgICAgICAgbWF4V2lkdGggPSBtaW5MZWZ0ICsgTWF0aC5taW4oY29udGFpbmVyRGF0YS53aWR0aCwgY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS5sZWZ0ICsgY2FudmFzRGF0YS53aWR0aCk7XG4gICAgICAgIG1heEhlaWdodCA9IG1pblRvcCArIE1hdGgubWluKGNvbnRhaW5lckRhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS50b3AgKyBjYW52YXNEYXRhLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gcG9pbnRlcnNbT2JqZWN0LmtleXMocG9pbnRlcnMpWzBdXTtcbiAgICAgIHZhciByYW5nZSA9IHtcbiAgICAgICAgeDogcG9pbnRlci5lbmRYIC0gcG9pbnRlci5zdGFydFgsXG4gICAgICAgIHk6IHBvaW50ZXIuZW5kWSAtIHBvaW50ZXIuc3RhcnRZXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjayhzaWRlKSB7XG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgIGNhc2UgQUNUSU9OX0VBU1Q6XG4gICAgICAgICAgICBpZiAocmlnaHQgKyByYW5nZS54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgcmFuZ2UueCA9IG1heFdpZHRoIC0gcmlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBBQ1RJT05fV0VTVDpcbiAgICAgICAgICAgIGlmIChsZWZ0ICsgcmFuZ2UueCA8IG1pbkxlZnQpIHtcbiAgICAgICAgICAgICAgcmFuZ2UueCA9IG1pbkxlZnQgLSBsZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQUNUSU9OX05PUlRIOlxuICAgICAgICAgICAgaWYgKHRvcCArIHJhbmdlLnkgPCBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgcmFuZ2UueSA9IG1pblRvcCAtIHRvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIEFDVElPTl9TT1VUSDpcbiAgICAgICAgICAgIGlmIChib3R0b20gKyByYW5nZS55ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHJhbmdlLnkgPSBtYXhIZWlnaHQgLSBib3R0b207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAvLyBNb3ZlIGNyb3AgYm94XG4gICAgICAgIGNhc2UgQUNUSU9OX0FMTDpcbiAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFJlc2l6ZSBjcm9wIGJveFxuXG4gICAgICAgIGNhc2UgQUNUSU9OX0VBU1Q6XG4gICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCAmJiAocmlnaHQgPj0gbWF4V2lkdGggfHwgYXNwZWN0UmF0aW8gJiYgKHRvcCA8PSBtaW5Ub3AgfHwgYm90dG9tID49IG1heEhlaWdodCkpKSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGVjayhBQ1RJT05fRUFTVCk7XG4gICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcblxuICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9XRVNUO1xuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIHRvcCArPSAoY3JvcEJveERhdGEuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBQ1RJT05fTk9SVEg6XG4gICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCAmJiAodG9wIDw9IG1pblRvcCB8fCBhc3BlY3RSYXRpbyAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IHJpZ2h0ID49IG1heFdpZHRoKSkpIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG5cbiAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgbGVmdCArPSAoY3JvcEJveERhdGEud2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQUNUSU9OX1dFU1Q6XG4gICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IGFzcGVjdFJhdGlvICYmICh0b3AgPD0gbWluVG9wIHx8IGJvdHRvbSA+PSBtYXhIZWlnaHQpKSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hlY2soQUNUSU9OX1dFU1QpO1xuICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX0VBU1Q7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgdG9wICs9IChjcm9wQm94RGF0YS5oZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSDpcbiAgICAgICAgICBpZiAocmFuZ2UueSA+PSAwICYmIChib3R0b20gPj0gbWF4SGVpZ2h0IHx8IGFzcGVjdFJhdGlvICYmIChsZWZ0IDw9IG1pbkxlZnQgfHwgcmlnaHQgPj0gbWF4V2lkdGgpKSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hlY2soQUNUSU9OX1NPVVRIKTtcbiAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcblxuICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEg7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBsZWZ0ICs9IChjcm9wQm94RGF0YS53aWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBQ1RJT05fTk9SVEhfRUFTVDpcbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgcmlnaHQgPj0gbWF4V2lkdGgpKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9FQVNUKTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCkge1xuICAgICAgICAgICAgICBpZiAocmlnaHQgPCBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA8PSAwICYmIHRvcCA8PSBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDApIHtcbiAgICAgICAgICAgICAgaWYgKHRvcCA+IG1pblRvcCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEhfV0VTVDtcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEhfV0VTVDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBQ1RJT05fTk9SVEhfV0VTVDpcbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgbGVmdCA8PSBtaW5MZWZ0KSkge1xuICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fTk9SVEgpO1xuICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBsZWZ0ICs9IGNyb3BCb3hEYXRhLndpZHRoIC0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS54IDw9IDApIHtcbiAgICAgICAgICAgICAgaWYgKGxlZnQgPiBtaW5MZWZ0KSB7XG4gICAgICAgICAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA8PSAwICYmIHRvcCA8PSBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCkge1xuICAgICAgICAgICAgICBpZiAodG9wID4gbWluVG9wKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2lkdGggPCAwICYmIGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSF9XRVNUOlxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IGJvdHRvbSA+PSBtYXhIZWlnaHQpKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9XRVNUKTtcbiAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fU09VVEgpO1xuICAgICAgICAgICAgY2hlY2soQUNUSU9OX1dFU1QpO1xuXG4gICAgICAgICAgICBpZiAocmFuZ2UueCA8PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChsZWZ0ID4gbWluTGVmdCkge1xuICAgICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPj0gMCAmJiBib3R0b20gPj0gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aWR0aCAtPSByYW5nZS54O1xuICAgICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS55ID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKGJvdHRvbSA8IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSByYW5nZS55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2lkdGggPCAwICYmIGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX1dFU1Q7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSF9FQVNUOlxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCAmJiAocmlnaHQgPj0gbWF4V2lkdGggfHwgYm90dG9tID49IG1heEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hlY2soQUNUSU9OX0VBU1QpO1xuICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9TT1VUSCk7XG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fRUFTVCk7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS54ID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPj0gMCAmJiBib3R0b20gPj0gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2UueSA+PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChib3R0b20gPCBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEhfV0VTVDtcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEhfV0VTVDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1vdmUgY2FudmFzXG5cbiAgICAgICAgY2FzZSBBQ1RJT05fTU9WRTpcbiAgICAgICAgICB0aGlzLm1vdmUocmFuZ2UueCwgcmFuZ2UueSk7XG4gICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBab29tIGNhbnZhc1xuXG4gICAgICAgIGNhc2UgQUNUSU9OX1pPT006XG4gICAgICAgICAgdGhpcy56b29tKGdldE1heFpvb21SYXRpbyhwb2ludGVycyksIGV2ZW50KTtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENyZWF0ZSBjcm9wIGJveFxuXG4gICAgICAgIGNhc2UgQUNUSU9OX0NST1A6XG4gICAgICAgICAgaWYgKCFyYW5nZS54IHx8ICFyYW5nZS55KSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZzZXQgPSBnZXRPZmZzZXQodGhpcy5jcm9wcGVyKTtcbiAgICAgICAgICBsZWZ0ID0gcG9pbnRlci5zdGFydFggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgICB0b3AgPSBwb2ludGVyLnN0YXJ0WSAtIG9mZnNldC50b3A7XG4gICAgICAgICAgd2lkdGggPSBjcm9wQm94RGF0YS5taW5XaWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBjcm9wQm94RGF0YS5taW5IZWlnaHQ7XG5cbiAgICAgICAgICBpZiAocmFuZ2UueCA+IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IHJhbmdlLnkgPiAwID8gQUNUSU9OX1NPVVRIX0VBU1QgOiBBQ1RJT05fTk9SVEhfRUFTVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnggPCAwKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgYWN0aW9uID0gcmFuZ2UueSA+IDAgPyBBQ1RJT05fU09VVEhfV0VTVCA6IEFDVElPTl9OT1JUSF9XRVNUO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZS55IDwgMCkge1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICB9IC8vIFNob3cgdGhlIGNyb3AgYm94IGlmIGlzIGhpZGRlblxuXG5cbiAgICAgICAgICBpZiAoIXRoaXMuY3JvcHBlZCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xuICAgICAgICAgICAgdGhpcy5jcm9wcGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRlZCkge1xuICAgICAgICAgICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlcmFibGUpIHtcbiAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjcm9wQm94RGF0YS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgY3JvcEJveERhdGEudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICB9IC8vIE92ZXJyaWRlXG5cblxuICAgICAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC5zdGFydFggPSBwLmVuZFg7XG4gICAgICAgIHAuc3RhcnRZID0gcC5lbmRZO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtZXRob2RzID0ge1xuICAgIC8vIFNob3cgdGhlIGNyb3AgYm94IG1hbnVhbGx5XG4gICAgY3JvcDogZnVuY3Rpb24gY3JvcCgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmNyb3BwZWQgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jcm9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tb2RhbCkge1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xuICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBSZXNldCB0aGUgaW1hZ2UgYW5kIGNyb3AgYm94IHRvIHRoZWlyIGluaXRpYWwgc3RhdGVzXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5pbWFnZURhdGEgPSBhc3NpZ24oe30sIHRoaXMuaW5pdGlhbEltYWdlRGF0YSk7XG4gICAgICAgIHRoaXMuY2FudmFzRGF0YSA9IGFzc2lnbih7fSwgdGhpcy5pbml0aWFsQ2FudmFzRGF0YSk7XG4gICAgICAgIHRoaXMuY3JvcEJveERhdGEgPSBhc3NpZ24oe30sIHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMoKTtcblxuICAgICAgICBpZiAodGhpcy5jcm9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBDbGVhciB0aGUgY3JvcCBib3hcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBpZiAodGhpcy5jcm9wcGVkICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLmNyb3BCb3hEYXRhLCB7XG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNyb3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgIHRoaXMubGltaXRDYW52YXModHJ1ZSwgdHJ1ZSk7IC8vIFJlbmRlciBjYW52YXMgYWZ0ZXIgY3JvcCBib3ggcmVuZGVyZWRcblxuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcygpO1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmRyYWdCb3gsIENMQVNTX01PREFMKTtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgaW1hZ2UncyBzcmMgYW5kIHJlYnVpbGQgdGhlIGNyb3BwZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIG5ldyBVUkwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGFzU2FtZVNpemVdIC0gSW5kaWNhdGUgaWYgdGhlIG5ldyBpbWFnZSBoYXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgb2xkIG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UodXJsKSB7XG4gICAgICB2YXIgaGFzU2FtZVNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW1nKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnNyYyA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTYW1lU2l6ZSkge1xuICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gdXJsO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0JveEltYWdlLnNyYyA9IHVybDtcbiAgICAgICAgICAgIGZvckVhY2godGhpcy5wcmV2aWV3cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJylbMF0uc3JjID0gdXJsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmlzSW1nKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgdGhpcy51bmNyZWF0ZSgpO1xuICAgICAgICAgIHRoaXMubG9hZCh1cmwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gRW5hYmxlICh1bmZyZWV6ZSkgdGhlIGNyb3BwZXJcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmNyb3BwZXIsIENMQVNTX0RJU0FCTEVEKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBEaXNhYmxlIChmcmVlemUpIHRoZSBjcm9wcGVyXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBhZGRDbGFzcyh0aGlzLmNyb3BwZXIsIENMQVNTX0RJU0FCTEVEKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGNyb3BwZXIgYW5kIHJlbW92ZSB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgaW1hZ2VcbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgICAgaWYgKCFlbGVtZW50W05BTUVTUEFDRV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRbTkFNRVNQQUNFXSA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMuaXNJbWcgJiYgdGhpcy5yZXBsYWNlZCkge1xuICAgICAgICBlbGVtZW50LnNyYyA9IHRoaXMub3JpZ2luYWxVcmw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudW5jcmVhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjYW52YXMgd2l0aCByZWxhdGl2ZSBvZmZzZXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IGRpc3RhbmNlIG9uIHRoZSB4LWF4aXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRZPW9mZnNldFhdIC0gVGhlIHJlbGF0aXZlIG9mZnNldCBkaXN0YW5jZSBvbiB0aGUgeS1heGlzLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZShvZmZzZXRYKSB7XG4gICAgICB2YXIgb2Zmc2V0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogb2Zmc2V0WDtcbiAgICAgIHZhciBfdGhpcyRjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgICAgIGxlZnQgPSBfdGhpcyRjYW52YXNEYXRhLmxlZnQsXG4gICAgICAgICAgdG9wID0gX3RoaXMkY2FudmFzRGF0YS50b3A7XG4gICAgICByZXR1cm4gdGhpcy5tb3ZlVG8oaXNVbmRlZmluZWQob2Zmc2V0WCkgPyBvZmZzZXRYIDogbGVmdCArIE51bWJlcihvZmZzZXRYKSwgaXNVbmRlZmluZWQob2Zmc2V0WSkgPyBvZmZzZXRZIDogdG9wICsgTnVtYmVyKG9mZnNldFkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeC1heGlzIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PXhdIC0gVGhlIHktYXhpcyBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgbW92ZVRvOiBmdW5jdGlvbiBtb3ZlVG8oeCkge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHg7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB4ID0gTnVtYmVyKHgpO1xuICAgICAgeSA9IE51bWJlcih5KTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5vcHRpb25zLm1vdmFibGUpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICAgICAgY2FudmFzRGF0YS5sZWZ0ID0geDtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEudG9wID0geTtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb20gdGhlIGNhbnZhcyB3aXRoIGEgcmVsYXRpdmUgcmF0aW9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gLSBUaGUgdGFyZ2V0IHJhdGlvLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IF9vcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHpvb206IGZ1bmN0aW9uIHpvb20ocmF0aW8sIF9vcmlnaW5hbEV2ZW50KSB7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICAgIHJhdGlvID0gTnVtYmVyKHJhdGlvKTtcblxuICAgICAgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgICByYXRpbyA9IDEgLyAoMSAtIHJhdGlvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhdGlvID0gMSArIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy56b29tVG8oY2FudmFzRGF0YS53aWR0aCAqIHJhdGlvIC8gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgsIG51bGwsIF9vcmlnaW5hbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIHJhdGlvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIC0gVGhlIHRhcmdldCByYXRpby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGl2b3QgLSBUaGUgem9vbSBwaXZvdCBwb2ludCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IF9vcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHpvb21UbzogZnVuY3Rpb24gem9vbVRvKHJhdGlvLCBwaXZvdCwgX29yaWdpbmFsRXZlbnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgICB2YXIgd2lkdGggPSBjYW52YXNEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGNhbnZhc0RhdGEuaGVpZ2h0LFxuICAgICAgICAgIG5hdHVyYWxXaWR0aCA9IGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoLFxuICAgICAgICAgIG5hdHVyYWxIZWlnaHQgPSBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQ7XG4gICAgICByYXRpbyA9IE51bWJlcihyYXRpbyk7XG5cbiAgICAgIGlmIChyYXRpbyA+PSAwICYmIHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgb3B0aW9ucy56b29tYWJsZSkge1xuICAgICAgICB2YXIgbmV3V2lkdGggPSBuYXR1cmFsV2lkdGggKiByYXRpbztcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IG5hdHVyYWxIZWlnaHQgKiByYXRpbztcblxuICAgICAgICBpZiAoZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX1pPT00sIHtcbiAgICAgICAgICByYXRpbzogcmF0aW8sXG4gICAgICAgICAgb2xkUmF0aW86IHdpZHRoIC8gbmF0dXJhbFdpZHRoLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IF9vcmlnaW5hbEV2ZW50XG4gICAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgdmFyIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHRoaXMuY3JvcHBlcik7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IHBvaW50ZXJzICYmIE9iamVjdC5rZXlzKHBvaW50ZXJzKS5sZW5ndGggPyBnZXRQb2ludGVyc0NlbnRlcihwb2ludGVycykgOiB7XG4gICAgICAgICAgICBwYWdlWDogX29yaWdpbmFsRXZlbnQucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogX29yaWdpbmFsRXZlbnQucGFnZVlcbiAgICAgICAgICB9OyAvLyBab29tIGZyb20gdGhlIHRyaWdnZXJpbmcgcG9pbnQgb2YgdGhlIGV2ZW50XG5cbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpICogKChjZW50ZXIucGFnZVggLSBvZmZzZXQubGVmdCAtIGNhbnZhc0RhdGEubGVmdCkgLyB3aWR0aCk7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgKiAoKGNlbnRlci5wYWdlWSAtIG9mZnNldC50b3AgLSBjYW52YXNEYXRhLnRvcCkgLyBoZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocGl2b3QpICYmIGlzTnVtYmVyKHBpdm90LngpICYmIGlzTnVtYmVyKHBpdm90LnkpKSB7XG4gICAgICAgICAgY2FudmFzRGF0YS5sZWZ0IC09IChuZXdXaWR0aCAtIHdpZHRoKSAqICgocGl2b3QueCAtIGNhbnZhc0RhdGEubGVmdCkgLyB3aWR0aCk7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgKiAoKHBpdm90LnkgLSBjYW52YXNEYXRhLnRvcCkgLyBoZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFpvb20gZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICBjYW52YXNEYXRhLnRvcCAtPSAobmV3SGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXNEYXRhLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSB0aGUgY2FudmFzIHdpdGggYSByZWxhdGl2ZSBkZWdyZWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIC0gVGhlIHJvdGF0ZSBkZWdyZWUuXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uIHJvdGF0ZShkZWdyZWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZVRvKCh0aGlzLmltYWdlRGF0YS5yb3RhdGUgfHwgMCkgKyBOdW1iZXIoZGVncmVlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIGRlZ3JlZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWUgLSBUaGUgcm90YXRlIGRlZ3JlZS5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHJvdGF0ZVRvOiBmdW5jdGlvbiByb3RhdGVUbyhkZWdyZWUpIHtcbiAgICAgIGRlZ3JlZSA9IE51bWJlcihkZWdyZWUpO1xuXG4gICAgICBpZiAoaXNOdW1iZXIoZGVncmVlKSAmJiB0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIHRoaXMub3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgdGhpcy5pbWFnZURhdGEucm90YXRlID0gZGVncmVlICUgMzYwO1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBpbWFnZSBvbiB0aGUgeC1heGlzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHgtYXhpcy5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHNjYWxlWDogZnVuY3Rpb24gc2NhbGVYKF9zY2FsZVgpIHtcbiAgICAgIHZhciBzY2FsZVkgPSB0aGlzLmltYWdlRGF0YS5zY2FsZVk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZShfc2NhbGVYLCBpc051bWJlcihzY2FsZVkpID8gc2NhbGVZIDogMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBpbWFnZSBvbiB0aGUgeS1heGlzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVkgLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHktYXhpcy5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHNjYWxlWTogZnVuY3Rpb24gc2NhbGVZKF9zY2FsZVkpIHtcbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLmltYWdlRGF0YS5zY2FsZVg7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZShpc051bWJlcihzY2FsZVgpID8gc2NhbGVYIDogMSwgX3NjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHgtYXhpcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWT1zY2FsZVhdIC0gVGhlIHNjYWxlIHJhdGlvIG9uIHRoZSB5LWF4aXMuXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzY2FsZTogZnVuY3Rpb24gc2NhbGUoc2NhbGVYKSB7XG4gICAgICB2YXIgc2NhbGVZID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzY2FsZVg7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSBmYWxzZTtcbiAgICAgIHNjYWxlWCA9IE51bWJlcihzY2FsZVgpO1xuICAgICAgc2NhbGVZID0gTnVtYmVyKHNjYWxlWSk7XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIHRoaXMub3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoc2NhbGVYKSkge1xuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgdHJhbnNmb3JtZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjYWxlWSkpIHtcbiAgICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNyb3BwZWQgYXJlYSBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhIChiYXNlIG9uIHRoZSBvcmlnaW5hbCBpbWFnZSlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyb3VuZGVkPWZhbHNlXSAtIEluZGljYXRlIGlmIHJvdW5kIHRoZSBkYXRhIHZhbHVlcyBvciBub3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBjcm9wcGVkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgICAgIHZhciByb3VuZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xuICAgICAgdmFyIGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuY3JvcHBlZCkge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIHg6IGNyb3BCb3hEYXRhLmxlZnQgLSBjYW52YXNEYXRhLmxlZnQsXG4gICAgICAgICAgeTogY3JvcEJveERhdGEudG9wIC0gY2FudmFzRGF0YS50b3AsXG4gICAgICAgICAgd2lkdGg6IGNyb3BCb3hEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY3JvcEJveERhdGEuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHZhciByYXRpbyA9IGltYWdlRGF0YS53aWR0aCAvIGltYWdlRGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgICAgIGZvckVhY2goZGF0YSwgZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gbiAvIHJhdGlvO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAgIC8vIEluIGNhc2Ugcm91bmRpbmcgb2ZmIGxlYWRzIHRvIGV4dHJhIDFweCBpbiByaWdodCBvciBib3R0b20gYm9yZGVyXG4gICAgICAgICAgLy8gd2Ugc2hvdWxkIHJvdW5kIHRoZSB0b3AtbGVmdCBjb3JuZXIgYW5kIHRoZSBkaW1lbnNpb24gKCMzNDMpLlxuICAgICAgICAgIHZhciBib3R0b20gPSBNYXRoLnJvdW5kKGRhdGEueSArIGRhdGEuaGVpZ2h0KTtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBNYXRoLnJvdW5kKGRhdGEueCArIGRhdGEud2lkdGgpO1xuICAgICAgICAgIGRhdGEueCA9IE1hdGgucm91bmQoZGF0YS54KTtcbiAgICAgICAgICBkYXRhLnkgPSBNYXRoLnJvdW5kKGRhdGEueSk7XG4gICAgICAgICAgZGF0YS53aWR0aCA9IHJpZ2h0IC0gZGF0YS54O1xuICAgICAgICAgIGRhdGEuaGVpZ2h0ID0gYm90dG9tIC0gZGF0YS55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucm90YXRhYmxlKSB7XG4gICAgICAgIGRhdGEucm90YXRlID0gaW1hZ2VEYXRhLnJvdGF0ZSB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBkYXRhLnNjYWxlWCA9IGltYWdlRGF0YS5zY2FsZVggfHwgMTtcbiAgICAgICAgZGF0YS5zY2FsZVkgPSBpbWFnZURhdGEuc2NhbGVZIHx8IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNyb3BwZWQgYXJlYSBwb3NpdGlvbiBhbmQgc2l6ZSB3aXRoIG5ldyBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGRhdGEuXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGEpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgICB2YXIgY3JvcEJveERhdGEgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5yb3RhdGUpICYmIGRhdGEucm90YXRlICE9PSBpbWFnZURhdGEucm90YXRlKSB7XG4gICAgICAgICAgICBpbWFnZURhdGEucm90YXRlID0gZGF0YS5yb3RhdGU7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5zY2FsZVgpICYmIGRhdGEuc2NhbGVYICE9PSBpbWFnZURhdGEuc2NhbGVYKSB7XG4gICAgICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gZGF0YS5zY2FsZVg7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuc2NhbGVZKSAmJiBkYXRhLnNjYWxlWSAhPT0gaW1hZ2VEYXRhLnNjYWxlWSkge1xuICAgICAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWSA9IGRhdGEuc2NhbGVZO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhdGlvID0gaW1hZ2VEYXRhLndpZHRoIC8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aDtcblxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS54KSkge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLmxlZnQgPSBkYXRhLnggKiByYXRpbyArIGNhbnZhc0RhdGEubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLnkpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEudG9wID0gZGF0YS55ICogcmF0aW8gKyBjYW52YXNEYXRhLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLndpZHRoKSkge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gZGF0YS53aWR0aCAqIHJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IGRhdGEuaGVpZ2h0ICogcmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKGNyb3BCb3hEYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29udGFpbmVyIHNpemUgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNvbnRhaW5lciBkYXRhLlxuICAgICAqL1xuICAgIGdldENvbnRhaW5lckRhdGE6IGZ1bmN0aW9uIGdldENvbnRhaW5lckRhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkeSA/IGFzc2lnbih7fSwgdGhpcy5jb250YWluZXJEYXRhKSA6IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGltYWdlIHBvc2l0aW9uIGFuZCBzaXplIGRhdGEuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBpbWFnZSBkYXRhLlxuICAgICAqL1xuICAgIGdldEltYWdlRGF0YTogZnVuY3Rpb24gZ2V0SW1hZ2VEYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZWQgPyBhc3NpZ24oe30sIHRoaXMuaW1hZ2VEYXRhKSA6IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhbnZhcyBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgY2FudmFzIGRhdGEuXG4gICAgICovXG4gICAgZ2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gZ2V0Q2FudmFzRGF0YSgpIHtcbiAgICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgZm9yRWFjaChbJ2xlZnQnLCAndG9wJywgJ3dpZHRoJywgJ2hlaWdodCcsICduYXR1cmFsV2lkdGgnLCAnbmF0dXJhbEhlaWdodCddLCBmdW5jdGlvbiAobikge1xuICAgICAgICAgIGRhdGFbbl0gPSBjYW52YXNEYXRhW25dO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FudmFzIHBvc2l0aW9uIGFuZCBzaXplIHdpdGggbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGNhbnZhcyBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgc2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gc2V0Q2FudmFzRGF0YShkYXRhKSB7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGNhbnZhc0RhdGEuYXNwZWN0UmF0aW87XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEubGVmdCkpIHtcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSBkYXRhLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS50b3ApKSB7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgPSBkYXRhLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLndpZHRoKSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gZGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IGRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3JvcCBib3ggcG9zaXRpb24gYW5kIHNpemUgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNyb3AgYm94IGRhdGEuXG4gICAgICovXG4gICAgZ2V0Q3JvcEJveERhdGE6IGZ1bmN0aW9uIGdldENyb3BCb3hEYXRhKCkge1xuICAgICAgdmFyIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcbiAgICAgIHZhciBkYXRhO1xuXG4gICAgICBpZiAodGhpcy5yZWFkeSAmJiB0aGlzLmNyb3BwZWQpIHtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICBsZWZ0OiBjcm9wQm94RGF0YS5sZWZ0LFxuICAgICAgICAgIHRvcDogY3JvcEJveERhdGEudG9wLFxuICAgICAgICAgIHdpZHRoOiBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNyb3BCb3hEYXRhLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjcm9wIGJveCBwb3NpdGlvbiBhbmQgc2l6ZSB3aXRoIG5ldyBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIG5ldyBjcm9wIGJveCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgc2V0Q3JvcEJveERhdGE6IGZ1bmN0aW9uIHNldENyb3BCb3hEYXRhKGRhdGEpIHtcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IHRoaXMuY3JvcEJveERhdGE7XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSB0aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgICB2YXIgd2lkdGhDaGFuZ2VkO1xuICAgICAgdmFyIGhlaWdodENoYW5nZWQ7XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuY3JvcHBlZCAmJiAhdGhpcy5kaXNhYmxlZCAmJiBpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLmxlZnQpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGRhdGEubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLnRvcCkpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS50b3AgPSBkYXRhLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLndpZHRoKSAmJiBkYXRhLndpZHRoICE9PSBjcm9wQm94RGF0YS53aWR0aCkge1xuICAgICAgICAgIHdpZHRoQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBkYXRhLmhlaWdodCAhPT0gY3JvcEJveERhdGEuaGVpZ2h0KSB7XG4gICAgICAgICAgaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBpZiAod2lkdGhDaGFuZ2VkKSB7XG4gICAgICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0Q2hhbmdlZCkge1xuICAgICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBjcm9wQm94RGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlckNyb3BCb3goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGNhbnZhcyBkcmF3biB0aGUgY3JvcHBlZCBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIGNvbmZpZyBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gLSBUaGUgcmVzdWx0IGNhbnZhcy5cbiAgICAgKi9cbiAgICBnZXRDcm9wcGVkQ2FudmFzOiBmdW5jdGlvbiBnZXRDcm9wcGVkQ2FudmFzKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAoIXRoaXMucmVhZHkgfHwgIXdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgICB2YXIgc291cmNlID0gZ2V0U291cmNlQ2FudmFzKHRoaXMuaW1hZ2UsIHRoaXMuaW1hZ2VEYXRhLCBjYW52YXNEYXRhLCBvcHRpb25zKTsgLy8gUmV0dXJucyB0aGUgc291cmNlIGNhbnZhcyBpZiBpdCBpcyBub3QgY3JvcHBlZC5cblxuICAgICAgaWYgKCF0aGlzLmNyb3BwZWQpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJGdldERhdGEgPSB0aGlzLmdldERhdGEoKSxcbiAgICAgICAgICBpbml0aWFsWCA9IF90aGlzJGdldERhdGEueCxcbiAgICAgICAgICBpbml0aWFsWSA9IF90aGlzJGdldERhdGEueSxcbiAgICAgICAgICBpbml0aWFsV2lkdGggPSBfdGhpcyRnZXREYXRhLndpZHRoLFxuICAgICAgICAgIGluaXRpYWxIZWlnaHQgPSBfdGhpcyRnZXREYXRhLmhlaWdodDtcblxuICAgICAgdmFyIHJhdGlvID0gc291cmNlLndpZHRoIC8gTWF0aC5mbG9vcihjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCk7XG5cbiAgICAgIGlmIChyYXRpbyAhPT0gMSkge1xuICAgICAgICBpbml0aWFsWCAqPSByYXRpbztcbiAgICAgICAgaW5pdGlhbFkgKj0gcmF0aW87XG4gICAgICAgIGluaXRpYWxXaWR0aCAqPSByYXRpbztcbiAgICAgICAgaW5pdGlhbEhlaWdodCAqPSByYXRpbztcbiAgICAgIH1cblxuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gaW5pdGlhbFdpZHRoIC8gaW5pdGlhbEhlaWdodDtcbiAgICAgIHZhciBtYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIHdpZHRoOiBvcHRpb25zLm1heFdpZHRoIHx8IEluZmluaXR5LFxuICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubWF4SGVpZ2h0IHx8IEluZmluaXR5XG4gICAgICB9KTtcbiAgICAgIHZhciBtaW5TaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIHdpZHRoOiBvcHRpb25zLm1pbldpZHRoIHx8IDAsXG4gICAgICAgIGhlaWdodDogb3B0aW9ucy5taW5IZWlnaHQgfHwgMFxuICAgICAgfSwgJ2NvdmVyJyk7XG5cbiAgICAgIHZhciBfZ2V0QWRqdXN0ZWRTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoIHx8IChyYXRpbyAhPT0gMSA/IHNvdXJjZS53aWR0aCA6IGluaXRpYWxXaWR0aCksXG4gICAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgfHwgKHJhdGlvICE9PSAxID8gc291cmNlLmhlaWdodCA6IGluaXRpYWxIZWlnaHQpXG4gICAgICB9KSxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRBZGp1c3RlZFNpemVzLmhlaWdodDtcblxuICAgICAgd2lkdGggPSBNYXRoLm1pbihtYXhTaXplcy53aWR0aCwgTWF0aC5tYXgobWluU2l6ZXMud2lkdGgsIHdpZHRoKSk7XG4gICAgICBoZWlnaHQgPSBNYXRoLm1pbihtYXhTaXplcy5oZWlnaHQsIE1hdGgubWF4KG1pblNpemVzLmhlaWdodCwgaGVpZ2h0KSk7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY2FudmFzLndpZHRoID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcih3aWR0aCk7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcihoZWlnaHQpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBfb3B0aW9ucyRpbWFnZVNtb290aGkgPSBvcHRpb25zLmltYWdlU21vb3RoaW5nRW5hYmxlZCxcbiAgICAgICAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQgPSBfb3B0aW9ucyRpbWFnZVNtb290aGkgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRpbWFnZVNtb290aGksXG4gICAgICAgICAgaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gb3B0aW9ucy5pbWFnZVNtb290aGluZ1F1YWxpdHk7XG4gICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGltYWdlU21vb3RoaW5nRW5hYmxlZDtcblxuICAgICAgaWYgKGltYWdlU21vb3RoaW5nUXVhbGl0eSkge1xuICAgICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9IGltYWdlU21vb3RoaW5nUXVhbGl0eTtcbiAgICAgIH0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5kcmF3SW1hZ2VcblxuXG4gICAgICB2YXIgc291cmNlV2lkdGggPSBzb3VyY2Uud2lkdGg7XG4gICAgICB2YXIgc291cmNlSGVpZ2h0ID0gc291cmNlLmhlaWdodDsgLy8gU291cmNlIGNhbnZhcyBwYXJhbWV0ZXJzXG5cbiAgICAgIHZhciBzcmNYID0gaW5pdGlhbFg7XG4gICAgICB2YXIgc3JjWSA9IGluaXRpYWxZO1xuICAgICAgdmFyIHNyY1dpZHRoO1xuICAgICAgdmFyIHNyY0hlaWdodDsgLy8gRGVzdGluYXRpb24gY2FudmFzIHBhcmFtZXRlcnNcblxuICAgICAgdmFyIGRzdFg7XG4gICAgICB2YXIgZHN0WTtcbiAgICAgIHZhciBkc3RXaWR0aDtcbiAgICAgIHZhciBkc3RIZWlnaHQ7XG5cbiAgICAgIGlmIChzcmNYIDw9IC1pbml0aWFsV2lkdGggfHwgc3JjWCA+IHNvdXJjZVdpZHRoKSB7XG4gICAgICAgIHNyY1ggPSAwO1xuICAgICAgICBzcmNXaWR0aCA9IDA7XG4gICAgICAgIGRzdFggPSAwO1xuICAgICAgICBkc3RXaWR0aCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNyY1ggPD0gMCkge1xuICAgICAgICBkc3RYID0gLXNyY1g7XG4gICAgICAgIHNyY1ggPSAwO1xuICAgICAgICBzcmNXaWR0aCA9IE1hdGgubWluKHNvdXJjZVdpZHRoLCBpbml0aWFsV2lkdGggKyBzcmNYKTtcbiAgICAgICAgZHN0V2lkdGggPSBzcmNXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoc3JjWCA8PSBzb3VyY2VXaWR0aCkge1xuICAgICAgICBkc3RYID0gMDtcbiAgICAgICAgc3JjV2lkdGggPSBNYXRoLm1pbihpbml0aWFsV2lkdGgsIHNvdXJjZVdpZHRoIC0gc3JjWCk7XG4gICAgICAgIGRzdFdpZHRoID0gc3JjV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmNXaWR0aCA8PSAwIHx8IHNyY1kgPD0gLWluaXRpYWxIZWlnaHQgfHwgc3JjWSA+IHNvdXJjZUhlaWdodCkge1xuICAgICAgICBzcmNZID0gMDtcbiAgICAgICAgc3JjSGVpZ2h0ID0gMDtcbiAgICAgICAgZHN0WSA9IDA7XG4gICAgICAgIGRzdEhlaWdodCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNyY1kgPD0gMCkge1xuICAgICAgICBkc3RZID0gLXNyY1k7XG4gICAgICAgIHNyY1kgPSAwO1xuICAgICAgICBzcmNIZWlnaHQgPSBNYXRoLm1pbihzb3VyY2VIZWlnaHQsIGluaXRpYWxIZWlnaHQgKyBzcmNZKTtcbiAgICAgICAgZHN0SGVpZ2h0ID0gc3JjSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChzcmNZIDw9IHNvdXJjZUhlaWdodCkge1xuICAgICAgICBkc3RZID0gMDtcbiAgICAgICAgc3JjSGVpZ2h0ID0gTWF0aC5taW4oaW5pdGlhbEhlaWdodCwgc291cmNlSGVpZ2h0IC0gc3JjWSk7XG4gICAgICAgIGRzdEhlaWdodCA9IHNyY0hlaWdodDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmFtcyA9IFtzcmNYLCBzcmNZLCBzcmNXaWR0aCwgc3JjSGVpZ2h0XTsgLy8gQXZvaWQgXCJJbmRleFNpemVFcnJvclwiXG5cbiAgICAgIGlmIChkc3RXaWR0aCA+IDAgJiYgZHN0SGVpZ2h0ID4gMCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB3aWR0aCAvIGluaXRpYWxXaWR0aDtcbiAgICAgICAgcGFyYW1zLnB1c2goZHN0WCAqIHNjYWxlLCBkc3RZICogc2NhbGUsIGRzdFdpZHRoICogc2NhbGUsIGRzdEhlaWdodCAqIHNjYWxlKTtcbiAgICAgIH0gLy8gQWxsIHRoZSBudW1lcmljYWwgcGFyYW1ldGVycyBzaG91bGQgYmUgaW50ZWdlciBmb3IgYGRyYXdJbWFnZWBcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZW5neXVhbmNoZW4vY3JvcHBlci9pc3N1ZXMvNDc2XG5cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgW3NvdXJjZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKHBhcmFtKSk7XG4gICAgICB9KSkpKTtcbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjcm9wIGJveC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0UmF0aW8gLSBUaGUgbmV3IGFzcGVjdCByYXRpby5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHNldEFzcGVjdFJhdGlvOiBmdW5jdGlvbiBzZXRBc3BlY3RSYXRpbyhhc3BlY3RSYXRpbykge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhaXNVbmRlZmluZWQoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAgIC8vIDAgLT4gTmFOXG4gICAgICAgIG9wdGlvbnMuYXNwZWN0UmF0aW8gPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbykgfHwgTmFOO1xuXG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgdGhpcy5pbml0Q3JvcEJveCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY3JvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRyYWcgbW9kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIFRoZSBuZXcgZHJhZyBtb2RlLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgc2V0RHJhZ01vZGU6IGZ1bmN0aW9uIHNldERyYWdNb2RlKG1vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGRyYWdCb3ggPSB0aGlzLmRyYWdCb3gsXG4gICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIGNyb3BwYWJsZSA9IG1vZGUgPT09IERSQUdfTU9ERV9DUk9QO1xuICAgICAgICB2YXIgbW92YWJsZSA9IG9wdGlvbnMubW92YWJsZSAmJiBtb2RlID09PSBEUkFHX01PREVfTU9WRTtcbiAgICAgICAgbW9kZSA9IGNyb3BwYWJsZSB8fCBtb3ZhYmxlID8gbW9kZSA6IERSQUdfTU9ERV9OT05FO1xuICAgICAgICBvcHRpb25zLmRyYWdNb2RlID0gbW9kZTtcbiAgICAgICAgc2V0RGF0YShkcmFnQm94LCBEQVRBX0FDVElPTiwgbW9kZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdCb3gsIENMQVNTX0NST1AsIGNyb3BwYWJsZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdCb3gsIENMQVNTX01PVkUsIG1vdmFibGUpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5jcm9wQm94TW92YWJsZSkge1xuICAgICAgICAgIC8vIFN5bmMgZHJhZyBtb2RlIHRvIGNyb3AgYm94IHdoZW4gaXQgaXMgbm90IG1vdmFibGVcbiAgICAgICAgICBzZXREYXRhKGZhY2UsIERBVEFfQUNUSU9OLCBtb2RlKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhmYWNlLCBDTEFTU19DUk9QLCBjcm9wcGFibGUpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGZhY2UsIENMQVNTX01PVkUsIG1vdmFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQW5vdGhlckNyb3BwZXIgPSBXSU5ET1cuQ3JvcHBlcjtcblxuICB2YXIgQ3JvcHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IENyb3BwZXIuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50IGZvciBjcm9wcGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDcm9wcGVyKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3BwZXIpO1xuXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIVJFR0VYUF9UQUdfTkFNRS50ZXN0KGVsZW1lbnQudGFnTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gPGltZz4gb3IgPGNhbnZhcz4gZWxlbWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgREVGQVVMVFMsIGlzUGxhaW5PYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNyb3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVsb2FkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnJlcGxhY2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnNpemVkID0gZmFsc2U7XG4gICAgICB0aGlzLnNpemluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENyb3BwZXIsIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgdXJsO1xuXG4gICAgICAgIGlmIChlbGVtZW50W05BTUVTUEFDRV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50W05BTUVTUEFDRV0gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnaW1nJykge1xuICAgICAgICAgIHRoaXMuaXNJbWcgPSB0cnVlOyAvLyBlLmcuOiBcImltZy9waWN0dXJlLmpwZ1wiXG5cbiAgICAgICAgICB1cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgJyc7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbFVybCA9IHVybDsgLy8gU3RvcCB3aGVuIGl0J3MgYSBibGFuayBpbWFnZVxuXG4gICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIGUuZy46IFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9pbWcvcGljdHVyZS5qcGdcIlxuXG5cbiAgICAgICAgICB1cmwgPSBlbGVtZW50LnNyYztcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnY2FudmFzJyAmJiB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICB1cmwgPSBlbGVtZW50LnRvRGF0YVVSTCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2FkKHVybCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxvYWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaW1hZ2VEYXRhID0ge307XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBpZiAoIW9wdGlvbnMucm90YXRhYmxlICYmICFvcHRpb25zLnNjYWxhYmxlKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGVja09yaWVudGF0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gLy8gT25seSBJRTEwKyBzdXBwb3J0cyBUeXBlZCBBcnJheXNcblxuXG4gICAgICAgIGlmICghb3B0aW9ucy5jaGVja09yaWVudGF0aW9uIHx8ICF3aW5kb3cuQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIERldGVjdCB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBkaXJlY3RseSBpZiBpdCBpcyBhIERhdGEgVVJMXG5cblxuICAgICAgICBpZiAoUkVHRVhQX0RBVEFfVVJMLnRlc3QodXJsKSkge1xuICAgICAgICAgIC8vIFJlYWQgQXJyYXlCdWZmZXIgZnJvbSBEYXRhIFVSTCBvZiBKUEVHIGltYWdlcyBkaXJlY3RseSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAgICAgaWYgKFJFR0VYUF9EQVRBX1VSTF9KUEVHLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkKGRhdGFVUkxUb0FycmF5QnVmZmVyKHVybCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5IGEgSlBFRyBpbWFnZSBtYXkgY29udGFpbnMgRXhpZiBPcmllbnRhdGlvbiBpbmZvcm1hdGlvbixcbiAgICAgICAgICAgIC8vIHRoZSByZXN0IHR5cGVzIG9mIERhdGEgVVJMcyBhcmUgbm90IG5lY2Vzc2FyeSB0byBjaGVjayBvcmllbnRhdGlvbiBhdCBhbGwuXG4gICAgICAgICAgICB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIDEuIERldGVjdCB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBieSBhIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAgICAvLyAyLiBMb2FkIHRoZSBpbWFnZSBhcyBBcnJheUJ1ZmZlciBmb3IgcmVhZGluZyBvcmllbnRhdGlvbiBpZiBpdHMgYSBKUEVHIGltYWdlLlxuXG5cbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7IC8vIDEuIENyb3NzIG9yaWdpbiByZXF1ZXN0cyBhcmUgb25seSBzdXBwb3J0ZWQgZm9yIHByb3RvY29sIHNjaGVtZXM6XG4gICAgICAgIC8vIGh0dHAsIGh0dHBzLCBkYXRhLCBjaHJvbWUsIGNocm9tZS1leHRlbnNpb24uXG4gICAgICAgIC8vIDIuIEFjY2VzcyB0byBYTUxIdHRwUmVxdWVzdCBmcm9tIGEgRGF0YSBVUkwgd2lsbCBiZSBibG9ja2VkIGJ5IENPUlMgcG9saWN5XG4gICAgICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgYXMgSUUxMSBhbmQgU2FmYXJpLlxuXG4gICAgICAgIHhoci5vbmFib3J0ID0gY2xvbmU7XG4gICAgICAgIHhoci5vbmVycm9yID0gY2xvbmU7XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSBjbG9uZTtcblxuICAgICAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBBYm9ydCB0aGUgcmVxdWVzdCBkaXJlY3RseSBpZiBpdCBub3QgYSBKUEVHIGltYWdlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKSAhPT0gTUlNRV9UWVBFX0pQRUcpIHtcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlYWQoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLnhociA9IG51bGw7XG4gICAgICAgIH07IC8vIEJ1c3QgY2FjaGUgd2hlbiB0aGVyZSBpcyBhIFwiY3Jvc3NPcmlnaW5cIiBwcm9wZXJ0eSB0byBhdm9pZCBicm93c2VyIGNhY2hlIGVycm9yXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5jaGVja0Nyb3NzT3JpZ2luICYmIGlzQ3Jvc3NPcmlnaW5VUkwodXJsKSAmJiBlbGVtZW50LmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgdXJsID0gYWRkVGltZXN0YW1wKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBlbGVtZW50LmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJztcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVhZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWQoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTsgLy8gUmVzZXQgdGhlIG9yaWVudGF0aW9uIHZhbHVlIHRvIGl0cyBkZWZhdWx0IHZhbHVlIDFcbiAgICAgICAgLy8gYXMgc29tZSBpT1MgYnJvd3NlcnMgd2lsbCByZW5kZXIgaW1hZ2Ugd2l0aCBpdHMgb3JpZW50YXRpb25cblxuICAgICAgICB2YXIgb3JpZW50YXRpb24gPSByZXNldEFuZEdldE9yaWVudGF0aW9uKGFycmF5QnVmZmVyKTtcbiAgICAgICAgdmFyIHJvdGF0ZSA9IDA7XG4gICAgICAgIHZhciBzY2FsZVggPSAxO1xuICAgICAgICB2YXIgc2NhbGVZID0gMTtcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPiAxKSB7XG4gICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgVVJMIHdoaWNoIGhhcyB0aGUgZGVmYXVsdCBvcmllbnRhdGlvbiB2YWx1ZVxuICAgICAgICAgIHRoaXMudXJsID0gYXJyYXlCdWZmZXJUb0RhdGFVUkwoYXJyYXlCdWZmZXIsIE1JTUVfVFlQRV9KUEVHKTtcblxuICAgICAgICAgIHZhciBfcGFyc2VPcmllbnRhdGlvbiA9IHBhcnNlT3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xuXG4gICAgICAgICAgcm90YXRlID0gX3BhcnNlT3JpZW50YXRpb24ucm90YXRlO1xuICAgICAgICAgIHNjYWxlWCA9IF9wYXJzZU9yaWVudGF0aW9uLnNjYWxlWDtcbiAgICAgICAgICBzY2FsZVkgPSBfcGFyc2VPcmllbnRhdGlvbi5zY2FsZVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgICBpbWFnZURhdGEucm90YXRlID0gcm90YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb25lKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgdXJsID0gdGhpcy51cmw7XG4gICAgICAgIHZhciBjcm9zc09yaWdpbiA9IGVsZW1lbnQuY3Jvc3NPcmlnaW47XG4gICAgICAgIHZhciBjcm9zc09yaWdpblVybCA9IHVybDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNoZWNrQ3Jvc3NPcmlnaW4gJiYgaXNDcm9zc09yaWdpblVSTCh1cmwpKSB7XG4gICAgICAgICAgaWYgKCFjcm9zc09yaWdpbikge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICB9IC8vIEJ1c3QgY2FjaGUgd2hlbiB0aGVyZSBpcyBub3QgYSBcImNyb3NzT3JpZ2luXCIgcHJvcGVydHkgKCM1MTkpXG5cblxuICAgICAgICAgIGNyb3NzT3JpZ2luVXJsID0gYWRkVGltZXN0YW1wKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5VcmwgPSBjcm9zc09yaWdpblVybDtcbiAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlLnNyYyA9IGNyb3NzT3JpZ2luVXJsIHx8IHVybDtcbiAgICAgICAgaW1hZ2UuYWx0ID0gZWxlbWVudC5hbHQgfHwgJ1RoZSBpbWFnZSB0byBjcm9wJztcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIGltYWdlLm9uZXJyb3IgPSB0aGlzLnN0b3AuYmluZCh0aGlzKTtcbiAgICAgICAgYWRkQ2xhc3MoaW1hZ2UsIENMQVNTX0hJREUpO1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGltYWdlLCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6aW5nID0gdHJ1ZTsgLy8gTWF0Y2ggYWxsIGJyb3dzZXJzIHRoYXQgdXNlIFdlYktpdCBhcyB0aGUgbGF5b3V0IGVuZ2luZSBpbiBpT1MgZGV2aWNlcyxcbiAgICAgICAgLy8gc3VjaCBhcyBTYWZhcmkgZm9yIGlPUywgQ2hyb21lIGZvciBpT1MsIGFuZCBpbi1hcHAgYnJvd3NlcnMuXG5cbiAgICAgICAgdmFyIGlzSU9TV2ViS2l0ID0gV0lORE9XLm5hdmlnYXRvciAmJiAvKD86aVBhZHxpUGhvbmV8aVBvZCkuKj9BcHBsZVdlYktpdC9pLnRlc3QoV0lORE9XLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZShuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgICBhc3NpZ24oX3RoaXMyLmltYWdlRGF0YSwge1xuICAgICAgICAgICAgbmF0dXJhbFdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICBuYXR1cmFsSGVpZ2h0OiBuYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgYXNwZWN0UmF0aW86IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfdGhpczIuc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMyLnNpemVkID0gdHJ1ZTtcblxuICAgICAgICAgIF90aGlzMi5idWlsZCgpO1xuICAgICAgICB9OyAvLyBNb3N0IG1vZGVybiBicm93c2VycyAoZXhjZXB0cyBpT1MgV2ViS2l0KVxuXG5cbiAgICAgICAgaWYgKGltYWdlLm5hdHVyYWxXaWR0aCAmJiAhaXNJT1NXZWJLaXQpIHtcbiAgICAgICAgICBkb25lKGltYWdlLm5hdHVyYWxXaWR0aCwgaW1hZ2UubmF0dXJhbEhlaWdodCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpemluZ0ltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc2l6aW5nSW1hZ2UgPSBzaXppbmdJbWFnZTtcblxuICAgICAgICBzaXppbmdJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9uZShzaXppbmdJbWFnZS53aWR0aCwgc2l6aW5nSW1hZ2UuaGVpZ2h0KTtcblxuICAgICAgICAgIGlmICghaXNJT1NXZWJLaXQpIHtcbiAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoc2l6aW5nSW1hZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzaXppbmdJbWFnZS5zcmMgPSBpbWFnZS5zcmM7IC8vIGlPUyBXZWJLaXQgd2lsbCBjb252ZXJ0IHRoZSBpbWFnZSBhdXRvbWF0aWNhbGx5XG4gICAgICAgIC8vIHdpdGggaXRzIG9yaWVudGF0aW9uIG9uY2UgYXBwZW5kIGl0IGludG8gRE9NICgjMjc5KVxuXG4gICAgICAgIGlmICghaXNJT1NXZWJLaXQpIHtcbiAgICAgICAgICBzaXppbmdJbWFnZS5zdHlsZS5jc3NUZXh0ID0gJ2xlZnQ6MDsnICsgJ21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7JyArICdtYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnQ7JyArICdtaW4taGVpZ2h0OjAhaW1wb3J0YW50OycgKyAnbWluLXdpZHRoOjAhaW1wb3J0YW50OycgKyAnb3BhY2l0eTowOycgKyAncG9zaXRpb246YWJzb2x1dGU7JyArICd0b3A6MDsnICsgJ3otaW5kZXg6LTE7JztcbiAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKHNpemluZ0ltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IG51bGw7XG4gICAgICAgIGltYWdlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYnVpbGRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpemVkIHx8IHRoaXMucmVhZHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBpbWFnZSA9IHRoaXMuaW1hZ2U7IC8vIENyZWF0ZSBjcm9wcGVyIGVsZW1lbnRzXG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IFRFTVBMQVRFO1xuICAgICAgICB2YXIgY3JvcHBlciA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY29udGFpbmVyXCIpKTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGNyb3BwZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1jYW52YXNcIikpO1xuICAgICAgICB2YXIgZHJhZ0JveCA9IGNyb3BwZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1kcmFnLWJveFwiKSk7XG4gICAgICAgIHZhciBjcm9wQm94ID0gY3JvcHBlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNyb3AtYm94XCIpKTtcbiAgICAgICAgdmFyIGZhY2UgPSBjcm9wQm94LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItZmFjZVwiKSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNyb3BwZXIgPSBjcm9wcGVyO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5kcmFnQm94ID0gZHJhZ0JveDtcbiAgICAgICAgdGhpcy5jcm9wQm94ID0gY3JvcEJveDtcbiAgICAgICAgdGhpcy52aWV3Qm94ID0gY3JvcHBlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLXZpZXctYm94XCIpKTtcbiAgICAgICAgdGhpcy5mYWNlID0gZmFjZTtcbiAgICAgICAgY2FudmFzLmFwcGVuZENoaWxkKGltYWdlKTsgLy8gSGlkZSB0aGUgb3JpZ2luYWwgaW1hZ2VcblxuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pOyAvLyBJbnNlcnRzIHRoZSBjcm9wcGVyIGFmdGVyIHRvIHRoZSBjdXJyZW50IGltYWdlXG5cbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjcm9wcGVyLCBlbGVtZW50Lm5leHRTaWJsaW5nKTsgLy8gU2hvdyB0aGUgaW1hZ2UgaWYgaXMgaGlkZGVuXG5cbiAgICAgICAgaWYgKCF0aGlzLmlzSW1nKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoaW1hZ2UsIENMQVNTX0hJREUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0UHJldmlldygpO1xuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgb3B0aW9ucy5pbml0aWFsQXNwZWN0UmF0aW8gPSBNYXRoLm1heCgwLCBvcHRpb25zLmluaXRpYWxBc3BlY3RSYXRpbykgfHwgTmFOO1xuICAgICAgICBvcHRpb25zLmFzcGVjdFJhdGlvID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5hc3BlY3RSYXRpbykgfHwgTmFOO1xuICAgICAgICBvcHRpb25zLnZpZXdNb2RlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMywgTWF0aC5yb3VuZChvcHRpb25zLnZpZXdNb2RlKSkpIHx8IDA7XG4gICAgICAgIGFkZENsYXNzKGNyb3BCb3gsIENMQVNTX0hJRERFTik7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmd1aWRlcykge1xuICAgICAgICAgIGFkZENsYXNzKGNyb3BCb3guZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWRhc2hlZFwiKSksIENMQVNTX0hJRERFTik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuY2VudGVyKSB7XG4gICAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY2VudGVyXCIpKSwgQ0xBU1NfSElEREVOKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmQpIHtcbiAgICAgICAgICBhZGRDbGFzcyhjcm9wcGVyLCBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWJnXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgICBhZGRDbGFzcyhmYWNlLCBDTEFTU19JTlZJU0lCTEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY3JvcEJveE1vdmFibGUpIHtcbiAgICAgICAgICBhZGRDbGFzcyhmYWNlLCBDTEFTU19NT1ZFKTtcbiAgICAgICAgICBzZXREYXRhKGZhY2UsIERBVEFfQUNUSU9OLCBBQ1RJT05fQUxMKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5jcm9wQm94UmVzaXphYmxlKSB7XG4gICAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItbGluZVwiKSksIENMQVNTX0hJRERFTik7XG4gICAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItcG9pbnRcIikpLCBDTEFTU19ISURERU4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0RHJhZ01vZGUob3B0aW9ucy5kcmFnTW9kZSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0Nyb3ApIHtcbiAgICAgICAgICB0aGlzLmNyb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGF0YShvcHRpb25zLmRhdGEpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMucmVhZHkpKSB7XG4gICAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfUkVBRFksIG9wdGlvbnMucmVhZHksIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfUkVBRFkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1bmJ1aWxkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5idWlsZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICB0aGlzLnJlc2V0UHJldmlldygpO1xuICAgICAgICB0aGlzLmNyb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNyb3BwZXIpO1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX0hJRERFTik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVuY3JlYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5jcmVhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgdGhpcy51bmJ1aWxkKCk7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY3JvcHBlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2l6aW5nKSB7XG4gICAgICAgICAgdGhpcy5zaXppbmdJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5zaXplZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVsb2FkaW5nKSB7XG4gICAgICAgICAgdGhpcy54aHIub25hYm9ydCA9IG51bGw7XG4gICAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBubyBjb25mbGljdCBjcm9wcGVyIGNsYXNzLlxuICAgICAgICogQHJldHVybnMge0Nyb3BwZXJ9IFRoZSBjcm9wcGVyIGNsYXNzLlxuICAgICAgICovXG5cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJub0NvbmZsaWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgd2luZG93LkNyb3BwZXIgPSBBbm90aGVyQ3JvcHBlcjtcbiAgICAgICAgcmV0dXJuIENyb3BwZXI7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENoYW5nZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgbmV3IGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNldERlZmF1bHRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24oREVGQVVMVFMsIGlzUGxhaW5PYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENyb3BwZXI7XG4gIH0oKTtcblxuICBhc3NpZ24oQ3JvcHBlci5wcm90b3R5cGUsIHJlbmRlciwgcHJldmlldywgZXZlbnRzLCBoYW5kbGVycywgY2hhbmdlLCBtZXRob2RzKTtcblxuICByZXR1cm4gQ3JvcHBlcjtcblxufSkpKTtcbiIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP3QoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcImV4aWZyXCIsW1wiZXhwb3J0c1wiXSx0KTp0KChlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6ZXx8c2VsZikuZXhpZnI9e30pfSh0aGlzLChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBuKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiByKGUsdCxyKXtyZXR1cm4gdCYmbihlLnByb3RvdHlwZSx0KSxyJiZuKGUsciksZX1mdW5jdGlvbiBpKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBhKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KTt2YXIgbj1bXCJwcm90b3R5cGVcIixcIl9fcHJvdG9fX1wiLFwiY2FsbGVyXCIsXCJhcmd1bWVudHNcIixcImxlbmd0aFwiLFwibmFtZVwiXTtPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KS5mb3JFYWNoKChmdW5jdGlvbihyKXstMT09PW4uaW5kZXhPZihyKSYmZVtyXSE9PXRbcl0mJihlW3JdPXRbcl0pfSkpLHQmJnUoZSx0KX1mdW5jdGlvbiBzKGUpe3JldHVybihzPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIG8oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKGUpe3JldHVybiExfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4oZj1vKCk/UmVmbGVjdC5jb25zdHJ1Y3Q6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPVtudWxsXTtyLnB1c2guYXBwbHkocix0KTt2YXIgaT1uZXcoRnVuY3Rpb24uYmluZC5hcHBseShlLHIpKTtyZXR1cm4gbiYmdShpLG4ucHJvdG90eXBlKSxpfSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgTWFwP25ldyBNYXA6dm9pZCAwO3JldHVybihjPWZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lfHwobj1lLC0xPT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbChuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSkpcmV0dXJuIGU7dmFyIG47aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7aWYodm9pZCAwIT09dCl7aWYodC5oYXMoZSkpcmV0dXJuIHQuZ2V0KGUpO3Quc2V0KGUscil9ZnVuY3Rpb24gcigpe3JldHVybiBmKGUsYXJndW1lbnRzLHModGhpcykuY29uc3RydWN0b3IpfXJldHVybiByLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6cixlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx1KHIsZSl9KShlKX1mdW5jdGlvbiBoKGUpe2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiBlfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/aChlKTp0fWZ1bmN0aW9uIGQoZSl7dmFyIHQ9bygpO3JldHVybiBmdW5jdGlvbigpe3ZhciBuLHI9cyhlKTtpZih0KXt2YXIgaT1zKHRoaXMpLmNvbnN0cnVjdG9yO249UmVmbGVjdC5jb25zdHJ1Y3Qocixhcmd1bWVudHMsaSl9ZWxzZSBuPXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBsKHRoaXMsbil9fWZ1bmN0aW9uIHYoZSx0LG4pe3JldHVybih2PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmdldD9SZWZsZWN0LmdldDpmdW5jdGlvbihlLHQsbil7dmFyIHI9ZnVuY3Rpb24oZSx0KXtmb3IoOyFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSYmbnVsbCE9PShlPXMoZSkpOyk7cmV0dXJuIGV9KGUsdCk7aWYocil7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpO3JldHVybiBpLmdldD9pLmdldC5jYWxsKG4pOmkudmFsdWV9fSkoZSx0LG58fGUpfXZhciBwPU9iamVjdC52YWx1ZXN8fGZ1bmN0aW9uKGUpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBlKXQucHVzaChlW25dKTtyZXR1cm4gdH0seT1PYmplY3QuZW50cmllc3x8ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpdC5wdXNoKFtuLGVbbl1dKTtyZXR1cm4gdH0sZz1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLHI9MTtyPHQ7cisrKW5bci0xXT1hcmd1bWVudHNbcl07cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBuIGluIHQpZVtuXT10W25dfSkpLGV9LGs9T2JqZWN0LmZyb21FbnRyaWVzfHxmdW5jdGlvbihlKXt2YXIgdD17fTtyZXR1cm4gbShlKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lWzBdLHI9ZVsxXTt0W25dPXJ9KSksdH0sbT1BcnJheS5mcm9tfHxmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgUCl7dmFyIHQ9W107cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5wdXNoKFtuLGVdKX0pKSx0fXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKX07ZnVuY3Rpb24gYihlKXtyZXR1cm4tMSE9PXRoaXMuaW5kZXhPZihlKX1BcnJheS5wcm90b3R5cGUuaW5jbHVkZXN8fChBcnJheS5wcm90b3R5cGUuaW5jbHVkZXM9YiksU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc3x8KFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXM9YiksU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRofHwoU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoPWZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowO3JldHVybiB0aGlzLnN1YnN0cmluZyh0LHQrZS5sZW5ndGgpPT09ZX0pLFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGh8fChTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoPWZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmxlbmd0aDtyZXR1cm4gdGhpcy5zdWJzdHJpbmcodC1lLmxlbmd0aCx0KT09PWV9KTt2YXIgQT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOmdsb2JhbCx3PUEuZmV0Y2h8fGZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4scil7dmFyIGk9bmV3IFhNTEh0dHBSZXF1ZXN0O2lmKGkub3BlbihcImdldFwiLGUsITApLGkucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixpLm9uZXJyb3I9cix0LmhlYWRlcnMpZm9yKHZhciBhIGluIHQuaGVhZGVycylpLnNldFJlcXVlc3RIZWFkZXIoYSx0LmhlYWRlcnNbYV0pO2kub25sb2FkPWZ1bmN0aW9uKCl7bih7b2s6aS5zdGF0dXM+PTIwMCYmaS5zdGF0dXM8MzAwLHN0YXR1czppLnN0YXR1cyxhcnJheUJ1ZmZlcjpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5yZXNwb25zZSl9fSl9LGkuc2VuZChudWxsKX0pKX0sTz1mdW5jdGlvbihlKXt2YXIgdD1bXTtpZihPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LHtzaXplOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZW5ndGh9fSxoYXM6e3ZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybi0xIT09dGhpcy5pbmRleE9mKGUpfX0sYWRkOnt2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmhhcyhlKXx8dGhpcy5wdXNoKGUpfX0sZGVsZXRlOnt2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLmhhcyhlKSl7dmFyIHQ9dGhpcy5pbmRleE9mKGUpO3RoaXMuc3BsaWNlKHQsMSl9fX19KSxBcnJheS5pc0FycmF5KGUpKWZvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXQuYWRkKGVbbl0pO3JldHVybiB0fSxTPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUChlKX0sUD12b2lkIDAhPT1BLk1hcCYmdm9pZCAwIT09QS5NYXAucHJvdG90eXBlLmtleXM/QS5NYXA6ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4pe2lmKHQodGhpcyxlKSx0aGlzLmNsZWFyKCksbilmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl0aGlzLnNldChuW3JdWzBdLG5bcl1bMV0pfXJldHVybiByKGUsW3trZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwPXt9LHRoaXMuX2tleXM9W119fSx7a2V5Olwic2l6ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9rZXlzLmxlbmd0aH19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fbWFwW1wibWFwX1wiK2VdfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX21hcFtcIm1hcF9cIitlXT10LHRoaXMuX2tleXMuaW5kZXhPZihlKTwwJiZ0aGlzLl9rZXlzLnB1c2goZSksdGhpc319LHtrZXk6XCJoYXNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fa2V5cy5pbmRleE9mKGUpPj0wfX0se2tleTpcImRlbGV0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX2tleXMuaW5kZXhPZihlKTtyZXR1cm4hKHQ8MCkmJihkZWxldGUgdGhpcy5fbWFwW1wibWFwX1wiK2VdLHRoaXMuX2tleXMuc3BsaWNlKHQsMSksITApfX0se2tleTpcImtleXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9rZXlzLnNsaWNlKDApfX0se2tleTpcInZhbHVlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gdGhpcy5fa2V5cy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlLmdldCh0KX0pKX19LHtrZXk6XCJlbnRyaWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLl9rZXlzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuW3QsZS5nZXQodCldfSkpfX0se2tleTpcImZvckVhY2hcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248dGhpcy5fa2V5cy5sZW5ndGg7bisrKWUuY2FsbCh0LHRoaXMuX21hcFtcIm1hcF9cIit0aGlzLl9rZXlzW25dXSx0aGlzLl9rZXlzW25dLHRoaXMpfX1dKSxlfSgpLFU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpnbG9iYWwseD1cInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yLEM9eCYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQsQj0hKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWx8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBwcm9jZXNzfHwhcHJvY2Vzcy52ZXJzaW9uc3x8IXByb2Nlc3MudmVyc2lvbnMubm9kZSksaj1VLkJ1ZmZlcixfPSEhajt2YXIgVj1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZX07ZnVuY3Rpb24gSShlKXtyZXR1cm4gdm9pZCAwPT09ZXx8KGUgaW5zdGFuY2VvZiBQPzA9PT1lLnNpemU6MD09PXAoZSkuZmlsdGVyKFYpLmxlbmd0aCl9ZnVuY3Rpb24gTChlKXt2YXIgdD1uZXcgRXJyb3IoZSk7dGhyb3cgZGVsZXRlIHQuc3RhY2ssdH1mdW5jdGlvbiBUKGUpe3ZhciB0PWZ1bmN0aW9uKGUpe3ZhciB0PTA7cmV0dXJuIGUuaWZkMC5lbmFibGVkJiYodCs9MTAyNCksZS5leGlmLmVuYWJsZWQmJih0Kz0yMDQ4KSxlLm1ha2VyTm90ZSYmKHQrPTIwNDgpLGUudXNlckNvbW1lbnQmJih0Kz0xMDI0KSxlLmdwcy5lbmFibGVkJiYodCs9NTEyKSxlLmludGVyb3AuZW5hYmxlZCYmKHQrPTEwMCksZS5pZmQxLmVuYWJsZWQmJih0Kz0xMDI0KSx0KzIwNDh9KGUpO3JldHVybiBlLmpmaWYuZW5hYmxlZCYmKHQrPTUwKSxlLnhtcC5lbmFibGVkJiYodCs9MmU0KSxlLmlwdGMuZW5hYmxlZCYmKHQrPTE0ZTMpLGUuaWNjLmVuYWJsZWQmJih0Kz02ZTMpLHR9dmFyIHo9ZnVuY3Rpb24oZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlKX0sRj1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmLThcIik6dm9pZCAwO2Z1bmN0aW9uIEUoZSl7cmV0dXJuIEY/Ri5kZWNvZGUoZSk6Xz9CdWZmZXIuZnJvbShlKS50b1N0cmluZyhcInV0ZjhcIik6ZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh6KGUpKSl9dmFyIEQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowLGk9YXJndW1lbnRzLmxlbmd0aD4yP2FyZ3VtZW50c1syXTp2b2lkIDAsYT1hcmd1bWVudHMubGVuZ3RoPjM/YXJndW1lbnRzWzNdOnZvaWQgMDtpZih0KHRoaXMsZSksXCJib29sZWFuXCI9PXR5cGVvZiBhJiYodGhpcy5sZT1hKSxBcnJheS5pc0FycmF5KG4pJiYobj1uZXcgVWludDhBcnJheShuKSksMD09PW4pdGhpcy5ieXRlT2Zmc2V0PTAsdGhpcy5ieXRlTGVuZ3RoPTA7ZWxzZSBpZihuIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe3ZvaWQgMD09PWkmJihpPW4uYnl0ZUxlbmd0aC1yKTt2YXIgcz1uZXcgRGF0YVZpZXcobixyLGkpO3RoaXMuX3N3YXBEYXRhVmlldyhzKX1lbHNlIGlmKG4gaW5zdGFuY2VvZiBVaW50OEFycmF5fHxuIGluc3RhbmNlb2YgRGF0YVZpZXd8fG4gaW5zdGFuY2VvZiBlKXt2b2lkIDA9PT1pJiYoaT1uLmJ5dGVMZW5ndGgtciksKHIrPW4uYnl0ZU9mZnNldCkraT5uLmJ5dGVPZmZzZXQrbi5ieXRlTGVuZ3RoJiZMKFwiQ3JlYXRpbmcgdmlldyBvdXRzaWRlIG9mIGF2YWlsYWJsZSBtZW1vcnkgaW4gQXJyYXlCdWZmZXJcIik7dmFyIHU9bmV3IERhdGFWaWV3KG4uYnVmZmVyLHIsaSk7dGhpcy5fc3dhcERhdGFWaWV3KHUpfWVsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIG4pe3ZhciBvPW5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIobikpO3RoaXMuX3N3YXBEYXRhVmlldyhvKX1lbHNlIEwoXCJJbnZhbGlkIGlucHV0IGFyZ3VtZW50IGZvciBCdWZmZXJWaWV3OiBcIituKX1yZXR1cm4gcihlLFt7a2V5OlwiX3N3YXBBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX3N3YXBEYXRhVmlldyhuZXcgRGF0YVZpZXcoZSkpfX0se2tleTpcIl9zd2FwQnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fc3dhcERhdGFWaWV3KG5ldyBEYXRhVmlldyhlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoKSl9fSx7a2V5OlwiX3N3YXBEYXRhVmlld1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuZGF0YVZpZXc9ZSx0aGlzLmJ1ZmZlcj1lLmJ1ZmZlcix0aGlzLmJ5dGVPZmZzZXQ9ZS5ieXRlT2Zmc2V0LHRoaXMuYnl0ZUxlbmd0aD1lLmJ5dGVMZW5ndGh9fSx7a2V5OlwiX2xlbmd0aFRvRW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYnl0ZUxlbmd0aC1lfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKHQsbil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOmU7dCBpbnN0YW5jZW9mIERhdGFWaWV3fHx0IGluc3RhbmNlb2YgZT90PW5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpOnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKHQ9bmV3IFVpbnQ4QXJyYXkodCkpLHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxMKFwiQnVmZmVyVmlldy5zZXQoKTogSW52YWxpZCBkYXRhIGFyZ3VtZW50LlwiKTt2YXIgaT10aGlzLnRvVWludDgoKTtyZXR1cm4gaS5zZXQodCxuKSxuZXcgcih0aGlzLG4sdC5ieXRlTGVuZ3RoKX19LHtrZXk6XCJzdWJhcnJheVwiLHZhbHVlOmZ1bmN0aW9uKHQsbil7cmV0dXJuIG5ldyBlKHRoaXMsdCxuPW58fHRoaXMuX2xlbmd0aFRvRW5kKHQpKX19LHtrZXk6XCJ0b1VpbnQ4XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsdGhpcy5ieXRlT2Zmc2V0LHRoaXMuYnl0ZUxlbmd0aCl9fSx7a2V5OlwiZ2V0VWludDhBcnJheVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLHRoaXMuYnl0ZU9mZnNldCtlLHQpfX0se2tleTpcImdldFN0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjAsdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5ieXRlTGVuZ3RoLG49dGhpcy5nZXRVaW50OEFycmF5KGUsdCk7cmV0dXJuIEUobil9fSx7a2V5OlwiZ2V0TGF0aW4xU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmJ5dGVMZW5ndGgsbj10aGlzLmdldFVpbnQ4QXJyYXkoZSx0KTtyZXR1cm4geihuKX19LHtrZXk6XCJnZXRVbmljb2RlU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjAsdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5ieXRlTGVuZ3RoLG49W10scj0wO3I8dCYmZStyPHRoaXMuYnl0ZUxlbmd0aDtyKz0yKW4ucHVzaCh0aGlzLmdldFVpbnQxNihlK3IpKTtyZXR1cm4geihuKX19LHtrZXk6XCJnZXRJbnQ4XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0SW50OChlKX19LHtrZXk6XCJnZXRVaW50OFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQ4KGUpfX0se2tleTpcImdldEludDE2XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0SW50MTYoZSx0KX19LHtrZXk6XCJnZXRJbnQzMlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmxlO3JldHVybiB0aGlzLmRhdGFWaWV3LmdldEludDMyKGUsdCl9fSx7a2V5OlwiZ2V0VWludDE2XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDE2KGUsdCl9fSx7a2V5OlwiZ2V0VWludDMyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDMyKGUsdCl9fSx7a2V5OlwiZ2V0RmxvYXQzMlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmxlO3JldHVybiB0aGlzLmRhdGFWaWV3LmdldEZsb2F0MzIoZSx0KX19LHtrZXk6XCJnZXRGbG9hdDY0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQ2NChlLHQpfX0se2tleTpcImdldEZsb2F0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQzMihlLHQpfX0se2tleTpcImdldERvdWJsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmxlO3JldHVybiB0aGlzLmRhdGFWaWV3LmdldEZsb2F0NjQoZSx0KX19LHtrZXk6XCJnZXRVaW50Qnl0ZXNcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7c3dpdGNoKHQpe2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRVaW50OChlLG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRVaW50MTYoZSxuKTtjYXNlIDQ6cmV0dXJuIHRoaXMuZ2V0VWludDMyKGUsbik7Y2FzZSA4OnJldHVybiB0aGlzLmdldFVpbnQ2NCYmdGhpcy5nZXRVaW50NjQoZSxuKX19fSx7a2V5OlwiZ2V0VWludFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtzd2l0Y2godCl7Y2FzZSA4OnJldHVybiB0aGlzLmdldFVpbnQ4KGUsbik7Y2FzZSAxNjpyZXR1cm4gdGhpcy5nZXRVaW50MTYoZSxuKTtjYXNlIDMyOnJldHVybiB0aGlzLmdldFVpbnQzMihlLG4pO2Nhc2UgNjQ6cmV0dXJuIHRoaXMuZ2V0VWludDY0JiZ0aGlzLmdldFVpbnQ2NChlLG4pfX19LHtrZXk6XCJ0b1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRhdGFWaWV3LnRvU3RyaW5nKGUsdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKX19LHtrZXk6XCJlbnN1cmVDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKCl7fX1dLFt7a2V5OlwiZnJvbVwiLHZhbHVlOmZ1bmN0aW9uKHQsbil7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzJiZ0LmxlPT09bj90Om5ldyBlKHQsdm9pZCAwLHZvaWQgMCxuKX19XSksZX0oKTtmdW5jdGlvbiBSKGUsdCl7TChcIlwiLmNvbmNhdChlLFwiICdcIikuY29uY2F0KHQsXCInIHdhcyBub3QgbG9hZGVkLCB0cnkgdXNpbmcgZnVsbCBidWlsZCBvZiBleGlmci5cIikpfXZhciBOPWZ1bmN0aW9uKGUpe2EoaSxlKTt2YXIgbj1kKGkpO2Z1bmN0aW9uIGkoZSl7dmFyIHI7cmV0dXJuIHQodGhpcyxpKSwocj1uLmNhbGwodGhpcykpLmtpbmQ9ZSxyfXJldHVybiByKGksW3trZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmhhcyhlKXx8Uih0aGlzLmtpbmQsZSksdCYmKGUgaW4gdHx8ZnVuY3Rpb24oZSx0KXtMKFwiVW5rbm93biBcIi5jb25jYXQoZSxcIiAnXCIpLmNvbmNhdCh0LFwiJy5cIikpfSh0aGlzLmtpbmQsZSksdFtlXS5lbmFibGVkfHxSKHRoaXMua2luZCxlKSksdihzKGkucHJvdG90eXBlKSxcImdldFwiLHRoaXMpLmNhbGwodGhpcyxlKX19LHtrZXk6XCJrZXlMaXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLmtleXMoKSl9fV0pLGl9KGMoUCkpLE09bmV3IE4oXCJmaWxlIHBhcnNlclwiKSxXPW5ldyBOKFwic2VnbWVudCBwYXJzZXJcIiksSz1uZXcgTihcImZpbGUgcmVhZGVyXCIpO2Z1bmN0aW9uIEgoZSl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbl09YXJndW1lbnRzW25dO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuYXBwbHkodGhpcyx0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19ZnVuY3Rpb24gWChlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX12YXIgWT1IKChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsbil7dmFyIHI9bmV3IEZpbGVSZWFkZXI7ci5vbmxvYWRlbmQ9ZnVuY3Rpb24oKXtyZXR1cm4gdChyLnJlc3VsdHx8bmV3IEFycmF5QnVmZmVyKX0sci5vbmVycm9yPW4sci5yZWFkQXNBcnJheUJ1ZmZlcihlKX0pKX0pKSxHPUgoKGZ1bmN0aW9uKGUpe3JldHVybiB3KGUpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSl9KSksSj1IKChmdW5jdGlvbihlLHQpe3JldHVybiBYKHQoZSksKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgRChlKX0pKX0pKSxxPUgoKGZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1uZXcoSy5nZXQobikpKGUsdCk7cmV0dXJuIFgoci5yZWFkKCksKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSl9KSksUT1IKChmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gSy5oYXMobik/cShlLHQsbik6cj9KKGUscik6KEwoXCJQYXJzZXIgXCIuY29uY2F0KG4sXCIgaXMgbm90IGxvYWRlZFwiKSksWCgpKX0pKSxaPVwiSW52YWxpZCBpbnB1dCBhcmd1bWVudFwiO2Z1bmN0aW9uICQoZSx0KXtyZXR1cm4obj1lKS5zdGFydHNXaXRoKFwiZGF0YTpcIil8fG4ubGVuZ3RoPjFlND9xKGUsdCxcImJhc2U2NFwiKTp4P1EoZSx0LFwidXJsXCIsRyk6Qj9xKGUsdCxcImZzXCIpOnZvaWQgTChaKTt2YXIgbn12YXIgZWU9ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiB0KHRoaXMsaSksbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHIoaSxbe2tleTpcInRhZ0tleXNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGxLZXlzfHwodGhpcy5hbGxLZXlzPW0odGhpcy5rZXlzKCkpKSx0aGlzLmFsbEtleXN9fSx7a2V5OlwidGFnVmFsdWVzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWxsVmFsdWVzfHwodGhpcy5hbGxWYWx1ZXM9bSh0aGlzLnZhbHVlcygpKSksdGhpcy5hbGxWYWx1ZXN9fV0pLGl9KGMoUCkpO2Z1bmN0aW9uIHRlKGUsdCxuKXt2YXIgcj1uZXcgZWUsaT1uO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXt2YXIgcz1pW2FdLHU9c1swXSxvPXNbMV07ci5zZXQodSxvKX1pZihBcnJheS5pc0FycmF5KHQpKXt2YXIgZj10O0FycmF5LmlzQXJyYXkoZil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBmLmVudHJpZXMmJihmPWYuZW50cmllcygpKSxmPW0oZikpO2Zvcih2YXIgYz0wO2M8Zi5sZW5ndGg7YysrKXt2YXIgaD1mW2NdO2Uuc2V0KGgscil9fWVsc2UgZS5zZXQodCxyKTtyZXR1cm4gcn1mdW5jdGlvbiBuZShlLHQsbil7dmFyIHIsaT1lLmdldCh0KSxhPW47QXJyYXkuaXNBcnJheShhKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGEuZW50cmllcyYmKGE9YS5lbnRyaWVzKCkpLGE9bShhKSk7Zm9yKHZhciBzPTA7czxhLmxlbmd0aDtzKyspcj1hW3NdLGkuc2V0KHJbMF0sclsxXSl9dmFyIHJlPVMoKSxpZT1TKCksYWU9UygpLHNlPTM3NTAwLHVlPTM3NTEwLG9lPTMzNzIzLGZlPTM0Njc1LGNlPTM0NjY1LGhlPTM0ODUzLGxlPTQwOTY1LGRlPVtcImNodW5rZWRcIixcImZpcnN0Q2h1bmtTaXplXCIsXCJmaXJzdENodW5rU2l6ZU5vZGVcIixcImZpcnN0Q2h1bmtTaXplQnJvd3NlclwiLFwiY2h1bmtTaXplXCIsXCJjaHVua0xpbWl0XCJdLHZlPVtcImpmaWZcIixcInhtcFwiLFwiaWNjXCIsXCJpcHRjXCIsXCJpaGRyXCJdLHBlPVtcInRpZmZcIl0uY29uY2F0KHZlKSx5ZT1bXCJpZmQwXCIsXCJpZmQxXCIsXCJleGlmXCIsXCJncHNcIixcImludGVyb3BcIl0sZ2U9W10uY29uY2F0KHBlLHllKSxrZT1bXCJtYWtlck5vdGVcIixcInVzZXJDb21tZW50XCJdLG1lPVtcInRyYW5zbGF0ZUtleXNcIixcInRyYW5zbGF0ZVZhbHVlc1wiLFwicmV2aXZlVmFsdWVzXCIsXCJtdWx0aVNlZ21lbnRcIl0sYmU9W10uY29uY2F0KG1lLFtcInNhbml0aXplXCIsXCJtZXJnZU91dHB1dFwiLFwic2lsZW50RXJyb3JzXCJdKSxBZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0KHRoaXMsZSl9cmV0dXJuIHIoZSxbe2tleTpcInRyYW5zbGF0ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zbGF0ZUtleXN8fHRoaXMudHJhbnNsYXRlVmFsdWVzfHx0aGlzLnJldml2ZVZhbHVlc319XSksZX0oKSx3ZT1mdW5jdGlvbihlKXthKHMsZSk7dmFyIG49ZChzKTtmdW5jdGlvbiBzKGUscixhLHUpe3ZhciBvO2lmKHQodGhpcyxzKSxpKGgobz1uLmNhbGwodGhpcykpLFwiZW5hYmxlZFwiLCExKSxpKGgobyksXCJza2lwXCIsTygpKSxpKGgobyksXCJwaWNrXCIsTygpKSxpKGgobyksXCJkZXBzXCIsTygpKSxpKGgobyksXCJ0cmFuc2xhdGVLZXlzXCIsITEpLGkoaChvKSxcInRyYW5zbGF0ZVZhbHVlc1wiLCExKSxpKGgobyksXCJyZXZpdmVWYWx1ZXNcIiwhMSksby5rZXk9ZSxvLmVuYWJsZWQ9cixvLnBhcnNlPW8uZW5hYmxlZCxvLmFwcGx5SW5oZXJpdGFibGVzKHUpLG8uY2FuQmVGaWx0ZXJlZD15ZS5pbmNsdWRlcyhlKSxvLmNhbkJlRmlsdGVyZWQmJihvLmRpY3Q9cmUuZ2V0KGUpKSx2b2lkIDAhPT1hKWlmKEFycmF5LmlzQXJyYXkoYSkpby5wYXJzZT1vLmVuYWJsZWQ9ITAsby5jYW5CZUZpbHRlcmVkJiZhLmxlbmd0aD4wJiZvLnRyYW5zbGF0ZVRhZ1NldChhLG8ucGljayk7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgYSl7aWYoby5lbmFibGVkPSEwLG8ucGFyc2U9ITEhPT1hLnBhcnNlLG8uY2FuQmVGaWx0ZXJlZCl7dmFyIGY9YS5waWNrLGM9YS5za2lwO2YmJmYubGVuZ3RoPjAmJm8udHJhbnNsYXRlVGFnU2V0KGYsby5waWNrKSxjJiZjLmxlbmd0aD4wJiZvLnRyYW5zbGF0ZVRhZ1NldChjLG8uc2tpcCl9by5hcHBseUluaGVyaXRhYmxlcyhhKX1lbHNlITA9PT1hfHwhMT09PWE/by5wYXJzZT1vLmVuYWJsZWQ9YTpMKFwiSW52YWxpZCBvcHRpb25zIGFyZ3VtZW50OiBcIi5jb25jYXQoYSkpO3JldHVybiBvfXJldHVybiByKHMsW3trZXk6XCJuZWVkZWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfHx0aGlzLmRlcHMuc2l6ZT4wfX0se2tleTpcImFwcGx5SW5oZXJpdGFibGVzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPW1lO0FycmF5LmlzQXJyYXkocil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmVudHJpZXMmJihyPXIuZW50cmllcygpKSxyPW0ocikpO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXZvaWQgMCE9PShuPWVbdD1yW2ldXSkmJih0aGlzW3RdPW4pfX0se2tleTpcInRyYW5zbGF0ZVRhZ1NldFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodGhpcy5kaWN0KXt2YXIgbixyLGk9dGhpcy5kaWN0LGE9aS50YWdLZXlzLHM9aS50YWdWYWx1ZXMsdT1lO0FycmF5LmlzQXJyYXkodSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LmVudHJpZXMmJih1PXUuZW50cmllcygpKSx1PW0odSkpO2Zvcih2YXIgbz0wO288dS5sZW5ndGg7bysrKVwic3RyaW5nXCI9PXR5cGVvZihuPXVbb10pPygtMT09PShyPXMuaW5kZXhPZihuKSkmJihyPWEuaW5kZXhPZihOdW1iZXIobikpKSwtMSE9PXImJnQuYWRkKE51bWJlcihhW3JdKSkpOnQuYWRkKG4pfWVsc2V7dmFyIGY9ZTtBcnJheS5pc0FycmF5KGYpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgZi5lbnRyaWVzJiYoZj1mLmVudHJpZXMoKSksZj1tKGYpKTtmb3IodmFyIGM9MDtjPGYubGVuZ3RoO2MrKyl7dmFyIGg9ZltjXTt0LmFkZChoKX19fX0se2tleTpcImZpbmFsaXplRmlsdGVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7IXRoaXMuZW5hYmxlZCYmdGhpcy5kZXBzLnNpemU+MD8odGhpcy5lbmFibGVkPSEwLENlKHRoaXMucGljayx0aGlzLmRlcHMpKTp0aGlzLmVuYWJsZWQmJnRoaXMucGljay5zaXplPjAmJkNlKHRoaXMucGljayx0aGlzLmRlcHMpfX1dKSxzfShBZSksT2U9e2pmaWY6ITEsdGlmZjohMCx4bXA6ITEsaWNjOiExLGlwdGM6ITEsaWZkMDohMCxpZmQxOiExLGV4aWY6ITAsZ3BzOiEwLGludGVyb3A6ITEsaWhkcjp2b2lkIDAsbWFrZXJOb3RlOiExLHVzZXJDb21tZW50OiExLG11bHRpU2VnbWVudDohMSxza2lwOltdLHBpY2s6W10sdHJhbnNsYXRlS2V5czohMCx0cmFuc2xhdGVWYWx1ZXM6ITAscmV2aXZlVmFsdWVzOiEwLHNhbml0aXplOiEwLG1lcmdlT3V0cHV0OiEwLHNpbGVudEVycm9yczohMCxjaHVua2VkOiEwLGZpcnN0Q2h1bmtTaXplOnZvaWQgMCxmaXJzdENodW5rU2l6ZU5vZGU6NTEyLGZpcnN0Q2h1bmtTaXplQnJvd3Nlcjo2NTUzNixjaHVua1NpemU6NjU1MzYsY2h1bmtMaW1pdDo1fSxTZT1TKCksUGU9ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaShlKXt2YXIgcjtyZXR1cm4gdCh0aGlzLGkpLHI9bi5jYWxsKHRoaXMpLCEwPT09ZT9yLnNldHVwRnJvbVRydWUoKTp2b2lkIDA9PT1lP3Iuc2V0dXBGcm9tVW5kZWZpbmVkKCk6QXJyYXkuaXNBcnJheShlKT9yLnNldHVwRnJvbUFycmF5KGUpOlwib2JqZWN0XCI9PXR5cGVvZiBlP3Iuc2V0dXBGcm9tT2JqZWN0KGUpOkwoXCJJbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQgXCIuY29uY2F0KGUpKSx2b2lkIDA9PT1yLmZpcnN0Q2h1bmtTaXplJiYoci5maXJzdENodW5rU2l6ZT14P3IuZmlyc3RDaHVua1NpemVCcm93c2VyOnIuZmlyc3RDaHVua1NpemVOb2RlKSxyLm1lcmdlT3V0cHV0JiYoci5pZmQxLmVuYWJsZWQ9ITEpLHIuZmlsdGVyTmVzdGVkU2VnbWVudFRhZ3MoKSxyLnRyYXZlcnNlVGlmZkRlcGVuZGVuY3lUcmVlKCksci5jaGVja0xvYWRlZFBsdWdpbnMoKSxyfXJldHVybiByKGksW3trZXk6XCJzZXR1cEZyb21VbmRlZmluZWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQ9ZGU7QXJyYXkuaXNBcnJheSh0KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZW50cmllcyYmKHQ9dC5lbnRyaWVzKCkpLHQ9bSh0KSk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpc1tlPXRbbl1dPU9lW2VdO3ZhciByPWJlO0FycmF5LmlzQXJyYXkocil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmVudHJpZXMmJihyPXIuZW50cmllcygpKSxyPW0ocikpO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXRoaXNbZT1yW2ldXT1PZVtlXTt2YXIgYT1rZTtBcnJheS5pc0FycmF5KGEpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYS5lbnRyaWVzJiYoYT1hLmVudHJpZXMoKSksYT1tKGEpKTtmb3IodmFyIHM9MDtzPGEubGVuZ3RoO3MrKyl0aGlzW2U9YVtzXV09T2VbZV07dmFyIHU9Z2U7QXJyYXkuaXNBcnJheSh1KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHUuZW50cmllcyYmKHU9dS5lbnRyaWVzKCkpLHU9bSh1KSk7Zm9yKHZhciBvPTA7bzx1Lmxlbmd0aDtvKyspdGhpc1tlPXVbb11dPW5ldyB3ZShlLE9lW2VdLHZvaWQgMCx0aGlzKX19LHtrZXk6XCJzZXR1cEZyb21UcnVlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PWRlO0FycmF5LmlzQXJyYXkodCl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmVudHJpZXMmJih0PXQuZW50cmllcygpKSx0PW0odCkpO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXRoaXNbZT10W25dXT1PZVtlXTt2YXIgcj1iZTtBcnJheS5pc0FycmF5KHIpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygci5lbnRyaWVzJiYocj1yLmVudHJpZXMoKSkscj1tKHIpKTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl0aGlzW2U9cltpXV09T2VbZV07dmFyIGE9a2U7QXJyYXkuaXNBcnJheShhKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGEuZW50cmllcyYmKGE9YS5lbnRyaWVzKCkpLGE9bShhKSk7Zm9yKHZhciBzPTA7czxhLmxlbmd0aDtzKyspdGhpc1tlPWFbc11dPSEwO3ZhciB1PWdlO0FycmF5LmlzQXJyYXkodSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LmVudHJpZXMmJih1PXUuZW50cmllcygpKSx1PW0odSkpO2Zvcih2YXIgbz0wO288dS5sZW5ndGg7bysrKXRoaXNbZT11W29dXT1uZXcgd2UoZSwhMCx2b2lkIDAsdGhpcyl9fSx7a2V5Olwic2V0dXBGcm9tQXJyYXlcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdCxuPWRlO0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXRoaXNbdD1uW3JdXT1PZVt0XTt2YXIgaT1iZTtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl0aGlzW3Q9aVthXV09T2VbdF07dmFyIHM9a2U7QXJyYXkuaXNBcnJheShzKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHMuZW50cmllcyYmKHM9cy5lbnRyaWVzKCkpLHM9bShzKSk7Zm9yKHZhciB1PTA7dTxzLmxlbmd0aDt1KyspdGhpc1t0PXNbdV1dPU9lW3RdO3ZhciBvPWdlO0FycmF5LmlzQXJyYXkobyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLmVudHJpZXMmJihvPW8uZW50cmllcygpKSxvPW0obykpO2Zvcih2YXIgZj0wO2Y8by5sZW5ndGg7ZisrKXRoaXNbdD1vW2ZdXT1uZXcgd2UodCwhMSx2b2lkIDAsdGhpcyk7dGhpcy5zZXR1cEdsb2JhbEZpbHRlcnMoZSx2b2lkIDAseWUpfX0se2tleTpcInNldHVwRnJvbU9iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0O3llLmlmZDA9eWUuaWZkMHx8eWUuaW1hZ2UseWUuaWZkMT15ZS5pZmQxfHx5ZS50aHVtYm5haWwsZyh0aGlzLGUpO3ZhciBuPWRlO0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXRoaXNbdD1uW3JdXT14ZShlW3RdLE9lW3RdKTt2YXIgaT1iZTtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl0aGlzW3Q9aVthXV09eGUoZVt0XSxPZVt0XSk7dmFyIHM9a2U7QXJyYXkuaXNBcnJheShzKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHMuZW50cmllcyYmKHM9cy5lbnRyaWVzKCkpLHM9bShzKSk7Zm9yKHZhciB1PTA7dTxzLmxlbmd0aDt1KyspdGhpc1t0PXNbdV1dPXhlKGVbdF0sT2VbdF0pO3ZhciBvPXBlO0FycmF5LmlzQXJyYXkobyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLmVudHJpZXMmJihvPW8uZW50cmllcygpKSxvPW0obykpO2Zvcih2YXIgZj0wO2Y8by5sZW5ndGg7ZisrKXRoaXNbdD1vW2ZdXT1uZXcgd2UodCxPZVt0XSxlW3RdLHRoaXMpO3ZhciBjPXllO0FycmF5LmlzQXJyYXkoYyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBjLmVudHJpZXMmJihjPWMuZW50cmllcygpKSxjPW0oYykpO2Zvcih2YXIgaD0wO2g8Yy5sZW5ndGg7aCsrKXRoaXNbdD1jW2hdXT1uZXcgd2UodCxPZVt0XSxlW3RdLHRoaXMudGlmZik7dGhpcy5zZXR1cEdsb2JhbEZpbHRlcnMoZS5waWNrLGUuc2tpcCx5ZSxnZSksITA9PT1lLnRpZmY/dGhpcy5iYXRjaEVuYWJsZVdpdGhCb29sKHllLCEwKTohMT09PWUudGlmZj90aGlzLmJhdGNoRW5hYmxlV2l0aFVzZXJWYWx1ZSh5ZSxlKTpBcnJheS5pc0FycmF5KGUudGlmZik/dGhpcy5zZXR1cEdsb2JhbEZpbHRlcnMoZS50aWZmLHZvaWQgMCx5ZSk6XCJvYmplY3RcIj09dHlwZW9mIGUudGlmZiYmdGhpcy5zZXR1cEdsb2JhbEZpbHRlcnMoZS50aWZmLnBpY2ssZS50aWZmLnNraXAseWUpfX0se2tleTpcImJhdGNoRW5hYmxlV2l0aEJvb2xcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWU7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3RoaXNbbltyXV0uZW5hYmxlZD10fX19LHtrZXk6XCJiYXRjaEVuYWJsZVdpdGhVc2VyVmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWU7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl0sYT10W2ldO3RoaXNbaV0uZW5hYmxlZD0hMSE9PWEmJnZvaWQgMCE9PWF9fX0se2tleTpcInNldHVwR2xvYmFsRmlsdGVyc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bjtpZihlJiZlLmxlbmd0aCl7dmFyIGk9cjtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl7dmFyIHM9aVthXTt0aGlzW3NdLmVuYWJsZWQ9ITF9dmFyIHU9VWUoZSxuKSxvPXU7QXJyYXkuaXNBcnJheShvKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG8uZW50cmllcyYmKG89by5lbnRyaWVzKCkpLG89bShvKSk7Zm9yKHZhciBmPTA7ZjxvLmxlbmd0aDtmKyspe3ZhciBjPW9bZl0saD1jWzBdLGw9Y1sxXTtDZSh0aGlzW2hdLnBpY2ssbCksdGhpc1toXS5lbmFibGVkPSEwfX1lbHNlIGlmKHQmJnQubGVuZ3RoKXt2YXIgZD1VZSh0LG4pLHY9ZDtBcnJheS5pc0FycmF5KHYpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygdi5lbnRyaWVzJiYodj12LmVudHJpZXMoKSksdj1tKHYpKTtmb3IodmFyIHA9MDtwPHYubGVuZ3RoO3ArKyl7dmFyIHk9dltwXSxnPXlbMF0saz15WzFdO0NlKHRoaXNbZ10uc2tpcCxrKX19fX0se2tleTpcImZpbHRlck5lc3RlZFNlZ21lbnRUYWdzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmlmZDAsdD10aGlzLmV4aWYsbj10aGlzLnhtcCxyPXRoaXMuaXB0YyxpPXRoaXMuaWNjO3RoaXMubWFrZXJOb3RlP3QuZGVwcy5hZGQoc2UpOnQuc2tpcC5hZGQoc2UpLHRoaXMudXNlckNvbW1lbnQ/dC5kZXBzLmFkZCh1ZSk6dC5za2lwLmFkZCh1ZSksbi5lbmFibGVkfHxlLnNraXAuYWRkKDcwMCksci5lbmFibGVkfHxlLnNraXAuYWRkKG9lKSxpLmVuYWJsZWR8fGUuc2tpcC5hZGQoZmUpfX0se2tleTpcInRyYXZlcnNlVGlmZkRlcGVuZGVuY3lUcmVlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9dGhpcy5pZmQwLG49dGhpcy5leGlmLHI9dGhpcy5ncHM7dGhpcy5pbnRlcm9wLm5lZWRlZCYmKG4uZGVwcy5hZGQobGUpLHQuZGVwcy5hZGQobGUpKSxuLm5lZWRlZCYmdC5kZXBzLmFkZChjZSksci5uZWVkZWQmJnQuZGVwcy5hZGQoaGUpLHRoaXMudGlmZi5lbmFibGVkPXllLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiEwPT09ZVt0XS5lbmFibGVkfSkpfHx0aGlzLm1ha2VyTm90ZXx8dGhpcy51c2VyQ29tbWVudDt2YXIgaT15ZTtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl7dGhpc1tpW2FdXS5maW5hbGl6ZUZpbHRlcnMoKX19fSx7a2V5Olwib25seVRpZmZcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiF2ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLmVuYWJsZWR9KSkuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuITA9PT1lfSkpJiZ0aGlzLnRpZmYuZW5hYmxlZH19LHtrZXk6XCJjaGVja0xvYWRlZFBsdWdpbnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXBlO0FycmF5LmlzQXJyYXkoZSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmVudHJpZXMmJihlPWUuZW50cmllcygpKSxlPW0oZSkpO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXt2YXIgbj1lW3RdO3RoaXNbbl0uZW5hYmxlZCYmIVcuaGFzKG4pJiZSKFwic2VnbWVudCBwYXJzZXJcIixuKX19fV0sW3trZXk6XCJ1c2VDYWNoZWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1TZS5nZXQoZSk7cmV0dXJuIHZvaWQgMCE9PXR8fCh0PW5ldyB0aGlzKGUpLFNlLnNldChlLHQpKSx0fX1dKSxpfShBZSk7ZnVuY3Rpb24gVWUoZSx0KXt2YXIgbixyLGksYT1bXSxzPXQ7QXJyYXkuaXNBcnJheShzKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHMuZW50cmllcyYmKHM9cy5lbnRyaWVzKCkpLHM9bShzKSk7Zm9yKHZhciB1PTA7dTxzLmxlbmd0aDt1Kyspe3I9c1t1XSxuPVtdO3ZhciBvPXJlLmdldChyKTtBcnJheS5pc0FycmF5KG8pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygby5lbnRyaWVzJiYobz1vLmVudHJpZXMoKSksbz1tKG8pKTtmb3IodmFyIGY9MDtmPG8ubGVuZ3RoO2YrKylpPW9bZl0sKGUuaW5jbHVkZXMoaVswXSl8fGUuaW5jbHVkZXMoaVsxXSkpJiZuLnB1c2goaVswXSk7bi5sZW5ndGgmJmEucHVzaChbcixuXSl9cmV0dXJuIGF9ZnVuY3Rpb24geGUoZSx0KXtyZXR1cm4gdm9pZCAwIT09ZT9lOnZvaWQgMCE9PXQ/dDp2b2lkIDB9ZnVuY3Rpb24gQ2UoZSx0KXt2YXIgbj10O0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1uW3JdO2UuYWRkKGkpfX1mdW5jdGlvbiBCZShlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX1mdW5jdGlvbiBqZSgpe31mdW5jdGlvbiBfZShlLHQpe2lmKCF0KXJldHVybiBlJiZlLnRoZW4/ZS50aGVuKGplKTpQcm9taXNlLnJlc29sdmUoKX1mdW5jdGlvbiBWZShlLHQpe3ZhciBuPWUoKTtyZXR1cm4gbiYmbi50aGVuP24udGhlbih0KTp0KG4pfWkoUGUsXCJkZWZhdWx0XCIsT2UpO3ZhciBJZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobil7dCh0aGlzLGUpLGkodGhpcyxcInBhcnNlcnNcIix7fSksdGhpcy5vcHRpb25zPVBlLnVzZUNhY2hlZChuKX1yZXR1cm4gcihlLFt7a2V5Olwic2V0dXBcIix2YWx1ZTpmdW5jdGlvbigpe2lmKCF0aGlzLmZpbGVQYXJzZXIpe3ZhciBlPXRoaXMuZmlsZSx0PWUuZ2V0VWludDE2KDApLG49TTtBcnJheS5pc0FycmF5KG4pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygbi5lbnRyaWVzJiYobj1uLmVudHJpZXMoKSksbj1tKG4pKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxhPWlbMF0scz1pWzFdO2lmKHMuY2FuSGFuZGxlKGUsdCkpcmV0dXJuIHRoaXMuZmlsZVBhcnNlcj1uZXcgcyh0aGlzLm9wdGlvbnMsdGhpcy5maWxlLHRoaXMucGFyc2VycyksZVthXT0hMH1MKFwiVW5rbm93biBmaWxlIGZvcm1hdFwiKX19fSx7a2V5OlwicmVhZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RyeXt2YXIgdD10aGlzO3JldHVybiBCZShmdW5jdGlvbihlLHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlPyQoZSx0KTp4JiYhQyYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ/JChlLnNyYyx0KTplIGluc3RhbmNlb2YgVWludDhBcnJheXx8ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxlIGluc3RhbmNlb2YgRGF0YVZpZXc/bmV3IEQoZSk6eCYmZSBpbnN0YW5jZW9mIEJsb2I/UShlLHQsXCJibG9iXCIsWSk6dm9pZCBMKFopfShlLHQub3B0aW9ucyksKGZ1bmN0aW9uKGUpe3QuZmlsZT1lfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicGFyc2VcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2Uuc2V0dXAoKTt2YXIgdD17fSxuPVtdO3JldHVybiBWZSgoZnVuY3Rpb24oKXtyZXR1cm4gZS5vcHRpb25zLnNpbGVudEVycm9ycz9CZShlLmRvUGFyc2UodCxuKS5jYXRjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIG4ucHVzaChlKX0pKSwoZnVuY3Rpb24oKXtuLnB1c2guYXBwbHkobixlLmZpbGVQYXJzZXIuZXJyb3JzKX0pKTpfZShlLmRvUGFyc2UodCxuKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gZS5maWxlLmNsb3NlJiZlLmZpbGUuY2xvc2UoKSxlLm9wdGlvbnMuc2lsZW50RXJyb3JzJiZuLmxlbmd0aD4wJiYodC5lcnJvcnM9biksSShyPXQpP3ZvaWQgMDpyO3ZhciByfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiZG9QYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPXRoaXM7cmV0dXJuIEJlKG4uZmlsZVBhcnNlci5wYXJzZSgpLChmdW5jdGlvbigpe3ZhciByLGk9cChuLnBhcnNlcnMpLm1hcCgocj1mdW5jdGlvbih0KXtyZXR1cm4gQmUodC5wYXJzZSgpLChmdW5jdGlvbihuKXt0LmFzc2lnblRvT3V0cHV0KGUsbil9KSl9LGZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIuYXBwbHkodGhpcyxlKSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0pKTtpZihuLm9wdGlvbnMuc2lsZW50RXJyb3JzKXt2YXIgYT1mdW5jdGlvbihlKXtyZXR1cm4gdC5wdXNoKGUpfTtpPWkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5jYXRjaChhKX0pKX1yZXR1cm4gX2UoUHJvbWlzZS5hbGwoaSkpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiZXh0cmFjdFRodW1ibmFpbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7ZS5zZXR1cCgpO3ZhciB0LG49ZS5vcHRpb25zLHI9ZS5maWxlLGk9Vy5nZXQoXCJ0aWZmXCIsbik7cmV0dXJuIFZlKChmdW5jdGlvbigpe2lmKCFyLnRpZmYpcmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWUoKTtpZih0JiZ0LnRoZW4pcmV0dXJuIHQudGhlbihqZSl9KChmdW5jdGlvbigpe2lmKHIuanBlZylyZXR1cm4gQmUoZS5maWxlUGFyc2VyLmdldE9yRmluZFNlZ21lbnQoXCJ0aWZmXCIpLChmdW5jdGlvbihlKXt0PWV9KSl9KSk7dD17c3RhcnQ6MCx0eXBlOlwidGlmZlwifX0pLChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PXQpcmV0dXJuIEJlKGUuZmlsZVBhcnNlci5lbnN1cmVTZWdtZW50Q2h1bmsodCksKGZ1bmN0aW9uKHQpe3JldHVybiBCZSgoZS5wYXJzZXJzLnRpZmY9bmV3IGkodCxuLHIpKS5leHRyYWN0VGh1bWJuYWlsKCksKGZ1bmN0aW9uKGUpe3JldHVybiByLmNsb3NlJiZyLmNsb3NlKCksZX0pKX0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1dKSxlfSgpO3ZhciBMZSxUZT0oTGU9ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksYT1uZXcgSWUodCk7cmV0dXJuIG49YS5yZWFkKGUpLHI9ZnVuY3Rpb24oKXtyZXR1cm4gYS5wYXJzZSgpfSxpP3I/cihuKTpuOihuJiZuLnRoZW58fChuPVByb21pc2UucmVzb2x2ZShuKSkscj9uLnRoZW4ocik6bil9LGZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKExlLmFwcGx5KHRoaXMsZSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19KSx6ZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxwYXJzZTpUZSxFeGlmcjpJZSxmaWxlUGFyc2VyczpNLHNlZ21lbnRQYXJzZXJzOlcsZmlsZVJlYWRlcnM6Syx0YWdLZXlzOnJlLHRhZ1ZhbHVlczppZSx0YWdSZXZpdmVyczphZSxjcmVhdGVEaWN0aW9uYXJ5OnRlLGV4dGVuZERpY3Rpb25hcnk6bmUsZmV0Y2hVcmxBc0FycmF5QnVmZmVyOkcscmVhZEJsb2JBc0FycmF5QnVmZmVyOlksY2h1bmtlZFByb3BzOmRlLG90aGVyU2VnbWVudHM6dmUsc2VnbWVudHM6cGUsdGlmZkJsb2Nrczp5ZSxzZWdtZW50c0FuZEJsb2NrczpnZSx0aWZmRXh0cmFjdGFibGVzOmtlLGluaGVyaXRhYmxlczptZSxhbGxGb3JtYXR0ZXJzOmJlLE9wdGlvbnM6UGV9KTtmdW5jdGlvbiBGZSgpe312YXIgRWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4scixhKXt2YXIgcz10aGlzO3QodGhpcyxlKSxpKHRoaXMsXCJlcnJvcnNcIixbXSksaSh0aGlzLFwiZW5zdXJlU2VnbWVudENodW5rXCIsZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbl09YXJndW1lbnRzW25dO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuYXBwbHkodGhpcyx0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19KChmdW5jdGlvbihlKXt2YXIgdCxuLHIsaT1lLnN0YXJ0LGE9ZS5zaXplfHw2NTUzNjtyZXR1cm4gdD1mdW5jdGlvbigpe2lmKHMuZmlsZS5jaHVua2VkKXJldHVybiBmdW5jdGlvbihlKXt2YXIgdD1lKCk7aWYodCYmdC50aGVuKXJldHVybiB0LnRoZW4oRmUpfSgoZnVuY3Rpb24oKXtpZighcy5maWxlLmF2YWlsYWJsZShpLGEpKXJldHVybiBmdW5jdGlvbihlKXtpZihlJiZlLnRoZW4pcmV0dXJuIGUudGhlbihGZSl9KGZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPWUoKX1jYXRjaChlKXtyZXR1cm4gdChlKX1yZXR1cm4gbiYmbi50aGVuP24udGhlbih2b2lkIDAsdCk6bn0oKGZ1bmN0aW9uKCl7cmV0dXJuIHQ9cy5maWxlLnJlYWRDaHVuayhpLGEpLG49ZnVuY3Rpb24odCl7ZS5jaHVuaz10fSxyP24/bih0KTp0Oih0JiZ0LnRoZW58fCh0PVByb21pc2UucmVzb2x2ZSh0KSksbj90LnRoZW4obik6dCk7dmFyIHQsbixyfSksKGZ1bmN0aW9uKHQpe0woXCJDb3VsZG4ndCByZWFkIHNlZ21lbnQ6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShlKSxcIi4gXCIpLmNvbmNhdCh0Lm1lc3NhZ2UpKX0pKSk7ZS5jaHVuaz1zLmZpbGUuc3ViYXJyYXkoaSxhKX0pKTtzLmZpbGUuYnl0ZUxlbmd0aD5pK2E/ZS5jaHVuaz1zLmZpbGUuc3ViYXJyYXkoaSxhKTp2b2lkIDA9PT1lLnNpemU/ZS5jaHVuaz1zLmZpbGUuc3ViYXJyYXkoaSk6TChcIlNlZ21lbnQgdW5yZWFjaGFibGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpKX0sbj1mdW5jdGlvbigpe3JldHVybiBlLmNodW5rfSwocj10KCkpJiZyLnRoZW4/ci50aGVuKG4pOm4ocil9KSkpLHRoaXMuZXh0ZW5kT3B0aW9ucyYmdGhpcy5leHRlbmRPcHRpb25zKG4pLHRoaXMub3B0aW9ucz1uLHRoaXMuZmlsZT1yLHRoaXMucGFyc2Vycz1hfXJldHVybiByKGUsW3trZXk6XCJpbmplY3RTZWdtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLm9wdGlvbnNbZV0uZW5hYmxlZCYmdGhpcy5jcmVhdGVQYXJzZXIoZSx0KX19LHtrZXk6XCJjcmVhdGVQYXJzZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPW5ldyhXLmdldChlKSkodCx0aGlzLm9wdGlvbnMsdGhpcy5maWxlKTtyZXR1cm4gdGhpcy5wYXJzZXJzW2VdPW59fSx7a2V5OlwiY3JlYXRlUGFyc2Vyc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWU7QXJyYXkuaXNBcnJheSh0KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZW50cmllcyYmKHQ9dC5lbnRyaWVzKCkpLHQ9bSh0KSk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl0saT1yLnR5cGUsYT1yLmNodW5rLHM9dGhpcy5vcHRpb25zW2ldO2lmKHMmJnMuZW5hYmxlZCl7dmFyIHU9dGhpcy5wYXJzZXJzW2ldO3UmJnUuYXBwZW5kfHx1fHx0aGlzLmNyZWF0ZVBhcnNlcihpLGEpfX19fSx7a2V5OlwicmVhZFNlZ21lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PWUubWFwKHRoaXMuZW5zdXJlU2VnbWVudENodW5rKTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZighdClyZXR1cm4gZSYmZS50aGVuP2UudGhlbihGZSk6UHJvbWlzZS5yZXNvbHZlKCl9KFByb21pc2UuYWxsKHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1dKSxlfSgpLERlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShuKXt2YXIgcj10aGlzLGE9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LHM9YXJndW1lbnRzLmxlbmd0aD4yP2FyZ3VtZW50c1syXTp2b2lkIDA7dCh0aGlzLGUpLGkodGhpcyxcImVycm9yc1wiLFtdKSxpKHRoaXMsXCJyYXdcIixTKCkpLGkodGhpcyxcImhhbmRsZUVycm9yXCIsKGZ1bmN0aW9uKGUpe2lmKCFyLm9wdGlvbnMuc2lsZW50RXJyb3JzKXRocm93IGU7ci5lcnJvcnMucHVzaChlLm1lc3NhZ2UpfSkpLHRoaXMuY2h1bms9dGhpcy5ub3JtYWxpemVJbnB1dChuKSx0aGlzLmZpbGU9cyx0aGlzLnR5cGU9dGhpcy5jb25zdHJ1Y3Rvci50eXBlLHRoaXMuZ2xvYmFsT3B0aW9ucz10aGlzLm9wdGlvbnM9YSx0aGlzLmxvY2FsT3B0aW9ucz1hW3RoaXMudHlwZV0sdGhpcy5jYW5UcmFuc2xhdGU9dGhpcy5sb2NhbE9wdGlvbnMmJnRoaXMubG9jYWxPcHRpb25zLnRyYW5zbGF0ZX1yZXR1cm4gcihlLFt7a2V5Olwibm9ybWFsaXplSW5wdXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEQ/ZTpuZXcgRChlKX19LHtrZXk6XCJ0cmFuc2xhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2FuVHJhbnNsYXRlJiYodGhpcy50cmFuc2xhdGVkPXRoaXMudHJhbnNsYXRlQmxvY2sodGhpcy5yYXcsdGhpcy50eXBlKSl9fSx7a2V5Olwib3V0cHV0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlZD90aGlzLnRyYW5zbGF0ZWQ6dGhpcy5yYXc/ayh0aGlzLnJhdyk6dm9pZCAwfX0se2tleTpcInRyYW5zbGF0ZUJsb2NrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hZS5nZXQodCkscj1pZS5nZXQodCksaT1yZS5nZXQodCksYT10aGlzLm9wdGlvbnNbdF0scz1hLnJldml2ZVZhbHVlcyYmISFuLHU9YS50cmFuc2xhdGVWYWx1ZXMmJiEhcixvPWEudHJhbnNsYXRlS2V5cyYmISFpLGY9e30sYz1lO0FycmF5LmlzQXJyYXkoYyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBjLmVudHJpZXMmJihjPWMuZW50cmllcygpKSxjPW0oYykpO2Zvcih2YXIgaD0wO2g8Yy5sZW5ndGg7aCsrKXt2YXIgbD1jW2hdLGQ9bFswXSx2PWxbMV07cyYmbi5oYXMoZCk/dj1uLmdldChkKSh2KTp1JiZyLmhhcyhkKSYmKHY9dGhpcy50cmFuc2xhdGVWYWx1ZSh2LHIuZ2V0KGQpKSksbyYmaS5oYXMoZCkmJihkPWkuZ2V0KGQpfHxkKSxmW2RdPXZ9cmV0dXJuIGZ9fSx7a2V5OlwidHJhbnNsYXRlVmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0W2VdfHx0LkRFRkFVTFR8fGV9fSx7a2V5OlwiYXNzaWduVG9PdXRwdXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuYXNzaWduT2JqZWN0VG9PdXRwdXQoZSx0aGlzLmNvbnN0cnVjdG9yLnR5cGUsdCl9fSx7a2V5OlwiYXNzaWduT2JqZWN0VG9PdXRwdXRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYodGhpcy5nbG9iYWxPcHRpb25zLm1lcmdlT3V0cHV0KXJldHVybiBnKGUsbik7ZVt0XT9nKGVbdF0sbik6ZVt0XT1ufX1dLFt7a2V5OlwiZmluZFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmdldFVpbnQxNih0KzIpKzIscj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmhlYWRlckxlbmd0aD90aGlzLmhlYWRlckxlbmd0aChlLHQsbik6dGhpcy5oZWFkZXJMZW5ndGgsaT10K3IsYT1uLXI7cmV0dXJue29mZnNldDp0LGxlbmd0aDpuLGhlYWRlckxlbmd0aDpyLHN0YXJ0Omksc2l6ZTphLGVuZDppK2F9fX0se2tleTpcInBhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49bmV3IFBlKGkoe30sdGhpcy50eXBlLHQpKSxyPW5ldyB0aGlzKGUsbik7cmV0dXJuIHIucGFyc2UoKX19XSksZX0oKTtmdW5jdGlvbiBSZShlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX1pKERlLFwiaGVhZGVyTGVuZ3RoXCIsNCksaShEZSxcInR5cGVcIix2b2lkIDApLGkoRGUsXCJtdWx0aVNlZ21lbnRcIiwhMSksaShEZSxcImNhbkhhbmRsZVwiLChmdW5jdGlvbigpe3JldHVybiExfSkpO2Z1bmN0aW9uIE5lKCl7fWZ1bmN0aW9uIE1lKGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oTmUpOlByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIFdlKGUpe3ZhciB0PWUoKTtpZih0JiZ0LnRoZW4pcmV0dXJuIHQudGhlbihOZSl9ZnVuY3Rpb24gS2UoZSx0KXt2YXIgbj1lKCk7cmV0dXJuIG4mJm4udGhlbj9uLnRoZW4odCk6dChuKX1mdW5jdGlvbiBIZShlLHQsbil7aWYoIWUucyl7aWYobiBpbnN0YW5jZW9mIFhlKXtpZighbi5zKXJldHVybiB2b2lkKG4ubz1IZS5iaW5kKG51bGwsZSx0KSk7MSZ0JiYodD1uLnMpLG49bi52fWlmKG4mJm4udGhlbilyZXR1cm4gdm9pZCBuLnRoZW4oSGUuYmluZChudWxsLGUsdCksSGUuYmluZChudWxsLGUsMikpO2Uucz10LGUudj1uO3ZhciByPWUubztyJiZyKGUpfX12YXIgWGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKHQsbil7dmFyIHI9bmV3IGUsaT10aGlzLnM7aWYoaSl7dmFyIGE9MSZpP3Q6bjtpZihhKXt0cnl7SGUociwxLGEodGhpcy52KSl9Y2F0Y2goZSl7SGUociwyLGUpfXJldHVybiByfXJldHVybiB0aGlzfXJldHVybiB0aGlzLm89ZnVuY3Rpb24oZSl7dHJ5e3ZhciBpPWUudjsxJmUucz9IZShyLDEsdD90KGkpOmkpOm4/SGUociwxLG4oaSkpOkhlKHIsMixpKX1jYXRjaChlKXtIZShyLDIsZSl9fSxyfSxlfSgpO2Z1bmN0aW9uIFllKGUpe3JldHVybiBlIGluc3RhbmNlb2YgWGUmJjEmZS5zfWZ1bmN0aW9uIEdlKGUsdCxuKXtmb3IodmFyIHI7Oyl7dmFyIGk9ZSgpO2lmKFllKGkpJiYoaT1pLnYpLCFpKXJldHVybiBhO2lmKGkudGhlbil7cj0wO2JyZWFrfXZhciBhPW4oKTtpZihhJiZhLnRoZW4pe2lmKCFZZShhKSl7cj0xO2JyZWFrfWE9YS5zfWlmKHQpe3ZhciBzPXQoKTtpZihzJiZzLnRoZW4mJiFZZShzKSl7cj0yO2JyZWFrfX19dmFyIHU9bmV3IFhlLG89SGUuYmluZChudWxsLHUsMik7cmV0dXJuKDA9PT1yP2kudGhlbihjKToxPT09cj9hLnRoZW4oZik6cy50aGVuKGgpKS50aGVuKHZvaWQgMCxvKSx1O2Z1bmN0aW9uIGYocil7YT1yO2Rve2lmKHQmJihzPXQoKSkmJnMudGhlbiYmIVllKHMpKXJldHVybiB2b2lkIHMudGhlbihoKS50aGVuKHZvaWQgMCxvKTtpZighKGk9ZSgpKXx8WWUoaSkmJiFpLnYpcmV0dXJuIHZvaWQgSGUodSwxLGEpO2lmKGkudGhlbilyZXR1cm4gdm9pZCBpLnRoZW4oYykudGhlbih2b2lkIDAsbyk7WWUoYT1uKCkpJiYoYT1hLnYpfXdoaWxlKCFhfHwhYS50aGVuKTthLnRoZW4oZikudGhlbih2b2lkIDAsbyl9ZnVuY3Rpb24gYyhlKXtlPyhhPW4oKSkmJmEudGhlbj9hLnRoZW4oZikudGhlbih2b2lkIDAsbyk6ZihhKTpIZSh1LDEsYSl9ZnVuY3Rpb24gaCgpeyhpPWUoKSk/aS50aGVuP2kudGhlbihjKS50aGVuKHZvaWQgMCxvKTpjKGkpOkhlKHUsMSxhKX19ZnVuY3Rpb24gSmUoZSl7cmV0dXJuIDE5Mj09PWV8fDE5ND09PWV8fDE5Nj09PWV8fDIxOT09PWV8fDIyMT09PWV8fDIxOD09PWV8fDI1ND09PWV9ZnVuY3Rpb24gcWUoZSl7cmV0dXJuIGU+PTIyNCYmZTw9MjM5fWZ1bmN0aW9uIFFlKGUsdCxuKXt2YXIgcj1XO0FycmF5LmlzQXJyYXkocil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmVudHJpZXMmJihyPXIuZW50cmllcygpKSxyPW0ocikpO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgYT1yW2ldLHM9YVswXTtpZihhWzFdLmNhbkhhbmRsZShlLHQsbikpcmV0dXJuIHN9fXZhciBaZT1mdW5jdGlvbihlKXthKHMsZSk7dmFyIG49ZChzKTtmdW5jdGlvbiBzKCl7dmFyIGU7dCh0aGlzLHMpO2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLGE9bmV3IEFycmF5KHIpLHU9MDt1PHI7dSsrKWFbdV09YXJndW1lbnRzW3VdO3JldHVybiBpKGgoZT1uLmNhbGwuYXBwbHkobixbdGhpc10uY29uY2F0KGEpKSksXCJhcHBTZWdtZW50c1wiLFtdKSxpKGgoZSksXCJqcGVnU2VnbWVudHNcIixbXSksaShoKGUpLFwidW5rbm93blNlZ21lbnRzXCIsW10pLGV9cmV0dXJuIHIocyxbe2tleTpcInBhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztyZXR1cm4gUmUoZS5maW5kQXBwU2VnbWVudHMoKSwoZnVuY3Rpb24oKXtyZXR1cm4gUmUoZS5yZWFkU2VnbWVudHMoZS5hcHBTZWdtZW50cyksKGZ1bmN0aW9uKCl7ZS5tZXJnZU11bHRpU2VnbWVudHMoKSxlLmNyZWF0ZVBhcnNlcnMoZS5tZXJnZWRBcHBTZWdtZW50c3x8ZS5hcHBTZWdtZW50cyl9KSl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJzZXR1cFNlZ21lbnRGaW5kZXJBcmdzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczshMD09PWU/KHRoaXMuZmluZEFsbD0hMCx0aGlzLndhbnRlZD1PKFcua2V5TGlzdCgpKSk6KGU9dm9pZCAwPT09ZT9XLmtleUxpc3QoKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiB0Lm9wdGlvbnNbZV0uZW5hYmxlZH0pKTplLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIHQub3B0aW9uc1tlXS5lbmFibGVkJiZXLmhhcyhlKX0pKSx0aGlzLmZpbmRBbGw9ITEsdGhpcy5yZW1haW5pbmc9TyhlKSx0aGlzLndhbnRlZD1PKGUpKSx0aGlzLnVuZmluaXNoZWRNdWx0aVNlZ21lbnQ9ITF9fSx7a2V5OlwiZmluZEFwcFNlZ21lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCx0PWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwO3RyeXt2YXIgbj10aGlzO24uc2V0dXBTZWdtZW50RmluZGVyQXJncyh0KTt2YXIgcj1uLmZpbGUsaT1uLmZpbmRBbGwsYT1uLndhbnRlZCxzPW4ucmVtYWluaW5nO3JldHVybiBLZSgoZnVuY3Rpb24oKXtpZighaSYmbi5maWxlLmNodW5rZWQpcmV0dXJuIGk9bShhKS5zb21lKChmdW5jdGlvbihlKXt2YXIgdD1XLmdldChlKSxyPW4ub3B0aW9uc1tlXTtyZXR1cm4gdC5tdWx0aVNlZ21lbnQmJnIubXVsdGlTZWdtZW50fSkpLFdlKChmdW5jdGlvbigpe2lmKGkpcmV0dXJuIE1lKG4uZmlsZS5yZWFkV2hvbGUoKSl9KSl9KSwoZnVuY3Rpb24oKXt2YXIgdD0hMTtpZihlPW4uZmluZEFwcFNlZ21lbnRzSW5SYW5nZShlLHIuYnl0ZUxlbmd0aCksIW4ub3B0aW9ucy5vbmx5VGlmZilyZXR1cm4gZnVuY3Rpb24oKXtpZihyLmNodW5rZWQpe3ZhciBpPSExO3JldHVybiBHZSgoZnVuY3Rpb24oKXtyZXR1cm4hdCYmcy5zaXplPjAmJiFpJiYoISFyLmNhblJlYWROZXh0Q2h1bmt8fCEhbi51bmZpbmlzaGVkTXVsdGlTZWdtZW50KX0pLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgYT1yLm5leHRDaHVua09mZnNldCxzPW4uYXBwU2VnbWVudHMuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIW4uZmlsZS5hdmFpbGFibGUoZS5vZmZzZXR8fGUuc3RhcnQsZS5sZW5ndGh8fGUuc2l6ZSl9KSk7cmV0dXJuIEtlKChmdW5jdGlvbigpe3JldHVybiBlPmEmJiFzP1JlKHIucmVhZE5leHRDaHVuayhlKSwoZnVuY3Rpb24oZSl7aT0hZX0pKTpSZShyLnJlYWROZXh0Q2h1bmsoYSksKGZ1bmN0aW9uKGUpe2k9IWV9KSl9KSwoZnVuY3Rpb24oKXt2b2lkIDA9PT0oZT1uLmZpbmRBcHBTZWdtZW50c0luUmFuZ2UoZSxyLmJ5dGVMZW5ndGgpKSYmKHQ9ITApfSkpfSkpfX0oKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcImZpbmRBcHBTZWdtZW50c0luUmFuZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3QtPTI7Zm9yKHZhciBuLHIsaSxhLHMsdSxvPXRoaXMuZmlsZSxmPXRoaXMuZmluZEFsbCxjPXRoaXMud2FudGVkLGg9dGhpcy5yZW1haW5pbmcsbD10aGlzLm9wdGlvbnM7ZTx0O2UrKylpZigyNTU9PT1vLmdldFVpbnQ4KGUpKWlmKHFlKG49by5nZXRVaW50OChlKzEpKSl7aWYocj1vLmdldFVpbnQxNihlKzIpLChpPVFlKG8sZSxyKSkmJmMuaGFzKGkpJiYocz0oYT1XLmdldChpKSkuZmluZFBvc2l0aW9uKG8sZSksdT1sW2ldLHMudHlwZT1pLHRoaXMuYXBwU2VnbWVudHMucHVzaChzKSwhZiYmKGEubXVsdGlTZWdtZW50JiZ1Lm11bHRpU2VnbWVudD8odGhpcy51bmZpbmlzaGVkTXVsdGlTZWdtZW50PXMuY2h1bmtOdW1iZXI8cy5jaHVua0NvdW50LHRoaXMudW5maW5pc2hlZE11bHRpU2VnbWVudHx8aC5kZWxldGUoaSkpOmguZGVsZXRlKGkpLDA9PT1oLnNpemUpKSlicmVhaztsLnJlY29yZFVua25vd25TZWdtZW50cyYmKChzPURlLmZpbmRQb3NpdGlvbihvLGUpKS5tYXJrZXI9bix0aGlzLnVua25vd25TZWdtZW50cy5wdXNoKHMpKSxlKz1yKzF9ZWxzZSBpZihKZShuKSl7aWYocj1vLmdldFVpbnQxNihlKzIpLDIxOD09PW4mJiExIT09bC5zdG9wQWZ0ZXJTb3MpcmV0dXJuO2wucmVjb3JkSnBlZ1NlZ21lbnRzJiZ0aGlzLmpwZWdTZWdtZW50cy5wdXNoKHtvZmZzZXQ6ZSxsZW5ndGg6cixtYXJrZXI6bn0pLGUrPXIrMX1yZXR1cm4gZX19LHtrZXk6XCJtZXJnZU11bHRpU2VnbWVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYodGhpcy5hcHBTZWdtZW50cy5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gZS5tdWx0aVNlZ21lbnR9KSkpe3ZhciB0PWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuLHIsaSxhPVMoKSxzPTA7czxlLmxlbmd0aDtzKyspcj0obj1lW3NdKVt0XSxhLmhhcyhyKT9pPWEuZ2V0KHIpOmEuc2V0KHIsaT1bXSksaS5wdXNoKG4pO3JldHVybiBtKGEpfSh0aGlzLmFwcFNlZ21lbnRzLFwidHlwZVwiKTt0aGlzLm1lcmdlZEFwcFNlZ21lbnRzPXQubWFwKChmdW5jdGlvbih0KXt2YXIgbj10WzBdLHI9dFsxXSxpPVcuZ2V0KG4sZS5vcHRpb25zKTtyZXR1cm4gaS5oYW5kbGVNdWx0aVNlZ21lbnRzP3t0eXBlOm4sY2h1bms6aS5oYW5kbGVNdWx0aVNlZ21lbnRzKHIpfTpyWzBdfSkpfX19LHtrZXk6XCJnZXRTZWdtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXBwU2VnbWVudHMuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZT09PWV9KSl9fSx7a2V5OlwiZ2V0T3JGaW5kU2VnbWVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RyeXt2YXIgdD10aGlzLG49dC5nZXRTZWdtZW50KGUpO3JldHVybiBLZSgoZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1uKXJldHVybiBSZSh0LmZpbmRBcHBTZWdtZW50cygwLFtlXSksKGZ1bmN0aW9uKCl7bj10LmdldFNlZ21lbnQoZSl9KSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gbn0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1dLFt7a2V5OlwiY2FuSGFuZGxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gNjU0OTY9PT10fX1dKSxzfShFZSk7ZnVuY3Rpb24gJGUoKXt9aShaZSxcInR5cGVcIixcImpwZWdcIiksTS5zZXQoXCJqcGVnXCIsWmUpO2Z1bmN0aW9uIGV0KGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oJGUpOlByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIHR0KGUsdCl7dmFyIG49ZSgpO3JldHVybiBuJiZuLnRoZW4/bi50aGVuKHQpOnQobil9dmFyIG50PVt2b2lkIDAsMSwxLDIsNCw4LDEsMSwyLDQsOCw0LDgsNF07dmFyIHJ0PWZ1bmN0aW9uKGUpe2EoaSxlKTt2YXIgbj1kKGkpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gdCh0aGlzLGkpLG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiByKGksW3trZXk6XCJwYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7ZS5wYXJzZUhlYWRlcigpO3ZhciB0PWUub3B0aW9ucztyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5pZmQwLmVuYWJsZWQpcmV0dXJuIGV0KGUucGFyc2VJZmQwQmxvY2soKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5leGlmLmVuYWJsZWQpcmV0dXJuIGV0KGUuc2FmZVBhcnNlKFwicGFyc2VFeGlmQmxvY2tcIikpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKHQuZ3BzLmVuYWJsZWQpcmV0dXJuIGV0KGUuc2FmZVBhcnNlKFwicGFyc2VHcHNCbG9ja1wiKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5pbnRlcm9wLmVuYWJsZWQpcmV0dXJuIGV0KGUuc2FmZVBhcnNlKFwicGFyc2VJbnRlcm9wQmxvY2tcIikpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKHQuaWZkMS5lbmFibGVkKXJldHVybiBldChlLnNhZmVQYXJzZShcInBhcnNlVGh1bWJuYWlsQmxvY2tcIikpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIGUuY3JlYXRlT3V0cHV0KCl9KSl9KSl9KSl9KSl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJzYWZlUGFyc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzW2VdKCk7cmV0dXJuIHZvaWQgMCE9PXQuY2F0Y2gmJih0PXQuY2F0Y2godGhpcy5oYW5kbGVFcnJvcikpLHR9fSx7a2V5OlwiZmluZElmZDBPZmZzZXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZvaWQgMD09PXRoaXMuaWZkME9mZnNldCYmKHRoaXMuaWZkME9mZnNldD10aGlzLmNodW5rLmdldFVpbnQzMig0KSl9fSx7a2V5OlwiZmluZElmZDFPZmZzZXRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHZvaWQgMD09PXRoaXMuaWZkMU9mZnNldCl7dGhpcy5maW5kSWZkME9mZnNldCgpO3ZhciBlPXRoaXMuY2h1bmsuZ2V0VWludDE2KHRoaXMuaWZkME9mZnNldCksdD10aGlzLmlmZDBPZmZzZXQrMisxMiplO3RoaXMuaWZkMU9mZnNldD10aGlzLmNodW5rLmdldFVpbnQzMih0KX19fSx7a2V5OlwicGFyc2VCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49UygpO3JldHVybiB0aGlzW3RdPW4sdGhpcy5wYXJzZVRhZ3MoZSx0LG4pLG59fSx7a2V5OlwicGFyc2VJZmQwQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2lmKGUuaWZkMClyZXR1cm47dmFyIHQ9ZS5maWxlO3JldHVybiBlLmZpbmRJZmQwT2Zmc2V0KCksZS5pZmQwT2Zmc2V0PDgmJkwoXCJNYWxmb3JtZWQgRVhJRiBkYXRhXCIpLCF0LmNodW5rZWQmJmUuaWZkME9mZnNldD50LmJ5dGVMZW5ndGgmJkwoXCJJRkQwIG9mZnNldCBwb2ludHMgdG8gb3V0c2lkZSBvZiBmaWxlLlxcbnRoaXMuaWZkME9mZnNldDogXCIuY29uY2F0KGUuaWZkME9mZnNldCxcIiwgZmlsZS5ieXRlTGVuZ3RoOiBcIikuY29uY2F0KHQuYnl0ZUxlbmd0aCkpLHR0KChmdW5jdGlvbigpe2lmKHQudGlmZilyZXR1cm4gZXQodC5lbnN1cmVDaHVuayhlLmlmZDBPZmZzZXQsVChlLm9wdGlvbnMpKSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1lLnBhcnNlQmxvY2soZS5pZmQwT2Zmc2V0LFwiaWZkMFwiKTtpZigwIT09dC5zaXplKXJldHVybiBlLmV4aWZPZmZzZXQ9dC5nZXQoY2UpLGUuaW50ZXJvcE9mZnNldD10LmdldChsZSksZS5ncHNPZmZzZXQ9dC5nZXQoaGUpLGUueG1wPXQuZ2V0KDcwMCksZS5pcHRjPXQuZ2V0KG9lKSxlLmljYz10LmdldChmZSksZS5vcHRpb25zLnNhbml0aXplJiYodC5kZWxldGUoY2UpLHQuZGVsZXRlKGxlKSx0LmRlbGV0ZShoZSksdC5kZWxldGUoNzAwKSx0LmRlbGV0ZShvZSksdC5kZWxldGUoZmUpKSx0fSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicGFyc2VFeGlmQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2lmKGUuZXhpZilyZXR1cm47cmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKCFlLmlmZDApcmV0dXJuIGV0KGUucGFyc2VJZmQwQmxvY2soKSl9KSwoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1lLmV4aWZPZmZzZXQpcmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKGUuZmlsZS50aWZmKXJldHVybiBldChlLmZpbGUuZW5zdXJlQ2h1bmsoZS5leGlmT2Zmc2V0LFQoZS5vcHRpb25zKSkpfSksKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5wYXJzZUJsb2NrKGUuZXhpZk9mZnNldCxcImV4aWZcIik7cmV0dXJuIGUuaW50ZXJvcE9mZnNldHx8KGUuaW50ZXJvcE9mZnNldD10LmdldChsZSkpLGUubWFrZXJOb3RlPXQuZ2V0KHNlKSxlLnVzZXJDb21tZW50PXQuZ2V0KHVlKSxlLm9wdGlvbnMuc2FuaXRpemUmJih0LmRlbGV0ZShsZSksdC5kZWxldGUoc2UpLHQuZGVsZXRlKHVlKSksZS51bnBhY2sodCw0MTcyOCksZS51bnBhY2sodCw0MTcyOSksdH0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInVucGFja1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5nZXQodCk7biYmMT09PW4ubGVuZ3RoJiZlLnNldCh0LG5bMF0pfX0se2tleTpcInBhcnNlR3BzQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2lmKGUuZ3BzKXJldHVybjtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYoIWUuaWZkMClyZXR1cm4gZXQoZS5wYXJzZUlmZDBCbG9jaygpKX0pLChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWUuZ3BzT2Zmc2V0KXt2YXIgdD1lLnBhcnNlQmxvY2soZS5ncHNPZmZzZXQsXCJncHNcIik7cmV0dXJuIHQmJnQuaGFzKDIpJiZ0Lmhhcyg0KSYmKHQuc2V0KFwibGF0aXR1ZGVcIixpdC5hcHBseSh2b2lkIDAsdC5nZXQoMikuY29uY2F0KFt0LmdldCgxKV0pKSksdC5zZXQoXCJsb25naXR1ZGVcIixpdC5hcHBseSh2b2lkIDAsdC5nZXQoNCkuY29uY2F0KFt0LmdldCgzKV0pKSkpLHR9fSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicGFyc2VJbnRlcm9wQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2lmKGUuaW50ZXJvcClyZXR1cm47cmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKCFlLmlmZDApcmV0dXJuIGV0KGUucGFyc2VJZmQwQmxvY2soKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodm9pZCAwPT09ZS5pbnRlcm9wT2Zmc2V0JiYhZS5leGlmKXJldHVybiBldChlLnBhcnNlRXhpZkJsb2NrKCkpfSksKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09ZS5pbnRlcm9wT2Zmc2V0KXJldHVybiBlLnBhcnNlQmxvY2soZS5pbnRlcm9wT2Zmc2V0LFwiaW50ZXJvcFwiKX0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInBhcnNlVGh1bWJuYWlsQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07dHJ5e3ZhciB0PXRoaXM7aWYodC5pZmQxfHx0LmlmZDFQYXJzZWQpcmV0dXJuO2lmKHQub3B0aW9ucy5tZXJnZU91dHB1dCYmIWUpcmV0dXJuO3JldHVybiB0LmZpbmRJZmQxT2Zmc2V0KCksdC5pZmQxT2Zmc2V0PjAmJih0LnBhcnNlQmxvY2sodC5pZmQxT2Zmc2V0LFwiaWZkMVwiKSx0LmlmZDFQYXJzZWQ9ITApLHQuaWZkMX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcImV4dHJhY3RUaHVtYm5haWxcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO3JldHVybiBlLmhlYWRlclBhcnNlZHx8ZS5wYXJzZUhlYWRlcigpLHR0KChmdW5jdGlvbigpe2lmKCFlLmlmZDFQYXJzZWQpcmV0dXJuIGV0KGUucGFyc2VUaHVtYm5haWxCbG9jayghMCkpfSksKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09ZS5pZmQxKXt2YXIgdD1lLmlmZDEuZ2V0KDUxMyksbj1lLmlmZDEuZ2V0KDUxNCk7cmV0dXJuIGUuY2h1bmsuZ2V0VWludDhBcnJheSh0LG4pfX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcImltYWdlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWZkMH19LHtrZXk6XCJ0aHVtYm5haWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZmQxfX0se2tleTpcImNyZWF0ZU91dHB1dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdCxuLHI9e30saT15ZTtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKylpZighSShlPXRoaXNbdD1pW2FdXSkpaWYobj10aGlzLmNhblRyYW5zbGF0ZT90aGlzLnRyYW5zbGF0ZUJsb2NrKGUsdCk6ayhlKSx0aGlzLm9wdGlvbnMubWVyZ2VPdXRwdXQpe2lmKFwiaWZkMVwiPT09dCljb250aW51ZTtnKHIsbil9ZWxzZSByW3RdPW47cmV0dXJuIHRoaXMubWFrZXJOb3RlJiYoci5tYWtlck5vdGU9dGhpcy5tYWtlck5vdGUpLHRoaXMudXNlckNvbW1lbnQmJihyLnVzZXJDb21tZW50PXRoaXMudXNlckNvbW1lbnQpLHJ9fSx7a2V5OlwiYXNzaWduVG9PdXRwdXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKHRoaXMuZ2xvYmFsT3B0aW9ucy5tZXJnZU91dHB1dClnKGUsdCk7ZWxzZXt2YXIgbj15KHQpO0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1uW3JdLGE9aVswXSxzPWlbMV07dGhpcy5hc3NpZ25PYmplY3RUb091dHB1dChlLGEscyl9fX19XSxbe2tleTpcImNhbkhhbmRsZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIDIyNT09PWUuZ2V0VWludDgodCsxKSYmMTE2NTUxOTIwNj09PWUuZ2V0VWludDMyKHQrNCkmJjA9PT1lLmdldFVpbnQxNih0KzgpfX1dKSxpfShmdW5jdGlvbihlKXthKGksZSk7dmFyIG49ZChpKTtmdW5jdGlvbiBpKCl7cmV0dXJuIHQodGhpcyxpKSxuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gcihpLFt7a2V5OlwicGFyc2VIZWFkZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuY2h1bmsuZ2V0VWludDE2KCk7MTg3NjE9PT1lP3RoaXMubGU9ITA6MTk3ODk9PT1lJiYodGhpcy5sZT0hMSksdGhpcy5jaHVuay5sZT10aGlzLmxlLHRoaXMuaGVhZGVyUGFyc2VkPSEwfX0se2tleTpcInBhcnNlVGFnc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOlMoKSxyPXRoaXMub3B0aW9uc1t0XSxpPXIucGljayxhPXIuc2tpcCxzPShpPU8oaSkpLnNpemU+MCx1PTA9PT1hLnNpemUsbz10aGlzLmNodW5rLmdldFVpbnQxNihlKTtlKz0yO2Zvcih2YXIgZj0wO2Y8bztmKyspe3ZhciBjPXRoaXMuY2h1bmsuZ2V0VWludDE2KGUpO2lmKHMpe2lmKGkuaGFzKGMpJiYobi5zZXQoYyx0aGlzLnBhcnNlVGFnKGUsYyx0KSksaS5kZWxldGUoYyksMD09PWkuc2l6ZSkpYnJlYWt9ZWxzZSF1JiZhLmhhcyhjKXx8bi5zZXQoYyx0aGlzLnBhcnNlVGFnKGUsYyx0KSk7ZSs9MTJ9cmV0dXJuIG59fSx7a2V5OlwicGFyc2VUYWdcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT10aGlzLmNodW5rLGE9aS5nZXRVaW50MTYoZSsyKSxzPWkuZ2V0VWludDMyKGUrNCksdT1udFthXTtpZih1KnM8PTQ/ZSs9ODplPWkuZ2V0VWludDMyKGUrOCksKGE8MXx8YT4xMykmJkwoXCJJbnZhbGlkIFRJRkYgdmFsdWUgdHlwZS4gYmxvY2s6IFwiLmNvbmNhdChuLnRvVXBwZXJDYXNlKCksXCIsIHRhZzogXCIpLmNvbmNhdCh0LnRvU3RyaW5nKDE2KSxcIiwgdHlwZTogXCIpLmNvbmNhdChhLFwiLCBvZmZzZXQgXCIpLmNvbmNhdChlKSksZT5pLmJ5dGVMZW5ndGgmJkwoXCJJbnZhbGlkIFRJRkYgdmFsdWUgb2Zmc2V0LiBibG9jazogXCIuY29uY2F0KG4udG9VcHBlckNhc2UoKSxcIiwgdGFnOiBcIikuY29uY2F0KHQudG9TdHJpbmcoMTYpLFwiLCB0eXBlOiBcIikuY29uY2F0KGEsXCIsIG9mZnNldCBcIikuY29uY2F0KGUsXCIgaXMgb3V0c2lkZSBvZiBjaHVuayBzaXplIFwiKS5jb25jYXQoaS5ieXRlTGVuZ3RoKSksMT09PWEpcmV0dXJuIGkuZ2V0VWludDhBcnJheShlLHMpO2lmKDI9PT1hKXJldHVyblwiXCI9PT0ocj1mdW5jdGlvbihlKXtmb3IoO2UuZW5kc1dpdGgoXCJcXDBcIik7KWU9ZS5zbGljZSgwLC0xKTtyZXR1cm4gZX0ocj1pLmdldFN0cmluZyhlLHMpKS50cmltKCkpP3ZvaWQgMDpyO2lmKDc9PT1hKXJldHVybiBpLmdldFVpbnQ4QXJyYXkoZSxzKTtpZigxPT09cylyZXR1cm4gdGhpcy5wYXJzZVRhZ1ZhbHVlKGEsZSk7Zm9yKHZhciBvPW5ldyhmdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiBVaW50OEFycmF5O2Nhc2UgMzpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZSA0OnJldHVybiBVaW50MzJBcnJheTtjYXNlIDU6cmV0dXJuIEFycmF5O2Nhc2UgNjpyZXR1cm4gSW50OEFycmF5O2Nhc2UgODpyZXR1cm4gSW50MTZBcnJheTtjYXNlIDk6cmV0dXJuIEludDMyQXJyYXk7Y2FzZSAxMDpyZXR1cm4gQXJyYXk7Y2FzZSAxMTpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2UgMTI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnJldHVybiBBcnJheX19KGEpKShzKSxmPXUsYz0wO2M8cztjKyspb1tjXT10aGlzLnBhcnNlVGFnVmFsdWUoYSxlKSxlKz1mO3JldHVybiBvfX0se2tleTpcInBhcnNlVGFnVmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuY2h1bms7c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm4gbi5nZXRVaW50OCh0KTtjYXNlIDM6cmV0dXJuIG4uZ2V0VWludDE2KHQpO2Nhc2UgNDpyZXR1cm4gbi5nZXRVaW50MzIodCk7Y2FzZSA1OnJldHVybiBuLmdldFVpbnQzMih0KS9uLmdldFVpbnQzMih0KzQpO2Nhc2UgNjpyZXR1cm4gbi5nZXRJbnQ4KHQpO2Nhc2UgODpyZXR1cm4gbi5nZXRJbnQxNih0KTtjYXNlIDk6cmV0dXJuIG4uZ2V0SW50MzIodCk7Y2FzZSAxMDpyZXR1cm4gbi5nZXRJbnQzMih0KS9uLmdldEludDMyKHQrNCk7Y2FzZSAxMTpyZXR1cm4gbi5nZXRGbG9hdCh0KTtjYXNlIDEyOnJldHVybiBuLmdldERvdWJsZSh0KTtjYXNlIDEzOnJldHVybiBuLmdldFVpbnQzMih0KTtkZWZhdWx0OkwoXCJJbnZhbGlkIHRpZmYgdHlwZSBcIi5jb25jYXQoZSkpfX19XSksaX0oRGUpKTtmdW5jdGlvbiBpdChlLHQsbixyKXt2YXIgaT1lK3QvNjArbi8zNjAwO3JldHVyblwiU1wiIT09ciYmXCJXXCIhPT1yfHwoaSo9LTEpLGl9aShydCxcInR5cGVcIixcInRpZmZcIiksaShydCxcImhlYWRlckxlbmd0aFwiLDEwKSxXLnNldChcInRpZmZcIixydCk7dmFyIGF0PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6emUsRXhpZnI6SWUsZmlsZVBhcnNlcnM6TSxzZWdtZW50UGFyc2VyczpXLGZpbGVSZWFkZXJzOkssdGFnS2V5czpyZSx0YWdWYWx1ZXM6aWUsdGFnUmV2aXZlcnM6YWUsY3JlYXRlRGljdGlvbmFyeTp0ZSxleHRlbmREaWN0aW9uYXJ5Om5lLGZldGNoVXJsQXNBcnJheUJ1ZmZlcjpHLHJlYWRCbG9iQXNBcnJheUJ1ZmZlcjpZLGNodW5rZWRQcm9wczpkZSxvdGhlclNlZ21lbnRzOnZlLHNlZ21lbnRzOnBlLHRpZmZCbG9ja3M6eWUsc2VnbWVudHNBbmRCbG9ja3M6Z2UsdGlmZkV4dHJhY3RhYmxlczprZSxpbmhlcml0YWJsZXM6bWUsYWxsRm9ybWF0dGVyczpiZSxPcHRpb25zOlBlLHBhcnNlOlRlfSk7ZnVuY3Rpb24gc3QoZSx0LG4pe3JldHVybiBuP3Q/dChlKTplOihlJiZlLnRoZW58fChlPVByb21pc2UucmVzb2x2ZShlKSksdD9lLnRoZW4odCk6ZSl9ZnVuY3Rpb24gdXQoZSl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbl09YXJndW1lbnRzW25dO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuYXBwbHkodGhpcyx0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19dmFyIG90PXV0KChmdW5jdGlvbihlKXt2YXIgdD1uZXcgSWUodnQpO3JldHVybiBzdCh0LnJlYWQoZSksKGZ1bmN0aW9uKCl7cmV0dXJuIHN0KHQucGFyc2UoKSwoZnVuY3Rpb24oZSl7aWYoZSYmZS5pZmQwKXJldHVybiBlLmlmZDBbMjc0XX0pKX0pKX0pKSxmdD11dCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEllKGR0KTtyZXR1cm4gc3QodC5yZWFkKGUpLChmdW5jdGlvbigpe3JldHVybiBzdCh0LnBhcnNlKCksKGZ1bmN0aW9uKGUpe2lmKGUmJmUuZ3BzKXt2YXIgdD1lLmdwcztyZXR1cm57bGF0aXR1ZGU6dC5sYXRpdHVkZSxsb25naXR1ZGU6dC5sb25naXR1ZGV9fX0pKX0pKX0pKSxjdD11dCgoZnVuY3Rpb24oZSl7cmV0dXJuIHN0KHRoaXMudGh1bWJuYWlsKGUpLChmdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lKXt2YXIgdD1uZXcgQmxvYihbZV0pO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKHQpfX0pKX0pKSxodD11dCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEllKHB0KTtyZXR1cm4gc3QodC5yZWFkKGUpLChmdW5jdGlvbigpe3JldHVybiBzdCh0LmV4dHJhY3RUaHVtYm5haWwoKSwoZnVuY3Rpb24oZSl7cmV0dXJuIGUmJl8/ai5mcm9tKGUpOmV9KSl9KSl9KSksbHQ9e2lmZDA6ITEsaWZkMTohMSxleGlmOiExLGdwczohMSxpbnRlcm9wOiExLHNhbml0aXplOiExLHJldml2ZVZhbHVlczohMCx0cmFuc2xhdGVLZXlzOiExLHRyYW5zbGF0ZVZhbHVlczohMSxtZXJnZU91dHB1dDohMX0sZHQ9Zyh7fSxsdCx7Zmlyc3RDaHVua1NpemU6NGU0LGdwczpbMSwyLDMsNF19KSx2dD1nKHt9LGx0LHtmaXJzdENodW5rU2l6ZTo0ZTQsaWZkMDpbMjc0XX0pLHB0PWcoe30sbHQse3RpZmY6ITEsaWZkMTohMCxtZXJnZU91dHB1dDohMX0pLHl0PU9iamVjdC5mcmVlemUoezE6e2RpbWVuc2lvblN3YXBwZWQ6ITEsc2NhbGVYOjEsc2NhbGVZOjEsZGVnOjAscmFkOjB9LDI6e2RpbWVuc2lvblN3YXBwZWQ6ITEsc2NhbGVYOi0xLHNjYWxlWToxLGRlZzowLHJhZDowfSwzOntkaW1lbnNpb25Td2FwcGVkOiExLHNjYWxlWDoxLHNjYWxlWToxLGRlZzoxODAscmFkOjE4MCpNYXRoLlBJLzE4MH0sNDp7ZGltZW5zaW9uU3dhcHBlZDohMSxzY2FsZVg6LTEsc2NhbGVZOjEsZGVnOjE4MCxyYWQ6MTgwKk1hdGguUEkvMTgwfSw1OntkaW1lbnNpb25Td2FwcGVkOiEwLHNjYWxlWDoxLHNjYWxlWTotMSxkZWc6OTAscmFkOjkwKk1hdGguUEkvMTgwfSw2OntkaW1lbnNpb25Td2FwcGVkOiEwLHNjYWxlWDoxLHNjYWxlWToxLGRlZzo5MCxyYWQ6OTAqTWF0aC5QSS8xODB9LDc6e2RpbWVuc2lvblN3YXBwZWQ6ITAsc2NhbGVYOjEsc2NhbGVZOi0xLGRlZzoyNzAscmFkOjI3MCpNYXRoLlBJLzE4MH0sODp7ZGltZW5zaW9uU3dhcHBlZDohMCxzY2FsZVg6MSxzY2FsZVk6MSxkZWc6MjcwLHJhZDoyNzAqTWF0aC5QSS8xODB9fSk7aWYoZS5yb3RhdGVDYW52YXM9ITAsZS5yb3RhdGVDc3M9ITAsXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvcil7dmFyIGd0PW5hdmlnYXRvci51c2VyQWdlbnQ7aWYoZ3QuaW5jbHVkZXMoXCJpUGFkXCIpfHxndC5pbmNsdWRlcyhcImlQaG9uZVwiKSl7dmFyIGt0PWd0Lm1hdGNoKC9PUyAoXFxkKylfKFxcZCspLyk7aWYoa3Qpe3ZhciBtdD1rdFsxXSxidD1rdFsyXSxBdD1OdW1iZXIobXQpKy4xKk51bWJlcihidCk7ZS5yb3RhdGVDYW52YXM9QXQ8MTMuNCxlLnJvdGF0ZUNzcz0hMX19ZWxzZSBpZihndC5pbmNsdWRlcyhcIk9TIFggMTBcIikpe3ZhciB3dD1ndC5tYXRjaCgvT1MgWCAxMFtfLl0oXFxkKykvKVsxXTtlLnJvdGF0ZUNhbnZhcz1lLnJvdGF0ZUNzcz1OdW1iZXIod3QpPDE1fWlmKGd0LmluY2x1ZGVzKFwiQ2hyb21lL1wiKSl7dmFyIE90PWd0Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKVsxXTtlLnJvdGF0ZUNhbnZhcz1lLnJvdGF0ZUNzcz1OdW1iZXIoT3QpPDgxfWVsc2UgaWYoZ3QuaW5jbHVkZXMoXCJGaXJlZm94L1wiKSl7dmFyIFN0PWd0Lm1hdGNoKC9GaXJlZm94XFwvKFxcZCspLylbMV07ZS5yb3RhdGVDYW52YXM9ZS5yb3RhdGVDc3M9TnVtYmVyKFN0KTw3N319ZnVuY3Rpb24gUHQoKXt9dmFyIFV0PWZ1bmN0aW9uKGUpe2EodSxlKTt2YXIgbj1kKHUpO2Z1bmN0aW9uIHUoKXt2YXIgZTt0KHRoaXMsdSk7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkocikscz0wO3M8cjtzKyspYVtzXT1hcmd1bWVudHNbc107cmV0dXJuIGkoaChlPW4uY2FsbC5hcHBseShuLFt0aGlzXS5jb25jYXQoYSkpKSxcInJhbmdlc1wiLG5ldyB4dCksMCE9PWUuYnl0ZUxlbmd0aCYmZS5yYW5nZXMuYWRkKDAsZS5ieXRlTGVuZ3RoKSxlfXJldHVybiByKHUsW3trZXk6XCJfdHJ5RXh0ZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2lmKDA9PT1lJiYwPT09dGhpcy5ieXRlTGVuZ3RoJiZuKXt2YXIgcj1uZXcgRGF0YVZpZXcobi5idWZmZXJ8fG4sbi5ieXRlT2Zmc2V0LG4uYnl0ZUxlbmd0aCk7dGhpcy5fc3dhcERhdGFWaWV3KHIpfWVsc2V7dmFyIGk9ZSt0O2lmKGk+dGhpcy5ieXRlTGVuZ3RoKXt2YXIgYT10aGlzLl9leHRlbmQoaSkuZGF0YVZpZXc7dGhpcy5fc3dhcERhdGFWaWV3KGEpfX19fSx7a2V5OlwiX2V4dGVuZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0O3Q9Xz9qLmFsbG9jVW5zYWZlKGUpOm5ldyBVaW50OEFycmF5KGUpO3ZhciBuPW5ldyBEYXRhVmlldyh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKTtyZXR1cm4gdC5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsdGhpcy5ieXRlT2Zmc2V0LHRoaXMuYnl0ZUxlbmd0aCksMCkse3VpbnRWaWV3OnQsZGF0YVZpZXc6bn19fSx7a2V5Olwic3ViYXJyYXlcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07cmV0dXJuIHQ9dHx8dGhpcy5fbGVuZ3RoVG9FbmQoZSksbiYmdGhpcy5fdHJ5RXh0ZW5kKGUsdCksdGhpcy5yYW5nZXMuYWRkKGUsdCksdihzKHUucHJvdG90eXBlKSxcInN1YmFycmF5XCIsdGhpcykuY2FsbCh0aGlzLGUsdCl9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO24mJnRoaXMuX3RyeUV4dGVuZCh0LGUuYnl0ZUxlbmd0aCxlKTt2YXIgcj12KHModS5wcm90b3R5cGUpLFwic2V0XCIsdGhpcykuY2FsbCh0aGlzLGUsdCk7cmV0dXJuIHRoaXMucmFuZ2VzLmFkZCh0LHIuYnl0ZUxlbmd0aCkscn19LHtrZXk6XCJlbnN1cmVDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPXRoaXM7aWYoIW4uY2h1bmtlZClyZXR1cm47aWYobi5yYW5nZXMuYXZhaWxhYmxlKGUsdCkpcmV0dXJuO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCF0KXJldHVybiBlJiZlLnRoZW4/ZS50aGVuKFB0KTpQcm9taXNlLnJlc29sdmUoKX0obi5yZWFkQ2h1bmsoZSx0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJhdmFpbGFibGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnJhbmdlcy5hdmFpbGFibGUoZSx0KX19XSksdX0oRCkseHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dCh0aGlzLGUpLGkodGhpcyxcImxpc3RcIixbXSl9cmV0dXJuIHIoZSxbe2tleTpcImxlbmd0aFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpc3QubGVuZ3RofX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZSt0LHI9dGhpcy5saXN0LmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIEN0KGUsdC5vZmZzZXQsbil8fEN0KGUsdC5lbmQsbil9KSk7aWYoci5sZW5ndGg+MCl7ZT1NYXRoLm1pbi5hcHBseShNYXRoLFtlXS5jb25jYXQoci5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm9mZnNldH0pKSkpLHQ9KG49TWF0aC5tYXguYXBwbHkoTWF0aCxbbl0uY29uY2F0KHIubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5lbmR9KSkpKSktZTt2YXIgaT1yLnNoaWZ0KCk7aS5vZmZzZXQ9ZSxpLmxlbmd0aD10LGkuZW5kPW4sdGhpcy5saXN0PXRoaXMubGlzdC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiFyLmluY2x1ZGVzKGUpfSkpfWVsc2UgdGhpcy5saXN0LnB1c2goe29mZnNldDplLGxlbmd0aDp0LGVuZDpufSl9fSx7a2V5OlwiYXZhaWxhYmxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lK3Q7cmV0dXJuIHRoaXMubGlzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gdC5vZmZzZXQ8PWUmJm48PXQuZW5kfSkpfX1dKSxlfSgpO2Z1bmN0aW9uIEN0KGUsdCxuKXtyZXR1cm4gZTw9dCYmdDw9bn1mdW5jdGlvbiBCdCgpe31mdW5jdGlvbiBqdChlLHQpe2lmKCF0KXJldHVybiBlJiZlLnRoZW4/ZS50aGVuKEJ0KTpQcm9taXNlLnJlc29sdmUoKX1mdW5jdGlvbiBfdChlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX12YXIgVnQ9ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiB0KHRoaXMsaSksbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHIoaSxbe2tleTpcInJlYWRXaG9sZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7cmV0dXJuIGUuY2h1bmtlZD0hMSxfdChZKGUuaW5wdXQpLChmdW5jdGlvbih0KXtlLl9zd2FwQXJyYXlCdWZmZXIodCl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJyZWFkQ2h1bmtlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2h1bmtlZD0hMCx0aGlzLnNpemU9dGhpcy5pbnB1dC5zaXplLHYocyhpLnByb3RvdHlwZSksXCJyZWFkQ2h1bmtlZFwiLHRoaXMpLmNhbGwodGhpcyl9fSx7a2V5OlwiX3JlYWRDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPXRoaXMscj10P2UrdDp2b2lkIDAsaT1uLmlucHV0LnNsaWNlKGUscik7cmV0dXJuIF90KFkoaSksKGZ1bmN0aW9uKHQpe3JldHVybiBuLnNldCh0LGUsITApfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fV0pLGl9KGZ1bmN0aW9uKGUpe2EocyxlKTt2YXIgbj1kKHMpO2Z1bmN0aW9uIHMoZSxyKXt2YXIgYTtyZXR1cm4gdCh0aGlzLHMpLGkoaChhPW4uY2FsbCh0aGlzLDApKSxcImNodW5rc1JlYWRcIiwwKSxhLmlucHV0PWUsYS5vcHRpb25zPXIsYX1yZXR1cm4gcihzLFt7a2V5OlwicmVhZFdob2xlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztyZXR1cm4gZS5jaHVua2VkPSExLGp0KGUucmVhZENodW5rKGUubmV4dENodW5rT2Zmc2V0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJyZWFkQ2h1bmtlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7cmV0dXJuIGUuY2h1bmtlZD0hMCxqdChlLnJlYWRDaHVuaygwLGUub3B0aW9ucy5maXJzdENodW5rU2l6ZSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicmVhZE5leHRDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RyeXt2YXIgdD10aGlzO2lmKHZvaWQgMD09PWUmJihlPXQubmV4dENodW5rT2Zmc2V0KSx0LmZ1bGx5UmVhZClyZXR1cm4gdC5jaHVua3NSZWFkKyssITE7dmFyIG49dC5vcHRpb25zLmNodW5rU2l6ZTtyZXR1cm4gcj10LnJlYWRDaHVuayhlLG4pLGk9ZnVuY3Rpb24oZSl7cmV0dXJuISFlJiZlLmJ5dGVMZW5ndGg9PT1ufSxhP2k/aShyKTpyOihyJiZyLnRoZW58fChyPVByb21pc2UucmVzb2x2ZShyKSksaT9yLnRoZW4oaSk6cil9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfXZhciByLGksYX19LHtrZXk6XCJyZWFkQ2h1bmtcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RyeXt2YXIgbj10aGlzO2lmKG4uY2h1bmtzUmVhZCsrLDA9PT0odD1uLnNhZmVXcmFwQWRkcmVzcyhlLHQpKSlyZXR1cm47cmV0dXJuIG4uX3JlYWRDaHVuayhlLHQpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5Olwic2FmZVdyYXBBZGRyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5zaXplJiZlK3Q+dGhpcy5zaXplP01hdGgubWF4KDAsdGhpcy5zaXplLWUpOnR9fSx7a2V5OlwibmV4dENodW5rT2Zmc2V0XCIsZ2V0OmZ1bmN0aW9uKCl7aWYoMCE9PXRoaXMucmFuZ2VzLmxpc3QubGVuZ3RoKXJldHVybiB0aGlzLnJhbmdlcy5saXN0WzBdLmxlbmd0aH19LHtrZXk6XCJjYW5SZWFkTmV4dENodW5rXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2h1bmtzUmVhZDx0aGlzLm9wdGlvbnMuY2h1bmtMaW1pdH19LHtrZXk6XCJmdWxseVJlYWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5zaXplJiZ0aGlzLm5leHRDaHVua09mZnNldD09PXRoaXMuc2l6ZX19LHtrZXk6XCJyZWFkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmNodW5rZWQ/dGhpcy5yZWFkQ2h1bmtlZCgpOnRoaXMucmVhZFdob2xlKCl9fSx7a2V5OlwiY2xvc2VcIix2YWx1ZTpmdW5jdGlvbigpe319XSksc30oVXQpKTtLLnNldChcImJsb2JcIixWdCksZS5FeGlmcj1JZSxlLk9wdGlvbnM9UGUsZS5hbGxGb3JtYXR0ZXJzPWJlLGUuY2h1bmtlZFByb3BzPWRlLGUuY3JlYXRlRGljdGlvbmFyeT10ZSxlLmRlZmF1bHQ9YXQsZS5kaXNhYmxlQWxsT3B0aW9ucz1sdCxlLmV4dGVuZERpY3Rpb25hcnk9bmUsZS5mZXRjaFVybEFzQXJyYXlCdWZmZXI9RyxlLmZpbGVQYXJzZXJzPU0sZS5maWxlUmVhZGVycz1LLGUuZ3BzPWZ0LGUuZ3BzT25seU9wdGlvbnM9ZHQsZS5pbmhlcml0YWJsZXM9bWUsZS5vcmllbnRhdGlvbj1vdCxlLm9yaWVudGF0aW9uT25seU9wdGlvbnM9dnQsZS5vdGhlclNlZ21lbnRzPXZlLGUucGFyc2U9VGUsZS5yZWFkQmxvYkFzQXJyYXlCdWZmZXI9WSxlLnJvdGF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBzdChvdCh0KSwoZnVuY3Rpb24odCl7cmV0dXJuIGcoe2NhbnZhczplLnJvdGF0ZUNhbnZhcyxjc3M6ZS5yb3RhdGVDc3N9LHl0W3RdKX0pKX0sZS5yb3RhdGlvbnM9eXQsZS5zZWdtZW50UGFyc2Vycz1XLGUuc2VnbWVudHM9cGUsZS5zZWdtZW50c0FuZEJsb2Nrcz1nZSxlLnRhZ0tleXM9cmUsZS50YWdSZXZpdmVycz1hZSxlLnRhZ1ZhbHVlcz1pZSxlLnRodW1ibmFpbD1odCxlLnRodW1ibmFpbE9ubHlPcHRpb25zPXB0LGUudGh1bWJuYWlsVXJsPWN0LGUudGlmZkJsb2Nrcz15ZSxlLnRpZmZFeHRyYWN0YWJsZXM9a2UsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1NoYWxsb3dFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWVcbiAgZm9yICh2YXIgaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2VcbiAgZm9yICh2YXIgaSBpbiBiKSBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0cnVlXG59XG4iLCIvKlxuICogIGJhc2U2NC5qc1xuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG4gKiAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogIFJlZmVyZW5jZXM6XG4gKiAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NFxuICovXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZ2xvYmFsKVxuICAgICAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgICAgICA/IGRlZmluZShmYWN0b3J5KSA6IGZhY3RvcnkoZ2xvYmFsKVxufSgoXG4gICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZlxuICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxcbjogdGhpc1xuKSwgZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIGV4aXN0aW5nIHZlcnNpb24gZm9yIG5vQ29uZmxpY3QoKVxuICAgIGdsb2JhbCA9IGdsb2JhbCB8fCB7fTtcbiAgICB2YXIgX0Jhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgdmFyIHZlcnNpb24gPSBcIjIuNi40XCI7XG4gICAgLy8gY29uc3RhbnRzXG4gICAgdmFyIGI2NGNoYXJzXG4gICAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIHZhciBiNjR0YWIgPSBmdW5jdGlvbihiaW4pIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBiaW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB0W2Jpbi5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfShiNjRjaGFycyk7XG4gICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgLy8gZW5jb2RlciBzdHVmZlxuICAgIHZhciBjYl91dG9iID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4gY2MgPCAweDgwID8gY1xuICAgICAgICAgICAgICAgIDogY2MgPCAweDgwMCA/IChmcm9tQ2hhckNvZGUoMHhjMCB8IChjYyA+Pj4gNikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSkpXG4gICAgICAgICAgICAgICAgOiAoZnJvbUNoYXJDb2RlKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+ICA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKCBjYyAgICAgICAgICYgMHgzZikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYyA9IDB4MTAwMDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMSkgLSAweERDMDApO1xuICAgICAgICAgICAgcmV0dXJuIChmcm9tQ2hhckNvZGUoMHhmMCB8ICgoY2MgPj4+IDE4KSAmIDB4MDcpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gMTIpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAgNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICggY2MgICAgICAgICAmIDB4M2YpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4gICAgdmFyIHV0b2IgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1LnJlcGxhY2UocmVfdXRvYiwgY2JfdXRvYik7XG4gICAgfTtcbiAgICB2YXIgY2JfZW5jb2RlID0gZnVuY3Rpb24oY2NjKSB7XG4gICAgICAgIHZhciBwYWRsZW4gPSBbMCwgMiwgMV1bY2NjLmxlbmd0aCAlIDNdLFxuICAgICAgICBvcmQgPSBjY2MuY2hhckNvZGVBdCgwKSA8PCAxNlxuICAgICAgICAgICAgfCAoKGNjYy5sZW5ndGggPiAxID8gY2NjLmNoYXJDb2RlQXQoMSkgOiAwKSA8PCA4KVxuICAgICAgICAgICAgfCAoKGNjYy5sZW5ndGggPiAyID8gY2NjLmNoYXJDb2RlQXQoMikgOiAwKSksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgYjY0Y2hhcnMuY2hhckF0KCBvcmQgPj4+IDE4KSxcbiAgICAgICAgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MyksXG4gICAgICAgICAgICBwYWRsZW4gPj0gMiA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiA2KSAmIDYzKSxcbiAgICAgICAgICAgIHBhZGxlbiA+PSAxID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KG9yZCAmIDYzKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgYnRvYSA9IGdsb2JhbC5idG9hICYmIHR5cGVvZiBnbG9iYWwuYnRvYSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gZnVuY3Rpb24oYil7IHJldHVybiBnbG9iYWwuYnRvYShiKSB9IDogZnVuY3Rpb24oYikge1xuICAgICAgICBpZiAoYi5tYXRjaCgvW15cXHgwMC1cXHhGRl0vKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHN0cmluZyBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKC9bXFxzXFxTXXsxLDN9L2csIGNiX2VuY29kZSk7XG4gICAgfTtcbiAgICB2YXIgX2VuY29kZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIGJ0b2EodXRvYihTdHJpbmcodSkpKTtcbiAgICB9O1xuICAgIHZhciBta1VyaVNhZmUgPSBmdW5jdGlvbiAoYjY0KSB7XG4gICAgICAgIHJldHVybiBiNjQucmVwbGFjZSgvWytcXC9dL2csIGZ1bmN0aW9uKG0wKSB7XG4gICAgICAgICAgICByZXR1cm4gbTAgPT0gJysnID8gJy0nIDogJ18nO1xuICAgICAgICB9KS5yZXBsYWNlKC89L2csICcnKTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbih1LCB1cmlzYWZlKSB7XG4gICAgICAgIHJldHVybiB1cmlzYWZlID8gbWtVcmlTYWZlKF9lbmNvZGUodSkpIDogX2VuY29kZSh1KTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGVVUkkgPSBmdW5jdGlvbih1KSB7IHJldHVybiBlbmNvZGUodSwgdHJ1ZSkgfTtcbiAgICB2YXIgZnJvbVVpbnQ4QXJyYXk7XG4gICAgaWYgKGdsb2JhbC5VaW50OEFycmF5KSBmcm9tVWludDhBcnJheSA9IGZ1bmN0aW9uKGEsIHVyaXNhZmUpIHtcbiAgICAgICAgLy8gcmV0dXJuIGJ0b2EoZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEpKTtcbiAgICAgICAgdmFyIGI2NCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICAgICAgICB2YXIgYTAgPSBhW2ldLCBhMSA9IGFbaSsxXSwgYTIgPSBhW2krMl07XG4gICAgICAgICAgICB2YXIgb3JkID0gYTAgPDwgMTYgfCBhMSA8PCA4IHwgYTI7XG4gICAgICAgICAgICBiNjQgKz0gICAgYjY0Y2hhcnMuY2hhckF0KCBvcmQgPj4+IDE4KVxuICAgICAgICAgICAgICAgICsgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MylcbiAgICAgICAgICAgICAgICArICggdHlwZW9mIGExICE9ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+ICA2KSAmIDYzKSA6ICc9JylcbiAgICAgICAgICAgICAgICArICggdHlwZW9mIGEyICE9ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gYjY0Y2hhcnMuY2hhckF0KCBvcmQgICAgICAgICAmIDYzKSA6ICc9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaXNhZmUgPyBta1VyaVNhZmUoYjY0KSA6IGI2NDtcbiAgICB9O1xuICAgIC8vIGRlY29kZXIgc3R1ZmZcbiAgICB2YXIgcmVfYnRvdSA9IC9bXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXXxbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfS9nO1xuICAgIHZhciBjYl9idG91ID0gZnVuY3Rpb24oY2NjYykge1xuICAgICAgICBzd2l0Y2goY2NjYy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIGNwID0gKCgweDA3ICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxOClcbiAgICAgICAgICAgICAgICB8ICAgICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpIDw8ICA2KVxuICAgICAgICAgICAgICAgIHwgICAgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSxcbiAgICAgICAgICAgIG9mZnNldCA9IGNwIC0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKChvZmZzZXQgID4+PiAxMCkgKyAweEQ4MDApXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKChvZmZzZXQgJiAweDNGRikgKyAweERDMDApKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpXG4gICAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDFmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBidG91ID0gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuICAgIH07XG4gICAgdmFyIGNiX2RlY29kZSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNjY2MubGVuZ3RoLFxuICAgICAgICBwYWRsZW4gPSBsZW4gJSA0LFxuICAgICAgICBuID0gKGxlbiA+IDAgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMCldIDw8IDE4IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDEgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMSldIDw8IDEyIDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDIgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMildIDw8ICA2IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDMgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMyldICAgICAgIDogMCksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuID4+PiAxNiksXG4gICAgICAgICAgICBmcm9tQ2hhckNvZGUoKG4gPj4+ICA4KSAmIDB4ZmYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuICAgICAgICAgJiAweGZmKVxuICAgICAgICBdO1xuICAgICAgICBjaGFycy5sZW5ndGggLT0gWzAsIDAsIDIsIDFdW3BhZGxlbl07XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIHZhciBfYXRvYiA9IGdsb2JhbC5hdG9iICYmIHR5cGVvZiBnbG9iYWwuYXRvYiA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gZnVuY3Rpb24oYSl7IHJldHVybiBnbG9iYWwuYXRvYihhKSB9IDogZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UoL1xcU3sxLDR9L2csIGNiX2RlY29kZSk7XG4gICAgfTtcbiAgICB2YXIgYXRvYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIF9hdG9iKFN0cmluZyhhKS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpKTtcbiAgICB9O1xuICAgIHZhciBfZGVjb2RlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gYnRvdShfYXRvYihhKSkgfTtcbiAgICB2YXIgX2Zyb21VUkkgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkucmVwbGFjZSgvWy1fXS9nLCBmdW5jdGlvbihtMCkge1xuICAgICAgICAgICAgcmV0dXJuIG0wID09ICctJyA/ICcrJyA6ICcvJ1xuICAgICAgICB9KS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpO1xuICAgIH07XG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gX2RlY29kZShfZnJvbVVSSShhKSk7XG4gICAgfTtcbiAgICB2YXIgdG9VaW50OEFycmF5O1xuICAgIGlmIChnbG9iYWwuVWludDhBcnJheSkgdG9VaW50OEFycmF5ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoX2Zyb21VUkkoYSkpLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgcmV0dXJuIEJhc2U2NDtcbiAgICB9O1xuICAgIC8vIGV4cG9ydCBCYXNlNjRcbiAgICBnbG9iYWwuQmFzZTY0ID0ge1xuICAgICAgICBWRVJTSU9OOiB2ZXJzaW9uLFxuICAgICAgICBhdG9iOiBhdG9iLFxuICAgICAgICBidG9hOiBidG9hLFxuICAgICAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgICAgIHRvQmFzZTY0OiBlbmNvZGUsXG4gICAgICAgIHV0b2I6IHV0b2IsXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxuICAgICAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICAgICAgYnRvdTogYnRvdSxcbiAgICAgICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgICAgIG5vQ29uZmxpY3Q6IG5vQ29uZmxpY3QsXG4gICAgICAgIGZyb21VaW50OEFycmF5OiBmcm9tVWludDhBcnJheSxcbiAgICAgICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXlcbiAgICB9O1xuICAgIC8vIGlmIEVTNSBpcyBhdmFpbGFibGUsIG1ha2UgQmFzZTY0LmV4dGVuZFN0cmluZygpIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBub0VudW0gPSBmdW5jdGlvbih2KXtcbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6dixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9O1xuICAgICAgICB9O1xuICAgICAgICBnbG9iYWwuQmFzZTY0LmV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLCAnZnJvbUJhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodGhpcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0Jywgbm9FbnVtKGZ1bmN0aW9uICh1cmlzYWZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdXJpc2FmZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0VVJJJywgbm9FbnVtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIGlmIChnbG9iYWxbJ01ldGVvciddKSB7IC8vIE1ldGVvci5qc1xuICAgICAgICBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICAvLyBtb2R1bGUuZXhwb3J0cyBhbmQgQU1EIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgaGFzIHByZWNlZGVuY2UuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLkJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGdsb2JhbC5CYXNlNjQgfSk7XG4gICAgfVxuICAgIC8vIHRoYXQncyBpdCFcbiAgICByZXR1cm4ge0Jhc2U2NDogZ2xvYmFsLkJhc2U2NH1cbn0pKTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNhZmVJc05hTiA9IE51bWJlci5pc05hTiB8fFxuICAgIGZ1bmN0aW9uIHBvbnlmaWxsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSB2YWx1ZTtcbiAgICB9O1xuZnVuY3Rpb24gaXNFcXVhbChmaXJzdCwgc2Vjb25kKSB7XG4gICAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChzYWZlSXNOYU4oZmlyc3QpICYmIHNhZmVJc05hTihzZWNvbmQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhcmVJbnB1dHNFcXVhbChuZXdJbnB1dHMsIGxhc3RJbnB1dHMpIHtcbiAgICBpZiAobmV3SW5wdXRzLmxlbmd0aCAhPT0gbGFzdElucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzRXF1YWwobmV3SW5wdXRzW2ldLCBsYXN0SW5wdXRzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplT25lKHJlc3VsdEZuLCBpc0VxdWFsKSB7XG4gICAgaWYgKGlzRXF1YWwgPT09IHZvaWQgMCkgeyBpc0VxdWFsID0gYXJlSW5wdXRzRXF1YWw7IH1cbiAgICB2YXIgbGFzdFRoaXM7XG4gICAgdmFyIGxhc3RBcmdzID0gW107XG4gICAgdmFyIGxhc3RSZXN1bHQ7XG4gICAgdmFyIGNhbGxlZE9uY2UgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBpc0VxdWFsKG5ld0FyZ3MsIGxhc3RBcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICBjYWxsZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0QXJncyA9IG5ld0FyZ3M7XG4gICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZU9uZTtcbiIsInZhciB3aWxkY2FyZCA9IHJlcXVpcmUoJ3dpbGRjYXJkJyk7XG52YXIgcmVNaW1lUGFydFNwbGl0ID0gL1tcXC9cXCtcXC5dLztcblxuLyoqXG4gICMgbWltZS1tYXRjaFxuXG4gIEEgc2ltcGxlIGZ1bmN0aW9uIHRvIGNoZWNrZXIgd2hldGhlciBhIHRhcmdldCBtaW1lIHR5cGUgbWF0Y2hlcyBhIG1pbWUtdHlwZVxuICBwYXR0ZXJuIChlLmcuIGltYWdlL2pwZWcgbWF0Y2hlcyBpbWFnZS9qcGVnIE9SIGltYWdlLyopLlxuXG4gICMjIEV4YW1wbGUgVXNhZ2VcblxuICA8PDwgZXhhbXBsZS5qc1xuXG4qKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBwYXR0ZXJuKSB7XG4gIGZ1bmN0aW9uIHRlc3QocGF0dGVybikge1xuICAgIHZhciByZXN1bHQgPSB3aWxkY2FyZChwYXR0ZXJuLCB0YXJnZXQsIHJlTWltZVBhcnRTcGxpdCk7XG5cbiAgICAvLyBlbnN1cmUgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgbWltZSB0eXBlIChzaG91bGQgaGF2ZSB0d28gcGFydHMpXG4gICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID49IDI7XG4gIH1cblxuICByZXR1cm4gcGF0dGVybiA/IHRlc3QocGF0dGVybi5zcGxpdCgnOycpWzBdKSA6IHRlc3Q7XG59O1xuIiwiLyoganNoaW50IG5vZGU6IHRydWUgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gICMgd2lsZGNhcmRcblxuICBWZXJ5IHNpbXBsZSB3aWxkY2FyZCBtYXRjaGluZywgd2hpY2ggaXMgZGVzaWduZWQgdG8gcHJvdmlkZSB0aGUgc2FtZVxuICBmdW5jdGlvbmFsaXR5IHRoYXQgaXMgZm91bmQgaW4gdGhlXG4gIFtldmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS13ZWJwbGF0Zm9ybS9ldmUpIGV2ZW50aW5nIGxpYnJhcnkuXG5cbiAgIyMgVXNhZ2VcblxuICBJdCB3b3JrcyB3aXRoIHN0cmluZ3M6XG5cbiAgPDw8IGV4YW1wbGVzL3N0cmluZ3MuanNcblxuICBBcnJheXM6XG5cbiAgPDw8IGV4YW1wbGVzL2FycmF5cy5qc1xuXG4gIE9iamVjdHMgKG1hdGNoaW5nIGFnYWluc3Qga2V5cyk6XG5cbiAgPDw8IGV4YW1wbGVzL29iamVjdHMuanNcblxuICBXaGlsZSB0aGUgbGlicmFyeSB3b3JrcyBpbiBOb2RlLCBpZiB5b3UgYXJlIGFyZSBsb29raW5nIGZvciBmaWxlLWJhc2VkXG4gIHdpbGRjYXJkIG1hdGNoaW5nIHRoZW4geW91IHNob3VsZCBoYXZlIGEgbG9vayBhdDpcblxuICA8aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2I+XG4qKi9cblxuZnVuY3Rpb24gV2lsZGNhcmRNYXRjaGVyKHRleHQsIHNlcGFyYXRvcikge1xuICB0aGlzLnRleHQgPSB0ZXh0ID0gdGV4dCB8fCAnJztcbiAgdGhpcy5oYXNXaWxkID0gfnRleHQuaW5kZXhPZignKicpO1xuICB0aGlzLnNlcGFyYXRvciA9IHNlcGFyYXRvcjtcbiAgdGhpcy5wYXJ0cyA9IHRleHQuc3BsaXQoc2VwYXJhdG9yKTtcbn1cblxuV2lsZGNhcmRNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBtYXRjaGVzID0gdHJ1ZTtcbiAgdmFyIHBhcnRzID0gdGhpcy5wYXJ0cztcbiAgdmFyIGlpO1xuICB2YXIgcGFydHNDb3VudCA9IHBhcnRzLmxlbmd0aDtcbiAgdmFyIHRlc3RQYXJ0cztcblxuICBpZiAodHlwZW9mIGlucHV0ID09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmhhc1dpbGQgJiYgdGhpcy50ZXh0ICE9IGlucHV0KSB7XG4gICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlc3RQYXJ0cyA9IChpbnB1dCB8fCAnJykuc3BsaXQodGhpcy5zZXBhcmF0b3IpO1xuICAgICAgZm9yIChpaSA9IDA7IG1hdGNoZXMgJiYgaWkgPCBwYXJ0c0NvdW50OyBpaSsrKSB7XG4gICAgICAgIGlmIChwYXJ0c1tpaV0gPT09ICcqJykgIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpaSA8IHRlc3RQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICBtYXRjaGVzID0gcGFydHNbaWldID09PSB0ZXN0UGFydHNbaWldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBtYXRjaGVzLCB0aGVuIHJldHVybiB0aGUgY29tcG9uZW50IHBhcnRzXG4gICAgICBtYXRjaGVzID0gbWF0Y2hlcyAmJiB0ZXN0UGFydHM7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBpbnB1dC5zcGxpY2UgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hdGNoZXMgPSBbXTtcblxuICAgIGZvciAoaWkgPSBpbnB1dC5sZW5ndGg7IGlpLS07ICkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goaW5wdXRbaWldKSkge1xuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoXSA9IGlucHV0W2lpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09ICdvYmplY3QnKSB7XG4gICAgbWF0Y2hlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5tYXRjaChrZXkpKSB7XG4gICAgICAgIG1hdGNoZXNba2V5XSA9IGlucHV0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRleHQsIHRlc3QsIHNlcGFyYXRvcikge1xuICB2YXIgbWF0Y2hlciA9IG5ldyBXaWxkY2FyZE1hdGNoZXIodGV4dCwgc2VwYXJhdG9yIHx8IC9bXFwvXFwuXS8pO1xuICBpZiAodHlwZW9mIHRlc3QgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaCh0ZXN0KTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVyO1xufTtcbiIsIi8qKlxuKiBDcmVhdGUgYW4gZXZlbnQgZW1pdHRlciB3aXRoIG5hbWVzcGFjZXNcbiogQG5hbWUgY3JlYXRlTmFtZXNwYWNlRW1pdHRlclxuKiBAZXhhbXBsZVxuKiB2YXIgZW1pdHRlciA9IHJlcXVpcmUoJy4vaW5kZXgnKSgpXG4qXG4qIGVtaXR0ZXIub24oJyonLCBmdW5jdGlvbiAoKSB7XG4qICAgY29uc29sZS5sb2coJ2FsbCBldmVudHMgZW1pdHRlZCcsIHRoaXMuZXZlbnQpXG4qIH0pXG4qXG4qIGVtaXR0ZXIub24oJ2V4YW1wbGUnLCBmdW5jdGlvbiAoKSB7XG4qICAgY29uc29sZS5sb2coJ2V4YW1wbGUgZXZlbnQgZW1pdHRlZCcpXG4qIH0pXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVOYW1lc3BhY2VFbWl0dGVyICgpIHtcbiAgdmFyIGVtaXR0ZXIgPSB7fVxuICB2YXIgX2ZucyA9IGVtaXR0ZXIuX2ZucyA9IHt9XG5cbiAgLyoqXG4gICogRW1pdCBhbiBldmVudC4gT3B0aW9uYWxseSBuYW1lc3BhY2UgdGhlIGV2ZW50LiBIYW5kbGVycyBhcmUgZmlyZWQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB3aXRoIGV4YWN0IG1hdGNoZXMgdGFraW5nIHByZWNlZGVuY2UuIFNlcGFyYXRlIHRoZSBuYW1lc3BhY2UgYW5kIGV2ZW50IHdpdGggYSBgOmBcbiAgKiBAbmFtZSBlbWl0XG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IOKAkyB0aGUgbmFtZSBvZiB0aGUgZXZlbnQsIHdpdGggb3B0aW9uYWwgbmFtZXNwYWNlXG4gICogQHBhcmFtIHsuLi4qfSBkYXRhIOKAkyB1cCB0byA2IGFyZ3VtZW50cyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyXG4gICogQGV4YW1wbGVcbiAgKiBlbWl0dGVyLmVtaXQoJ2V4YW1wbGUnKVxuICAqIGVtaXR0ZXIuZW1pdCgnZGVtbzp0ZXN0JylcbiAgKiBlbWl0dGVyLmVtaXQoJ2RhdGEnLCB7IGV4YW1wbGU6IHRydWV9LCAnYSBzdHJpbmcnLCAxKVxuICAqL1xuICBlbWl0dGVyLmVtaXQgPSBmdW5jdGlvbiBlbWl0IChldmVudCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNikge1xuICAgIHZhciB0b0VtaXQgPSBnZXRMaXN0ZW5lcnMoZXZlbnQpXG5cbiAgICBpZiAodG9FbWl0Lmxlbmd0aCkge1xuICAgICAgZW1pdEFsbChldmVudCwgdG9FbWl0LCBbYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNl0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlIGVuIGV2ZW50IGxpc3RlbmVyLlxuICAqIEBuYW1lIG9uXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgKiBAZXhhbXBsZVxuICAqIGVtaXR0ZXIub24oJ2V4YW1wbGUnLCBmdW5jdGlvbiAoKSB7fSlcbiAgKiBlbWl0dGVyLm9uKCdkZW1vJywgZnVuY3Rpb24gKCkge30pXG4gICovXG4gIGVtaXR0ZXIub24gPSBmdW5jdGlvbiBvbiAoZXZlbnQsIGZuKSB7XG4gICAgaWYgKCFfZm5zW2V2ZW50XSkge1xuICAgICAgX2Zuc1tldmVudF0gPSBbXVxuICAgIH1cblxuICAgIF9mbnNbZXZlbnRdLnB1c2goZm4pXG4gIH1cblxuICAvKipcbiAgKiBDcmVhdGUgZW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBmaXJlcyBvbmNlLlxuICAqIEBuYW1lIG9uY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAqIEBleGFtcGxlXG4gICogZW1pdHRlci5vbmNlKCdleGFtcGxlJywgZnVuY3Rpb24gKCkge30pXG4gICogZW1pdHRlci5vbmNlKCdkZW1vJywgZnVuY3Rpb24gKCkge30pXG4gICovXG4gIGVtaXR0ZXIub25jZSA9IGZ1bmN0aW9uIG9uY2UgKGV2ZW50LCBmbikge1xuICAgIGZ1bmN0aW9uIG9uZSAoKSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICBlbWl0dGVyLm9mZihldmVudCwgb25lKVxuICAgIH1cbiAgICB0aGlzLm9uKGV2ZW50LCBvbmUpXG4gIH1cblxuICAvKipcbiAgKiBTdG9wIGxpc3RlbmluZyB0byBhbiBldmVudC4gU3RvcCBhbGwgbGlzdGVuZXJzIG9uIGFuIGV2ZW50IGJ5IG9ubHkgcGFzc2luZyB0aGUgZXZlbnQgbmFtZS4gU3RvcCBhIHNpbmdsZSBsaXN0ZW5lciBieSBwYXNzaW5nIHRoYXQgZXZlbnQgaGFuZGxlciBhcyBhIGNhbGxiYWNrLlxuICAqIFlvdSBtdXN0IGJlIGV4cGxpY2l0IGFib3V0IHdoYXQgd2lsbCBiZSB1bnN1YnNjcmliZWQ6IGBlbWl0dGVyLm9mZignZGVtbycpYCB3aWxsIHVuc3Vic2NyaWJlIGFuIGBlbWl0dGVyLm9uKCdkZW1vJylgIGxpc3RlbmVyLFxuICAqIGBlbWl0dGVyLm9mZignZGVtbzpleGFtcGxlJylgIHdpbGwgdW5zdWJzY3JpYmUgYW4gYGVtaXR0ZXIub24oJ2RlbW86ZXhhbXBsZScpYCBsaXN0ZW5lclxuICAqIEBuYW1lIG9mZlxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0g4oCTIHRoZSBzcGVjaWZpYyBoYW5kbGVyXG4gICogQGV4YW1wbGVcbiAgKiBlbWl0dGVyLm9mZignZXhhbXBsZScpXG4gICogZW1pdHRlci5vZmYoJ2RlbW8nLCBmdW5jdGlvbiAoKSB7fSlcbiAgKi9cbiAgZW1pdHRlci5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50LCBmbikge1xuICAgIHZhciBrZWVwID0gW11cblxuICAgIGlmIChldmVudCAmJiBmbikge1xuICAgICAgdmFyIGZucyA9IHRoaXMuX2Zuc1tldmVudF1cbiAgICAgIHZhciBpID0gMFxuICAgICAgdmFyIGwgPSBmbnMgPyBmbnMubGVuZ3RoIDogMFxuXG4gICAgICBmb3IgKGk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGZuc1tpXSAhPT0gZm4pIHtcbiAgICAgICAgICBrZWVwLnB1c2goZm5zW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAga2VlcC5sZW5ndGggPyB0aGlzLl9mbnNbZXZlbnRdID0ga2VlcCA6IGRlbGV0ZSB0aGlzLl9mbnNbZXZlbnRdXG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMgKGUpIHtcbiAgICB2YXIgb3V0ID0gX2Zuc1tlXSA/IF9mbnNbZV0gOiBbXVxuICAgIHZhciBpZHggPSBlLmluZGV4T2YoJzonKVxuICAgIHZhciBhcmdzID0gKGlkeCA9PT0gLTEpID8gW2VdIDogW2Uuc3Vic3RyaW5nKDAsIGlkeCksIGUuc3Vic3RyaW5nKGlkeCArIDEpXVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfZm5zKVxuICAgIHZhciBpID0gMFxuICAgIHZhciBsID0ga2V5cy5sZW5ndGhcblxuICAgIGZvciAoaTsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIGlmIChrZXkgPT09ICcqJykge1xuICAgICAgICBvdXQgPSBvdXQuY29uY2F0KF9mbnNba2V5XSlcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyICYmIGFyZ3NbMF0gPT09IGtleSkge1xuICAgICAgICBvdXQgPSBvdXQuY29uY2F0KF9mbnNba2V5XSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0QWxsIChlLCBmbnMsIGFyZ3MpIHtcbiAgICB2YXIgaSA9IDBcbiAgICB2YXIgbCA9IGZucy5sZW5ndGhcblxuICAgIGZvciAoaTsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKCFmbnNbaV0pIGJyZWFrXG4gICAgICBmbnNbaV0uZXZlbnQgPSBlXG4gICAgICBmbnNbaV0uYXBwbHkoZm5zW2ldLCBhcmdzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbWl0dGVyXG59XG4iLCJsZXQgeyB1cmxBbHBoYWJldCB9ID0gcmVxdWlyZSgnLi91cmwtYWxwaGFiZXQvaW5kZXguY2pzJylcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnICYmXG4gICAgdHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1JlYWN0IE5hdGl2ZSBkb2VzIG5vdCBoYXZlIGEgYnVpbHQtaW4gc2VjdXJlIHJhbmRvbSBnZW5lcmF0b3IuICcgK1xuICAgICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcyB1c2UgYG5hbm9pZC9ub24tc2VjdXJlYC4gJyArXG4gICAgICAgICdGb3Igc2VjdXJlIElEcywgaW1wb3J0IGByZWFjdC1uYXRpdmUtZ2V0LXJhbmRvbS12YWx1ZXNgICcgK1xuICAgICAgICAnYmVmb3JlIE5hbm8gSUQuJ1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbXBvcnQgZmlsZSB3aXRoIGBpZiAoIXdpbmRvdy5jcnlwdG8pIHdpbmRvdy5jcnlwdG8gPSB3aW5kb3cubXNDcnlwdG9gJyArXG4gICAgICAgICcgYmVmb3JlIGltcG9ydGluZyBOYW5vIElEIHRvIGZpeCBJRSAxMSBzdXBwb3J0J1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91ciBicm93c2VyIGRvZXMgbm90IGhhdmUgc2VjdXJlIHJhbmRvbSBnZW5lcmF0b3IuICcgK1xuICAgICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgbmFub2lkL25vbi1zZWN1cmUuJ1xuICAgIClcbiAgfVxufVxubGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxubGV0IGN1c3RvbVJhbmRvbSA9IChhbHBoYWJldCwgc2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIGxldCBtYXNrID0gKDIgPDwgKE1hdGgubG9nKGFscGhhYmV0Lmxlbmd0aCAtIDEpIC8gTWF0aC5MTjIpKSAtIDFcbiAgbGV0IHN0ZXAgPSAtfigoMS42ICogbWFzayAqIHNpemUpIC8gYWxwaGFiZXQubGVuZ3RoKVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBieXRlcyA9IGdldFJhbmRvbShzdGVwKVxuICAgICAgbGV0IGogPSBzdGVwXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2pdICYgbWFza10gfHwgJydcbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIHNpemUpID0+IGN1c3RvbVJhbmRvbShhbHBoYWJldCwgc2l6ZSwgcmFuZG9tKVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJydcbiAgbGV0IGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSlcbiAgd2hpbGUgKHNpemUtLSkge1xuICAgIGxldCBieXRlID0gYnl0ZXNbc2l6ZV0gJiA2M1xuICAgIGlmIChieXRlIDwgMzYpIHtcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjMpIHtcbiAgICAgIGlkICs9ICdfJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnLSdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkXG59XG5tb2R1bGUuZXhwb3J0cyA9IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCwgY3VzdG9tUmFuZG9tLCB1cmxBbHBoYWJldCwgcmFuZG9tIH1cbiIsImxldCB1cmxBbHBoYWJldCA9XG4gICd1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSB7IHVybEFscGhhYmV0IH1cbiIsInZhciBuLGwsdSx0LGkscixvLGYsZT17fSxjPVtdLHM9L2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtmdW5jdGlvbiBhKG4sbCl7Zm9yKHZhciB1IGluIGwpblt1XT1sW3VdO3JldHVybiBufWZ1bmN0aW9uIHYobil7dmFyIGw9bi5wYXJlbnROb2RlO2wmJmwucmVtb3ZlQ2hpbGQobil9ZnVuY3Rpb24gaChsLHUsdCl7dmFyIGkscixvLGY9e307Zm9yKG8gaW4gdSlcImtleVwiPT1vP2k9dVtvXTpcInJlZlwiPT1vP3I9dVtvXTpmW29dPXVbb107aWYoYXJndW1lbnRzLmxlbmd0aD4yJiYoZi5jaGlsZHJlbj1hcmd1bWVudHMubGVuZ3RoPjM/bi5jYWxsKGFyZ3VtZW50cywyKTp0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBsJiZudWxsIT1sLmRlZmF1bHRQcm9wcylmb3IobyBpbiBsLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT1mW29dJiYoZltvXT1sLmRlZmF1bHRQcm9wc1tvXSk7cmV0dXJuIHAobCxmLGkscixudWxsKX1mdW5jdGlvbiBwKG4sdCxpLHIsbyl7dmFyIGY9e3R5cGU6bixwcm9wczp0LGtleTppLHJlZjpyLF9fazpudWxsLF9fOm51bGwsX19iOjAsX19lOm51bGwsX19kOnZvaWQgMCxfX2M6bnVsbCxfX2g6bnVsbCxjb25zdHJ1Y3Rvcjp2b2lkIDAsX192Om51bGw9PW8/Kyt1Om99O3JldHVybiBudWxsPT1vJiZudWxsIT1sLnZub2RlJiZsLnZub2RlKGYpLGZ9ZnVuY3Rpb24geShuKXtyZXR1cm4gbi5jaGlsZHJlbn1mdW5jdGlvbiBkKG4sbCl7dGhpcy5wcm9wcz1uLHRoaXMuY29udGV4dD1sfWZ1bmN0aW9uIF8obixsKXtpZihudWxsPT1sKXJldHVybiBuLl9fP18obi5fXyxuLl9fLl9fay5pbmRleE9mKG4pKzEpOm51bGw7Zm9yKHZhciB1O2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXJldHVybiB1Ll9fZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/XyhuKTpudWxsfWZ1bmN0aW9uIGsobil7dmFyIGwsdTtpZihudWxsIT0obj1uLl9fKSYmbnVsbCE9bi5fX2Mpe2ZvcihuLl9fZT1uLl9fYy5iYXNlPW51bGwsbD0wO2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXtuLl9fZT1uLl9fYy5iYXNlPXUuX19lO2JyZWFrfXJldHVybiBrKG4pfX1mdW5jdGlvbiB4KG4peyghbi5fX2QmJihuLl9fZD0hMCkmJmkucHVzaChuKSYmIWIuX19yKyt8fG8hPT1sLmRlYm91bmNlUmVuZGVyaW5nKSYmKChvPWwuZGVib3VuY2VSZW5kZXJpbmcpfHxyKShiKX1mdW5jdGlvbiBiKCl7Zm9yKHZhciBuO2IuX19yPWkubGVuZ3RoOyluPWkuc29ydChmdW5jdGlvbihuLGwpe3JldHVybiBuLl9fdi5fX2ItbC5fX3YuX19ifSksaT1bXSxuLnNvbWUoZnVuY3Rpb24obil7dmFyIGwsdSx0LGkscixvO24uX19kJiYocj0oaT0obD1uKS5fX3YpLl9fZSwobz1sLl9fUCkmJih1PVtdLCh0PWEoe30saSkpLl9fdj1pLl9fdisxLEkobyxpLHQsbC5fX24sdm9pZCAwIT09by5vd25lclNWR0VsZW1lbnQsbnVsbCE9aS5fX2g/W3JdOm51bGwsdSxudWxsPT1yP18oaSk6cixpLl9faCksVCh1LGkpLGkuX19lIT1yJiZrKGkpKSl9KX1mdW5jdGlvbiBtKG4sbCx1LHQsaSxyLG8sZixzLGEpe3ZhciB2LGgsZCxrLHgsYixtLEE9dCYmdC5fX2t8fGMsUD1BLmxlbmd0aDtmb3IodS5fX2s9W10sdj0wO3Y8bC5sZW5ndGg7disrKWlmKG51bGwhPShrPXUuX19rW3ZdPW51bGw9PShrPWxbdl0pfHxcImJvb2xlYW5cIj09dHlwZW9mIGs/bnVsbDpcInN0cmluZ1wiPT10eXBlb2Yga3x8XCJudW1iZXJcIj09dHlwZW9mIGt8fFwiYmlnaW50XCI9PXR5cGVvZiBrP3AobnVsbCxrLG51bGwsbnVsbCxrKTpBcnJheS5pc0FycmF5KGspP3AoeSx7Y2hpbGRyZW46a30sbnVsbCxudWxsLG51bGwpOmsuX19iPjA/cChrLnR5cGUsay5wcm9wcyxrLmtleSxudWxsLGsuX192KTprKSl7aWYoay5fXz11LGsuX19iPXUuX19iKzEsbnVsbD09PShkPUFbdl0pfHxkJiZrLmtleT09ZC5rZXkmJmsudHlwZT09PWQudHlwZSlBW3ZdPXZvaWQgMDtlbHNlIGZvcihoPTA7aDxQO2grKyl7aWYoKGQ9QVtoXSkmJmsua2V5PT1kLmtleSYmay50eXBlPT09ZC50eXBlKXtBW2hdPXZvaWQgMDticmVha31kPW51bGx9SShuLGssZD1kfHxlLGkscixvLGYscyxhKSx4PWsuX19lLChoPWsucmVmKSYmZC5yZWYhPWgmJihtfHwobT1bXSksZC5yZWYmJm0ucHVzaChkLnJlZixudWxsLGspLG0ucHVzaChoLGsuX19jfHx4LGspKSxudWxsIT14PyhudWxsPT1iJiYoYj14KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBrLnR5cGUmJmsuX19rPT09ZC5fX2s/ay5fX2Q9cz1nKGsscyxuKTpzPXcobixrLGQsQSx4LHMpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHUudHlwZSYmKHUuX19kPXMpKTpzJiZkLl9fZT09cyYmcy5wYXJlbnROb2RlIT1uJiYocz1fKGQpKX1mb3IodS5fX2U9Yix2PVA7di0tOyludWxsIT1BW3ZdJiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdS50eXBlJiZudWxsIT1BW3ZdLl9fZSYmQVt2XS5fX2U9PXUuX19kJiYodS5fX2Q9Xyh0LHYrMSkpLEwoQVt2XSxBW3ZdKSk7aWYobSlmb3Iodj0wO3Y8bS5sZW5ndGg7disrKXoobVt2XSxtWysrdl0sbVsrK3ZdKX1mdW5jdGlvbiBnKG4sbCx1KXtmb3IodmFyIHQsaT1uLl9fayxyPTA7aSYmcjxpLmxlbmd0aDtyKyspKHQ9aVtyXSkmJih0Ll9fPW4sbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnR5cGU/Zyh0LGwsdSk6dyh1LHQsdCxpLHQuX19lLGwpKTtyZXR1cm4gbH1mdW5jdGlvbiB3KG4sbCx1LHQsaSxyKXt2YXIgbyxmLGU7aWYodm9pZCAwIT09bC5fX2Qpbz1sLl9fZCxsLl9fZD12b2lkIDA7ZWxzZSBpZihudWxsPT11fHxpIT1yfHxudWxsPT1pLnBhcmVudE5vZGUpbjppZihudWxsPT1yfHxyLnBhcmVudE5vZGUhPT1uKW4uYXBwZW5kQ2hpbGQoaSksbz1udWxsO2Vsc2V7Zm9yKGY9cixlPTA7KGY9Zi5uZXh0U2libGluZykmJmU8dC5sZW5ndGg7ZSs9MilpZihmPT1pKWJyZWFrIG47bi5pbnNlcnRCZWZvcmUoaSxyKSxvPXJ9cmV0dXJuIHZvaWQgMCE9PW8/bzppLm5leHRTaWJsaW5nfWZ1bmN0aW9uIEEobixsLHUsdCxpKXt2YXIgcjtmb3IociBpbiB1KVwiY2hpbGRyZW5cIj09PXJ8fFwia2V5XCI9PT1yfHxyIGluIGx8fEMobixyLG51bGwsdVtyXSx0KTtmb3IociBpbiBsKWkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGxbcl18fFwiY2hpbGRyZW5cIj09PXJ8fFwia2V5XCI9PT1yfHxcInZhbHVlXCI9PT1yfHxcImNoZWNrZWRcIj09PXJ8fHVbcl09PT1sW3JdfHxDKG4scixsW3JdLHVbcl0sdCl9ZnVuY3Rpb24gUChuLGwsdSl7XCItXCI9PT1sWzBdP24uc2V0UHJvcGVydHkobCx1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8cy50ZXN0KGwpP3U6dStcInB4XCJ9ZnVuY3Rpb24gQyhuLGwsdSx0LGkpe3ZhciByO246aWYoXCJzdHlsZVwiPT09bClpZihcInN0cmluZ1wiPT10eXBlb2YgdSluLnN0eWxlLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYobi5zdHlsZS5jc3NUZXh0PXQ9XCJcIiksdClmb3IobCBpbiB0KXUmJmwgaW4gdXx8UChuLnN0eWxlLGwsXCJcIik7aWYodSlmb3IobCBpbiB1KXQmJnVbbF09PT10W2xdfHxQKG4uc3R5bGUsbCx1W2xdKX1lbHNlIGlmKFwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdKXI9bCE9PShsPWwucmVwbGFjZSgvQ2FwdHVyZSQvLFwiXCIpKSxsPWwudG9Mb3dlckNhc2UoKWluIG4/bC50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpOmwuc2xpY2UoMiksbi5sfHwobi5sPXt9KSxuLmxbbCtyXT11LHU/dHx8bi5hZGRFdmVudExpc3RlbmVyKGwscj9IOiQscik6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwscj9IOiQscik7ZWxzZSBpZihcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sKXtpZihpKWw9bC5yZXBsYWNlKC94bGlua1tIOmhdLyxcImhcIikucmVwbGFjZSgvc05hbWUkLyxcInNcIik7ZWxzZSBpZihcImhyZWZcIiE9PWwmJlwibGlzdFwiIT09bCYmXCJmb3JtXCIhPT1sJiZcInRhYkluZGV4XCIhPT1sJiZcImRvd25sb2FkXCIhPT1sJiZsIGluIG4pdHJ5e25bbF09bnVsbD09dT9cIlwiOnU7YnJlYWsgbn1jYXRjaChuKXt9XCJmdW5jdGlvblwiPT10eXBlb2YgdXx8KG51bGwhPXUmJighMSE9PXV8fFwiYVwiPT09bFswXSYmXCJyXCI9PT1sWzFdKT9uLnNldEF0dHJpYnV0ZShsLHUpOm4ucmVtb3ZlQXR0cmlidXRlKGwpKX19ZnVuY3Rpb24gJChuKXt0aGlzLmxbbi50eXBlKyExXShsLmV2ZW50P2wuZXZlbnQobik6bil9ZnVuY3Rpb24gSChuKXt0aGlzLmxbbi50eXBlKyEwXShsLmV2ZW50P2wuZXZlbnQobik6bil9ZnVuY3Rpb24gSShuLHUsdCxpLHIsbyxmLGUsYyl7dmFyIHMsdixoLHAsXyxrLHgsYixnLHcsQSxQPXUudHlwZTtpZih2b2lkIDAhPT11LmNvbnN0cnVjdG9yKXJldHVybiBudWxsO251bGwhPXQuX19oJiYoYz10Ll9faCxlPXUuX19lPXQuX19lLHUuX19oPW51bGwsbz1bZV0pLChzPWwuX19iKSYmcyh1KTt0cnl7bjppZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQKXtpZihiPXUucHJvcHMsZz0ocz1QLmNvbnRleHRUeXBlKSYmaVtzLl9fY10sdz1zP2c/Zy5wcm9wcy52YWx1ZTpzLl9fOmksdC5fX2M/eD0odj11Ll9fYz10Ll9fYykuX189di5fX0U6KFwicHJvdG90eXBlXCJpbiBQJiZQLnByb3RvdHlwZS5yZW5kZXI/dS5fX2M9dj1uZXcgUChiLHcpOih1Ll9fYz12PW5ldyBkKGIsdyksdi5jb25zdHJ1Y3Rvcj1QLHYucmVuZGVyPU0pLGcmJmcuc3ViKHYpLHYucHJvcHM9Yix2LnN0YXRlfHwodi5zdGF0ZT17fSksdi5jb250ZXh0PXcsdi5fX249aSxoPXYuX19kPSEwLHYuX19oPVtdKSxudWxsPT12Ll9fcyYmKHYuX19zPXYuc3RhdGUpLG51bGwhPVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiYodi5fX3M9PXYuc3RhdGUmJih2Ll9fcz1hKHt9LHYuX19zKSksYSh2Ll9fcyxQLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhiLHYuX19zKSkpLHA9di5wcm9wcyxfPXYuc3RhdGUsaCludWxsPT1QLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbCE9di5jb21wb25lbnRXaWxsTW91bnQmJnYuY29tcG9uZW50V2lsbE1vdW50KCksbnVsbCE9di5jb21wb25lbnREaWRNb3VudCYmdi5fX2gucHVzaCh2LmNvbXBvbmVudERpZE1vdW50KTtlbHNle2lmKG51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZiIT09cCYmbnVsbCE9di5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZ2LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoYix3KSwhdi5fX2UmJm51bGwhPXYuc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PXYuc2hvdWxkQ29tcG9uZW50VXBkYXRlKGIsdi5fX3Msdyl8fHUuX192PT09dC5fX3Ype3YucHJvcHM9Yix2LnN0YXRlPXYuX19zLHUuX192IT09dC5fX3YmJih2Ll9fZD0hMSksdi5fX3Y9dSx1Ll9fZT10Ll9fZSx1Ll9faz10Ll9fayx1Ll9fay5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJihuLl9fPXUpfSksdi5fX2gubGVuZ3RoJiZmLnB1c2godik7YnJlYWsgbn1udWxsIT12LmNvbXBvbmVudFdpbGxVcGRhdGUmJnYuY29tcG9uZW50V2lsbFVwZGF0ZShiLHYuX19zLHcpLG51bGwhPXYuY29tcG9uZW50RGlkVXBkYXRlJiZ2Ll9faC5wdXNoKGZ1bmN0aW9uKCl7di5jb21wb25lbnREaWRVcGRhdGUocCxfLGspfSl9di5jb250ZXh0PXcsdi5wcm9wcz1iLHYuc3RhdGU9di5fX3MsKHM9bC5fX3IpJiZzKHUpLHYuX19kPSExLHYuX192PXUsdi5fX1A9bixzPXYucmVuZGVyKHYucHJvcHMsdi5zdGF0ZSx2LmNvbnRleHQpLHYuc3RhdGU9di5fX3MsbnVsbCE9di5nZXRDaGlsZENvbnRleHQmJihpPWEoYSh7fSxpKSx2LmdldENoaWxkQ29udGV4dCgpKSksaHx8bnVsbD09di5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8KGs9di5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwLF8pKSxBPW51bGwhPXMmJnMudHlwZT09PXkmJm51bGw9PXMua2V5P3MucHJvcHMuY2hpbGRyZW46cyxtKG4sQXJyYXkuaXNBcnJheShBKT9BOltBXSx1LHQsaSxyLG8sZixlLGMpLHYuYmFzZT11Ll9fZSx1Ll9faD1udWxsLHYuX19oLmxlbmd0aCYmZi5wdXNoKHYpLHgmJih2Ll9fRT12Ll9fPW51bGwpLHYuX19lPSExfWVsc2UgbnVsbD09byYmdS5fX3Y9PT10Ll9fdj8odS5fX2s9dC5fX2ssdS5fX2U9dC5fX2UpOnUuX19lPWoodC5fX2UsdSx0LGkscixvLGYsYyk7KHM9bC5kaWZmZWQpJiZzKHUpfWNhdGNoKG4pe3UuX192PW51bGwsKGN8fG51bGwhPW8pJiYodS5fX2U9ZSx1Ll9faD0hIWMsb1tvLmluZGV4T2YoZSldPW51bGwpLGwuX19lKG4sdSx0KX19ZnVuY3Rpb24gVChuLHUpe2wuX19jJiZsLl9fYyh1LG4pLG4uc29tZShmdW5jdGlvbih1KXt0cnl7bj11Ll9faCx1Ll9faD1bXSxuLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpfSl9Y2F0Y2gobil7bC5fX2Uobix1Ll9fdil9fSl9ZnVuY3Rpb24gaihsLHUsdCxpLHIsbyxmLGMpe3ZhciBzLGEsaCxwPXQucHJvcHMseT11LnByb3BzLGQ9dS50eXBlLGs9MDtpZihcInN2Z1wiPT09ZCYmKHI9ITApLG51bGwhPW8pZm9yKDtrPG8ubGVuZ3RoO2srKylpZigocz1vW2tdKSYmKHM9PT1sfHwoZD9zLmxvY2FsTmFtZT09ZDozPT1zLm5vZGVUeXBlKSkpe2w9cyxvW2tdPW51bGw7YnJlYWt9aWYobnVsbD09bCl7aWYobnVsbD09PWQpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHkpO2w9cj9kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLGQpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZCx5LmlzJiZ5KSxvPW51bGwsYz0hMX1pZihudWxsPT09ZClwPT09eXx8YyYmbC5kYXRhPT09eXx8KGwuZGF0YT15KTtlbHNle2lmKG89byYmbi5jYWxsKGwuY2hpbGROb2RlcyksYT0ocD10LnByb3BzfHxlKS5kYW5nZXJvdXNseVNldElubmVySFRNTCxoPXkuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIWMpe2lmKG51bGwhPW8pZm9yKHA9e30saz0wO2s8bC5hdHRyaWJ1dGVzLmxlbmd0aDtrKyspcFtsLmF0dHJpYnV0ZXNba10ubmFtZV09bC5hdHRyaWJ1dGVzW2tdLnZhbHVlOyhofHxhKSYmKGgmJihhJiZoLl9faHRtbD09YS5fX2h0bWx8fGguX19odG1sPT09bC5pbm5lckhUTUwpfHwobC5pbm5lckhUTUw9aCYmaC5fX2h0bWx8fFwiXCIpKX1pZihBKGwseSxwLHIsYyksaCl1Ll9faz1bXTtlbHNlIGlmKGs9dS5wcm9wcy5jaGlsZHJlbixtKGwsQXJyYXkuaXNBcnJheShrKT9rOltrXSx1LHQsaSxyJiZcImZvcmVpZ25PYmplY3RcIiE9PWQsbyxmLG8/b1swXTp0Ll9fayYmXyh0LDApLGMpLG51bGwhPW8pZm9yKGs9by5sZW5ndGg7ay0tOyludWxsIT1vW2tdJiZ2KG9ba10pO2N8fChcInZhbHVlXCJpbiB5JiZ2b2lkIDAhPT0oaz15LnZhbHVlKSYmKGshPT1sLnZhbHVlfHxcInByb2dyZXNzXCI9PT1kJiYhaykmJkMobCxcInZhbHVlXCIsayxwLnZhbHVlLCExKSxcImNoZWNrZWRcImluIHkmJnZvaWQgMCE9PShrPXkuY2hlY2tlZCkmJmshPT1sLmNoZWNrZWQmJkMobCxcImNoZWNrZWRcIixrLHAuY2hlY2tlZCwhMSkpfXJldHVybiBsfWZ1bmN0aW9uIHoobix1LHQpe3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24odSk6bi5jdXJyZW50PXV9Y2F0Y2gobil7bC5fX2Uobix0KX19ZnVuY3Rpb24gTChuLHUsdCl7dmFyIGkscjtpZihsLnVubW91bnQmJmwudW5tb3VudChuKSwoaT1uLnJlZikmJihpLmN1cnJlbnQmJmkuY3VycmVudCE9PW4uX19lfHx6KGksbnVsbCx1KSksbnVsbCE9KGk9bi5fX2MpKXtpZihpLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtpLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobil7bC5fX2Uobix1KX1pLmJhc2U9aS5fX1A9bnVsbH1pZihpPW4uX19rKWZvcihyPTA7cjxpLmxlbmd0aDtyKyspaVtyXSYmTChpW3JdLHUsXCJmdW5jdGlvblwiIT10eXBlb2Ygbi50eXBlKTt0fHxudWxsPT1uLl9fZXx8dihuLl9fZSksbi5fX2U9bi5fX2Q9dm9pZCAwfWZ1bmN0aW9uIE0obixsLHUpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yKG4sdSl9ZnVuY3Rpb24gTih1LHQsaSl7dmFyIHIsbyxmO2wuX18mJmwuX18odSx0KSxvPShyPVwiZnVuY3Rpb25cIj09dHlwZW9mIGkpP251bGw6aSYmaS5fX2t8fHQuX19rLGY9W10sSSh0LHU9KCFyJiZpfHx0KS5fX2s9aCh5LG51bGwsW3VdKSxvfHxlLGUsdm9pZCAwIT09dC5vd25lclNWR0VsZW1lbnQsIXImJmk/W2ldOm8/bnVsbDp0LmZpcnN0Q2hpbGQ/bi5jYWxsKHQuY2hpbGROb2Rlcyk6bnVsbCxmLCFyJiZpP2k6bz9vLl9fZTp0LmZpcnN0Q2hpbGQsciksVChmLHUpfW49Yy5zbGljZSxsPXtfX2U6ZnVuY3Rpb24obixsKXtmb3IodmFyIHUsdCxpO2w9bC5fXzspaWYoKHU9bC5fX2MpJiYhdS5fXyl0cnl7aWYoKHQ9dS5jb25zdHJ1Y3RvcikmJm51bGwhPXQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYodS5zZXRTdGF0ZSh0LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSksaT11Ll9fZCksbnVsbCE9dS5jb21wb25lbnREaWRDYXRjaCYmKHUuY29tcG9uZW50RGlkQ2F0Y2gobiksaT11Ll9fZCksaSlyZXR1cm4gdS5fX0U9dX1jYXRjaChsKXtuPWx9dGhyb3cgbn19LHU9MCx0PWZ1bmN0aW9uKG4pe3JldHVybiBudWxsIT1uJiZ2b2lkIDA9PT1uLmNvbnN0cnVjdG9yfSxkLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1O3U9bnVsbCE9dGhpcy5fX3MmJnRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1hKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4oYSh7fSx1KSx0aGlzLnByb3BzKSksbiYmYSh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYobCYmdGhpcy5fX2gucHVzaChsKSx4KHRoaXMpKX0sZC5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5fX3YmJih0aGlzLl9fZT0hMCxuJiZ0aGlzLl9faC5wdXNoKG4pLHgodGhpcykpfSxkLnByb3RvdHlwZS5yZW5kZXI9eSxpPVtdLHI9XCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpOnNldFRpbWVvdXQsYi5fX3I9MCxmPTAsZXhwb3J0cy5yZW5kZXI9TixleHBvcnRzLmh5ZHJhdGU9ZnVuY3Rpb24gbihsLHUpe04obCx1LG4pfSxleHBvcnRzLmNyZWF0ZUVsZW1lbnQ9aCxleHBvcnRzLmg9aCxleHBvcnRzLkZyYWdtZW50PXksZXhwb3J0cy5jcmVhdGVSZWY9ZnVuY3Rpb24oKXtyZXR1cm57Y3VycmVudDpudWxsfX0sZXhwb3J0cy5pc1ZhbGlkRWxlbWVudD10LGV4cG9ydHMuQ29tcG9uZW50PWQsZXhwb3J0cy5jbG9uZUVsZW1lbnQ9ZnVuY3Rpb24obCx1LHQpe3ZhciBpLHIsbyxmPWEoe30sbC5wcm9wcyk7Zm9yKG8gaW4gdSlcImtleVwiPT1vP2k9dVtvXTpcInJlZlwiPT1vP3I9dVtvXTpmW29dPXVbb107cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MiYmKGYuY2hpbGRyZW49YXJndW1lbnRzLmxlbmd0aD4zP24uY2FsbChhcmd1bWVudHMsMik6dCkscChsLnR5cGUsZixpfHxsLmtleSxyfHxsLnJlZixudWxsKX0sZXhwb3J0cy5jcmVhdGVDb250ZXh0PWZ1bmN0aW9uKG4sbCl7dmFyIHU9e19fYzpsPVwiX19jQ1wiK2YrKyxfXzpuLENvbnN1bWVyOmZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uY2hpbGRyZW4obCl9LFByb3ZpZGVyOmZ1bmN0aW9uKG4pe3ZhciB1LHQ7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0fHwodT1bXSwodD17fSlbbF09dGhpcyx0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiB0fSx0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLnByb3BzLnZhbHVlIT09bi52YWx1ZSYmdS5zb21lKHgpfSx0aGlzLnN1Yj1mdW5jdGlvbihuKXt1LnB1c2gobik7dmFyIGw9bi5jb21wb25lbnRXaWxsVW5tb3VudDtuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dS5zcGxpY2UodS5pbmRleE9mKG4pLDEpLGwmJmwuY2FsbChuKX19KSxuLmNoaWxkcmVufX07cmV0dXJuIHUuUHJvdmlkZXIuX189dS5Db25zdW1lci5jb250ZXh0VHlwZT11fSxleHBvcnRzLnRvQ2hpbGRBcnJheT1mdW5jdGlvbiBuKGwsdSl7cmV0dXJuIHU9dXx8W10sbnVsbD09bHx8XCJib29sZWFuXCI9PXR5cGVvZiBsfHwoQXJyYXkuaXNBcnJheShsKT9sLnNvbWUoZnVuY3Rpb24obCl7bihsLHUpfSk6dS5wdXNoKGwpKSx1fSxleHBvcnRzLm9wdGlvbnM9bDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5qcy5tYXBcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgdW5kZWY7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGVuY29kZSBhIGdpdmVuIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGVuY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/IyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAvL1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBlbmNvZGUoa2V5KTtcbiAgICAgIHZhbHVlID0gZW5jb2RlKHZhbHVlKTtcblxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBlbmNvZGUgdGhlIHN0cmluZ3MsIHdlIHNob3VsZCBiYWlsIG91dCBhcyB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBhZGQgaW52YWxpZCBzdHJpbmdzIHRvIHRoZSBxdWVyeS5cbiAgICAgIC8vXG4gICAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsnPScrIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9pc1JlYWN0TmF0aXZlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1JlYWN0TmF0aXZlXCIpKTtcblxudmFyIF91cmlUb0Jsb2IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3VyaVRvQmxvYlwiKSk7XG5cbnZhciBfaXNDb3Jkb3ZhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0NvcmRvdmFcIikpO1xuXG52YXIgX3JlYWRBc0J5dGVBcnJheSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVhZEFzQnl0ZUFycmF5XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgRmlsZVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIE1ha2UgdGhpcy5zaXplIGEgbWV0aG9kXG4gIGZ1bmN0aW9uIEZpbGVTb3VyY2UoZmlsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlU291cmNlKTtcblxuICAgIHRoaXMuX2ZpbGUgPSBmaWxlO1xuICAgIHRoaXMuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWxlU291cmNlLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAvLyBJbiBBcGFjaGUgQ29yZG92YSBhcHBsaWNhdGlvbnMsIGEgRmlsZSBtdXN0IGJlIHJlc29sdmVkIHVzaW5nXG4gICAgICAvLyBGaWxlUmVhZGVyIGluc3RhbmNlcywgc2VlXG4gICAgICAvLyBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuLzgueC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gICAgICBpZiAoKDAsIF9pc0NvcmRvdmEuZGVmYXVsdCkoKSkge1xuICAgICAgICByZXR1cm4gKDAsIF9yZWFkQXNCeXRlQXJyYXkuZGVmYXVsdCkodGhpcy5fZmlsZS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHsvLyBOb3RoaW5nIHRvIGRvIGhlcmUgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMuXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVTb3VyY2U7XG59KCk7XG5cbnZhciBTdHJlYW1Tb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJlYW1Tb3VyY2UocmVhZGVyLCBjaHVua1NpemUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyZWFtU291cmNlKTtcblxuICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICB0aGlzLl9idWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmVhbVNvdXJjZSwgW3tcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5fYnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgZGF0YSBpcyBiZWZvcmUgdGhlIHJlYWRlcidzIGN1cnJlbnQgb2Zmc2V0XCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBoYXNFbm91Z2hEYXRhID0gZW5kIDw9IHRoaXMuX2J1ZmZlck9mZnNldCArIGxlbih0aGlzLl9idWZmZXIpO1xuXG4gICAgICBpZiAodGhpcy5fZG9uZSB8fCBoYXNFbm91Z2hEYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldERhdGFGcm9tQnVmZmVyKHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIHZhciBkb25lID0gdmFsdWUgPT0gbnVsbCA/IHRoaXMuX2RvbmUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgICAgIGRvbmUgPSBfcmVmLmRvbmU7XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBfdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuX2J1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMuX2J1ZmZlciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9idWZmZXIgPSBjb25jYXQoX3RoaXMuX2J1ZmZlciwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREYXRhRnJvbUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGF0YUZyb21CdWZmZXIoc3RhcnQsIGVuZCkge1xuICAgICAgLy8gUmVtb3ZlIGRhdGEgZnJvbSBidWZmZXIgYmVmb3JlIGBzdGFydGAuXG4gICAgICAvLyBEYXRhIG1pZ2h0IGJlIHJlcmVhZCBmcm9tIHRoZSBidWZmZXIgaWYgYW4gdXBsb2FkIGZhaWxzLCBzbyB3ZSBjYW4gb25seVxuICAgICAgLy8gc2FmZWx5IGRlbGV0ZSBkYXRhIHdoZW4gaXQgY29tZXMgKmJlZm9yZSogd2hhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC5cbiAgICAgIGlmIChzdGFydCA+IHRoaXMuX2J1ZmZlck9mZnNldCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2Uoc3RhcnQgLSB0aGlzLl9idWZmZXJPZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSBzdGFydDtcbiAgICAgIH0gLy8gSWYgdGhlIGJ1ZmZlciBpcyBlbXB0eSBhZnRlciByZW1vdmluZyBvbGQgZGF0YSwgYWxsIGRhdGEgaGFzIGJlZW4gcmVhZC5cblxuXG4gICAgICB2YXIgaGFzQWxsRGF0YUJlZW5SZWFkID0gbGVuKHRoaXMuX2J1ZmZlcikgPT09IDA7XG5cbiAgICAgIGlmICh0aGlzLl9kb25lICYmIGhhc0FsbERhdGFCZWVuUmVhZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gV2UgYWxyZWFkeSByZW1vdmVkIGRhdGEgYmVmb3JlIGBzdGFydGAsIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmaXJzdFxuICAgICAgLy8gY2h1bmsgZnJvbSB0aGUgYnVmZmVyLlxuXG5cbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuc2xpY2UoMCwgZW5kIC0gc3RhcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkZXIuY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyZWFtU291cmNlO1xufSgpO1xuXG5mdW5jdGlvbiBsZW4oYmxvYk9yQXJyYXkpIHtcbiAgaWYgKGJsb2JPckFycmF5ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICBpZiAoYmxvYk9yQXJyYXkuc2l6ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYmxvYk9yQXJyYXkuc2l6ZTtcbiAgcmV0dXJuIGJsb2JPckFycmF5Lmxlbmd0aDtcbn1cbi8qXG4gIFR5cGVkIGFycmF5cyBhbmQgYmxvYnMgZG9uJ3QgaGF2ZSBhIGNvbmNhdCBtZXRob2QuXG4gIFRoaXMgZnVuY3Rpb24gaGVscHMgU3RyZWFtU291cmNlIGFjY3VtdWxhdGUgZGF0YSB0byByZWFjaCBjaHVua1NpemUuXG4qL1xuXG5cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGlmIChhLmNvbmNhdCkge1xuICAgIC8vIElzIGBhYCBhbiBBcnJheT9cbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW2EsIGJdLCB7XG4gICAgICB0eXBlOiBhLnR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhLnNldCkge1xuICAgIC8vIElzIGBhYCBhIHR5cGVkIGFycmF5P1xuICAgIHZhciBjID0gbmV3IGEuY29uc3RydWN0b3IoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgYy5zZXQoYSk7XG4gICAgYy5zZXQoYiwgYS5sZW5ndGgpO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGEgdHlwZScpO1xufVxuXG52YXIgRmlsZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbGVSZWFkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVSZWFkZXIsIFt7XG4gICAga2V5OiBcIm9wZW5GaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5GaWxlKGlucHV0LCBjaHVua1NpemUpIHtcbiAgICAgIC8vIEluIFJlYWN0IE5hdGl2ZSwgd2hlbiB1c2VyIHNlbGVjdHMgYSBmaWxlLCBpbnN0ZWFkIG9mIGEgRmlsZSBvciBCbG9iLFxuICAgICAgLy8geW91IHVzdWFsbHkgZ2V0IGEgZmlsZSBvYmplY3Qge30gd2l0aCBhIHVyaSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyBhIGxvY2FsIHBhdGggdG8gdGhlIGZpbGUuIFdlIHVzZSBYTUxIdHRwUmVxdWVzdCB0byBmZXRjaFxuICAgICAgLy8gdGhlIGZpbGUgYmxvYiwgYmVmb3JlIHVwbG9hZGluZyB3aXRoIHR1cy5cbiAgICAgIGlmICgoMCwgX2lzUmVhY3ROYXRpdmUuZGVmYXVsdCkoKSAmJiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQudXJpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gKDAsIF91cmlUb0Jsb2IuZGVmYXVsdCkoaW5wdXQudXJpKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGaWxlU291cmNlKGJsb2IpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBmZXRjaCBgZmlsZS51cmlgIGFzIEJsb2IsIG1ha2Ugc3VyZSB0aGUgdXJpIGlzIGNvcnJlY3QgYW5kIGFjY2Vzc2libGUuIFwiLmNvbmNhdChlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFNpbmNlIHdlIGVtdWxhdGUgdGhlIEJsb2IgdHlwZSBpbiBvdXIgdGVzdHMgKG5vdCBhbGwgdGFyZ2V0IGJyb3dzZXJzXG4gICAgICAvLyBzdXBwb3J0IGl0KSwgd2UgY2Fubm90IHVzZSBgaW5zdGFuY2VvZmAgZm9yIHRlc3Rpbmcgd2hldGhlciB0aGUgaW5wdXQgdmFsdWVcbiAgICAgIC8vIGNhbiBiZSBoYW5kbGVkLiBJbnN0ZWFkLCB3ZSBzaW1wbHkgY2hlY2sgaXMgdGhlIHNsaWNlKCkgZnVuY3Rpb24gYW5kIHRoZVxuICAgICAgLy8gc2l6ZSBwcm9wZXJ0eSBhcmUgYXZhaWxhYmxlLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQuc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGlucHV0LnNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEZpbGVTb3VyY2UoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dC5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNodW5rU2l6ZSA9ICtjaHVua1NpemU7XG5cbiAgICAgICAgaWYgKCFpc0Zpbml0ZShjaHVua1NpemUpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNyZWF0ZSBzb3VyY2UgZm9yIHN0cmVhbSB3aXRob3V0IGEgZmluaXRlIHZhbHVlIGZvciB0aGUgYGNodW5rU2l6ZWAgb3B0aW9uJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU3RyZWFtU291cmNlKGlucHV0LCBjaHVua1NpemUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignc291cmNlIG9iamVjdCBtYXkgb25seSBiZSBhbiBpbnN0YW5jZSBvZiBGaWxlLCBCbG9iLCBvciBSZWFkZXIgaW4gdGhpcyBlbnZpcm9ubWVudCcpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZVJlYWRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmlsZVJlYWRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmdlcnByaW50O1xuXG52YXIgX2lzUmVhY3ROYXRpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzUmVhY3ROYXRpdmVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBUT0RPOiBEaWZmZXJlbmNpYXRlIGJldHdlZW4gaW5wdXQgdHlwZXNcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZpbmdlcnByaW50IGZvciBhIGZpbGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRoZSBzdG9yZSB0aGUgZW5kcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0ZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSB7XG4gIGlmICgoMCwgX2lzUmVhY3ROYXRpdmUuZGVmYXVsdCkoKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhY3ROYXRpdmVGaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFsndHVzLWJyJywgZmlsZS5uYW1lLCBmaWxlLnR5cGUsIGZpbGUuc2l6ZSwgZmlsZS5sYXN0TW9kaWZpZWQsIG9wdGlvbnMuZW5kcG9pbnRdLmpvaW4oJy0nKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWN0TmF0aXZlRmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucykge1xuICB2YXIgZXhpZkhhc2ggPSBmaWxlLmV4aWYgPyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShmaWxlLmV4aWYpKSA6ICdub2V4aWYnO1xuICByZXR1cm4gWyd0dXMtcm4nLCBmaWxlLm5hbWUgfHwgJ25vbmFtZScsIGZpbGUuc2l6ZSB8fCAnbm9zaXplJywgZXhpZkhhc2gsIG9wdGlvbnMuZW5kcG9pbnRdLmpvaW4oJy8nKTtcbn1cblxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIC8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4MzE5MzcvMTUxNjY2XG4gIHZhciBoYXNoID0gMDtcblxuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBfY2hhcjtcbiAgICBoYXNoICY9IGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG52YXIgWEhSSHR0cFN0YWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEhSSHR0cFN0YWNrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYSFJIdHRwU3RhY2spO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFhIUkh0dHBTdGFjaywgW3tcbiAgICBrZXk6IFwiY3JlYXRlUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICByZXR1cm4gJ1hIUkh0dHBTdGFjayc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFhIUkh0dHBTdGFjaztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gWEhSSHR0cFN0YWNrO1xuXG52YXIgUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVxdWVzdCk7XG5cbiAgICB0aGlzLl94aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHRoaXMuX3hoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5faGVhZGVycyA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlcXVlc3QsIFt7XG4gICAga2V5OiBcImdldE1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRob2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0aG9kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVUkxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VVJMKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhlYWRlcihoZWFkZXIsIHZhbHVlKSB7XG4gICAgICB0aGlzLl94aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcblxuICAgICAgdGhpcy5faGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9ncmVzc0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvZ3Jlc3NIYW5kbGVyKHByb2dyZXNzSGFuZGxlcikge1xuICAgICAgLy8gVGVzdCBzdXBwb3J0IGZvciBwcm9ncmVzcyBldmVudHMgYmVmb3JlIGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgaWYgKCEoJ3VwbG9hZCcgaW4gdGhpcy5feGhyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3hoci51cGxvYWQub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKGUubG9hZGVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuX3hoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoX3RoaXMuX3hocikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLl94aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5feGhyLnNlbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICB0aGlzLl94aHIuYWJvcnQoKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVbmRlcmx5aW5nT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuZGVybHlpbmdPYmplY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXF1ZXN0O1xufSgpO1xuXG52YXIgUmVzcG9uc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXNwb25zZSh4aHIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2UpO1xuXG4gICAgdGhpcy5feGhyID0geGhyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNlLCBbe1xuICAgIGtleTogXCJnZXRTdGF0dXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5zdGF0dXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVbmRlcmx5aW5nT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuZGVybHlpbmdPYmplY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNwb25zZTtcbn0oKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuYWJsZURlYnVnTG9nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9sb2dnZXIuZW5hYmxlRGVidWdMb2c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FuU3RvcmVVUkxzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91cmxTdG9yYWdlLmNhblN0b3JlVVJMcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdHRwU3RhY2tcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2h0dHBTdGFjay5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5VcGxvYWQgPSB2b2lkIDA7XG5cbnZhciBfdXBsb2FkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXBsb2FkXCIpKTtcblxudmFyIF9ub29wVXJsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vb3BVcmxTdG9yYWdlXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xuXG52YXIgX3VybFN0b3JhZ2UgPSByZXF1aXJlKFwiLi91cmxTdG9yYWdlXCIpO1xuXG52YXIgX2h0dHBTdGFjayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaHR0cFN0YWNrXCIpKTtcblxudmFyIF9maWxlUmVhZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9maWxlUmVhZGVyXCIpKTtcblxudmFyIF9maW5nZXJwcmludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmluZ2VycHJpbnRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG4vKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgX3VwbG9hZC5kZWZhdWx0LmRlZmF1bHRPcHRpb25zLCB7XG4gIGh0dHBTdGFjazogbmV3IF9odHRwU3RhY2suZGVmYXVsdCgpLFxuICBmaWxlUmVhZGVyOiBuZXcgX2ZpbGVSZWFkZXIuZGVmYXVsdCgpLFxuICB1cmxTdG9yYWdlOiBfdXJsU3RvcmFnZS5jYW5TdG9yZVVSTHMgPyBuZXcgX3VybFN0b3JhZ2UuV2ViU3RvcmFnZVVybFN0b3JhZ2UoKSA6IG5ldyBfbm9vcFVybFN0b3JhZ2UuZGVmYXVsdCgpLFxuICBmaW5nZXJwcmludDogX2ZpbmdlcnByaW50LmRlZmF1bHRcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG5cbnZhciBVcGxvYWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlVXBsb2FkKSB7XG4gIF9pbmhlcml0cyhVcGxvYWQsIF9CYXNlVXBsb2FkKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFVwbG9hZCk7XG5cbiAgZnVuY3Rpb24gVXBsb2FkKCkge1xuICAgIHZhciBmaWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVcGxvYWQpO1xuXG4gICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLCB7fSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZpbGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFVwbG9hZCwgbnVsbCwgW3tcbiAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSh1cmwsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMsIHt9LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBfdXBsb2FkLmRlZmF1bHQudGVybWluYXRlKHVybCwgb3B0aW9ucywgY2IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVcGxvYWQ7XG59KF91cGxvYWQuZGVmYXVsdCk7XG5cbmV4cG9ydHMuVXBsb2FkID0gVXBsb2FkO1xudmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgWE1MSHR0cFJlcXVlc3QgPSBfd2luZG93LlhNTEh0dHBSZXF1ZXN0LFxuICAgIEJsb2IgPSBfd2luZG93LkJsb2I7XG52YXIgaXNTdXBwb3J0ZWQgPSBYTUxIdHRwUmVxdWVzdCAmJiBCbG9iICYmIHR5cGVvZiBCbG9iLnByb3RvdHlwZS5zbGljZSA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIGlzQ29yZG92YSA9IGZ1bmN0aW9uIGlzQ29yZG92YSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiB3aW5kb3cuUGhvbmVHYXAgIT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5Db3Jkb3ZhICE9ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuY29yZG92YSAhPSAndW5kZWZpbmVkJyk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpc0NvcmRvdmE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIGlzUmVhY3ROYXRpdmUgPSBmdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnO1xufTtcblxudmFyIF9kZWZhdWx0ID0gaXNSZWFjdE5hdGl2ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVhZEFzQnl0ZUFycmF5O1xuXG4vKipcbiAqIHJlYWRBc0J5dGVBcnJheSBjb252ZXJ0cyBhIEZpbGUgb2JqZWN0IHRvIGEgVWludDhBcnJheS5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIG9uIHRoZSBBcGFjaGUgQ29yZG92YSBwbGF0Zm9ybS5cbiAqIFNlZSBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuL2xhdGVzdC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gKi9cbmZ1bmN0aW9uIHJlYWRBc0J5dGVBcnJheShjaHVuaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQpO1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfTtcblxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihjaHVuayk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXJpVG9CbG9iO1xuXG4vKipcbiAqIHVyaVRvQmxvYiByZXNvbHZlcyBhIFVSSSB0byBhIEJsb2Igb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yXG4gKiBSZWFjdCBOYXRpdmUgdG8gcmV0cmlldmUgYSBmaWxlIChpZGVudGlmaWVkIGJ5IGEgZmlsZTovL1xuICogVVJJKSBhcyBhIGJsb2IuXG4gKi9cbmZ1bmN0aW9uIHVyaVRvQmxvYih1cmkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYmxvYiA9IHhoci5yZXNwb25zZTtcbiAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgfTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCB1cmkpO1xuICAgIHhoci5zZW5kKCk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5XZWJTdG9yYWdlVXJsU3RvcmFnZSA9IGV4cG9ydHMuY2FuU3RvcmVVUkxzID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBnbG9iYWwgd2luZG93LCBsb2NhbFN0b3JhZ2UgKi9cblxuXG52YXIgaGFzU3RvcmFnZSA9IGZhbHNlO1xuXG50cnkge1xuICBoYXNTdG9yYWdlID0gJ2xvY2FsU3RvcmFnZScgaW4gd2luZG93OyAvLyBBdHRlbXB0IHRvIHN0b3JlIGFuZCByZWFkIGVudHJpZXMgZnJvbSB0aGUgbG9jYWwgc3RvcmFnZSB0byBkZXRlY3QgUHJpdmF0ZVxuICAvLyBNb2RlIG9uIFNhZmFyaSBvbiBpT1MgKHNlZSAjNDkpXG5cbiAgdmFyIGtleSA9ICd0dXNTdXBwb3J0JztcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gSWYgd2UgdHJ5IHRvIGFjY2VzcyBsb2NhbFN0b3JhZ2UgaW5zaWRlIGEgc2FuZGJveGVkIGlmcmFtZSwgYSBTZWN1cml0eUVycm9yXG4gIC8vIGlzIHRocm93bi4gV2hlbiBpbiBwcml2YXRlIG1vZGUgb24gaU9TIFNhZmFyaSwgYSBRdW90YUV4Y2VlZGVkRXJyb3IgaXNcbiAgLy8gdGhyb3duIChzZWUgIzQ5KVxuICBpZiAoZS5jb2RlID09PSBlLlNFQ1VSSVRZX0VSUiB8fCBlLmNvZGUgPT09IGUuUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgaGFzU3RvcmFnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxudmFyIGNhblN0b3JlVVJMcyA9IGhhc1N0b3JhZ2U7XG5leHBvcnRzLmNhblN0b3JlVVJMcyA9IGNhblN0b3JlVVJMcztcblxudmFyIFdlYlN0b3JhZ2VVcmxTdG9yYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViU3RvcmFnZVVybFN0b3JhZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYlN0b3JhZ2VVcmxTdG9yYWdlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJTdG9yYWdlVXJsU3RvcmFnZSwgW3tcbiAgICBrZXk6IFwiZmluZEFsbFVwbG9hZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFsbFVwbG9hZHMoKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuX2ZpbmRFbnRyaWVzKCd0dXM6OicpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuX2ZpbmRFbnRyaWVzKFwidHVzOjpcIi5jb25jYXQoZmluZ2VycHJpbnQsIFwiOjpcIikpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVXBsb2FkKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHVybFN0b3JhZ2VLZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVXBsb2FkKGZpbmdlcnByaW50LCB1cGxvYWQpIHtcbiAgICAgIHZhciBpZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTIpO1xuICAgICAgdmFyIGtleSA9IFwidHVzOjpcIi5jb25jYXQoZmluZ2VycHJpbnQsIFwiOjpcIikuY29uY2F0KGlkKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodXBsb2FkKSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kRW50cmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEVudHJpZXMocHJlZml4KSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2tleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG5cbiAgICAgICAgaWYgKF9rZXkuaW5kZXhPZihwcmVmaXgpICE9PSAwKSBjb250aW51ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB1cGxvYWQgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKF9rZXkpKTtcbiAgICAgICAgICB1cGxvYWQudXJsU3RvcmFnZUtleSA9IF9rZXk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHVwbG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBUaGUgSlNPTiBwYXJzZSBlcnJvciBpcyBpbnRlbnRpb25hbGx5IGlnbm9yZWQgaGVyZSwgc28gYSBtYWxmb3JtZWRcbiAgICAgICAgICAvLyBlbnRyeSBpbiB0aGUgc3RvcmFnZSBjYW5ub3QgcHJldmVudCBhbiB1cGxvYWQuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYlN0b3JhZ2VVcmxTdG9yYWdlO1xufSgpO1xuXG5leHBvcnRzLldlYlN0b3JhZ2VVcmxTdG9yYWdlID0gV2ViU3RvcmFnZVVybFN0b3JhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG52YXIgRGV0YWlsZWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhEZXRhaWxlZEVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGV0YWlsZWRFcnJvcik7XG5cbiAgZnVuY3Rpb24gRGV0YWlsZWRFcnJvcihtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGNhdXNpbmdFcnIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgdmFyIHJlcSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERldGFpbGVkRXJyb3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBfdGhpcy5vcmlnaW5hbFJlcXVlc3QgPSByZXE7XG4gICAgX3RoaXMub3JpZ2luYWxSZXNwb25zZSA9IHJlcztcbiAgICBfdGhpcy5jYXVzaW5nRXJyb3IgPSBjYXVzaW5nRXJyO1xuXG4gICAgaWYgKGNhdXNpbmdFcnIgIT0gbnVsbCkge1xuICAgICAgbWVzc2FnZSArPSBcIiwgY2F1c2VkIGJ5IFwiLmNvbmNhdChjYXVzaW5nRXJyLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmIChyZXEgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlcXVlc3RJZCA9IHJlcS5nZXRIZWFkZXIoJ1gtUmVxdWVzdC1JRCcpIHx8ICduL2EnO1xuICAgICAgdmFyIG1ldGhvZCA9IHJlcS5nZXRNZXRob2QoKTtcbiAgICAgIHZhciB1cmwgPSByZXEuZ2V0VVJMKCk7XG4gICAgICB2YXIgc3RhdHVzID0gcmVzID8gcmVzLmdldFN0YXR1cygpIDogJ24vYSc7XG4gICAgICB2YXIgYm9keSA9IHJlcyA/IHJlcy5nZXRCb2R5KCkgfHwgJycgOiAnbi9hJztcbiAgICAgIG1lc3NhZ2UgKz0gXCIsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFwiLmNvbmNhdChtZXRob2QsIFwiLCB1cmw6IFwiKS5jb25jYXQodXJsLCBcIiwgcmVzcG9uc2UgY29kZTogXCIpLmNvbmNhdChzdGF0dXMsIFwiLCByZXNwb25zZSB0ZXh0OiBcIikuY29uY2F0KGJvZHksIFwiLCByZXF1ZXN0IGlkOiBcIikuY29uY2F0KHJlcXVlc3RJZCwgXCIpXCIpO1xuICAgIH1cblxuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBEZXRhaWxlZEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIF9kZWZhdWx0ID0gRGV0YWlsZWRFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5lbmFibGVEZWJ1Z0xvZyA9IGVuYWJsZURlYnVnTG9nO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5cbi8qIGVzbGludCBuby1jb25zb2xlOiBcIm9mZlwiICovXG52YXIgaXNFbmFibGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVuYWJsZURlYnVnTG9nKCkge1xuICBpc0VuYWJsZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2cobXNnKSB7XG4gIGlmICghaXNFbmFibGVkKSByZXR1cm47XG4gIGNvbnNvbGUubG9nKG1zZyk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuXG5cbnZhciBOb29wVXJsU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vb3BVcmxTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb29wVXJsU3RvcmFnZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9vcFVybFN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImxpc3RBbGxVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RBbGxVcGxvYWRzKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRVcGxvYWRzQnlGaW5nZXJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVXBsb2FkKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFVwbG9hZChmaW5nZXJwcmludCwgdXBsb2FkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb29wVXJsU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTm9vcFVybFN0b3JhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfanNCYXNlID0gcmVxdWlyZShcImpzLWJhc2U2NFwiKTtcblxudmFyIF91cmxQYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInVybC1wYXJzZVwiKSk7XG5cbnZhciBfZXJyb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Vycm9yXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5cbnZhciBfdXVpZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXVpZFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVuZHBvaW50OiBudWxsLFxuICB1cGxvYWRVcmw6IG51bGwsXG4gIG1ldGFkYXRhOiB7fSxcbiAgZmluZ2VycHJpbnQ6IG51bGwsXG4gIHVwbG9hZFNpemU6IG51bGwsXG4gIG9uUHJvZ3Jlc3M6IG51bGwsXG4gIG9uQ2h1bmtDb21wbGV0ZTogbnVsbCxcbiAgb25TdWNjZXNzOiBudWxsLFxuICBvbkVycm9yOiBudWxsLFxuICBfb25VcGxvYWRVcmxBdmFpbGFibGU6IG51bGwsXG4gIG92ZXJyaWRlUGF0Y2hNZXRob2Q6IGZhbHNlLFxuICBoZWFkZXJzOiB7fSxcbiAgYWRkUmVxdWVzdElkOiBmYWxzZSxcbiAgb25CZWZvcmVSZXF1ZXN0OiBudWxsLFxuICBvbkFmdGVyUmVzcG9uc2U6IG51bGwsXG4gIG9uU2hvdWxkUmV0cnk6IG51bGwsXG4gIGNodW5rU2l6ZTogSW5maW5pdHksXG4gIHJldHJ5RGVsYXlzOiBbMCwgMTAwMCwgMzAwMCwgNTAwMF0sXG4gIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nOiB0cnVlLFxuICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gIHVwbG9hZExlbmd0aERlZmVycmVkOiBmYWxzZSxcbiAgdXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uOiBmYWxzZSxcbiAgdXJsU3RvcmFnZTogbnVsbCxcbiAgZmlsZVJlYWRlcjogbnVsbCxcbiAgaHR0cFN0YWNrOiBudWxsXG59O1xuXG52YXIgQmFzZVVwbG9hZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VVcGxvYWQoZmlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVXBsb2FkKTsgLy8gV2FybiBhYm91dCByZW1vdmVkIG9wdGlvbnMgZnJvbSBwcmV2aW91cyB2ZXJzaW9uc1xuXG5cbiAgICBpZiAoJ3Jlc3VtZScgaW4gb3B0aW9ucykge1xuICAgICAgY29uc29sZS5sb2coJ3R1czogVGhlIGByZXN1bWVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkIGluIHR1cy1qcy1jbGllbnQgdjIuIFBsZWFzZSB1c2UgdGhlIFVSTCBzdG9yYWdlIEFQSSBpbnN0ZWFkLicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9IC8vIFRoZSBkZWZhdWx0IG9wdGlvbnMgd2lsbCBhbHJlYWR5IGJlIGFkZGVkIGZyb20gdGhlIHdyYXBwZXIgY2xhc3Nlcy5cblxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gVGhlIHN0b3JhZ2UgbW9kdWxlIHVzZWQgdG8gc3RvcmUgVVJMc1xuXG4gICAgdGhpcy5fdXJsU3RvcmFnZSA9IHRoaXMub3B0aW9ucy51cmxTdG9yYWdlOyAvLyBUaGUgdW5kZXJseWluZyBGaWxlL0Jsb2Igb2JqZWN0XG5cbiAgICB0aGlzLmZpbGUgPSBmaWxlOyAvLyBUaGUgVVJMIGFnYWluc3Qgd2hpY2ggdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZFxuXG4gICAgdGhpcy51cmwgPSBudWxsOyAvLyBUaGUgdW5kZXJseWluZyByZXF1ZXN0IG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdFxuXG4gICAgdGhpcy5fcmVxID0gbnVsbDsgLy8gVGhlIGZpbmdlcnBpbnJ0IGZvciB0aGUgY3VycmVudCBmaWxlIChzZXQgYWZ0ZXIgc3RhcnQoKSlcblxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gbnVsbDsgLy8gVGhlIGtleSB0aGF0IHRoZSBVUkwgc3RvcmFnZSByZXR1cm5lZCB3aGVuIHNhdmluZyBhbiBVUkwgd2l0aCBhIGZpbmdlcnByaW50LFxuXG4gICAgdGhpcy5fdXJsU3RvcmFnZUtleSA9IG51bGw7IC8vIFRoZSBvZmZzZXQgdXNlZCBpbiB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0XG5cbiAgICB0aGlzLl9vZmZzZXQgPSBudWxsOyAvLyBUcnVlIGlmIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZFxuXG4gICAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlOyAvLyBUaGUgZmlsZSdzIHNpemUgaW4gYnl0ZXNcblxuICAgIHRoaXMuX3NpemUgPSBudWxsOyAvLyBUaGUgU291cmNlIG9iamVjdCB3aGljaCB3aWxsIHdyYXAgYXJvdW5kIHRoZSBnaXZlbiBmaWxlIGFuZCBwcm92aWRlcyB1c1xuICAgIC8vIHdpdGggYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZ2V0dGluZyBpdHMgc2l6ZSBhbmQgc2xpY2UgY2h1bmtzIGZyb20gaXRzXG4gICAgLy8gY29udGVudCBhbGxvd2luZyB1cyB0byBlYXNpbHkgaGFuZGxlIEZpbGVzLCBCbG9icywgQnVmZmVycyBhbmQgU3RyZWFtcy5cblxuICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7IC8vIFRoZSBjdXJyZW50IGNvdW50IG9mIGF0dGVtcHRzIHdoaWNoIGhhdmUgYmVlbiBtYWRlLiBaZXJvIGluZGljYXRlcyBub25lLlxuXG4gICAgdGhpcy5fcmV0cnlBdHRlbXB0ID0gMDsgLy8gVGhlIHRpbWVvdXQncyBJRCB3aGljaCBpcyB1c2VkIHRvIGRlbGF5IHRoZSBuZXh0IHJldHJ5XG5cbiAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBudWxsOyAvLyBUaGUgb2Zmc2V0IG9mIHRoZSByZW1vdGUgdXBsb2FkIGJlZm9yZSB0aGUgbGF0ZXN0IGF0dGVtcHQgd2FzIHN0YXJ0ZWQuXG5cbiAgICB0aGlzLl9vZmZzZXRCZWZvcmVSZXRyeSA9IDA7IC8vIEFuIGFycmF5IG9mIEJhc2VVcGxvYWQgaW5zdGFuY2VzIHdoaWNoIGFyZSB1c2VkIGZvciB1cGxvYWRpbmcgdGhlIGRpZmZlcmVudFxuICAgIC8vIHBhcnRzLCBpZiB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiBpcyB1c2VkLlxuXG4gICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzID0gbnVsbDsgLy8gQW4gYXJyYXkgb2YgdXBsb2FkIFVSTHMgd2hpY2ggYXJlIHVzZWQgZm9yIHVwbG9hZGluZyB0aGUgZGlmZmVyZW50XG4gICAgLy8gcGFydHMsIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQuXG5cbiAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVc2UgdGhlIFRlcm1pbmF0aW9uIGV4dGVuc2lvbiB0byBkZWxldGUgYW4gdXBsb2FkIGZyb20gdGhlIHNlcnZlciBieSBzZW5kaW5nIGEgREVMRVRFXG4gICAqIHJlcXVlc3QgdG8gdGhlIHNwZWNpZmllZCB1cGxvYWQgVVJMLiBUaGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyB0aGVcbiAgICogVGVybWluYXRpb24gZXh0ZW5zaW9uLiBJZiB0aGUgYG9wdGlvbnMucmV0cnlEZWxheXNgIHByb3BlcnR5IGlzIHNldCwgdGhlIG1ldGhvZCB3aWxsXG4gICAqIGFsc28gcmV0cnkgaWYgYW4gZXJyb3Igb2N1cnJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cGxvYWQncyBVUkwgd2hpY2ggd2lsbCBiZSB0ZXJtaW5hdGVkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciBpbmZsdWVuY2luZyBIVFRQIHJlcXVlc3RzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkL3JlamVjdGVkIHdoZW4gdGhlIHJlcXVlc3RzIGZpbmlzaC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmFzZVVwbG9hZCwgW3tcbiAgICBrZXk6IFwiZmluZFByZXZpb3VzVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kUHJldmlvdXNVcGxvYWRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maW5nZXJwcmludCh0aGlzLmZpbGUsIHRoaXMub3B0aW9ucykudGhlbihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl91cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChmaW5nZXJwcmludCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3VtZUZyb21QcmV2aW91c1VwbG9hZChwcmV2aW91c1VwbG9hZCkge1xuICAgICAgdGhpcy51cmwgPSBwcmV2aW91c1VwbG9hZC51cGxvYWRVcmwgfHwgbnVsbDtcbiAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IHByZXZpb3VzVXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscyB8fCBudWxsO1xuICAgICAgdGhpcy5fdXJsU3RvcmFnZUtleSA9IHByZXZpb3VzVXBsb2FkLnVybFN0b3JhZ2VLZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlO1xuXG4gICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcigndHVzOiBubyBmaWxlIG9yIHN0cmVhbSB0byB1cGxvYWQgcHJvdmlkZWQnKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmRwb2ludCAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZFVybCkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IG5laXRoZXIgYW4gZW5kcG9pbnQgb3IgYW4gdXBsb2FkIFVSTCBpcyBwcm92aWRlZCcpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXRyeURlbGF5cyA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cztcblxuICAgICAgaWYgKHJldHJ5RGVsYXlzICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJldHJ5RGVsYXlzKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IHRoZSBgcmV0cnlEZWxheXNgIG9wdGlvbiBtdXN0IGVpdGhlciBiZSBhbiBhcnJheSBvciBudWxsJykpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxKSB7XG4gICAgICAgIC8vIFRlc3Qgd2hpY2ggb3B0aW9ucyBhcmUgaW5jb21wYXRpYmxlIHdpdGggcGFyYWxsZWwgdXBsb2Fkcy5cbiAgICAgICAgWyd1cGxvYWRVcmwnLCAndXBsb2FkU2l6ZScsICd1cGxvYWRMZW5ndGhEZWZlcnJlZCddLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbk5hbWUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIF90aGlzMi5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IHVzZSB0aGUgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiIG9wdGlvbiB3aGVuIHBhcmFsbGVsVXBsb2FkcyBpcyBlbmFibGVkXCIpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KGZpbGUsIHRoaXMub3B0aW9ucykudGhlbihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgaWYgKGZpbmdlcnByaW50ID09IG51bGwpIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKCdObyBmaW5nZXJwcmludCB3YXMgY2FsY3VsYXRlZCBtZWFuaW5nIHRoYXQgdGhlIHVwbG9hZCBjYW5ub3QgYmUgc3RvcmVkIGluIHRoZSBVUkwgc3RvcmFnZS4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ2FsY3VsYXRlZCBmaW5nZXJwcmludDogXCIuY29uY2F0KGZpbmdlcnByaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuX2ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG5cbiAgICAgICAgaWYgKF90aGlzMi5fc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMi5vcHRpb25zLmZpbGVSZWFkZXIub3BlbkZpbGUoZmlsZSwgX3RoaXMyLm9wdGlvbnMuY2h1bmtTaXplKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfdGhpczIuX3NvdXJjZSA9IHNvdXJjZTsgLy8gSWYgdGhlIHVwbG9hZCB3YXMgY29uZmlndXJlZCB0byB1c2UgbXVsdGlwbGUgcmVxdWVzdHMgb3IgaWYgd2UgcmVzdW1lIGZyb21cbiAgICAgICAgLy8gYW4gdXBsb2FkIHdoaWNoIHVzZWQgbXVsdGlwbGUgcmVxdWVzdHMsIHdlIHN0YXJ0IGEgcGFyYWxsZWwgdXBsb2FkLlxuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxIHx8IF90aGlzMi5fcGFyYWxsZWxVcGxvYWRVcmxzICE9IG51bGwpIHtcbiAgICAgICAgICBfdGhpczIuX3N0YXJ0UGFyYWxsZWxVcGxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuX3N0YXJ0U2luZ2xlVXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczIuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIHRoZSB1cGxvYWRpbmcgcHJvY2VkdXJlIGZvciBhIHBhcmFsbGVsaXplZCB1cGxvYWQsIHdoZXJlIG9uZSBmaWxlIGlzIHNwbGl0IGludG9cbiAgICAgKiBtdWx0aXBsZSByZXF1ZXN0IHdoaWNoIGFyZSBydW4gaW4gcGFyYWxsZWwuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFBhcmFsbGVsVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFBhcmFsbGVsVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB0b3RhbFNpemUgPSB0aGlzLl9zaXplID0gdGhpcy5fc291cmNlLnNpemU7XG4gICAgICB2YXIgdG90YWxQcm9ncmVzcyA9IDA7XG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMgPSBbXTtcbiAgICAgIHZhciBwYXJ0Q291bnQgPSB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgIT0gbnVsbCA/IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscy5sZW5ndGggOiB0aGlzLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzOyAvLyBUaGUgaW5wdXQgZmlsZSB3aWxsIGJlIHNwbGl0IGludG8gbXVsdGlwbGUgc2xpY2VzIHdoaWNoIGFyZSB1cGxvYWRlZCBpbiBzZXBhcmF0ZVxuICAgICAgLy8gcmVxdWVzdHMuIEhlcmUgd2UgZ2VuZXJhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gZm9yIHRoZSBzbGljZXMuXG5cbiAgICAgIHZhciBwYXJ0cyA9IHNwbGl0U2l6ZUludG9QYXJ0cyh0aGlzLl9zb3VyY2Uuc2l6ZSwgcGFydENvdW50LCB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMpOyAvLyBDcmVhdGUgYW4gZW1wdHkgbGlzdCBmb3Igc3RvcmluZyB0aGUgdXBsb2FkIFVSTHNcblxuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7IC8vIEdlbmVyYXRlIGEgcHJvbWlzZSBmb3IgZWFjaCBzbGljZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZSBpZiB0aGUgcmVzcGVjdGl2ZVxuICAgICAgLy8gdXBsb2FkIGlzIGNvbXBsZXRlZC5cblxuICAgICAgdmFyIHVwbG9hZHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBsYXN0UGFydFByb2dyZXNzID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc291cmNlLnNsaWNlKHBhcnQuc3RhcnQsIHBhcnQuZW5kKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gTWVyZ2Ugd2l0aCB0aGUgdXNlciBzdXBwbGllZCBvcHRpb25zIGJ1dCBvdmVyd3JpdGUgc29tZSB2YWx1ZXMuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIF90aGlzMy5vcHRpb25zLCB7XG4gICAgICAgICAgICAgIC8vIElmIGF2YWlsYWJsZSwgdGhlIHBhcnRpYWwgdXBsb2FkIHNob3VsZCBiZSByZXN1bWVkIGZyb20gYSBwcmV2aW91cyBVUkwuXG4gICAgICAgICAgICAgIHVwbG9hZFVybDogcGFydC51cGxvYWRVcmwgfHwgbnVsbCxcbiAgICAgICAgICAgICAgLy8gV2UgdGFrZSBtYW51YWxseSBjYXJlIG9mIHJlc3VtaW5nIGZvciBwYXJ0aWFsIHVwbG9hZHMsIHNvIHRoZXkgc2hvdWxkXG4gICAgICAgICAgICAgIC8vIG5vdCBiZSBzdG9yZWQgaW4gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIHRvIG5vdCBjYXVzZSByZWN1cnNpb24uXG4gICAgICAgICAgICAgIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICAgICAgICAvLyBBZGQgdGhlIGhlYWRlciB0byBpbmRpY2F0ZSB0aGUgdGhpcyBpcyBhIHBhcnRpYWwgdXBsb2FkLlxuICAgICAgICAgICAgICBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkKHt9LCBfdGhpczMub3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgJ1VwbG9hZC1Db25jYXQnOiAncGFydGlhbCdcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC8vIFJlamVjdCBvciByZXNvbHZlIHRoZSBwcm9taXNlIGlmIHRoZSB1cGxvYWQgZXJyb3JzIG9yIGNvbXBsZXRlcy5cbiAgICAgICAgICAgICAgb25TdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICBvbkVycm9yOiByZWplY3QsXG4gICAgICAgICAgICAgIC8vIEJhc2VkIGluIHRoZSBwcm9ncmVzcyBmb3IgdGhpcyBwYXJ0aWFsIHVwbG9hZCwgY2FsY3VsYXRlIHRoZSBwcm9ncmVzc1xuICAgICAgICAgICAgICAvLyBmb3IgdGhlIGVudGlyZSBmaW5hbCB1cGxvYWQuXG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MobmV3UGFydFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyA9IHRvdGFsUHJvZ3Jlc3MgLSBsYXN0UGFydFByb2dyZXNzICsgbmV3UGFydFByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGxhc3RQYXJ0UHJvZ3Jlc3MgPSBuZXdQYXJ0UHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICBfdGhpczMuX2VtaXRQcm9ncmVzcyh0b3RhbFByb2dyZXNzLCB0b3RhbFNpemUpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIGV2ZXJ5IHBhcnRpYWwgdXBsb2FkIGhhcyBhbiB1cGxvYWQgVVJMLCBzbyB3ZSBjYW4gYWRkXG4gICAgICAgICAgICAgIC8vIHRoZW0gdG8gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBfb25VcGxvYWRVcmxBdmFpbGFibGU6IGZ1bmN0aW9uIF9vblVwbG9hZFVybEF2YWlsYWJsZSgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJsc1tpbmRleF0gPSB1cGxvYWQudXJsOyAvLyBUZXN0IGlmIGFsbCB1cGxvYWRzIGhhdmUgcmVjZWl2ZWQgYW4gVVJMXG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHMuZmlsdGVyKGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gISF1O1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczMuX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdXBsb2FkID0gbmV3IEJhc2VVcGxvYWQodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdXBsb2FkLnN0YXJ0KCk7IC8vIFN0b3JlIHRoZSB1cGxvYWQgaW4gYW4gYXJyYXksIHNvIHdlIGNhbiBsYXRlciBhYm9ydCB0aGVtIGlmIG5lY2Vzc2FyeS5cblxuICAgICAgICAgICAgX3RoaXMzLl9wYXJhbGxlbFVwbG9hZHMucHVzaCh1cGxvYWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlcTsgLy8gV2FpdCB1bnRpbCBhbGwgcGFydGlhbCB1cGxvYWRzIGFyZSBmaW5pc2hlZCBhbmQgd2UgY2FuIHNlbmQgdGhlIFBPU1QgcmVxdWVzdCBmb3JcbiAgICAgIC8vIGNyZWF0aW5nIHRoZSBmaW5hbCB1cGxvYWQuXG5cbiAgICAgIFByb21pc2UuYWxsKHVwbG9hZHMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXEgPSBfdGhpczMuX29wZW5SZXF1ZXN0KCdQT1NUJywgX3RoaXMzLm9wdGlvbnMuZW5kcG9pbnQpO1xuICAgICAgICByZXEuc2V0SGVhZGVyKCdVcGxvYWQtQ29uY2F0JywgXCJmaW5hbDtcIi5jb25jYXQoX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHMuam9pbignICcpKSk7IC8vIEFkZCBtZXRhZGF0YSBpZiB2YWx1ZXMgaGF2ZSBiZWVuIGFkZGVkXG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gZW5jb2RlTWV0YWRhdGEoX3RoaXMzLm9wdGlvbnMubWV0YWRhdGEpO1xuXG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gJycpIHtcbiAgICAgICAgICByZXEuc2V0SGVhZGVyKCdVcGxvYWQtTWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShyZXMuZ2V0U3RhdHVzKCksIDIwMCkpIHtcbiAgICAgICAgICBfdGhpczMuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkJyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuZ2V0SGVhZGVyKCdMb2NhdGlvbicpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgTG9jYXRpb24gaGVhZGVyJyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczMudXJsID0gcmVzb2x2ZVVybChfdGhpczMub3B0aW9ucy5lbmRwb2ludCwgbG9jYXRpb24pO1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ3JlYXRlZCB1cGxvYWQgYXQgXCIuY29uY2F0KF90aGlzMy51cmwpKTtcblxuICAgICAgICBfdGhpczMuX2VtaXRTdWNjZXNzKCk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMzLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSB0aGUgdXBsb2FkaW5nIHByb2NlZHVyZSBmb3IgYSBub24tcGFyYWxsZWwgdXBsb2FkLiBIZXJlIHRoZSBlbnRpcmUgZmlsZSBpc1xuICAgICAqIHVwbG9hZGVkIGluIGEgc2VxdWVudGlhbCBtYXR0ZXIuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFNpbmdsZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRTaW5nbGVVcGxvYWQoKSB7XG4gICAgICAvLyBGaXJzdCwgd2UgbG9vayBhdCB0aGUgdXBsb2FkTGVuZ3RoRGVmZXJyZWQgb3B0aW9uLlxuICAgICAgLy8gTmV4dCwgd2UgY2hlY2sgaWYgdGhlIGNhbGxlciBoYXMgc3VwcGxpZWQgYSBtYW51YWwgdXBsb2FkIHNpemUuXG4gICAgICAvLyBGaW5hbGx5LCB3ZSB0cnkgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHNpemUgZnJvbSB0aGUgc291cmNlIG9iamVjdC5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRTaXplICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICt0aGlzLm9wdGlvbnMudXBsb2FkU2l6ZTtcblxuICAgICAgICBpZiAoaXNOYU4odGhpcy5fc2l6ZSkpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IGNhbm5vdCBjb252ZXJ0IGB1cGxvYWRTaXplYCBvcHRpb24gaW50byBhIG51bWJlcicpKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHRoaXMuX3NvdXJjZS5zaXplO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaXplID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgYXV0b21hdGljYWxseSBkZXJpdmUgdXBsb2FkJ3Mgc2l6ZSBmcm9tIGlucHV0IGFuZCBtdXN0IGJlIHNwZWNpZmllZCBtYW51YWxseSB1c2luZyB0aGUgYHVwbG9hZFNpemVgIG9wdGlvblwiKSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVzZXQgdGhlIGFib3J0ZWQgZmxhZyB3aGVuIHRoZSB1cGxvYWQgaXMgc3RhcnRlZCBvciBlbHNlIHRoZVxuICAgICAgLy8gX3BlcmZvcm1VcGxvYWQgd2lsbCBzdG9wIGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuXG4gICAgICAvLyBhYm9ydGVkIHByZXZpb3VzbHkuXG5cblxuICAgICAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlOyAvLyBUaGUgdXBsb2FkIGhhZCBiZWVuIHN0YXJ0ZWQgcHJldmlvdXNseSBhbmQgd2Ugc2hvdWxkIHJldXNlIHRoaXMgVVJMLlxuXG4gICAgICBpZiAodGhpcy51cmwgIT0gbnVsbCkge1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiUmVzdW1pbmcgdXBsb2FkIGZyb20gcHJldmlvdXMgVVJMOiBcIi5jb25jYXQodGhpcy51cmwpKTtcblxuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEEgVVJMIGhhcyBtYW51YWxseSBiZWVuIHNwZWNpZmllZCwgc28gd2UgdHJ5IHRvIHJlc3VtZVxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkVXJsICE9IG51bGwpIHtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIlJlc3VtaW5nIHVwbG9hZCBmcm9tIHByb3ZpZGVkIFVSTDogXCIuY29uY2F0KHRoaXMub3B0aW9ucy51cmwpKTtcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLm9wdGlvbnMudXBsb2FkVXJsO1xuXG4gICAgICAgIHRoaXMuX3Jlc3VtZVVwbG9hZCgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQW4gdXBsb2FkIGhhcyBub3Qgc3RhcnRlZCBmb3IgdGhlIGZpbGUgeWV0LCBzbyB3ZSBzdGFydCBhIG5ldyBvbmVcblxuXG4gICAgICAoMCwgX2xvZ2dlci5sb2cpKCdDcmVhdGluZyBhIG5ldyB1cGxvYWQnKTtcblxuICAgICAgdGhpcy5fY3JlYXRlVXBsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGFueSBydW5uaW5nIHJlcXVlc3QgYW5kIHN0b3AgdGhlIGN1cnJlbnQgdXBsb2FkLiBBZnRlciBhYm9ydCBpcyBjYWxsZWQsIG5vIGV2ZW50XG4gICAgICogaGFuZGxlciB3aWxsIGJlIGludm9rZWQgYW55bW9yZS4gWW91IGNhbiB1c2UgdGhlIGBzdGFydGAgbWV0aG9kIHRvIHJlc3VtZSB0aGUgdXBsb2FkXG4gICAgICogYWdhaW4uXG4gICAgICogSWYgYHNob3VsZFRlcm1pbmF0ZWAgaXMgdHJ1ZSwgdGhlIGB0ZXJtaW5hdGVgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIHJlbW92ZSB0aGVcbiAgICAgKiBjdXJyZW50IHVwbG9hZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFRlcm1pbmF0ZSBUcnVlIGlmIHRoZSB1cGxvYWQgc2hvdWxkIGJlIGRlbGV0ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdHMgZmluaXNoLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoc2hvdWxkVGVybWluYXRlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpczsgLy8gQ291bnQgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIGEgY2FsbGJhY2sgaXMgYmVpbmcgcHJvdmlkZWQgaW4gdGhlIG9sZCBzdHlsZSByZXF1aXJlZCBieSB0dXMtanMtY2xpZW50IDEueCwgdGhlbiB0aHJvdyBhbiBlcnJvciBpZiBpdCBpcy5cbiAgICAgIC8vIGBhcmd1bWVudHNgIGlzIGEgSmF2YVNjcmlwdCBidWlsdC1pbiB2YXJpYWJsZSB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgZnVuY3Rpb24ncyBhcmd1bWVudHMuXG5cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0dXM6IHRoZSBhYm9ydCBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgYSBjYWxsYmFjayBzaW5jZSB2MiBhbnltb3JlOyBwbGVhc2UgdXNlIHRoZSByZXR1cm5lZCBQcm9taXNlIGluc3RlYWQnKTtcbiAgICAgIH0gLy8gU3RvcCBhbnkgcGFyYWxsZWwgcGFydGlhbCB1cGxvYWRzLCB0aGF0IGhhdmUgYmVlbiBzdGFydGVkIGluIF9zdGFydFBhcmFsbGVsVXBsb2Fkcy5cblxuXG4gICAgICBpZiAodGhpcy5fcGFyYWxsZWxVcGxvYWRzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzLmZvckVhY2goZnVuY3Rpb24gKHVwbG9hZCkge1xuICAgICAgICAgIHVwbG9hZC5hYm9ydChzaG91bGRUZXJtaW5hdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU3RvcCBhbnkgY3VycmVudCBydW5uaW5nIHJlcXVlc3QuXG5cblxuICAgICAgaWYgKHRoaXMuX3JlcSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcblxuICAgICAgICB0aGlzLl9zb3VyY2UuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7IC8vIFN0b3AgYW55IHRpbWVvdXQgdXNlZCBmb3IgaW5pdGlhdGluZyBhIHJldHJ5LlxuXG4gICAgICBpZiAodGhpcy5fcmV0cnlUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JldHJ5VGltZW91dCk7XG4gICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2hvdWxkVGVybWluYXRlIHx8IHRoaXMudXJsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQmFzZVVwbG9hZC50ZXJtaW5hdGUodGhpcy51cmwsIHRoaXMub3B0aW9ucykgLy8gUmVtb3ZlIGVudHJ5IGZyb20gdGhlIFVSTCBzdG9yYWdlIHNpbmNlIHRoZSB1cGxvYWQgVVJMIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5fcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdEh0dHBFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgbWVzc2FnZSwgY2F1c2luZ0Vycikge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBfZXJyb3IuZGVmYXVsdChtZXNzYWdlLCBjYXVzaW5nRXJyLCByZXEsIHJlcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0RXJyb3IoZXJyKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpczsgLy8gRG8gbm90IGVtaXQgZXJyb3JzLCBlLmcuIGZyb20gYWJvcnRlZCBIVFRQIHJlcXVlc3RzLCBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuIHN0b3BwZWQuXG5cblxuICAgICAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybjsgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJldHJ5LCB3aGVuIGVuYWJsZWQsIGJlZm9yZSBzZW5kaW5nIHRoZSBlcnJvciB0byB0aGUgdXNlci5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cyAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgcmVzZXQgdGhlIGF0dGVtcHQgY291bnRlciBpZlxuICAgICAgICAvLyAtIHdlIHdlcmUgYWxyZWFkeSBhYmxlIHRvIGNvbm5lY3QgdG8gdGhlIHNlcnZlciAob2Zmc2V0ICE9IG51bGwpIGFuZFxuICAgICAgICAvLyAtIHdlIHdlcmUgYWJsZSB0byB1cGxvYWQgYSBzbWFsbCBjaHVuayBvZiBkYXRhIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgdmFyIHNob3VsZFJlc2V0RGVsYXlzID0gdGhpcy5fb2Zmc2V0ICE9IG51bGwgJiYgdGhpcy5fb2Zmc2V0ID4gdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnk7XG5cbiAgICAgICAgaWYgKHNob3VsZFJlc2V0RGVsYXlzKSB7XG4gICAgICAgICAgdGhpcy5fcmV0cnlBdHRlbXB0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRSZXRyeShlcnIsIHRoaXMuX3JldHJ5QXR0ZW1wdCwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5c1t0aGlzLl9yZXRyeUF0dGVtcHQrK107XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnkgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczUuc3RhcnQoKTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0U3VjY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN1Y2Nlc3MoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdG9yZWQgZmluZ2VycHJpbnQgYW5kIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnQuIFRoaXMgY2F1c2VzXG4gICAgICAgIC8vIG5ldyB1cGxvYWRzIG9mIHRoZSBzYW1lIGZpbGUgdG8gYmUgdHJlYXRlZCBhcyBhIGRpZmZlcmVudCBmaWxlLlxuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uU3VjY2VzcygpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXIuIFRoaXNcbiAgICAgKiBkYXRhIG1heSBub3QgaGF2ZSBiZWVuIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIgeWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzU2VudCAgTnVtYmVyIG9mIGJ5dGVzIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNUb3RhbCBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRQcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFByb2dyZXNzKGJ5dGVzU2VudCwgYnl0ZXNUb3RhbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gYSBjaHVuayBvZiBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIGFuZCBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemUgIFNpemUgb2YgdGhlIGNodW5rIHRoYXQgd2FzIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzQWNjZXB0ZWQgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0Q2h1bmtDb21wbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdENodW5rQ29tcGxldGUoY2h1bmtTaXplLCBieXRlc0FjY2VwdGVkLCBieXRlc1RvdGFsKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNodW5rQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ2h1bmtDb21wbGV0ZShjaHVua1NpemUsIGJ5dGVzQWNjZXB0ZWQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXBsb2FkIHVzaW5nIHRoZSBjcmVhdGlvbiBleHRlbnNpb24gYnkgc2VuZGluZyBhIFBPU1RcbiAgICAgKiByZXF1ZXN0IHRvIHRoZSBlbmRwb2ludC4gQWZ0ZXIgc3VjY2Vzc2Z1bCBjcmVhdGlvbiB0aGUgZmlsZSB3aWxsIGJlXG4gICAgICogdXBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ3R1czogdW5hYmxlIHRvIGNyZWF0ZSB1cGxvYWQgYmVjYXVzZSBubyBlbmRwb2ludCBpcyBwcm92aWRlZCcpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdCgnUE9TVCcsIHRoaXMub3B0aW9ucy5lbmRwb2ludCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLURlZmVyLUxlbmd0aCcsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLUxlbmd0aCcsIHRoaXMuX3NpemUpO1xuICAgICAgfSAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuXG5cbiAgICAgIHZhciBtZXRhZGF0YSA9IGVuY29kZU1ldGFkYXRhKHRoaXMub3B0aW9ucy5tZXRhZGF0YSk7XG5cbiAgICAgIGlmIChtZXRhZGF0YSAhPT0gJycpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLU1ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24gJiYgIXRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QocmVxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXM2Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCcpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmdldEhlYWRlcignTG9jYXRpb24nKTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlcicpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2LnVybCA9IHJlc29sdmVVcmwoX3RoaXM2Lm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczYudXJsKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczYuX3NpemUgPT09IDApIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIHRvIHVwbG9hZCBhbmQgZmlsZSB3YXMgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWRcbiAgICAgICAgICBfdGhpczYuX2VtaXRTdWNjZXNzKCk7XG5cbiAgICAgICAgICBfdGhpczYuX3NvdXJjZS5jbG9zZSgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2Ll9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCk7XG5cbiAgICAgICAgaWYgKF90aGlzNi5vcHRpb25zLnVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbikge1xuICAgICAgICAgIF90aGlzNi5faGFuZGxlVXBsb2FkUmVzcG9uc2UocmVxLCByZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzNi5fb2Zmc2V0ID0gMDtcblxuICAgICAgICAgIF90aGlzNi5fcGVyZm9ybVVwbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXM2Ll9lbWl0SHR0cEVycm9yKHJlcSwgbnVsbCwgJ3R1czogZmFpbGVkIHRvIGNyZWF0ZSB1cGxvYWQnLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogVHJ5IHRvIHJlc3VtZSBhbiBleGlzdGluZyB1cGxvYWQuIEZpcnN0IGEgSEVBRCByZXF1ZXN0IHdpbGwgYmUgc2VudFxuICAgICAqIHRvIHJldHJpZXZlIHRoZSBvZmZzZXQuIElmIHRoZSByZXF1ZXN0IGZhaWxzIGEgbmV3IHVwbG9hZCB3aWxsIGJlXG4gICAgICogY3JlYXRlZC4gSW4gdGhlIGNhc2Ugb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXN1bWVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3VtZVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoJ0hFQUQnLCB0aGlzLnVybCk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlcy5nZXRTdGF0dXMoKTtcblxuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCAyMDApKSB7XG4gICAgICAgICAgaWYgKGluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3RvcmVkIGZpbmdlcnByaW50IGFuZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50LFxuICAgICAgICAgICAgLy8gb24gY2xpZW50IGVycm9ycyBzaW5jZSB0aGUgZmlsZSBjYW4gbm90IGJlIGZvdW5kXG4gICAgICAgICAgICBfdGhpczcuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgdXBsb2FkIGlzIGxvY2tlZCAoaW5kaWNhdGVkIGJ5IHRoZSA0MjMgTG9ja2VkIHN0YXR1cyBjb2RlKSwgd2VcbiAgICAgICAgICAvLyBlbWl0IGFuIGVycm9yIGluc3RlYWQgb2YgZGlyZWN0bHkgc3RhcnRpbmcgYSBuZXcgdXBsb2FkLiBUaGlzIHdheSB0aGVcbiAgICAgICAgICAvLyByZXRyeSBsb2dpYyBjYW4gY2F0Y2ggdGhlIGVycm9yIGFuZCB3aWxsIHJldHJ5IHRoZSB1cGxvYWQuIEFuIHVwbG9hZFxuICAgICAgICAgIC8vIGlzIHVzdWFsbHkgbG9ja2VkIGZvciBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIGFuZCB3aWxsIGJlIGF2YWlsYWJsZVxuICAgICAgICAgIC8vIGFmdGVyd2FyZHMuXG5cblxuICAgICAgICAgIGlmIChzdGF0dXMgPT09IDQyMykge1xuICAgICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1cGxvYWQgaXMgY3VycmVudGx5IGxvY2tlZDsgcmV0cnkgbGF0ZXInKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3RoaXM3Lm9wdGlvbnMuZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGF0dGVtcHQgdG8gY3JlYXRlIGEgbmV3IHVwbG9hZCBpZiBubyBlbmRwb2ludCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogdW5hYmxlIHRvIHJlc3VtZSB1cGxvYWQgKG5ldyB1cGxvYWQgY2Fubm90IGJlIGNyZWF0ZWQgd2l0aG91dCBhbiBlbmRwb2ludCknKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWRcblxuXG4gICAgICAgICAgX3RoaXM3LnVybCA9IG51bGw7XG5cbiAgICAgICAgICBfdGhpczcuX2NyZWF0ZVVwbG9hZCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlSW50KHJlcy5nZXRIZWFkZXIoJ1VwbG9hZC1PZmZzZXQnKSwgMTApO1xuXG4gICAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlJyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcignVXBsb2FkLUxlbmd0aCcpLCAxMCk7XG5cbiAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkgJiYgIV90aGlzNy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgbGVuZ3RoIHZhbHVlJyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIF90aGlzNy5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF90aGlzNy5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSgpO1xuICAgICAgICB9IC8vIFVwbG9hZCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBsZXRlZCBhbmQgd2UgZG8gbm90IG5lZWQgdG8gc2VuZCBhZGRpdGlvbmFsXG4gICAgICAgIC8vIGRhdGEgdG8gdGhlIHNlcnZlclxuXG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0UHJvZ3Jlc3MobGVuZ3RoLCBsZW5ndGgpO1xuXG4gICAgICAgICAgX3RoaXM3Ll9lbWl0U3VjY2VzcygpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM3Ll9vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgICAgX3RoaXM3Ll9wZXJmb3JtVXBsb2FkKCk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgbnVsbCwgJ3R1czogZmFpbGVkIHRvIHJlc3VtZSB1cGxvYWQnLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHVwbG9hZGluZyB0aGUgZmlsZSB1c2luZyBQQVRDSCByZXF1ZXN0cy4gVGhlIGZpbGUgd2lsbCBiZSBkaXZpZGVkXG4gICAgICogaW50byBjaHVua3MgYXMgc3BlY2lmaWVkIGluIHRoZSBjaHVua1NpemUgb3B0aW9uLiBEdXJpbmcgdGhlIHVwbG9hZFxuICAgICAqIHRoZSBvblByb2dyZXNzIGV2ZW50IGhhbmRsZXIgbWF5IGJlIGludm9rZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7IC8vIElmIHRoZSB1cGxvYWQgaGFzIGJlZW4gYWJvcnRlZCwgd2Ugd2lsbCBub3Qgc2VuZCB0aGUgbmV4dCBQQVRDSCByZXF1ZXN0LlxuICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgdGhlIGFib3J0IG1ldGhvZCB3YXMgY2FsbGVkIGR1cmluZyBhIGNhbGxiYWNrLCBzdWNoXG4gICAgICAvLyBhcyBvbkNodW5rQ29tcGxldGUgb3Igb25Qcm9ncmVzcy5cblxuXG4gICAgICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXE7IC8vIFNvbWUgYnJvd3NlciBhbmQgc2VydmVycyBtYXkgbm90IHN1cHBvcnQgdGhlIFBBVENIIG1ldGhvZC4gRm9yIHRob3NlXG4gICAgICAvLyBjYXNlcywgeW91IGNhbiB0ZWxsIHR1cy1qcy1jbGllbnQgdG8gdXNlIGEgUE9TVCByZXF1ZXN0IHdpdGggdGhlXG4gICAgICAvLyBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlIGhlYWRlciBmb3Igc2ltdWxhdGluZyBhIFBBVENIIHJlcXVlc3QuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcnJpZGVQYXRjaE1ldGhvZCkge1xuICAgICAgICByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdCgnUE9TVCcsIHRoaXMudXJsKTtcbiAgICAgICAgcmVxLnNldEhlYWRlcignWC1IVFRQLU1ldGhvZC1PdmVycmlkZScsICdQQVRDSCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoJ1BBVENIJywgdGhpcy51cmwpO1xuICAgICAgfVxuXG4gICAgICByZXEuc2V0SGVhZGVyKCdVcGxvYWQtT2Zmc2V0JywgdGhpcy5fb2Zmc2V0KTtcblxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9hZGRDaHVua1RvUmVxdWVzdChyZXEpO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXM4Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHVwbG9hZGluZyBjaHVuaycpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM4Ll9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcyk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gRG9uJ3QgZW1pdCBhbiBlcnJvciBpZiB0aGUgdXBsb2FkIHdhcyBhYm9ydGVkIG1hbnVhbGx5XG4gICAgICAgIGlmIChfdGhpczguX2Fib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczguX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCBcInR1czogZmFpbGVkIHRvIHVwbG9hZCBjaHVuayBhdCBvZmZzZXQgXCIuY29uY2F0KF90aGlzOC5fb2Zmc2V0KSwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfYWRkQ2h1bmt0b1JlcXVlc3QgcmVhZHMgYSBjaHVuayBmcm9tIHRoZSBzb3VyY2UgYW5kIHNlbmRzIGl0IHVzaW5nIHRoZVxuICAgICAqIHN1cHBsaWVkIHJlcXVlc3Qgb2JqZWN0LiBJdCB3aWxsIG5vdCBoYW5kbGUgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ2h1bmtUb1JlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENodW5rVG9SZXF1ZXN0KHJlcSkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9vZmZzZXQgKyB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgcmVxLnNldFByb2dyZXNzSGFuZGxlcihmdW5jdGlvbiAoYnl0ZXNTZW50KSB7XG4gICAgICAgIF90aGlzOS5fZW1pdFByb2dyZXNzKHN0YXJ0ICsgYnl0ZXNTZW50LCBfdGhpczkuX3NpemUpO1xuICAgICAgfSk7XG4gICAgICByZXEuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpOyAvLyBUaGUgc3BlY2lmaWVkIGNodW5rU2l6ZSBtYXkgYmUgSW5maW5pdHkgb3IgdGhlIGNhbGNsdWF0ZWQgZW5kIHBvc2l0aW9uXG4gICAgICAvLyBtYXkgZXhjZWVkIHRoZSBmaWxlJ3Mgc2l6ZS4gSW4gYm90aCBjYXNlcywgd2UgbGltaXQgdGhlIGVuZCBwb3NpdGlvbiB0b1xuICAgICAgLy8gdGhlIGlucHV0J3MgdG90YWwgc2l6ZSBmb3Igc2ltcGxlciBjYWxjdWxhdGlvbnMgYW5kIGNvcnJlY3RuZXNzLlxuXG4gICAgICBpZiAoKGVuZCA9PT0gSW5maW5pdHkgfHwgZW5kID4gdGhpcy5fc2l6ZSkgJiYgIXRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICBlbmQgPSB0aGlzLl9zaXplO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpLnRoZW4oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICAgICAgZG9uZSA9IF9yZWYyLmRvbmU7IC8vIElmIHRoZSB1cGxvYWQgbGVuZ3RoIGlzIGRlZmVycmVkLCB0aGUgdXBsb2FkIHNpemUgd2FzIG5vdCBzcGVjaWZpZWQgZHVyaW5nXG4gICAgICAgIC8vIHVwbG9hZCBjcmVhdGlvbi4gU28sIGlmIHRoZSBmaWxlIHJlYWRlciBpcyBkb25lIHJlYWRpbmcsIHdlIGtub3cgdGhlIHRvdGFsXG4gICAgICAgIC8vIHVwbG9hZCBzaXplIGFuZCBjYW4gdGVsbCB0aGUgdHVzIHNlcnZlci5cblxuICAgICAgICBpZiAoX3RoaXM5Lm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQgJiYgZG9uZSkge1xuICAgICAgICAgIF90aGlzOS5fc2l6ZSA9IF90aGlzOS5fb2Zmc2V0ICsgKHZhbHVlICYmIHZhbHVlLnNpemUgPyB2YWx1ZS5zaXplIDogMCk7XG4gICAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLUxlbmd0aCcsIF90aGlzOS5fc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM5Ll9zZW5kUmVxdWVzdChyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM5Ll9lbWl0UHJvZ3Jlc3MoX3RoaXM5Ll9vZmZzZXQsIF90aGlzOS5fc2l6ZSk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzOS5fc2VuZFJlcXVlc3QocmVxLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogX2hhbmRsZVVwbG9hZFJlc3BvbnNlIGlzIHVzZWQgYnkgcmVxdWVzdHMgdGhhdCBoYXZlbiBiZWVuIHNlbnQgdXNpbmcgX2FkZENodW5rVG9SZXF1ZXN0XG4gICAgICogYW5kIGFscmVhZHkgaGF2ZSByZWNlaXZlZCBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlVXBsb2FkUmVzcG9uc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcignVXBsb2FkLU9mZnNldCcpLCAxMCk7XG5cbiAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgIHRoaXMuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IGludmFsaWQgb3IgbWlzc2luZyBvZmZzZXQgdmFsdWUnKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VtaXRQcm9ncmVzcyhvZmZzZXQsIHRoaXMuX3NpemUpO1xuXG4gICAgICB0aGlzLl9lbWl0Q2h1bmtDb21wbGV0ZShvZmZzZXQgLSB0aGlzLl9vZmZzZXQsIG9mZnNldCwgdGhpcy5fc2l6ZSk7XG5cbiAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcblxuICAgICAgaWYgKG9mZnNldCA9PSB0aGlzLl9zaXplKSB7XG4gICAgICAgIC8vIFlheSwgZmluYWxseSBkb25lIDopXG4gICAgICAgIHRoaXMuX2VtaXRTdWNjZXNzKCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLmNsb3NlKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZXJmb3JtVXBsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG1ldGhvZCBhbmQgVVJMLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QobWV0aG9kLCB1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLl9yZXEgPSByZXE7XG4gICAgICByZXR1cm4gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGluIHRoZSBVUkwgc3RvcmFnZSwgaWYgaXQgaGFzIGJlZW4gc2F2ZWQgYmVmb3JlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRnJvbVVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21VcmxTdG9yYWdlKCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX3VybFN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5yZW1vdmVVcGxvYWQodGhpcy5fdXJsU3RvcmFnZUtleSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMTAuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHVwbG9hZCBVUkwgdG8gdGhlIFVSTCBzdG9yYWdlLCBpZiBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhdmVVcGxvYWRJblVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7IC8vIE9ubHkgaWYgYSBmaW5nZXJwcmludCB3YXMgY2FsY3VsYXRlZCBmb3IgdGhlIGlucHV0IChpLmUuIG5vdCBhIHN0cmVhbSksIHdlIGNhbiBzdG9yZSB0aGUgdXBsb2FkIFVSTC5cblxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmcgfHwgIXRoaXMuX2ZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3JlZFVwbG9hZCA9IHtcbiAgICAgICAgc2l6ZTogdGhpcy5fc2l6ZSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMub3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBuZXcgRGF0ZSgpLnRvU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9wYXJhbGxlbFVwbG9hZHMpIHtcbiAgICAgICAgLy8gU2F2ZSBtdWx0aXBsZSBVUkxzIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQgLi4uXG4gICAgICAgIHN0b3JlZFVwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMgPSB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAuLi4gb3RoZXJ3aXNlIHdlIGp1c3Qgc2F2ZSB0aGUgb25lIGF2YWlsYWJsZSBVUkwuXG4gICAgICAgIHN0b3JlZFVwbG9hZC51cGxvYWRVcmwgPSB0aGlzLnVybDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5hZGRVcGxvYWQodGhpcy5fZmluZ2VycHJpbnQsIHN0b3JlZFVwbG9hZCkudGhlbihmdW5jdGlvbiAodXJsU3RvcmFnZUtleSkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMS5fdXJsU3RvcmFnZUtleSA9IHVybFN0b3JhZ2VLZXk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMxMS5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHJlcXVlc3Qgd2l0aCB0aGUgcHJvdmlkZWQgYm9keS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NlbmRSZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZW5kUmVxdWVzdChyZXEpIHtcbiAgICAgIHZhciBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgcmV0dXJuIHNlbmRSZXF1ZXN0KHJlcSwgYm9keSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ0ZXJtaW5hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVybWluYXRlKHVybCwgb3B0aW9ucykge1xuICAgICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIGEgY2FsbGJhY2sgaXMgYmVpbmcgcHJvdmlkZWQgYXMgdGhlIGxhc3RcbiAgICAgIC8vIGFyZ3VtZW50IGluIHRoZSBvbGQgc3R5bGUgcmVxdWlyZWQgYnkgdHVzLWpzLWNsaWVudCAxLngsIHRoZW4gdGhyb3cgYW4gZXJyb3IgaWYgaXQgaXMuXG4gICAgICAvLyBgYXJndW1lbnRzYCBpcyBhIEphdmFTY3JpcHQgYnVpbHQtaW4gdmFyaWFibGUgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHVzOiB0aGUgdGVybWluYXRlIGZ1bmN0aW9uIGRvZXMgbm90IGFjY2VwdCBhIGNhbGxiYWNrIHNpbmNlIHYyIGFueW1vcmU7IHBsZWFzZSB1c2UgdGhlIHJldHVybmVkIFByb21pc2UgaW5zdGVhZCcpO1xuICAgICAgfSAvLyBOb3RlIHRoYXQgaW4gb3JkZXIgZm9yIHRoZSB0cmljayBhYm92ZSB0byB3b3JrLCBhIGRlZmF1bHQgdmFsdWUgY2Fubm90IGJlIHNldCBmb3IgYG9wdGlvbnNgLFxuICAgICAgLy8gc28gdGhlIGNoZWNrIGJlbG93IHJlcGxhY2VzIHRoZSBvbGQgZGVmYXVsdCBge31gLlxuXG5cbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QoJ0RFTEVURScsIHVybCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2VuZFJlcXVlc3QocmVxLCBudWxsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgLy8gQSAyMDQgcmVzcG9uc2UgaW5kaWNhdGVzIGEgc3VjY2Vzc2Z1bGwgcmVxdWVzdFxuICAgICAgICBpZiAocmVzLmdldFN0YXR1cygpID09PSAyMDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgX2Vycm9yLmRlZmF1bHQoJ3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSB0ZXJtaW5hdGluZyB1cGxvYWQnLCBudWxsLCByZXEsIHJlcyk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgX2Vycm9yLmRlZmF1bHQpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IF9lcnJvci5kZWZhdWx0KCd0dXM6IGZhaWxlZCB0byB0ZXJtaW5hdGUgdXBsb2FkJywgZXJyLCByZXEsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnIsIDAsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IC8vIEluc3RlYWQgb2Yga2VlcGluZyB0cmFjayBvZiB0aGUgcmV0cnkgYXR0ZW1wdHMsIHdlIHJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBkZWxheXNcbiAgICAgICAgLy8gYXJyYXkuIElmIHRoZSBhcnJheSBpcyBlbXB0eSwgYWxsIHJldHJ5IGF0dGVtcHRzIGFyZSB1c2VkIHVwIGFuZCB3ZSB3aWxsIGJ1YmJsZSB1cCB0aGUgZXJyb3IuXG4gICAgICAgIC8vIFdlIHJlY3Vyc2l2ZWx5IGNhbGwgdGhlIHRlcm1pbmF0ZSBmdW5jdGlvbiB3aWxsIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHJldHJ5RGVsYXlzIGFycmF5LlxuXG5cbiAgICAgICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5yZXRyeURlbGF5c1swXTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0RlbGF5cyA9IG9wdGlvbnMucmV0cnlEZWxheXMuc2xpY2UoMSk7XG5cbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgcmV0cnlEZWxheXM6IHJlbWFpbmluZ0RlbGF5c1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBCYXNlVXBsb2FkLnRlcm1pbmF0ZSh1cmwsIG5ld09wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVXBsb2FkO1xufSgpO1xuXG5mdW5jdGlvbiBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICB2YXIgZW5jb2RlZCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBtZXRhZGF0YSkge1xuICAgIGVuY29kZWQucHVzaChcIlwiLmNvbmNhdChrZXksIFwiIFwiKS5jb25jYXQoX2pzQmFzZS5CYXNlNjQuZW5jb2RlKG1ldGFkYXRhW2tleV0pKSk7XG4gIH1cblxuICByZXR1cm4gZW5jb2RlZC5qb2luKCcsJyk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gc3RhdHVzIGlzIGluIHRoZSByYW5nZSBvZiB0aGUgZXhwZWN0ZWQgY2F0ZWdvcnkuXG4gKiBGb3IgZXhhbXBsZSwgb25seSBhIHN0YXR1cyBiZXR3ZWVuIDIwMCBhbmQgMjk5IHdpbGwgc2F0aXNmeSB0aGUgY2F0ZWdvcnkgMjAwLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIGNhdGVnb3J5KSB7XG4gIHJldHVybiBzdGF0dXMgPj0gY2F0ZWdvcnkgJiYgc3RhdHVzIDwgY2F0ZWdvcnkgKyAxMDA7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG1ldGhvZCBhbmQgVVJMLlxuICogVGhlIG5lY2Vzc2FyeSBoZWFkZXJzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGV2ZXJ5IHJlcXVlc3RcbiAqIHdpbGwgYmUgYWRkZWQsIGluY2x1ZGluZyB0aGUgcmVxdWVzdCBJRC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIG9wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gIHZhciByZXEgPSBvcHRpb25zLmh0dHBTdGFjay5jcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgcmVxLnNldEhlYWRlcignVHVzLVJlc3VtYWJsZScsICcxLjAuMCcpO1xuICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICByZXEuc2V0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWRkUmVxdWVzdElkKSB7XG4gICAgdmFyIHJlcXVlc3RJZCA9ICgwLCBfdXVpZC5kZWZhdWx0KSgpO1xuICAgIHJlcS5zZXRIZWFkZXIoJ1gtUmVxdWVzdC1JRCcsIHJlcXVlc3RJZCk7XG4gIH1cblxuICByZXR1cm4gcmVxO1xufVxuLyoqXG4gKiBTZW5kIGEgcmVxdWVzdCB3aXRoIHRoZSBwcm92aWRlZCBib2R5IHdoaWxlIGludm9raW5nIHRoZSBvbkJlZm9yZVJlcXVlc3RcbiAqIGFuZCBvbkFmdGVyUmVzcG9uc2UgY2FsbGJhY2tzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2VuZFJlcXVlc3QocmVxLCBib2R5LCBvcHRpb25zKSB7XG4gIHZhciBvbkJlZm9yZVJlcXVlc3RQcm9taXNlID0gdHlwZW9mIG9wdGlvbnMub25CZWZvcmVSZXF1ZXN0ID09PSAnZnVuY3Rpb24nID8gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMub25CZWZvcmVSZXF1ZXN0KHJlcSkpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHJldHVybiBvbkJlZm9yZVJlcXVlc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXEuc2VuZChib2R5KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHZhciBvbkFmdGVyUmVzcG9uc2VQcm9taXNlID0gdHlwZW9mIG9wdGlvbnMub25BZnRlclJlc3BvbnNlID09PSAnZnVuY3Rpb24nID8gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMub25BZnRlclJlc3BvbnNlKHJlcSwgcmVzKSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHJldHVybiBvbkFmdGVyUmVzcG9uc2VQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYnJvd3NlciBydW5uaW5nIHRoaXMgY29kZSBoYXMgaW50ZXJuZXQgYWNjZXNzLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsd2F5cyByZXR1cm4gdHJ1ZSBpbiB0aGUgbm9kZS5qcyBlbnZpcm9ubWVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaXNPbmxpbmUoKSB7XG4gIHZhciBvbmxpbmUgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnbmF2aWdhdG9yJyBpbiB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlKSB7XG4gICAgb25saW5lID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gb25saW5lO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgaXQgaXMgb2sgdG8gcmV0cnkgYSByZXF1ZXN0LlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIHRoZSBlcnJvciByZXR1cm5lZCBmcm9tIHRoZSBsYXN0IHJlcXVlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeUF0dGVtcHQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHJldHJpZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHR1cyBVcGxvYWQgb3B0aW9uc1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2hvdWxkUmV0cnkoZXJyLCByZXRyeUF0dGVtcHQsIG9wdGlvbnMpIHtcbiAgLy8gV2Ugb25seSBhdHRlbXB0IGEgcmV0cnkgaWZcbiAgLy8gLSByZXRyeURlbGF5cyBvcHRpb24gaXMgc2V0XG4gIC8vIC0gd2UgZGlkbid0IGV4Y2VlZCB0aGUgbWF4aXVtIG51bWJlciBvZiByZXRyaWVzLCB5ZXQsIGFuZFxuICAvLyAtIHRoaXMgZXJyb3Igd2FzIGNhdXNlZCBieSBhIHJlcXVlc3Qgb3IgaXQncyByZXNwb25zZSBhbmRcbiAgLy8gLSB0aGUgZXJyb3IgaXMgc2VydmVyIGVycm9yIChpLmUuIG5vdCBhIHN0YXR1cyA0eHggZXhjZXB0IGEgNDA5IG9yIDQyMykgb3JcbiAgLy8gYSBvblNob3VsZFJldHJ5IGlzIHNwZWNpZmllZCBhbmQgcmV0dXJucyB0cnVlXG4gIC8vIC0gdGhlIGJyb3dzZXIgZG9lcyBub3QgaW5kaWNhdGUgdGhhdCB3ZSBhcmUgb2ZmbGluZVxuICBpZiAob3B0aW9ucy5yZXRyeURlbGF5cyA9PSBudWxsIHx8IHJldHJ5QXR0ZW1wdCA+PSBvcHRpb25zLnJldHJ5RGVsYXlzLmxlbmd0aCB8fCBlcnIub3JpZ2luYWxSZXF1ZXN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5vblNob3VsZFJldHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMub25TaG91bGRSZXRyeShlcnIsIHJldHJ5QXR0ZW1wdCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc3RhdHVzID0gZXJyLm9yaWdpbmFsUmVzcG9uc2UgPyBlcnIub3JpZ2luYWxSZXNwb25zZS5nZXRTdGF0dXMoKSA6IDA7XG4gIHJldHVybiAoIWluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApIHx8IHN0YXR1cyA9PT0gNDA5IHx8IHN0YXR1cyA9PT0gNDIzKSAmJiBpc09ubGluZSgpO1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgbGluayBnaXZlbiB0aGUgb3JpZ2luIGFzIHNvdXJjZS4gRm9yIGV4YW1wbGUsXG4gKiBpZiBhIEhUVFAgcmVxdWVzdCB0byBodHRwOi8vZXhhbXBsZS5jb20vZmlsZXMvIHJldHVybnMgYSBMb2NhdGlvblxuICogaGVhZGVyIHdpdGggdGhlIHZhbHVlIC91cGxvYWQvYWJjLCB0aGUgcmVzb2x2ZWQgVVJMIHdpbGwgYmU6XG4gKiBodHRwOi8vZXhhbXBsZS5jb20vdXBsb2FkL2FiY1xuICovXG5cblxuZnVuY3Rpb24gcmVzb2x2ZVVybChvcmlnaW4sIGxpbmspIHtcbiAgcmV0dXJuIG5ldyBfdXJsUGFyc2UuZGVmYXVsdChsaW5rLCBvcmlnaW4pLnRvU3RyaW5nKCk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgZm9yIHRoZSBwYXJ0cyBpZiBhbiB1cGxvYWRcbiAqIGlzIHNwbGl0IGludG8gbXVsdGlwbGUgcGFyYWxsZWwgcmVxdWVzdHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsU2l6ZSBUaGUgYnl0ZSBzaXplIG9mIHRoZSB1cGxvYWQsIHdoaWNoIHdpbGwgYmUgc3BsaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFydENvdW50IFRoZSBudW1iZXIgaW4gaG93IG1hbnkgcGFydHMgdGhlIHVwbG9hZCB3aWxsIGJlIHNwbGl0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJldmlvdXNVcmxzIFRoZSB1cGxvYWQgVVJMcyBmb3IgcHJldmlvdXMgcGFydHMuXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3BsaXRTaXplSW50b1BhcnRzKHRvdGFsU2l6ZSwgcGFydENvdW50LCBwcmV2aW91c1VybHMpIHtcbiAgdmFyIHBhcnRTaXplID0gTWF0aC5mbG9vcih0b3RhbFNpemUgLyBwYXJ0Q291bnQpO1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRDb3VudDsgaSsrKSB7XG4gICAgcGFydHMucHVzaCh7XG4gICAgICBzdGFydDogcGFydFNpemUgKiBpLFxuICAgICAgZW5kOiBwYXJ0U2l6ZSAqIChpICsgMSlcbiAgICB9KTtcbiAgfVxuXG4gIHBhcnRzW3BhcnRDb3VudCAtIDFdLmVuZCA9IHRvdGFsU2l6ZTsgLy8gQXR0YWNoIFVSTHMgZnJvbSBwcmV2aW91cyB1cGxvYWRzLCBpZiBhdmFpbGFibGUuXG5cbiAgaWYgKHByZXZpb3VzVXJscykge1xuICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgICBwYXJ0LnVwbG9hZFVybCA9IHByZXZpb3VzVXJsc1tpbmRleF0gfHwgbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuQmFzZVVwbG9hZC5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xudmFyIF9kZWZhdWx0ID0gQmFzZVVwbG9hZDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXVpZDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFVVSUQgdjQgYmFzZWQgb24gcmFuZG9tIG51bWJlcnMuIFdlIGludGVudGlvYW5sbHkgdXNlIHRoZSBsZXNzXG4gKiBzZWN1cmUgTWF0aC5yYW5kb20gZnVuY3Rpb24gaGVyZSBzaW5jZSB0aGUgbW9yZSBzZWN1cmUgY3J5cHRvLmdldFJhbmRvbU51bWJlcnNcbiAqIGlzIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtcy5cbiAqIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBmb3IgdXMgc2luY2Ugd2UgdXNlIHRoZSBVVUlEIG9ubHkgZm9yIGdlbmVyYXRpbmcgYVxuICogcmVxdWVzdCBJRCwgc28gd2UgY2FuIGNvcnJlbGF0ZSBzZXJ2ZXIgbG9ncyB0byBjbGllbnQgZXJyb3JzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGFrZW4gZnJvbSBmb2xsb3dpbmcgc2l0ZTpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9jcmVhdGUtZ3VpZC11dWlkLWluLWphdmFzY3JpcHRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZSBVVUlEXG4gKi9cbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLFxuICAgICAgICB2ID0gYyA9PSAneCcgPyByIDogciAmIDB4MyB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvL1xuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxcXC9dKyk/KFtcXFNcXHNdKikvaVxuICAsIHdpbmRvd3NEcml2ZUxldHRlciA9IC9eW2EtekEtWl06L1xuICAsIHdoaXRlc3BhY2UgPSAnW1xcXFx4MDlcXFxceDBBXFxcXHgwQlxcXFx4MENcXFxceDBEXFxcXHgyMFxcXFx4QTBcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdUZFRkZdJ1xuICAsIGxlZnQgPSBuZXcgUmVnRXhwKCdeJysgd2hpdGVzcGFjZSArJysnKTtcblxuLyoqXG4gKiBUcmltIGEgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRyaW0uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gKHN0ciA/IHN0ciA6ICcnKS50b1N0cmluZygpLnJlcGxhY2UobGVmdCwgJycpO1xufVxuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzLCB1cmwpIHsgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/IGFkZHJlc3MucmVwbGFjZSgvXFxcXC9nLCAnLycpIDogYWRkcmVzcztcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBnbG9iYWxWYXI7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBnbG9iYWw7XG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gc2VsZjtcbiAgZWxzZSBnbG9iYWxWYXIgPSB7fTtcblxuICB2YXIgbG9jYXRpb24gPSBnbG9iYWxWYXIubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgcHJvdG9jb2wgc2NoZW1lIGlzIHNwZWNpYWwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFRoZSBwcm90b2NvbCBzY2hlbWUgb2YgdGhlIFVSTFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm90b2NvbCBzY2hlbWUgaXMgc3BlY2lhbCwgZWxzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1NwZWNpYWwoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lID09PSAnZmlsZTonIHx8XG4gICAgc2NoZW1lID09PSAnZnRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwczonIHx8XG4gICAgc2NoZW1lID09PSAnd3M6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ3dzczonXG4gICk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb25cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MsIGxvY2F0aW9uKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgbG9jYXRpb24gPSBsb2NhdGlvbiB8fCB7fTtcblxuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG4gIHZhciBwcm90b2NvbCA9IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnO1xuICB2YXIgZm9yd2FyZFNsYXNoZXMgPSAhIW1hdGNoWzJdO1xuICB2YXIgb3RoZXJTbGFzaGVzID0gISFtYXRjaFszXTtcbiAgdmFyIHNsYXNoZXNDb3VudCA9IDA7XG4gIHZhciByZXN0O1xuXG4gIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgIGlmIChvdGhlclNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAob3RoZXJTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gbWF0Y2hbM10gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzNdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdCA9IG1hdGNoWzRdXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgaWYgKHNsYXNoZXNDb3VudCA+PSAyKSB7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZSgyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTcGVjaWFsKHByb3RvY29sKSkge1xuICAgIHJlc3QgPSBtYXRjaFs0XTtcbiAgfSBlbHNlIGlmIChwcm90b2NvbCkge1xuICAgIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNsYXNoZXNDb3VudCA+PSAyICYmIGlzU3BlY2lhbChsb2NhdGlvbi5wcm90b2NvbCkpIHtcbiAgICByZXN0ID0gbWF0Y2hbNF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBzbGFzaGVzOiBmb3J3YXJkU2xhc2hlcyB8fCBpc1NwZWNpYWwocHJvdG9jb2wpLFxuICAgIHNsYXNoZXNDb3VudDogc2xhc2hlc0NvdW50LFxuICAgIHJlc3Q6IHJlc3RcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnLCBsb2NhdGlvbik7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoXG4gICAgZXh0cmFjdGVkLnByb3RvY29sID09PSAnZmlsZTonICYmIChcbiAgICAgIGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgIT09IDIgfHwgd2luZG93c0RyaXZlTGV0dGVyLnRlc3QoYWRkcmVzcykpIHx8XG4gICAgKCFleHRyYWN0ZWQuc2xhc2hlcyAmJlxuICAgICAgKGV4dHJhY3RlZC5wcm90b2NvbCB8fFxuICAgICAgICBleHRyYWN0ZWQuc2xhc2hlc0NvdW50IDwgMiB8fFxuICAgICAgICAhaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpKVxuICApIHtcbiAgICBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcywgdXJsKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIERlZmF1bHQgdG8gYSAvIGZvciBwYXRobmFtZSBpZiBub25lIGV4aXN0cy4gVGhpcyBub3JtYWxpemVzIHRoZSBVUkxcbiAgLy8gdG8gYWx3YXlzIGhhdmUgYSAvXG4gIC8vXG4gIGlmICh1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnLycgKyB1cmwucGF0aG5hbWU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdFxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpICYmIHVybC5ob3N0XG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzIHx8IGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoJ0F1dGhvcml6YXRpb24gcmVxdWlyZWQnKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoRXJyb3InXG4gICAgdGhpcy5pc0F1dGhFcnJvciA9IHRydWVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhFcnJvclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlcXVlc3RDbGllbnQgPSByZXF1aXJlKCcuL1JlcXVlc3RDbGllbnQnKVxuY29uc3QgdG9rZW5TdG9yYWdlID0gcmVxdWlyZSgnLi90b2tlblN0b3JhZ2UnKVxuXG5jb25zdCBnZXROYW1lID0gKGlkKSA9PiB7XG4gIHJldHVybiBpZC5zcGxpdCgnLScpLm1hcCgocykgPT4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSkpLmpvaW4oJyAnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFByb3ZpZGVyIGV4dGVuZHMgUmVxdWVzdENsaWVudCB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlclxuICAgIHRoaXMuaWQgPSB0aGlzLnByb3ZpZGVyXG4gICAgdGhpcy5uYW1lID0gdGhpcy5vcHRzLm5hbWUgfHwgZ2V0TmFtZSh0aGlzLmlkKVxuICAgIHRoaXMucGx1Z2luSWQgPSB0aGlzLm9wdHMucGx1Z2luSWRcbiAgICB0aGlzLnRva2VuS2V5ID0gYGNvbXBhbmlvbi0ke3RoaXMucGx1Z2luSWR9LWF1dGgtdG9rZW5gXG4gICAgdGhpcy5jb21wYW5pb25LZXlzUGFyYW1zID0gdGhpcy5vcHRzLmNvbXBhbmlvbktleXNQYXJhbXNcbiAgICB0aGlzLnByZUF1dGhUb2tlbiA9IG51bGxcbiAgfVxuXG4gIGhlYWRlcnMgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbc3VwZXIuaGVhZGVycygpLCB0aGlzLmdldEF1dGhUb2tlbigpXSlcbiAgICAgIC50aGVuKChbaGVhZGVycywgdG9rZW5dKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0ge31cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgYXV0aEhlYWRlcnNbJ3VwcHktYXV0aC10b2tlbiddID0gdG9rZW5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbXBhbmlvbktleXNQYXJhbXMpIHtcbiAgICAgICAgICBhdXRoSGVhZGVyc1sndXBweS1jcmVkZW50aWFscy1wYXJhbXMnXSA9IGJ0b2EoXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHBhcmFtczogdGhpcy5jb21wYW5pb25LZXlzUGFyYW1zIH0pLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5oZWFkZXJzLCAuLi5hdXRoSGVhZGVycyB9XG4gICAgICB9KVxuICB9XG5cbiAgb25SZWNlaXZlUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgcmVzcG9uc2UgPSBzdXBlci5vblJlY2VpdmVSZXNwb25zZShyZXNwb25zZSlcbiAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpXG4gICAgY29uc3Qgb2xkQXV0aGVudGljYXRlZCA9IHBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLmF1dGhlbnRpY2F0ZWRcbiAgICBjb25zdCBhdXRoZW50aWNhdGVkID0gb2xkQXV0aGVudGljYXRlZCA/IHJlc3BvbnNlLnN0YXR1cyAhPT0gNDAxIDogcmVzcG9uc2Uuc3RhdHVzIDwgNDAwXG4gICAgcGx1Z2luLnNldFBsdWdpblN0YXRlKHsgYXV0aGVudGljYXRlZCB9KVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgc2V0QXV0aFRva2VuICh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnRva2VuS2V5LCB0b2tlbilcbiAgfVxuXG4gIGdldEF1dGhUb2tlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBweS5nZXRQbHVnaW4odGhpcy5wbHVnaW5JZCkuc3RvcmFnZS5nZXRJdGVtKHRoaXMudG9rZW5LZXkpXG4gIH1cblxuICBhdXRoVXJsIChxdWVyaWVzID0ge30pIHtcbiAgICBpZiAodGhpcy5wcmVBdXRoVG9rZW4pIHtcbiAgICAgIHF1ZXJpZXMudXBweVByZUF1dGhUb2tlbiA9IHRoaXMucHJlQXV0aFRva2VuXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMuaG9zdG5hbWV9LyR7dGhpcy5pZH0vY29ubmVjdD8ke25ldyBVUkxTZWFyY2hQYXJhbXMocXVlcmllcyl9YFxuICB9XG5cbiAgZmlsZVVybCAoaWQpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5ob3N0bmFtZX0vJHt0aGlzLmlkfS9nZXQvJHtpZH1gXG4gIH1cblxuICBmZXRjaFByZUF1dGhUb2tlbiAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBhbmlvbktleXNQYXJhbXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QoYCR7dGhpcy5pZH0vcHJlYXV0aC9gLCB7IHBhcmFtczogdGhpcy5jb21wYW5pb25LZXlzUGFyYW1zIH0pXG4gICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgIHRoaXMucHJlQXV0aFRva2VuID0gcmVzLnRva2VuXG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coYFtDb21wYW5pb25DbGllbnRdIHVuYWJsZSB0byBmZXRjaCBwcmVBdXRoVG9rZW4gJHtlcnJ9YCwgJ3dhcm5pbmcnKVxuICAgICAgfSlcbiAgfVxuXG4gIGxpc3QgKGRpcmVjdG9yeSkge1xuICAgIHJldHVybiB0aGlzLmdldChgJHt0aGlzLmlkfS9saXN0LyR7ZGlyZWN0b3J5IHx8ICcnfWApXG4gIH1cblxuICBsb2dvdXQgKCkge1xuICAgIHJldHVybiB0aGlzLmdldChgJHt0aGlzLmlkfS9sb2dvdXRgKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiBQcm9taXNlLmFsbChbXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnRva2VuS2V5KSxcbiAgICAgIF0pKS50aGVuKChbcmVzcG9uc2VdKSA9PiByZXNwb25zZSlcbiAgfVxuXG4gIHN0YXRpYyBpbml0UGx1Z2luIChwbHVnaW4sIG9wdHMsIGRlZmF1bHRPcHRzKSB7XG4gICAgcGx1Z2luLnR5cGUgPSAnYWNxdWlyZXInXG4gICAgcGx1Z2luLmZpbGVzID0gW11cbiAgICBpZiAoZGVmYXVsdE9wdHMpIHtcbiAgICAgIHBsdWdpbi5vcHRzID0geyAuLi5kZWZhdWx0T3B0cywgLi4ub3B0cyB9XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc2VydmVyVXJsIHx8IG9wdHMuc2VydmVyUGF0dGVybikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgc2VydmVyVXJsYCBhbmQgYHNlcnZlclBhdHRlcm5gIGhhdmUgYmVlbiByZW5hbWVkIHRvIGBjb21wYW5pb25VcmxgIGFuZCBgY29tcGFuaW9uQWxsb3dlZEhvc3RzYCByZXNwZWN0aXZlbHkgaW4gdGhlIDAuMzAuNSByZWxlYXNlLiBQbGVhc2UgY29uc3VsdCB0aGUgZG9jcyAoZm9yIGV4YW1wbGUsIGh0dHBzOi8vdXBweS5pby9kb2NzL2luc3RhZ3JhbS8gZm9yIHRoZSBJbnN0YWdyYW0gcGx1Z2luKSBhbmQgdXNlIHRoZSB1cGRhdGVkIG9wdGlvbnMuYCcpXG4gICAgfVxuXG4gICAgaWYgKG9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzKSB7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gb3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHNcbiAgICAgIC8vIHZhbGlkYXRlIGNvbXBhbmlvbkFsbG93ZWRIb3N0cyBwYXJhbVxuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShwYXR0ZXJuKSAmJiAhKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7cGx1Z2luLmlkfTogdGhlIG9wdGlvbiBcImNvbXBhbmlvbkFsbG93ZWRIb3N0c1wiIG11c3QgYmUgb25lIG9mIHN0cmluZywgQXJyYXksIFJlZ0V4cGApXG4gICAgICB9XG4gICAgICBwbHVnaW4ub3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMgPSBwYXR0ZXJuXG4gICAgfSBlbHNlIGlmICgvXig/IWh0dHBzPzpcXC9cXC8pLiokL2kudGVzdChvcHRzLmNvbXBhbmlvblVybCkpIHtcbiAgICAgIC8vIGRvZXMgbm90IHN0YXJ0IHdpdGggaHR0cHM6Ly9cbiAgICAgIHBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cyA9IGBodHRwczovLyR7b3B0cy5jb21wYW5pb25VcmwucmVwbGFjZSgvXlxcL1xcLy8sICcnKX1gXG4gICAgfSBlbHNlIHtcbiAgICAgIHBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cyA9IG5ldyBVUkwob3B0cy5jb21wYW5pb25VcmwpLm9yaWdpblxuICAgIH1cblxuICAgIHBsdWdpbi5zdG9yYWdlID0gcGx1Z2luLm9wdHMuc3RvcmFnZSB8fCB0b2tlblN0b3JhZ2VcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZldGNoV2l0aE5ldHdvcmtFcnJvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9mZXRjaFdpdGhOZXR3b3JrRXJyb3InKVxuY29uc3QgQXV0aEVycm9yID0gcmVxdWlyZSgnLi9BdXRoRXJyb3InKVxuXG4vLyBSZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoIHNvIHdlIGNhbiBhbHdheXMgc2FmZWx5IGFwcGVuZCAveHl6LlxuZnVuY3Rpb24gc3RyaXBTbGFzaCAodXJsKSB7XG4gIHJldHVybiB1cmwucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVKU09OUmVzcG9uc2UgKHJlcykge1xuICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgdGhyb3cgbmV3IEF1dGhFcnJvcigpXG4gIH1cblxuICBjb25zdCBqc29uUHJvbWlzZSA9IHJlcy5qc29uKClcblxuICBpZiAocmVzLnN0YXR1cyA8IDIwMCB8fCByZXMuc3RhdHVzID4gMzAwKSB7XG4gICAgbGV0IGVyck1zZyA9IGBGYWlsZWQgcmVxdWVzdCB3aXRoIHN0YXR1czogJHtyZXMuc3RhdHVzfS4gJHtyZXMuc3RhdHVzVGV4dH1gXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVyckRhdGEgPSBhd2FpdCBqc29uUHJvbWlzZVxuICAgICAgZXJyTXNnID0gZXJyRGF0YS5tZXNzYWdlID8gYCR7ZXJyTXNnfSBtZXNzYWdlOiAke2VyckRhdGEubWVzc2FnZX1gIDogZXJyTXNnXG4gICAgICBlcnJNc2cgPSBlcnJEYXRhLnJlcXVlc3RJZCA/IGAke2Vyck1zZ30gcmVxdWVzdC1JZDogJHtlcnJEYXRhLnJlcXVlc3RJZH1gIDogZXJyTXNnXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnNhZmUtZmluYWxseVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGpzb25Qcm9taXNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVxdWVzdENsaWVudCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAjZ2V0UG9zdFJlc3BvbnNlRnVuYyA9IHNraXAgPT4gcmVzcG9uc2UgPT4gKHNraXAgPyByZXNwb25zZSA6IHRoaXMub25SZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpKVxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgdGhpcy51cHB5ID0gdXBweVxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLm9uUmVjZWl2ZVJlc3BvbnNlID0gdGhpcy5vblJlY2VpdmVSZXNwb25zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5hbGxvd2VkSGVhZGVycyA9IFsnYWNjZXB0JywgJ2NvbnRlbnQtdHlwZScsICd1cHB5LWF1dGgtdG9rZW4nXVxuICAgIHRoaXMucHJlZmxpZ2h0RG9uZSA9IGZhbHNlXG4gIH1cblxuICBnZXQgaG9zdG5hbWUgKCkge1xuICAgIGNvbnN0IHsgY29tcGFuaW9uIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGhvc3QgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG4gICAgcmV0dXJuIHN0cmlwU2xhc2goY29tcGFuaW9uICYmIGNvbXBhbmlvbltob3N0XSA/IGNvbXBhbmlvbltob3N0XSA6IGhvc3QpXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdEhlYWRlcnMgPXtcbiAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICdVcHB5LVZlcnNpb25zJzogYEB1cHB5L2NvbXBhbmlvbi1jbGllbnQ9JHtSZXF1ZXN0Q2xpZW50LlZFUlNJT059YCxcbiAgfVxuXG4gIGhlYWRlcnMgKCkge1xuICAgIGNvbnN0IHVzZXJIZWFkZXJzID0gdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwge31cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIC4uLlJlcXVlc3RDbGllbnQuZGVmYXVsdEhlYWRlcnMsXG4gICAgICAuLi51c2VySGVhZGVycyxcbiAgICB9KVxuICB9XG5cbiAgb25SZWNlaXZlUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGNvbXBhbmlvbiA9IHN0YXRlLmNvbXBhbmlvbiB8fCB7fVxuICAgIGNvbnN0IGhvc3QgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG4gICAgY29uc3QgeyBoZWFkZXJzIH0gPSByZXNwb25zZVxuICAgIC8vIFN0b3JlIHRoZSBzZWxmLWlkZW50aWZpZWQgZG9tYWluIG5hbWUgZm9yIHRoZSBDb21wYW5pb24gaW5zdGFuY2Ugd2UganVzdCBoaXQuXG4gICAgaWYgKGhlYWRlcnMuaGFzKCdpLWFtJykgJiYgaGVhZGVycy5nZXQoJ2ktYW0nKSAhPT0gY29tcGFuaW9uW2hvc3RdKSB7XG4gICAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgICBjb21wYW5pb246IHsgLi4uY29tcGFuaW9uLCBbaG9zdF06IGhlYWRlcnMuZ2V0KCdpLWFtJykgfSxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgI2dldFVybCAodXJsKSB7XG4gICAgaWYgKC9eKGh0dHBzPzp8KVxcL1xcLy8udGVzdCh1cmwpKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS8ke3VybH1gXG4gIH1cblxuICAjZXJyb3JIYW5kbGVyIChtZXRob2QsIHBhdGgpIHtcbiAgICByZXR1cm4gKGVycikgPT4ge1xuICAgICAgaWYgKCFlcnI/LmlzQXV0aEVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBDb3VsZCBub3QgJHttZXRob2R9ICR7dGhpcy4jZ2V0VXJsKHBhdGgpfWApXG4gICAgICAgIGVycm9yLmNhdXNlID0gZXJyXG4gICAgICAgIGVyciA9IGVycm9yIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgfVxuICB9XG5cbiAgcHJlZmxpZ2h0IChwYXRoKSB7XG4gICAgaWYgKHRoaXMucHJlZmxpZ2h0RG9uZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoKHRoaXMuI2dldFVybChwYXRoKSwge1xuICAgICAgbWV0aG9kOiAnT1BUSU9OUycsXG4gICAgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5oYXMoJ2FjY2Vzcy1jb250cm9sLWFsbG93LWhlYWRlcnMnKSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dlZEhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnYWNjZXNzLWNvbnRyb2wtYWxsb3ctaGVhZGVycycpXG4gICAgICAgICAgICAuc3BsaXQoJywnKS5tYXAoKGhlYWRlck5hbWUpID0+IGhlYWRlck5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmbGlnaHREb25lID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5hbGxvd2VkSGVhZGVycy5zbGljZSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhgW0NvbXBhbmlvbkNsaWVudF0gdW5hYmxlIHRvIG1ha2UgcHJlZmxpZ2h0IHJlcXVlc3QgJHtlcnJ9YCwgJ3dhcm5pbmcnKVxuICAgICAgICB0aGlzLnByZWZsaWdodERvbmUgPSB0cnVlXG4gICAgICAgIHJldHVybiB0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKClcbiAgICAgIH0pXG4gIH1cblxuICBwcmVmbGlnaHRBbmRIZWFkZXJzIChwYXRoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLnByZWZsaWdodChwYXRoKSwgdGhpcy5oZWFkZXJzKCldKVxuICAgICAgLnRoZW4oKFthbGxvd2VkSGVhZGVycywgaGVhZGVyc10pID0+IHtcbiAgICAgICAgLy8gZmlsdGVyIHRvIGtlZXAgb25seSBhbGxvd2VkIEhlYWRlcnNcbiAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaCgoaGVhZGVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFhbGxvd2VkSGVhZGVycy5pbmNsdWRlcyhoZWFkZXIudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBweS5sb2coYFtDb21wYW5pb25DbGllbnRdIGV4Y2x1ZGluZyBkaXNhbGxvd2VkIGhlYWRlciAke2hlYWRlcn1gKVxuICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBoZWFkZXJzXG4gICAgICB9KVxuICB9XG5cbiAgZ2V0IChwYXRoLCBza2lwUG9zdFJlc3BvbnNlKSB7XG4gICAgY29uc3QgbWV0aG9kID0gJ2dldCdcbiAgICByZXR1cm4gdGhpcy5wcmVmbGlnaHRBbmRIZWFkZXJzKHBhdGgpXG4gICAgICAudGhlbigoaGVhZGVycykgPT4gZmV0Y2hXaXRoTmV0d29ya0Vycm9yKHRoaXMuI2dldFVybChwYXRoKSwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUgfHwgJ3NhbWUtb3JpZ2luJyxcbiAgICAgIH0pKVxuICAgICAgLnRoZW4odGhpcy4jZ2V0UG9zdFJlc3BvbnNlRnVuYyhza2lwUG9zdFJlc3BvbnNlKSlcbiAgICAgIC50aGVuKGhhbmRsZUpTT05SZXNwb25zZSlcbiAgICAgIC5jYXRjaCh0aGlzLiNlcnJvckhhbmRsZXIobWV0aG9kLCBwYXRoKSlcbiAgfVxuXG4gIHBvc3QgKHBhdGgsIGRhdGEsIHNraXBQb3N0UmVzcG9uc2UpIHtcbiAgICBjb25zdCBtZXRob2QgPSAncG9zdCdcbiAgICByZXR1cm4gdGhpcy5wcmVmbGlnaHRBbmRIZWFkZXJzKHBhdGgpXG4gICAgICAudGhlbigoaGVhZGVycykgPT4gZmV0Y2hXaXRoTmV0d29ya0Vycm9yKHRoaXMuI2dldFVybChwYXRoKSwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUgfHwgJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICB9KSlcbiAgICAgIC50aGVuKHRoaXMuI2dldFBvc3RSZXNwb25zZUZ1bmMoc2tpcFBvc3RSZXNwb25zZSkpXG4gICAgICAudGhlbihoYW5kbGVKU09OUmVzcG9uc2UpXG4gICAgICAuY2F0Y2godGhpcy4jZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGF0aCkpXG4gIH1cblxuICBkZWxldGUgKHBhdGgsIGRhdGEsIHNraXBQb3N0UmVzcG9uc2UpIHtcbiAgICBjb25zdCBtZXRob2QgPSAnZGVsZXRlJ1xuICAgIHJldHVybiB0aGlzLnByZWZsaWdodEFuZEhlYWRlcnMocGF0aClcbiAgICAgIC50aGVuKChoZWFkZXJzKSA9PiBmZXRjaFdpdGhOZXR3b3JrRXJyb3IoYCR7dGhpcy5ob3N0bmFtZX0vJHtwYXRofWAsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBjcmVkZW50aWFsczogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlIHx8ICdzYW1lLW9yaWdpbicsXG4gICAgICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IG51bGwsXG4gICAgICB9KSlcbiAgICAgIC50aGVuKHRoaXMuI2dldFBvc3RSZXNwb25zZUZ1bmMoc2tpcFBvc3RSZXNwb25zZSkpXG4gICAgICAudGhlbihoYW5kbGVKU09OUmVzcG9uc2UpXG4gICAgICAuY2F0Y2godGhpcy4jZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGF0aCkpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSZXF1ZXN0Q2xpZW50ID0gcmVxdWlyZSgnLi9SZXF1ZXN0Q2xpZW50JylcblxuY29uc3QgZ2V0TmFtZSA9IChpZCkgPT4ge1xuICByZXR1cm4gaWQuc3BsaXQoJy0nKS5tYXAoKHMpID0+IHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpKS5qb2luKCcgJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZWFyY2hQcm92aWRlciBleHRlbmRzIFJlcXVlc3RDbGllbnQge1xuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5wcm92aWRlciA9IG9wdHMucHJvdmlkZXJcbiAgICB0aGlzLmlkID0gdGhpcy5wcm92aWRlclxuICAgIHRoaXMubmFtZSA9IHRoaXMub3B0cy5uYW1lIHx8IGdldE5hbWUodGhpcy5pZClcbiAgICB0aGlzLnBsdWdpbklkID0gdGhpcy5vcHRzLnBsdWdpbklkXG4gIH1cblxuICBmaWxlVXJsIChpZCkge1xuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS9zZWFyY2gvJHt0aGlzLmlkfS9nZXQvJHtpZH1gXG4gIH1cblxuICBzZWFyY2ggKHRleHQsIHF1ZXJpZXMpIHtcbiAgICBxdWVyaWVzID0gcXVlcmllcyA/IGAmJHtxdWVyaWVzfWAgOiAnJ1xuICAgIHJldHVybiB0aGlzLmdldChgc2VhcmNoLyR7dGhpcy5pZH0vbGlzdD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpfSR7cXVlcmllc31gKVxuICB9XG59XG4iLCJjb25zdCBlZSA9IHJlcXVpcmUoJ25hbWVzcGFjZS1lbWl0dGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVcHB5U29ja2V0IHtcbiAgI3F1ZXVlZCA9IFtdXG5cbiAgI2VtaXR0ZXIgPSBlZSgpXG5cbiAgI2lzT3BlbiA9IGZhbHNlXG5cbiAgI3NvY2tldFxuXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0c1xuXG4gICAgaWYgKCFvcHRzIHx8IG9wdHMuYXV0b09wZW4gIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIGdldCBpc09wZW4gKCkgeyByZXR1cm4gdGhpcy4jaXNPcGVuIH1cblxuICBbU3ltYm9sLmZvcigndXBweSB0ZXN0OiBnZXRTb2NrZXQnKV0gKCkgeyByZXR1cm4gdGhpcy4jc29ja2V0IH1cblxuICBbU3ltYm9sLmZvcigndXBweSB0ZXN0OiBnZXRRdWV1ZWQnKV0gKCkgeyByZXR1cm4gdGhpcy4jcXVldWVkIH1cblxuICBvcGVuICgpIHtcbiAgICB0aGlzLiNzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMub3B0cy50YXJnZXQpXG5cbiAgICB0aGlzLiNzb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgdGhpcy4jaXNPcGVuID0gdHJ1ZVxuXG4gICAgICB3aGlsZSAodGhpcy4jcXVldWVkLmxlbmd0aCA+IDAgJiYgdGhpcy4jaXNPcGVuKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy4jcXVldWVkLnNoaWZ0KClcbiAgICAgICAgdGhpcy5zZW5kKGZpcnN0LmFjdGlvbiwgZmlyc3QucGF5bG9hZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiNzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuI2lzT3BlbiA9IGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy4jc29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuI2hhbmRsZU1lc3NhZ2VcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLiNzb2NrZXQ/LmNsb3NlKClcbiAgfVxuXG4gIHNlbmQgKGFjdGlvbiwgcGF5bG9hZCkge1xuICAgIC8vIGF0dGFjaCB1dWlkXG5cbiAgICBpZiAoIXRoaXMuI2lzT3Blbikge1xuICAgICAgdGhpcy4jcXVldWVkLnB1c2goeyBhY3Rpb24sIHBheWxvYWQgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuI3NvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGFjdGlvbixcbiAgICAgIHBheWxvYWQsXG4gICAgfSkpXG4gIH1cblxuICBvbiAoYWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgdGhpcy4jZW1pdHRlci5vbihhY3Rpb24sIGhhbmRsZXIpXG4gIH1cblxuICBlbWl0IChhY3Rpb24sIHBheWxvYWQpIHtcbiAgICB0aGlzLiNlbWl0dGVyLmVtaXQoYWN0aW9uLCBwYXlsb2FkKVxuICB9XG5cbiAgb25jZSAoYWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgdGhpcy4jZW1pdHRlci5vbmNlKGFjdGlvbiwgaGFuZGxlcilcbiAgfVxuXG4gICNoYW5kbGVNZXNzYWdlPSAoZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShlLmRhdGEpXG4gICAgICB0aGlzLmVtaXQobWVzc2FnZS5hY3Rpb24sIG1lc3NhZ2UucGF5bG9hZClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRPRE86IHVzZSBhIG1vcmUgcm9idXN0IGVycm9yIGhhbmRsZXIuXG4gICAgICBjb25zb2xlLmxvZyhlcnIpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTWFuYWdlcyBjb21tdW5pY2F0aW9ucyB3aXRoIENvbXBhbmlvblxuICovXG5cbmNvbnN0IFJlcXVlc3RDbGllbnQgPSByZXF1aXJlKCcuL1JlcXVlc3RDbGllbnQnKVxuY29uc3QgUHJvdmlkZXIgPSByZXF1aXJlKCcuL1Byb3ZpZGVyJylcbmNvbnN0IFNlYXJjaFByb3ZpZGVyID0gcmVxdWlyZSgnLi9TZWFyY2hQcm92aWRlcicpXG5jb25zdCBTb2NrZXQgPSByZXF1aXJlKCcuL1NvY2tldCcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBSZXF1ZXN0Q2xpZW50LFxuICBQcm92aWRlcixcbiAgU2VhcmNoUHJvdmlkZXIsXG4gIFNvY2tldCxcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIHNlcnZlcyBhcyBhbiBBc3luYyB3cmFwcGVyIGZvciBMb2NhbFN0b3JhZ2VcbiAqL1xubW9kdWxlLmV4cG9ydHMuc2V0SXRlbSA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpXG4gICAgcmVzb2x2ZSgpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLmdldEl0ZW0gPSAoa2V5KSA9PiB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSlcbn1cblxubW9kdWxlLmV4cG9ydHMucmVtb3ZlSXRlbSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgIHJlc29sdmUoKVxuICB9KVxufVxuIiwiLyoqXG4gKiBDb3JlIHBsdWdpbiBsb2dpYyB0aGF0IGFsbCBwbHVnaW5zIHNoYXJlLlxuICpcbiAqIEJhc2VQbHVnaW4gZG9lcyBub3QgY29udGFpbiBET00gcmVuZGVyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGZvciBwbHVnaW5zXG4gKiB3aXRob3V0IGEgdXNlciBpbnRlcmZhY2UuXG4gKlxuICogU2VlIGBQbHVnaW5gIGZvciB0aGUgZXh0ZW5kZWQgdmVyc2lvbiB3aXRoIFByZWFjdCByZW5kZXJpbmcgZm9yIGludGVyZmFjZXMuXG4gKi9cblxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCYXNlUGx1Z2luIHtcbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMgPSB7fSkge1xuICAgIHRoaXMudXBweSA9IHVwcHlcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gIH1cblxuICBnZXRQbHVnaW5TdGF0ZSAoKSB7XG4gICAgY29uc3QgeyBwbHVnaW5zIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIHJldHVybiBwbHVnaW5zW3RoaXMuaWRdIHx8IHt9XG4gIH1cblxuICBzZXRQbHVnaW5TdGF0ZSAodXBkYXRlKSB7XG4gICAgY29uc3QgeyBwbHVnaW5zIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuXG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgLi4ucGx1Z2lucyxcbiAgICAgICAgW3RoaXMuaWRdOiB7XG4gICAgICAgICAgLi4ucGx1Z2luc1t0aGlzLmlkXSxcbiAgICAgICAgICAuLi51cGRhdGUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgdGhpcy5vcHRzID0geyAuLi50aGlzLm9wdHMsIC4uLm5ld09wdHMgfVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoKSAvLyBzbyB0aGF0IFVJIHJlLXJlbmRlcnMgd2l0aCBuZXcgb3B0aW9uc1xuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIGNvbnN0IHRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihbdGhpcy5kZWZhdWx0TG9jYWxlLCB0aGlzLnVwcHkubG9jYWxlLCB0aGlzLm9wdHMubG9jYWxlXSlcbiAgICB0aGlzLmkxOG4gPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZUFycmF5LmJpbmQodHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kYWJsZSBtZXRob2RzXG4gICAqID09PT09PT09PT09PT09PT09PVxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBoZXJlIHRvIHNlcnZlIGFzIGFuIG92ZXJ2aWV3IG9mIHRoZSBleHRlbmRhYmxlIG1ldGhvZHMgYXMgd2VsbCBhc1xuICAgKiBtYWtpbmcgdGhlbSBub3QgY29uZGl0aW9uYWwgaW4gdXNlLCBzdWNoIGFzIGBpZiAodGhpcy5hZnRlclVwZGF0ZSlgLlxuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBhZGRUYXJnZXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5kIHRoZSBhZGRUYXJnZXQgbWV0aG9kIHRvIGFkZCB5b3VyIHBsdWdpbiB0byBhbm90aGVyIHBsdWdpblxcJ3MgdGFyZ2V0JylcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGluc3RhbGwgKCkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICB1bmluc3RhbGwgKCkge31cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gcGx1Z2luIGlzIG1vdW50ZWQsIHdoZXRoZXIgaW4gRE9NIG9yIGludG8gYW5vdGhlciBwbHVnaW4uXG4gICAqIE5lZWRlZCBiZWNhdXNlIHNvbWV0aW1lcyBwbHVnaW5zIGFyZSBtb3VudGVkIHNlcGFyYXRlbHkvYWZ0ZXIgYGluc3RhbGxgLFxuICAgKiBzbyB0aGlzLmVsIGFuZCB0aGlzLnBhcmVudCBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIGBpbnN0YWxsYC5cbiAgICogVGhpcyBpcyB0aGUgY2FzZSB3aXRoIEB1cHB5L3JlYWN0IHBsdWdpbnMsIGZvciBleGFtcGxlLlxuICAgKi9cbiAgcmVuZGVyICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuZCB0aGUgcmVuZGVyIG1ldGhvZCB0byBhZGQgeW91ciBwbHVnaW4gdG8gYSBET00gZWxlbWVudCcpXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICB1cGRhdGUgKCkge31cblxuICAvLyBDYWxsZWQgYWZ0ZXIgZXZlcnkgc3RhdGUgdXBkYXRlLCBhZnRlciBldmVyeXRoaW5nJ3MgbW91bnRlZC4gRGVib3VuY2VkLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBhZnRlclVwZGF0ZSAoKSB7fVxufVxuIiwiY29uc3QgeyByZW5kZXIgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBmaW5kRE9NRWxlbWVudCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kRE9NRWxlbWVudCcpXG5cbmNvbnN0IEJhc2VQbHVnaW4gPSByZXF1aXJlKCcuL0Jhc2VQbHVnaW4nKVxuXG4vKipcbiAqIERlZmVyIGEgZnJlcXVlbnQgY2FsbCB0byB0aGUgbWljcm90YXNrIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZSAoZm4pIHtcbiAgbGV0IGNhbGxpbmcgPSBudWxsXG4gIGxldCBsYXRlc3RBcmdzID0gbnVsbFxuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBsYXRlc3RBcmdzID0gYXJnc1xuICAgIGlmICghY2FsbGluZykge1xuICAgICAgY2FsbGluZyA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjYWxsaW5nID0gbnVsbFxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IGBhcmdzYCBtYXkgYmUgZGlmZmVyZW50IGZyb20gdGhlIG1vc3RcbiAgICAgICAgLy8gcmVjZW50IHN0YXRlLCBpZiBtdWx0aXBsZSBjYWxscyBoYXBwZW5lZCBzaW5jZSB0aGlzIHRhc2tcbiAgICAgICAgLy8gd2FzIHF1ZXVlZC4gU28gd2UgdXNlIHRoZSBgbGF0ZXN0QXJnc2AsIHdoaWNoIGRlZmluaXRlbHlcbiAgICAgICAgLy8gaXMgdGhlIG1vc3QgcmVjZW50IGNhbGwuXG4gICAgICAgIHJldHVybiBmbiguLi5sYXRlc3RBcmdzKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxpbmdcbiAgfVxufVxuXG4vKipcbiAqIFVJUGx1Z2luIGlzIHRoZSBleHRlbmRlZCB2ZXJzaW9uIG9mIEJhc2VQbHVnaW4gdG8gaW5jb3Jwb3JhdGUgcmVuZGVyaW5nIHdpdGggUHJlYWN0LlxuICogVXNlIHRoaXMgZm9yIHBsdWdpbnMgdGhhdCBuZWVkIGEgdXNlciBpbnRlcmZhY2UuXG4gKlxuICogRm9yIHBsdWdpbnMgd2l0aG91dCBhbiB1c2VyIGludGVyZmFjZSwgc2VlIEJhc2VQbHVnaW4uXG4gKi9cbmNsYXNzIFVJUGx1Z2luIGV4dGVuZHMgQmFzZVBsdWdpbiB7XG4gICN1cGRhdGVVSVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBzdXBwbGllZCBgdGFyZ2V0YCBpcyBhIERPTSBlbGVtZW50IG9yIGFuIGBvYmplY3RgLlxuICAgKiBJZiBpdOKAmXMgYW4gb2JqZWN0IOKAlCB0YXJnZXQgaXMgYSBwbHVnaW4sIGFuZCB3ZSBzZWFyY2ggYHBsdWdpbnNgXG4gICAqIGZvciBhIHBsdWdpbiB3aXRoIHNhbWUgbmFtZSBhbmQgcmV0dXJuIGl0cyB0YXJnZXQuXG4gICAqL1xuICBtb3VudCAodGFyZ2V0LCBwbHVnaW4pIHtcbiAgICBjb25zdCBjYWxsZXJQbHVnaW5OYW1lID0gcGx1Z2luLmlkXG5cbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZmluZERPTUVsZW1lbnQodGFyZ2V0KVxuXG4gICAgaWYgKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuaXNUYXJnZXRET01FbCA9IHRydWVcbiAgICAgIC8vIFdoZW4gdGFyZ2V0IGlzIDxib2R5PiB3aXRoIGEgc2luZ2xlIDxkaXY+IGVsZW1lbnQsXG4gICAgICAvLyBQcmVhY3QgdGhpbmtzIGl04oCZcyB0aGUgVXBweSByb290IGVsZW1lbnQgaW4gdGhlcmUgd2hlbiBkb2luZyBhIGRpZmYsXG4gICAgICAvLyBhbmQgZGVzdHJveXMgaXQuIFNvIHdlIGFyZSBjcmVhdGluZyBhIGZyYWdtZW50IChjb3VsZCBiZSBlbXB0eSBkaXYpXG4gICAgICBjb25zdCB1cHB5Um9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblxuICAgICAgLy8gQVBJIGZvciBwbHVnaW5zIHRoYXQgcmVxdWlyZSBhIHN5bmNocm9ub3VzIHJlcmVuZGVyLlxuICAgICAgdGhpcy4jdXBkYXRlVUkgPSBkZWJvdW5jZSgoc3RhdGUpID0+IHtcbiAgICAgICAgLy8gcGx1Z2luIGNvdWxkIGJlIHJlbW92ZWQsIGJ1dCB0aGlzLnJlcmVuZGVyIGlzIGRlYm91bmNlZCBiZWxvdyxcbiAgICAgICAgLy8gc28gaXQgY291bGQgc3RpbGwgYmUgY2FsbGVkIGV2ZW4gYWZ0ZXIgdXBweS5yZW1vdmVQbHVnaW4gb3IgdXBweS5jbG9zZVxuICAgICAgICAvLyBoZW5jZSB0aGUgY2hlY2tcbiAgICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMuaWQpKSByZXR1cm5cbiAgICAgICAgcmVuZGVyKHRoaXMucmVuZGVyKHN0YXRlKSwgdXBweVJvb3RFbGVtZW50KVxuICAgICAgICB0aGlzLmFmdGVyVXBkYXRlKClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMudXBweS5sb2coYEluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfSB0byBhIERPTSBlbGVtZW50ICcke3RhcmdldH0nYClcblxuICAgICAgaWYgKHRoaXMub3B0cy5yZXBsYWNlVGFyZ2V0Q29udGVudCkge1xuICAgICAgICAvLyBEb2luZyByZW5kZXIoaChudWxsKSwgdGFyZ2V0RWxlbWVudCksIHdoaWNoIHNob3VsZCBoYXZlIGJlZW5cbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5LCBzaW5jZSBiZWNhdXNlIHRoZSBjb21wb25lbnQgbWlnaHQgbmVlZCB0byBkbyBhZGRpdGlvbmFsIGNsZWFudXAgd2hlbiBpdCBpcyByZW1vdmVkLFxuICAgICAgICAvLyBzdG9wcGVkIHdvcmtpbmcg4oCUIFByZWFjdCBqdXN0IGFkZHMgbnVsbCBpbnRvIHRhcmdldCwgbm90IHJlcGxhY2luZ1xuICAgICAgICB0YXJnZXRFbGVtZW50LmlubmVySFRNTCA9ICcnXG4gICAgICB9XG5cbiAgICAgIHJlbmRlcih0aGlzLnJlbmRlcih0aGlzLnVwcHkuZ2V0U3RhdGUoKSksIHVwcHlSb290RWxlbWVudClcbiAgICAgIHRoaXMuZWwgPSB1cHB5Um9vdEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kQ2hpbGQodXBweVJvb3RFbGVtZW50KVxuXG4gICAgICB0aGlzLm9uTW91bnQoKVxuXG4gICAgICByZXR1cm4gdGhpcy5lbFxuICAgIH1cblxuICAgIGxldCB0YXJnZXRQbHVnaW5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgVUlQbHVnaW4pIHtcbiAgICAgIC8vIFRhcmdldGluZyBhIHBsdWdpbiAqaW5zdGFuY2UqXG4gICAgICB0YXJnZXRQbHVnaW4gPSB0YXJnZXRcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRhcmdldGluZyBhIHBsdWdpbiB0eXBlXG4gICAgICBjb25zdCBUYXJnZXQgPSB0YXJnZXRcbiAgICAgIC8vIEZpbmQgdGhlIHRhcmdldCBwbHVnaW4gaW5zdGFuY2UuXG4gICAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMocCA9PiB7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgVGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0UGx1Z2luID0gcFxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0YXJnZXRQbHVnaW4pIHtcbiAgICAgIHRoaXMudXBweS5sb2coYEluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfSB0byAke3RhcmdldFBsdWdpbi5pZH1gKVxuICAgICAgdGhpcy5wYXJlbnQgPSB0YXJnZXRQbHVnaW5cbiAgICAgIHRoaXMuZWwgPSB0YXJnZXRQbHVnaW4uYWRkVGFyZ2V0KHBsdWdpbilcblxuICAgICAgdGhpcy5vbk1vdW50KClcbiAgICAgIHJldHVybiB0aGlzLmVsXG4gICAgfVxuXG4gICAgdGhpcy51cHB5LmxvZyhgTm90IGluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfWApXG5cbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHRhcmdldCBvcHRpb24gZ2l2ZW4gdG8gJHtjYWxsZXJQbHVnaW5OYW1lfS5gXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1lc3NhZ2UgKz0gJyBUaGUgZ2l2ZW4gdGFyZ2V0IGlzIG5vdCBhIFBsdWdpbiBjbGFzcy4gJ1xuICAgICAgICArICdQbGVhc2UgY2hlY2sgdGhhdCB5b3VcXCdyZSBub3Qgc3BlY2lmeWluZyBhIFJlYWN0IENvbXBvbmVudCBpbnN0ZWFkIG9mIGEgcGx1Z2luLiAnXG4gICAgICAgICsgJ0lmIHlvdSBhcmUgdXNpbmcgQHVwcHkvKiBwYWNrYWdlcyBkaXJlY3RseSwgbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgMSB2ZXJzaW9uIG9mIEB1cHB5L2NvcmUgaW5zdGFsbGVkOiAnXG4gICAgICAgICsgJ3J1biBgbnBtIGxzIEB1cHB5L2NvcmVgIG9uIHRoZSBjb21tYW5kIGxpbmUgYW5kIHZlcmlmeSB0aGF0IGFsbCB0aGUgdmVyc2lvbnMgbWF0Y2ggYW5kIGFyZSBkZWR1cGVkIGNvcnJlY3RseS4nXG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgKz0gJ0lmIHlvdSBtZWFudCB0byB0YXJnZXQgYW4gSFRNTCBlbGVtZW50LCBwbGVhc2UgbWFrZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnQgZXhpc3RzLiAnXG4gICAgICAgICsgJ0NoZWNrIHRoYXQgdGhlIDxzY3JpcHQ+IHRhZyBpbml0aWFsaXppbmcgVXBweSBpcyByaWdodCBiZWZvcmUgdGhlIGNsb3NpbmcgPC9ib2R5PiB0YWcgYXQgdGhlIGVuZCBvZiB0aGUgcGFnZS4gJ1xuICAgICAgICArICcoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlcy8xMDQyKVxcblxcbidcbiAgICAgICAgKyAnSWYgeW91IG1lYW50IHRvIHRhcmdldCBhIHBsdWdpbiwgcGxlYXNlIGNvbmZpcm0gdGhhdCB5b3VyIGBpbXBvcnRgIHN0YXRlbWVudHMgb3IgYHJlcXVpcmVgIGNhbGxzIGFyZSBjb3JyZWN0LidcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICB1cGRhdGUgKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuZWwgIT0gbnVsbCkge1xuICAgICAgdGhpcy4jdXBkYXRlVUk/LihzdGF0ZSlcbiAgICB9XG4gIH1cblxuICB1bm1vdW50ICgpIHtcbiAgICBpZiAodGhpcy5pc1RhcmdldERPTUVsKSB7XG4gICAgICB0aGlzLmVsPy5yZW1vdmUoKVxuICAgIH1cbiAgICB0aGlzLm9uVW5tb3VudCgpXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBvbk1vdW50ICgpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgb25Vbm1vdW50ICgpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVUlQbHVnaW5cbiIsIi8qIGdsb2JhbCBBZ2dyZWdhdGVFcnJvciAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IGVlID0gcmVxdWlyZSgnbmFtZXNwYWNlLWVtaXR0ZXInKVxuY29uc3QgeyBuYW5vaWQgfSA9IHJlcXVpcmUoJ25hbm9pZCcpXG5jb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJ2xvZGFzaC50aHJvdHRsZScpXG5jb25zdCBwcmV0dGllckJ5dGVzID0gcmVxdWlyZSgnQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzJylcbmNvbnN0IG1hdGNoID0gcmVxdWlyZSgnbWltZS1tYXRjaCcpXG5jb25zdCBEZWZhdWx0U3RvcmUgPSByZXF1aXJlKCdAdXBweS9zdG9yZS1kZWZhdWx0JylcbmNvbnN0IGdldEZpbGVUeXBlID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVUeXBlJylcbmNvbnN0IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVOYW1lQW5kRXh0ZW5zaW9uJylcbmNvbnN0IGdlbmVyYXRlRmlsZUlEID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dlbmVyYXRlRmlsZUlEJylcbmNvbnN0IHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MgPSByZXF1aXJlKCcuL3N1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MnKVxuY29uc3QgZ2V0RmlsZU5hbWUgPSByZXF1aXJlKCcuL2dldEZpbGVOYW1lJylcbmNvbnN0IHsganVzdEVycm9yc0xvZ2dlciwgZGVidWdMb2dnZXIgfSA9IHJlcXVpcmUoJy4vbG9nZ2VycycpXG5cbmNvbnN0IGxvY2FsZSA9IHJlcXVpcmUoJy4vbG9jYWxlJylcblxuLy8gRXhwb3J0ZWQgZnJvbSBoZXJlLlxuY2xhc3MgUmVzdHJpY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuaXNSZXN0cmljdGlvbiA9IHRydWVcbiAgfVxufVxuaWYgKHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWdsb2JhbC1hc3NpZ25cbiAgZ2xvYmFsVGhpcy5BZ2dyZWdhdGVFcnJvciA9IGNsYXNzIEFnZ3JlZ2F0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChlcnJvcnMsIG1lc3NhZ2UpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgICB0aGlzLmVycm9ycyA9IGVycm9yc1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBBZ2dyZWdhdGVSZXN0cmljdGlvbkVycm9yIGV4dGVuZHMgQWdncmVnYXRlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5pc1Jlc3RyaWN0aW9uID0gdHJ1ZVxuICB9XG59XG5cbi8qKlxuICogVXBweSBDb3JlIG1vZHVsZS5cbiAqIE1hbmFnZXMgcGx1Z2lucywgc3RhdGUgdXBkYXRlcywgYWN0cyBhcyBhbiBldmVudCBidXMsXG4gKiBhZGRzL3JlbW92ZXMgZmlsZXMgYW5kIG1ldGFkYXRhLlxuICovXG5jbGFzcyBVcHB5IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlXG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQmFzZVBsdWdpbltdPn0gKi9cbiAgI3BsdWdpbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgI3N0b3JlVW5zdWJzY3JpYmVcblxuICAjZW1pdHRlciA9IGVlKClcblxuICAjcHJlUHJvY2Vzc29ycyA9IG5ldyBTZXQoKVxuXG4gICN1cGxvYWRlcnMgPSBuZXcgU2V0KClcblxuICAjcG9zdFByb2Nlc3NvcnMgPSBuZXcgU2V0KClcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgVXBweVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyDigJQgVXBweSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGxvY2FsZVxuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBpZDogJ3VwcHknLFxuICAgICAgYXV0b1Byb2NlZWQ6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBAZGVwcmVjYXRlZCBUaGUgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZFxuICAgICAgICovXG4gICAgICBhbGxvd011bHRpcGxlVXBsb2FkczogdHJ1ZSxcbiAgICAgIGFsbG93TXVsdGlwbGVVcGxvYWRCYXRjaGVzOiB0cnVlLFxuICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIG1heEZpbGVTaXplOiBudWxsLFxuICAgICAgICBtaW5GaWxlU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4VG90YWxGaWxlU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4TnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICAgICAgbWluTnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICAgICAgYWxsb3dlZEZpbGVUeXBlczogbnVsbCxcbiAgICAgICAgcmVxdWlyZWRNZXRhRmllbGRzOiBbXSxcbiAgICAgIH0sXG4gICAgICBtZXRhOiB7fSxcbiAgICAgIG9uQmVmb3JlRmlsZUFkZGVkOiAoY3VycmVudEZpbGUpID0+IGN1cnJlbnRGaWxlLFxuICAgICAgb25CZWZvcmVVcGxvYWQ6IChmaWxlcykgPT4gZmlsZXMsXG4gICAgICBzdG9yZTogRGVmYXVsdFN0b3JlKCksXG4gICAgICBsb2dnZXI6IGp1c3RFcnJvcnNMb2dnZXIsXG4gICAgICBpbmZvVGltZW91dDogNTAwMCxcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlcixcbiAgICAvLyBtYWtpbmcgc3VyZSB0byBtZXJnZSByZXN0cmljdGlvbnMgdG9vXG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLnJlc3RyaWN0aW9ucyxcbiAgICAgICAgLi4uKG9wdHMgJiYgb3B0cy5yZXN0cmljdGlvbnMpLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGRlYnVnOiB0cnVlIGZvciBiYWNrd2FyZHMtY29tcGF0YWJpbGl0eSwgdW5sZXNzIGxvZ2dlciBpcyBzZXQgaW4gb3B0c1xuICAgIC8vIG9wdHMgaW5zdGVhZCBvZiB0aGlzLm9wdHMgdG8gYXZvaWQgY29tcGFyaW5nIG9iamVjdHMg4oCUIHdlIHNldCBsb2dnZXI6IGp1c3RFcnJvcnNMb2dnZXIgaW4gZGVmYXVsdE9wdGlvbnNcbiAgICBpZiAob3B0cyAmJiBvcHRzLmxvZ2dlciAmJiBvcHRzLmRlYnVnKSB7XG4gICAgICB0aGlzLmxvZygnWW91IGFyZSB1c2luZyBhIGN1c3RvbSBgbG9nZ2VyYCwgYnV0IGFsc28gc2V0IGBkZWJ1ZzogdHJ1ZWAsIHdoaWNoIHVzZXMgYnVpbHQtaW4gbG9nZ2VyIHRvIG91dHB1dCBsb2dzIHRvIGNvbnNvbGUuIElnbm9yaW5nIGBkZWJ1ZzogdHJ1ZWAgYW5kIHVzaW5nIHlvdXIgY3VzdG9tIGBsb2dnZXJgLicsICd3YXJuaW5nJylcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5kZWJ1Zykge1xuICAgICAgdGhpcy5vcHRzLmxvZ2dlciA9IGRlYnVnTG9nZ2VyXG4gICAgfVxuXG4gICAgdGhpcy5sb2coYFVzaW5nIENvcmUgdiR7dGhpcy5jb25zdHJ1Y3Rvci5WRVJTSU9OfWApXG5cbiAgICBpZiAodGhpcy5vcHRzLnJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzXG4gICAgICAgICYmIHRoaXMub3B0cy5yZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcyAhPT0gbnVsbFxuICAgICAgICAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLm9wdHMucmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgcmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXNgIG11c3QgYmUgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgLy8gX19fV2h5IHRocm90dGxlIGF0IDUwMG1zP1xuICAgIC8vICAgIC0gV2UgbXVzdCB0aHJvdHRsZSBhdCA+MjUwbXMgZm9yIHN1cGVyZm9jdXMgaW4gRGFzaGJvYXJkIHRvIHdvcmsgd2VsbFxuICAgIC8vICAgIChiZWNhdXNlIGFuaW1hdGlvbiB0YWtlcyAwLjI1cywgYW5kIHdlIHdhbnQgdG8gd2FpdCBmb3IgYWxsIGFuaW1hdGlvbnMgdG8gYmUgb3ZlciBiZWZvcmUgcmVmb2N1c2luZykuXG4gICAgLy8gICAgW1ByYWN0aWNhbCBDaGVja106IGlmIHRob3R0bGUgaXMgYXQgMTAwbXMsIHRoZW4gaWYgeW91IGFyZSB1cGxvYWRpbmcgYSBmaWxlLFxuICAgIC8vICAgIGFuZCBjbGljayAnQUREIE1PUkUgRklMRVMnLCAtIGZvY3VzIHdvbid0IGFjdGl2YXRlIGluIEZpcmVmb3guXG4gICAgLy8gICAgLSBXZSBtdXN0IHRocm90dGxlIGF0IGFyb3VuZCA+NTAwbXMgdG8gYXZvaWQgcGVyZm9ybWFuY2UgbGFncy5cbiAgICAvLyAgICBbUHJhY3RpY2FsIENoZWNrXSBGaXJlZm94LCB0cnkgdG8gdXBsb2FkIGEgYmlnIGZpbGUgZm9yIGEgcHJvbG9uZ2VkIHBlcmlvZCBvZiB0aW1lLiBMYXB0b3Agd2lsbCBzdGFydCB0byBoZWF0IHVwLlxuICAgIHRoaXMuY2FsY3VsYXRlUHJvZ3Jlc3MgPSB0aHJvdHRsZSh0aGlzLmNhbGN1bGF0ZVByb2dyZXNzLmJpbmQodGhpcyksIDUwMCwgeyBsZWFkaW5nOiB0cnVlLCB0cmFpbGluZzogdHJ1ZSB9KVxuXG4gICAgdGhpcy5zdG9yZSA9IHRoaXMub3B0cy5zdG9yZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgcGx1Z2luczoge30sXG4gICAgICBmaWxlczoge30sXG4gICAgICBjdXJyZW50VXBsb2Fkczoge30sXG4gICAgICBhbGxvd05ld1VwbG9hZDogdHJ1ZSxcbiAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICB1cGxvYWRQcm9ncmVzczogc3VwcG9ydHNVcGxvYWRQcm9ncmVzcygpLFxuICAgICAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uOiB0cnVlLFxuICAgICAgICByZXN1bWFibGVVcGxvYWRzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICB0b3RhbFByb2dyZXNzOiAwLFxuICAgICAgbWV0YTogeyAuLi50aGlzLm9wdHMubWV0YSB9LFxuICAgICAgaW5mbzogW10sXG4gICAgICByZWNvdmVyZWRTdGF0ZTogbnVsbCxcbiAgICB9KVxuXG4gICAgdGhpcy4jc3RvcmVVbnN1YnNjcmliZSA9IHRoaXMuc3RvcmUuc3Vic2NyaWJlKChwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcGF0Y2gpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnc3RhdGUtdXBkYXRlJywgcHJldlN0YXRlLCBuZXh0U3RhdGUsIHBhdGNoKVxuICAgICAgdGhpcy51cGRhdGVBbGwobmV4dFN0YXRlKVxuICAgIH0pXG5cbiAgICAvLyBFeHBvc2luZyB1cHB5IG9iamVjdCBvbiB3aW5kb3cgZm9yIGRlYnVnZ2luZyBhbmQgdGVzdGluZ1xuICAgIGlmICh0aGlzLm9wdHMuZGVidWcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvd1t0aGlzLm9wdHMuaWRdID0gdGhpc1xuICAgIH1cblxuICAgIHRoaXMuI2FkZExpc3RlbmVycygpXG4gIH1cblxuICBlbWl0IChldmVudCwgLi4uYXJncykge1xuICAgIHRoaXMuI2VtaXR0ZXIuZW1pdChldmVudCwgLi4uYXJncylcbiAgfVxuXG4gIG9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLiNlbWl0dGVyLm9uKGV2ZW50LCBjYWxsYmFjaylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgb25jZSAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy4jZW1pdHRlci5vbmNlKGV2ZW50LCBjYWxsYmFjaylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgb2ZmIChldmVudCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLiNlbWl0dGVyLm9mZihldmVudCwgY2FsbGJhY2spXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG9uIGFsbCBwbHVnaW5zIGFuZCBydW4gYHVwZGF0ZWAgb24gdGhlbS5cbiAgICogQ2FsbGVkIGVhY2ggdGltZSBzdGF0ZSBjaGFuZ2VzLlxuICAgKlxuICAgKi9cbiAgdXBkYXRlQWxsIChzdGF0ZSkge1xuICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMocGx1Z2luID0+IHtcbiAgICAgIHBsdWdpbi51cGRhdGUoc3RhdGUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHN0YXRlIHdpdGggYSBwYXRjaFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGF0Y2gge2ZvbzogJ2Jhcid9XG4gICAqL1xuICBzZXRTdGF0ZSAocGF0Y2gpIHtcbiAgICB0aGlzLnN0b3JlLnNldFN0YXRlKHBhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogQmFjayBjb21wYXQgZm9yIHdoZW4gdXBweS5zdGF0ZSBpcyB1c2VkIGluc3RlYWQgb2YgdXBweS5nZXRTdGF0ZSgpLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IHN0YXRlICgpIHtcbiAgICAvLyBIZXJlLCBzdGF0ZSBpcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG9ydGhhbmQgdG8gc2V0IHN0YXRlIGZvciBhIHNwZWNpZmljIGZpbGUuXG4gICAqL1xuICBzZXRGaWxlU3RhdGUgKGZpbGVJRCwgc3RhdGUpIHtcbiAgICBpZiAoIXRoaXMuZ2V0U3RhdGUoKS5maWxlc1tmaWxlSURdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbuKAmXQgc2V0IHN0YXRlIGZvciAke2ZpbGVJRH0gKHRoZSBmaWxlIGNvdWxkIGhhdmUgYmVlbiByZW1vdmVkKWApXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmaWxlczogeyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMsIFtmaWxlSURdOiB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlc1tmaWxlSURdLCAuLi5zdGF0ZSB9IH0sXG4gICAgfSlcbiAgfVxuXG4gIGkxOG5Jbml0ICgpIHtcbiAgICBjb25zdCB0cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0cmFuc2xhdG9yKVxuICAgIHRoaXMuaTE4bkFycmF5ID0gdHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRyYW5zbGF0b3IpXG4gICAgdGhpcy5sb2NhbGUgPSB0cmFuc2xhdG9yLmxvY2FsZVxuICB9XG5cbiAgc2V0T3B0aW9ucyAobmV3T3B0cykge1xuICAgIHRoaXMub3B0cyA9IHtcbiAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgIC4uLm5ld09wdHMsXG4gICAgICByZXN0cmljdGlvbnM6IHtcbiAgICAgICAgLi4udGhpcy5vcHRzLnJlc3RyaWN0aW9ucyxcbiAgICAgICAgLi4uKG5ld09wdHMgJiYgbmV3T3B0cy5yZXN0cmljdGlvbnMpLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBpZiAobmV3T3B0cy5tZXRhKSB7XG4gICAgICB0aGlzLnNldE1ldGEobmV3T3B0cy5tZXRhKVxuICAgIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgaWYgKG5ld09wdHMubG9jYWxlKSB7XG4gICAgICB0aGlzLml0ZXJhdGVQbHVnaW5zKChwbHVnaW4pID0+IHtcbiAgICAgICAgcGx1Z2luLnNldE9wdGlvbnMoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBOb3RlOiB0aGlzIGlzIG5vdCB0aGUgcHJlYWN0IGBzZXRTdGF0ZWAsIGl0J3MgYW4gaW50ZXJuYWwgZnVuY3Rpb24gdGhhdCBoYXMgdGhlIHNhbWUgbmFtZS5cbiAgICB0aGlzLnNldFN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIHdpdGggbmV3IG9wdGlvbnNcbiAgfVxuXG4gIHJlc2V0UHJvZ3Jlc3MgKCkge1xuICAgIGNvbnN0IGRlZmF1bHRQcm9ncmVzcyA9IHtcbiAgICAgIHBlcmNlbnRhZ2U6IDAsXG4gICAgICBieXRlc1VwbG9hZGVkOiAwLFxuICAgICAgdXBsb2FkQ29tcGxldGU6IGZhbHNlLFxuICAgICAgdXBsb2FkU3RhcnRlZDogbnVsbCxcbiAgICB9XG4gICAgY29uc3QgZmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0ge31cbiAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaChmaWxlSUQgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbGUgPSB7IC4uLmZpbGVzW2ZpbGVJRF0gfVxuICAgICAgdXBkYXRlZEZpbGUucHJvZ3Jlc3MgPSB7IC4uLnVwZGF0ZWRGaWxlLnByb2dyZXNzLCAuLi5kZWZhdWx0UHJvZ3Jlc3MgfVxuICAgICAgdXBkYXRlZEZpbGVzW2ZpbGVJRF0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgICB0b3RhbFByb2dyZXNzOiAwLFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ3Jlc2V0LXByb2dyZXNzJylcbiAgfVxuXG4gIGFkZFByZVByb2Nlc3NvciAoZm4pIHtcbiAgICB0aGlzLiNwcmVQcm9jZXNzb3JzLmFkZChmbilcbiAgfVxuXG4gIHJlbW92ZVByZVByb2Nlc3NvciAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy4jcHJlUHJvY2Vzc29ycy5kZWxldGUoZm4pXG4gIH1cblxuICBhZGRQb3N0UHJvY2Vzc29yIChmbikge1xuICAgIHRoaXMuI3Bvc3RQcm9jZXNzb3JzLmFkZChmbilcbiAgfVxuXG4gIHJlbW92ZVBvc3RQcm9jZXNzb3IgKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc3RQcm9jZXNzb3JzLmRlbGV0ZShmbilcbiAgfVxuXG4gIGFkZFVwbG9hZGVyIChmbikge1xuICAgIHRoaXMuI3VwbG9hZGVycy5hZGQoZm4pXG4gIH1cblxuICByZW1vdmVVcGxvYWRlciAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy4jdXBsb2FkZXJzLmRlbGV0ZShmbilcbiAgfVxuXG4gIHNldE1ldGEgKGRhdGEpIHtcbiAgICBjb25zdCB1cGRhdGVkTWV0YSA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLm1ldGEsIC4uLmRhdGEgfVxuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cblxuICAgIE9iamVjdC5rZXlzKHVwZGF0ZWRGaWxlcykuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZUlEXSA9IHsgLi4udXBkYXRlZEZpbGVzW2ZpbGVJRF0sIG1ldGE6IHsgLi4udXBkYXRlZEZpbGVzW2ZpbGVJRF0ubWV0YSwgLi4uZGF0YSB9IH1cbiAgICB9KVxuXG4gICAgdGhpcy5sb2coJ0FkZGluZyBtZXRhZGF0YTonKVxuICAgIHRoaXMubG9nKGRhdGEpXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1ldGE6IHVwZGF0ZWRNZXRhLFxuICAgICAgZmlsZXM6IHVwZGF0ZWRGaWxlcyxcbiAgICB9KVxuICB9XG5cbiAgc2V0RmlsZU1ldGEgKGZpbGVJRCwgZGF0YSkge1xuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBpZiAoIXVwZGF0ZWRGaWxlc1tmaWxlSURdKSB7XG4gICAgICB0aGlzLmxvZygnV2FzIHRyeWluZyB0byBzZXQgbWV0YWRhdGEgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICcsIGZpbGVJRClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBuZXdNZXRhID0geyAuLi51cGRhdGVkRmlsZXNbZmlsZUlEXS5tZXRhLCAuLi5kYXRhIH1cbiAgICB1cGRhdGVkRmlsZXNbZmlsZUlEXSA9IHsgLi4udXBkYXRlZEZpbGVzW2ZpbGVJRF0sIG1ldGE6IG5ld01ldGEgfVxuICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlczogdXBkYXRlZEZpbGVzIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgZmlsZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSUQgVGhlIElEIG9mIHRoZSBmaWxlIG9iamVjdCB0byByZXR1cm4uXG4gICAqL1xuICBnZXRGaWxlIChmaWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpLmZpbGVzW2ZpbGVJRF1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZpbGVzIGluIGFuIGFycmF5LlxuICAgKi9cbiAgZ2V0RmlsZXMgKCkge1xuICAgIGNvbnN0IHsgZmlsZXMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGZpbGVzKVxuICB9XG5cbiAgZ2V0T2JqZWN0T2ZGaWxlc1BlclN0YXRlICgpIHtcbiAgICBjb25zdCB7IGZpbGVzOiBmaWxlc09iamVjdCwgdG90YWxQcm9ncmVzcywgZXJyb3IgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGZpbGVzID0gT2JqZWN0LnZhbHVlcyhmaWxlc09iamVjdClcbiAgICBjb25zdCBpblByb2dyZXNzRmlsZXMgPSBmaWxlcy5maWx0ZXIoKHsgcHJvZ3Jlc3MgfSkgPT4gIXByb2dyZXNzLnVwbG9hZENvbXBsZXRlICYmIHByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQpXG4gICAgY29uc3QgbmV3RmlsZXMgPSAgZmlsZXMuZmlsdGVyKChmaWxlKSA9PiAhZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkKVxuICAgIGNvbnN0IHN0YXJ0ZWRGaWxlcyA9IGZpbGVzLmZpbHRlcihcbiAgICAgIGZpbGUgPT4gZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8IGZpbGUucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzLFxuICAgIClcbiAgICBjb25zdCB1cGxvYWRTdGFydGVkRmlsZXMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZClcbiAgICBjb25zdCBwYXVzZWRGaWxlcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5pc1BhdXNlZClcbiAgICBjb25zdCBjb21wbGV0ZUZpbGVzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiBmaWxlLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlKVxuICAgIGNvbnN0IGVycm9yZWRGaWxlcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5lcnJvcilcbiAgICBjb25zdCBpblByb2dyZXNzTm90UGF1c2VkRmlsZXMgPSBpblByb2dyZXNzRmlsZXMuZmlsdGVyKChmaWxlKSA9PiAhZmlsZS5pc1BhdXNlZClcbiAgICBjb25zdCBwcm9jZXNzaW5nRmlsZXMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5ld0ZpbGVzLFxuICAgICAgc3RhcnRlZEZpbGVzLFxuICAgICAgdXBsb2FkU3RhcnRlZEZpbGVzLFxuICAgICAgcGF1c2VkRmlsZXMsXG4gICAgICBjb21wbGV0ZUZpbGVzLFxuICAgICAgZXJyb3JlZEZpbGVzLFxuICAgICAgaW5Qcm9ncmVzc0ZpbGVzLFxuICAgICAgaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzLFxuICAgICAgcHJvY2Vzc2luZ0ZpbGVzLFxuXG4gICAgICBpc1VwbG9hZFN0YXJ0ZWQ6IHVwbG9hZFN0YXJ0ZWRGaWxlcy5sZW5ndGggPiAwLFxuICAgICAgaXNBbGxDb21wbGV0ZTogdG90YWxQcm9ncmVzcyA9PT0gMTAwXG4gICAgICAgICYmIGNvbXBsZXRlRmlsZXMubGVuZ3RoID09PSBmaWxlcy5sZW5ndGhcbiAgICAgICAgJiYgcHJvY2Vzc2luZ0ZpbGVzLmxlbmd0aCA9PT0gMCxcbiAgICAgIGlzQWxsRXJyb3JlZDogISFlcnJvciAmJiBlcnJvcmVkRmlsZXMubGVuZ3RoID09PSBmaWxlcy5sZW5ndGgsXG4gICAgICBpc0FsbFBhdXNlZDogaW5Qcm9ncmVzc0ZpbGVzLmxlbmd0aCAhPT0gMCAmJiBwYXVzZWRGaWxlcy5sZW5ndGggPT09IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGgsXG4gICAgICBpc1VwbG9hZEluUHJvZ3Jlc3M6IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGggPiAwLFxuICAgICAgaXNTb21lR2hvc3Q6IGZpbGVzLnNvbWUoZmlsZSA9PiBmaWxlLmlzR2hvc3QpLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHB1YmxpYyB3cmFwcGVyIGZvciBfY2hlY2tSZXN0cmljdGlvbnMg4oCUIGNoZWNrcyBpZiBhIGZpbGUgcGFzc2VzIGEgc2V0IG9mIHJlc3RyaWN0aW9ucy5cbiAgICogRm9yIHVzZSBpbiBVSSBwbHVpZ2lucyAobGlrZSBQcm92aWRlcnMpLCB0byBkaXNhbGxvdyBzZWxlY3RpbmcgZmlsZXMgdGhhdCB3b27igJl0IHBhc3MgcmVzdHJpY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZmlsZSBvYmplY3QgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtBcnJheX0gW2ZpbGVzXSBhcnJheSB0byBjaGVjayBtYXhOdW1iZXJPZkZpbGVzIGFuZCBtYXhUb3RhbEZpbGVTaXplXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHsgcmVzdWx0OiB0cnVlL2ZhbHNlLCByZWFzb246IHdoeSBmaWxlIGRpZG7igJl0IHBhc3MgcmVzdHJpY3Rpb25zIH1cbiAgICovXG4gIHZhbGlkYXRlUmVzdHJpY3Rpb25zIChmaWxlLCBmaWxlcykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLiNjaGVja1Jlc3RyaWN0aW9ucyhmaWxlLCBmaWxlcylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgIHJlYXNvbjogZXJyLm1lc3NhZ2UsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGZpbGUgcGFzc2VzIGEgc2V0IG9mIHJlc3RyaWN0aW9ucyBzZXQgaW4gb3B0aW9uczogbWF4RmlsZVNpemUsIG1pbkZpbGVTaXplLFxuICAgKiBtYXhOdW1iZXJPZkZpbGVzIGFuZCBhbGxvd2VkRmlsZVR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZmlsZSBvYmplY3QgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtBcnJheX0gW2ZpbGVzXSBhcnJheSB0byBjaGVjayBtYXhOdW1iZXJPZkZpbGVzIGFuZCBtYXhUb3RhbEZpbGVTaXplXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjY2hlY2tSZXN0cmljdGlvbnMgKGZpbGUsIGZpbGVzID0gdGhpcy5nZXRGaWxlcygpKSB7XG4gICAgY29uc3QgeyBtYXhGaWxlU2l6ZSwgbWluRmlsZVNpemUsIG1heFRvdGFsRmlsZVNpemUsIG1heE51bWJlck9mRmlsZXMsIGFsbG93ZWRGaWxlVHlwZXMgfSA9IHRoaXMub3B0cy5yZXN0cmljdGlvbnNcblxuICAgIGlmIChtYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgICBpZiAoZmlsZXMubGVuZ3RoICsgMSA+IG1heE51bWJlck9mRmlsZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IoYCR7dGhpcy5pMThuKCd5b3VDYW5Pbmx5VXBsb2FkWCcsIHsgc21hcnRfY291bnQ6IG1heE51bWJlck9mRmlsZXMgfSl9YClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsb3dlZEZpbGVUeXBlcykge1xuICAgICAgY29uc3QgaXNDb3JyZWN0RmlsZVR5cGUgPSBhbGxvd2VkRmlsZVR5cGVzLnNvbWUoKHR5cGUpID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG1pbWUtdHlwZVxuICAgICAgICBpZiAodHlwZS5pbmRleE9mKCcvJykgPiAtMSkge1xuICAgICAgICAgIGlmICghZmlsZS50eXBlKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICByZXR1cm4gbWF0Y2goZmlsZS50eXBlLnJlcGxhY2UoLzsuKj8kLywgJycpLCB0eXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgaXMgbGlrZWx5IGFuIGV4dGVuc2lvblxuICAgICAgICBpZiAodHlwZVswXSA9PT0gJy4nICYmIGZpbGUuZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGUuZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0pXG5cbiAgICAgIGlmICghaXNDb3JyZWN0RmlsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZEZpbGVUeXBlc1N0cmluZyA9IGFsbG93ZWRGaWxlVHlwZXMuam9pbignLCAnKVxuICAgICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ3lvdUNhbk9ubHlVcGxvYWRGaWxlVHlwZXMnLCB7IHR5cGVzOiBhbGxvd2VkRmlsZVR5cGVzU3RyaW5nIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IGNoZWNrIG1heFRvdGFsRmlsZVNpemUgaWYgdGhlIHNpemUgaXMgdW5rbm93bi5cbiAgICBpZiAobWF4VG90YWxGaWxlU2l6ZSAmJiBmaWxlLnNpemUgIT0gbnVsbCkge1xuICAgICAgbGV0IHRvdGFsRmlsZXNTaXplID0gMFxuICAgICAgdG90YWxGaWxlc1NpemUgKz0gZmlsZS5zaXplXG4gICAgICBmaWxlcy5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgIHRvdGFsRmlsZXNTaXplICs9IGYuc2l6ZVxuICAgICAgfSlcbiAgICAgIGlmICh0b3RhbEZpbGVzU2l6ZSA+IG1heFRvdGFsRmlsZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCdleGNlZWRzU2l6ZScsIHtcbiAgICAgICAgICBzaXplOiBwcmV0dGllckJ5dGVzKG1heFRvdGFsRmlsZVNpemUpLFxuICAgICAgICAgIGZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgY2hlY2sgbWF4RmlsZVNpemUgaWYgdGhlIHNpemUgaXMgdW5rbm93bi5cbiAgICBpZiAobWF4RmlsZVNpemUgJiYgZmlsZS5zaXplICE9IG51bGwpIHtcbiAgICAgIGlmIChmaWxlLnNpemUgPiBtYXhGaWxlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ2V4Y2VlZHNTaXplJywge1xuICAgICAgICAgIHNpemU6IHByZXR0aWVyQnl0ZXMobWF4RmlsZVNpemUpLFxuICAgICAgICAgIGZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgY2hlY2sgbWluRmlsZVNpemUgaWYgdGhlIHNpemUgaXMgdW5rbm93bi5cbiAgICBpZiAobWluRmlsZVNpemUgJiYgZmlsZS5zaXplICE9IG51bGwpIHtcbiAgICAgIGlmIChmaWxlLnNpemUgPCBtaW5GaWxlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ2luZmVyaW9yU2l6ZScsIHtcbiAgICAgICAgICBzaXplOiBwcmV0dGllckJ5dGVzKG1pbkZpbGVTaXplKSxcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIG1pbk51bWJlck9mRmlsZXMgcmVzdHJpY3Rpb24gaXMgcmVhY2hlZCBiZWZvcmUgdXBsb2FkaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2NoZWNrTWluTnVtYmVyT2ZGaWxlcyAoZmlsZXMpIHtcbiAgICBjb25zdCB7IG1pbk51bWJlck9mRmlsZXMgfSA9IHRoaXMub3B0cy5yZXN0cmljdGlvbnNcbiAgICBpZiAoT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aCA8IG1pbk51bWJlck9mRmlsZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXN0cmljdGlvbkVycm9yKGAke3RoaXMuaTE4bigneW91SGF2ZVRvQXRMZWFzdFNlbGVjdFgnLCB7IHNtYXJ0X2NvdW50OiBtaW5OdW1iZXJPZkZpbGVzIH0pfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlcXVpcmVkTWV0YUZpZWxkIHJlc3RyaWN0aW9uIGlzIG1ldCBmb3IgYSBzcGVjaWZpYyBmaWxlLlxuICAgKlxuICAgKi9cbiAgI2NoZWNrUmVxdWlyZWRNZXRhRmllbGRzT25GaWxlIChmaWxlKSB7XG4gICAgY29uc3QgeyByZXF1aXJlZE1ldGFGaWVsZHMgfSA9IHRoaXMub3B0cy5yZXN0cmljdGlvbnNcbiAgICBjb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlXG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXVxuICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZWRNZXRhRmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZmlsZS5tZXRhLCByZXF1aXJlZE1ldGFGaWVsZHNbaV0pIHx8IGZpbGUubWV0YVtyZXF1aXJlZE1ldGFGaWVsZHNbaV1dID09PSAnJykge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgUmVzdHJpY3Rpb25FcnJvcihgJHt0aGlzLmkxOG4oJ21pc3NpbmdSZXF1aXJlZE1ldGFGaWVsZE9uRmlsZScsIHsgZmlsZU5hbWU6IGZpbGUubmFtZSB9KX1gKVxuICAgICAgICBlcnJvcnMucHVzaChlcnIpXG4gICAgICAgIG1pc3NpbmdGaWVsZHMucHVzaChyZXF1aXJlZE1ldGFGaWVsZHNbaV0pXG4gICAgICAgIHRoaXMuI3Nob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyLCB7IGZpbGUsIHNob3dJbmZvcm1lcjogZmFsc2UsIHRocm93RXJyOiBmYWxzZSB9KVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7IG1pc3NpbmdSZXF1aXJlZE1ldGFGaWVsZHM6IG1pc3NpbmdGaWVsZHMgfSlcbiAgICByZXR1cm4gZXJyb3JzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVxdWlyZWRNZXRhRmllbGQgcmVzdHJpY3Rpb24gaXMgbWV0IGJlZm9yZSB1cGxvYWRpbmcuXG4gICAqXG4gICAqL1xuICAjY2hlY2tSZXF1aXJlZE1ldGFGaWVsZHMgKGZpbGVzKSB7XG4gICAgY29uc3QgZXJyb3JzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZsYXRNYXAoKGZpbGVJRCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZShmaWxlSUQpXG4gICAgICByZXR1cm4gdGhpcy4jY2hlY2tSZXF1aXJlZE1ldGFGaWVsZHNPbkZpbGUoZmlsZSlcbiAgICB9KVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVSZXN0cmljdGlvbkVycm9yKGVycm9ycywgYCR7dGhpcy5pMThuKCdtaXNzaW5nUmVxdWlyZWRNZXRhRmllbGQnKX1gKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGFuIGVycm9yLCBzZXRzIEluZm9ybWVyIG1lc3NhZ2UsIHRoZW4gdGhyb3dzIHRoZSBlcnJvci5cbiAgICogRW1pdHMgYSAncmVzdHJpY3Rpb24tZmFpbGVkJyBldmVudCBpZiBpdOKAmXMgYSByZXN0cmljdGlvbiBlcnJvclxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZ30gZXJyIOKAlCBFcnJvciBvYmplY3Qgb3IgcGxhaW4gc3RyaW5nIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNob3dJbmZvcm1lcj10cnVlXSDigJQgU29tZXRpbWVzIGRldmVsb3BlciBtaWdodCB3YW50IHRvIHNob3cgSW5mb3JtZXIgbWFudWFsbHlcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmZpbGU9bnVsbF0g4oCUIEZpbGUgb2JqZWN0IHVzZWQgdG8gZW1pdCB0aGUgcmVzdHJpY3Rpb24gZXJyb3JcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50aHJvd0Vycj10cnVlXSDigJQgRXJyb3JzIHNob3VsZG7igJl0IGJlIHRocm93biwgZm9yIGV4YW1wbGUsIGluIGB1cGxvYWQtZXJyb3JgIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjc2hvd09yTG9nRXJyb3JBbmRUaHJvdyAoZXJyLCB7IHNob3dJbmZvcm1lciA9IHRydWUsIGZpbGUgPSBudWxsLCB0aHJvd0VyciA9IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBlcnIgPT09ICdvYmplY3QnID8gZXJyLm1lc3NhZ2UgOiBlcnJcbiAgICBjb25zdCBkZXRhaWxzID0gKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmIGVyci5kZXRhaWxzKSA/IGVyci5kZXRhaWxzIDogJydcblxuICAgIC8vIFJlc3RyaWN0aW9uIGVycm9ycyBzaG91bGQgYmUgbG9nZ2VkLCBidXQgbm90IGFzIGVycm9ycyxcbiAgICAvLyBhcyB0aGV5IGFyZSBleHBlY3RlZCBhbmQgc2hvd24gaW4gdGhlIFVJLlxuICAgIGxldCBsb2dNZXNzYWdlV2l0aERldGFpbHMgPSBtZXNzYWdlXG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIGxvZ01lc3NhZ2VXaXRoRGV0YWlscyArPSBgICR7ZGV0YWlsc31gXG4gICAgfVxuICAgIGlmIChlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgdGhpcy5sb2cobG9nTWVzc2FnZVdpdGhEZXRhaWxzKVxuICAgICAgdGhpcy5lbWl0KCdyZXN0cmljdGlvbi1mYWlsZWQnLCBmaWxlLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGxvZ01lc3NhZ2VXaXRoRGV0YWlscywgJ2Vycm9yJylcbiAgICB9XG5cbiAgICAvLyBTb21ldGltZXMgaW5mb3JtZXIgaGFzIHRvIGJlIHNob3duIG1hbnVhbGx5IGJ5IHRoZSBkZXZlbG9wZXIsXG4gICAgLy8gZm9yIGV4YW1wbGUsIGluIGBvbkJlZm9yZUZpbGVBZGRlZGAuXG4gICAgaWYgKHNob3dJbmZvcm1lcikge1xuICAgICAgdGhpcy5pbmZvKHsgbWVzc2FnZSwgZGV0YWlscyB9LCAnZXJyb3InLCB0aGlzLm9wdHMuaW5mb1RpbWVvdXQpXG4gICAgfVxuXG4gICAgaWYgKHRocm93RXJyKSB7XG4gICAgICB0aHJvdyAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSlcbiAgICB9XG4gIH1cblxuICAjYXNzZXJ0TmV3VXBsb2FkQWxsb3dlZCAoZmlsZSkge1xuICAgIGNvbnN0IHsgYWxsb3dOZXdVcGxvYWQgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuXG4gICAgaWYgKGFsbG93TmV3VXBsb2FkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy4jc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ25vTW9yZUZpbGVzQWxsb3dlZCcpKSwgeyBmaWxlIH0pXG4gICAgfVxuICB9XG5cbiAgY2hlY2tJZkZpbGVBbHJlYWR5RXhpc3RzIChmaWxlSUQpIHtcbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGlmIChmaWxlc1tmaWxlSURdICYmICFmaWxlc1tmaWxlSURdLmlzR2hvc3QpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZpbGUgc3RhdGUgb2JqZWN0IGJhc2VkIG9uIHVzZXItcHJvdmlkZWQgYGFkZEZpbGUoKWAgb3B0aW9ucy5cbiAgICpcbiAgICogTm90ZSB0aGlzIGlzIGV4dHJlbWVseSBzaWRlLWVmZmVjdGZ1bCBhbmQgc2hvdWxkIG9ubHkgYmUgZG9uZSB3aGVuIGEgZmlsZSBzdGF0ZSBvYmplY3RcbiAgICogd2lsbCBiZSBhZGRlZCB0byBzdGF0ZSBpbW1lZGlhdGVseSBhZnRlcndhcmQhXG4gICAqXG4gICAqIFRoZSBgZmlsZXNgIHZhbHVlIGlzIHBhc3NlZCBpbiBiZWNhdXNlIGl0IG1heSBiZSB1cGRhdGVkIGJ5IHRoZSBjYWxsZXIgd2l0aG91dCB1cGRhdGluZyB0aGUgc3RvcmUuXG4gICAqL1xuICAjY2hlY2tBbmRDcmVhdGVGaWxlU3RhdGVPYmplY3QgKGZpbGVzLCBmaWxlRGVzY3JpcHRvcikge1xuICAgIGNvbnN0IGZpbGVUeXBlID0gZ2V0RmlsZVR5cGUoZmlsZURlc2NyaXB0b3IpXG4gICAgY29uc3QgZmlsZU5hbWUgPSBnZXRGaWxlTmFtZShmaWxlVHlwZSwgZmlsZURlc2NyaXB0b3IpXG4gICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uKGZpbGVOYW1lKS5leHRlbnNpb25cbiAgICBjb25zdCBpc1JlbW90ZSA9IEJvb2xlYW4oZmlsZURlc2NyaXB0b3IuaXNSZW1vdGUpXG4gICAgY29uc3QgZmlsZUlEID0gZ2VuZXJhdGVGaWxlSUQoe1xuICAgICAgLi4uZmlsZURlc2NyaXB0b3IsXG4gICAgICB0eXBlOiBmaWxlVHlwZSxcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuY2hlY2tJZkZpbGVBbHJlYWR5RXhpc3RzKGZpbGVJRCkpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCdub0R1cGxpY2F0ZXMnLCB7IGZpbGVOYW1lIH0pKVxuICAgICAgdGhpcy4jc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhlcnJvciwgeyBmaWxlOiBmaWxlRGVzY3JpcHRvciB9KVxuICAgIH1cblxuICAgIGNvbnN0IG1ldGEgPSBmaWxlRGVzY3JpcHRvci5tZXRhIHx8IHt9XG4gICAgbWV0YS5uYW1lID0gZmlsZU5hbWVcbiAgICBtZXRhLnR5cGUgPSBmaWxlVHlwZVxuXG4gICAgLy8gYG51bGxgIG1lYW5zIHRoZSBzaXplIGlzIHVua25vd24uXG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlci5pc0Zpbml0ZShmaWxlRGVzY3JpcHRvci5kYXRhLnNpemUpID8gZmlsZURlc2NyaXB0b3IuZGF0YS5zaXplIDogbnVsbFxuXG4gICAgbGV0IG5ld0ZpbGUgPSB7XG4gICAgICBzb3VyY2U6IGZpbGVEZXNjcmlwdG9yLnNvdXJjZSB8fCAnJyxcbiAgICAgIGlkOiBmaWxlSUQsXG4gICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgIGV4dGVuc2lvbjogZmlsZUV4dGVuc2lvbiB8fCAnJyxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4udGhpcy5nZXRTdGF0ZSgpLm1ldGEsXG4gICAgICAgIC4uLm1ldGEsXG4gICAgICB9LFxuICAgICAgdHlwZTogZmlsZVR5cGUsXG4gICAgICBkYXRhOiBmaWxlRGVzY3JpcHRvci5kYXRhLFxuICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgICAgYnl0ZXNVcGxvYWRlZDogMCxcbiAgICAgICAgYnl0ZXNUb3RhbDogc2l6ZSxcbiAgICAgICAgdXBsb2FkQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICB1cGxvYWRTdGFydGVkOiBudWxsLFxuICAgICAgfSxcbiAgICAgIHNpemUsXG4gICAgICBpc1JlbW90ZSxcbiAgICAgIHJlbW90ZTogZmlsZURlc2NyaXB0b3IucmVtb3RlIHx8ICcnLFxuICAgICAgcHJldmlldzogZmlsZURlc2NyaXB0b3IucHJldmlldyxcbiAgICB9XG5cbiAgICBjb25zdCBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCA9IHRoaXMub3B0cy5vbkJlZm9yZUZpbGVBZGRlZChuZXdGaWxlLCBmaWxlcylcblxuICAgIGlmIChvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIERvbuKAmXQgc2hvdyBVSSBpbmZvIGZvciB0aGlzIGVycm9yLCBhcyBpdCBzaG91bGQgYmUgZG9uZSBieSB0aGUgZGV2ZWxvcGVyXG4gICAgICB0aGlzLiNzaG93T3JMb2dFcnJvckFuZFRocm93KG5ldyBSZXN0cmljdGlvbkVycm9yKCdDYW5ub3QgYWRkIHRoZSBmaWxlIGJlY2F1c2Ugb25CZWZvcmVGaWxlQWRkZWQgcmV0dXJuZWQgZmFsc2UuJyksIHsgc2hvd0luZm9ybWVyOiBmYWxzZSwgZmlsZURlc2NyaXB0b3IgfSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCA9PT0gJ29iamVjdCcgJiYgb25CZWZvcmVGaWxlQWRkZWRSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIG5ld0ZpbGUgPSBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmaWxlc0FycmF5ID0gT2JqZWN0LmtleXMoZmlsZXMpLm1hcChpID0+IGZpbGVzW2ldKVxuICAgICAgdGhpcy4jY2hlY2tSZXN0cmljdGlvbnMobmV3RmlsZSwgZmlsZXNBcnJheSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuI3Nob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyLCB7IGZpbGU6IG5ld0ZpbGUgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmlsZVxuICB9XG5cbiAgLy8gU2NoZWR1bGUgYW4gdXBsb2FkIGlmIGBhdXRvUHJvY2VlZGAgaXMgZW5hYmxlZC5cbiAgI3N0YXJ0SWZBdXRvUHJvY2VlZCAoKSB7XG4gICAgaWYgKHRoaXMub3B0cy5hdXRvUHJvY2VlZCAmJiAhdGhpcy5zY2hlZHVsZWRBdXRvUHJvY2VlZCkge1xuICAgICAgdGhpcy5zY2hlZHVsZWRBdXRvUHJvY2VlZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnNjaGVkdWxlZEF1dG9Qcm9jZWVkID0gbnVsbFxuICAgICAgICB0aGlzLnVwbG9hZCgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0sIDQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBmaWxlIHRvIGBzdGF0ZS5maWxlc2AuIFRoaXMgd2lsbCBydW4gYG9uQmVmb3JlRmlsZUFkZGVkYCxcbiAgICogdHJ5IHRvIGd1ZXNzIGZpbGUgdHlwZSBpbiBhIGNsZXZlciB3YXksIGNoZWNrIGZpbGUgYWdhaW5zdCByZXN0cmljdGlvbnMsXG4gICAqIGFuZCBzdGFydCBhbiB1cGxvYWQgaWYgYGF1dG9Qcm9jZWVkID09PSB0cnVlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGZpbGUgb2JqZWN0IHRvIGFkZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBpZCBmb3IgdGhlIGFkZGVkIGZpbGVcbiAgICovXG4gIGFkZEZpbGUgKGZpbGUpIHtcbiAgICB0aGlzLiNhc3NlcnROZXdVcGxvYWRBbGxvd2VkKGZpbGUpXG5cbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICBsZXQgbmV3RmlsZSA9IHRoaXMuI2NoZWNrQW5kQ3JlYXRlRmlsZVN0YXRlT2JqZWN0KGZpbGVzLCBmaWxlKVxuXG4gICAgLy8gVXNlcnMgYXJlIGFza2VkIHRvIHJlLXNlbGVjdCByZWNvdmVyZWQgZmlsZXMgd2l0aG91dCBkYXRhLFxuICAgIC8vIGFuZCB0byBrZWVwIHRoZSBwcm9ncmVzcywgbWV0YSBhbmQgZXZlcnRoaW5nIGVsc2UsIHdlIG9ubHkgcmVwbGFjZSBzYWlkIGRhdGFcbiAgICBpZiAoZmlsZXNbbmV3RmlsZS5pZF0gJiYgZmlsZXNbbmV3RmlsZS5pZF0uaXNHaG9zdCkge1xuICAgICAgbmV3RmlsZSA9IHtcbiAgICAgICAgLi4uZmlsZXNbbmV3RmlsZS5pZF0sXG4gICAgICAgIGRhdGE6IGZpbGUuZGF0YSxcbiAgICAgICAgaXNHaG9zdDogZmFsc2UsXG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhgUmVwbGFjZWQgdGhlIGJsb2IgaW4gdGhlIHJlc3RvcmVkIGdob3N0IGZpbGU6ICR7bmV3RmlsZS5uYW1lfSwgJHtuZXdGaWxlLmlkfWApXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmaWxlczoge1xuICAgICAgICAuLi5maWxlcyxcbiAgICAgICAgW25ld0ZpbGUuaWRdOiBuZXdGaWxlLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCdmaWxlLWFkZGVkJywgbmV3RmlsZSlcbiAgICB0aGlzLmVtaXQoJ2ZpbGVzLWFkZGVkJywgW25ld0ZpbGVdKVxuICAgIHRoaXMubG9nKGBBZGRlZCBmaWxlOiAke25ld0ZpbGUubmFtZX0sICR7bmV3RmlsZS5pZH0sIG1pbWUgdHlwZTogJHtuZXdGaWxlLnR5cGV9YClcblxuICAgIHRoaXMuI3N0YXJ0SWZBdXRvUHJvY2VlZCgpXG5cbiAgICByZXR1cm4gbmV3RmlsZS5pZFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBtdWx0aXBsZSBmaWxlcyB0byBgc3RhdGUuZmlsZXNgLiBTZWUgdGhlIGBhZGRGaWxlKClgIGRvY3VtZW50YXRpb24uXG4gICAqXG4gICAqIElmIGFuIGVycm9yIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBmaWxlLCBpdCBpcyBsb2dnZWQgYW5kIHRoZSB1c2VyIGlzIG5vdGlmaWVkLlxuICAgKiBUaGlzIGlzIGdvb2QgZm9yIFVJIHBsdWdpbnMsIGJ1dCBub3QgZm9yIHByb2dyYW1tYXRpYyB1c2UuXG4gICAqIFByb2dyYW1tYXRpYyB1c2VycyBzaG91bGQgdXN1YWxseSBzdGlsbCB1c2UgYGFkZEZpbGUoKWAgb24gaW5kaXZpZHVhbCBmaWxlcy5cbiAgICovXG4gIGFkZEZpbGVzIChmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICB0aGlzLiNhc3NlcnROZXdVcGxvYWRBbGxvd2VkKClcblxuICAgIC8vIGNyZWF0ZSBhIGNvcHkgb2YgdGhlIGZpbGVzIG9iamVjdCBvbmx5IG9uY2VcbiAgICBjb25zdCBmaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBjb25zdCBuZXdGaWxlcyA9IFtdXG4gICAgY29uc3QgZXJyb3JzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVEZXNjcmlwdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IG5ld0ZpbGUgPSB0aGlzLiNjaGVja0FuZENyZWF0ZUZpbGVTdGF0ZU9iamVjdChmaWxlcywgZmlsZURlc2NyaXB0b3JzW2ldKVxuICAgICAgICAvLyBVc2VycyBhcmUgYXNrZWQgdG8gcmUtc2VsZWN0IHJlY292ZXJlZCBmaWxlcyB3aXRob3V0IGRhdGEsXG4gICAgICAgIC8vIGFuZCB0byBrZWVwIHRoZSBwcm9ncmVzcywgbWV0YSBhbmQgZXZlcnRoaW5nIGVsc2UsIHdlIG9ubHkgcmVwbGFjZSBzYWlkIGRhdGFcbiAgICAgICAgaWYgKGZpbGVzW25ld0ZpbGUuaWRdICYmIGZpbGVzW25ld0ZpbGUuaWRdLmlzR2hvc3QpIHtcbiAgICAgICAgICBuZXdGaWxlID0ge1xuICAgICAgICAgICAgLi4uZmlsZXNbbmV3RmlsZS5pZF0sXG4gICAgICAgICAgICBkYXRhOiBmaWxlRGVzY3JpcHRvcnNbaV0uZGF0YSxcbiAgICAgICAgICAgIGlzR2hvc3Q6IGZhbHNlLFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZyhgUmVwbGFjZWQgYmxvYiBpbiBhIGdob3N0IGZpbGU6ICR7bmV3RmlsZS5uYW1lfSwgJHtuZXdGaWxlLmlkfWApXG4gICAgICAgIH1cbiAgICAgICAgZmlsZXNbbmV3RmlsZS5pZF0gPSBuZXdGaWxlXG4gICAgICAgIG5ld0ZpbGVzLnB1c2gobmV3RmlsZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzIH0pXG5cbiAgICBuZXdGaWxlcy5mb3JFYWNoKChuZXdGaWxlKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2ZpbGUtYWRkZWQnLCBuZXdGaWxlKVxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ2ZpbGVzLWFkZGVkJywgbmV3RmlsZXMpXG5cbiAgICBpZiAobmV3RmlsZXMubGVuZ3RoID4gNSkge1xuICAgICAgdGhpcy5sb2coYEFkZGVkIGJhdGNoIG9mICR7bmV3RmlsZXMubGVuZ3RofSBmaWxlc2ApXG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKG5ld0ZpbGVzKS5mb3JFYWNoKGZpbGVJRCA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBBZGRlZCBmaWxlOiAke25ld0ZpbGVzW2ZpbGVJRF0ubmFtZX1cXG4gaWQ6ICR7bmV3RmlsZXNbZmlsZUlEXS5pZH1cXG4gdHlwZTogJHtuZXdGaWxlc1tmaWxlSURdLnR5cGV9YClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG5ld0ZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuI3N0YXJ0SWZBdXRvUHJvY2VlZCgpXG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9ICdNdWx0aXBsZSBlcnJvcnMgb2NjdXJyZWQgd2hpbGUgYWRkaW5nIGZpbGVzOlxcbidcbiAgICAgIGVycm9ycy5mb3JFYWNoKChzdWJFcnJvcikgPT4ge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG4gKiAke3N1YkVycm9yLm1lc3NhZ2V9YFxuICAgICAgfSlcblxuICAgICAgdGhpcy5pbmZvKHtcbiAgICAgICAgbWVzc2FnZTogdGhpcy5pMThuKCdhZGRCdWxrRmlsZXNGYWlsZWQnLCB7IHNtYXJ0X2NvdW50OiBlcnJvcnMubGVuZ3RoIH0pLFxuICAgICAgICBkZXRhaWxzOiBtZXNzYWdlLFxuICAgICAgfSwgJ2Vycm9yJywgdGhpcy5vcHRzLmluZm9UaW1lb3V0KVxuXG4gICAgICBpZiAodHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMsIG1lc3NhZ2UpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgICAgZXJyLmVycm9ycyA9IGVycm9yc1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW1vdmVGaWxlcyAoZmlsZUlEcywgcmVhc29uKSB7XG4gICAgY29uc3QgeyBmaWxlcywgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHsgLi4uZmlsZXMgfVxuICAgIGNvbnN0IHVwZGF0ZWRVcGxvYWRzID0geyAuLi5jdXJyZW50VXBsb2FkcyB9XG5cbiAgICBjb25zdCByZW1vdmVkRmlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIGlmIChmaWxlc1tmaWxlSURdKSB7XG4gICAgICAgIHJlbW92ZWRGaWxlc1tmaWxlSURdID0gZmlsZXNbZmlsZUlEXVxuICAgICAgICBkZWxldGUgdXBkYXRlZEZpbGVzW2ZpbGVJRF1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gUmVtb3ZlIGZpbGVzIGZyb20gdGhlIGBmaWxlSURzYCBsaXN0IGluIGVhY2ggdXBsb2FkLlxuICAgIGZ1bmN0aW9uIGZpbGVJc05vdFJlbW92ZWQgKHVwbG9hZEZpbGVJRCkge1xuICAgICAgcmV0dXJuIHJlbW92ZWRGaWxlc1t1cGxvYWRGaWxlSURdID09PSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyh1cGRhdGVkVXBsb2FkcykuZm9yRWFjaCgodXBsb2FkSUQpID0+IHtcbiAgICAgIGNvbnN0IG5ld0ZpbGVJRHMgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0uZmlsZUlEcy5maWx0ZXIoZmlsZUlzTm90UmVtb3ZlZClcblxuICAgICAgLy8gUmVtb3ZlIHRoZSB1cGxvYWQgaWYgbm8gZmlsZXMgYXJlIGFzc29jaWF0ZWQgd2l0aCBpdCBhbnltb3JlLlxuICAgICAgaWYgKG5ld0ZpbGVJRHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkVXBsb2Fkc1t1cGxvYWRJRF1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRVcGxvYWRzW3VwbG9hZElEXSA9IHtcbiAgICAgICAgLi4uY3VycmVudFVwbG9hZHNbdXBsb2FkSURdLFxuICAgICAgICBmaWxlSURzOiBuZXdGaWxlSURzLFxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBzdGF0ZVVwZGF0ZSA9IHtcbiAgICAgIGN1cnJlbnRVcGxvYWRzOiB1cGRhdGVkVXBsb2FkcyxcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgfVxuXG4gICAgLy8gSWYgYWxsIGZpbGVzIHdlcmUgcmVtb3ZlZCAtIGFsbG93IG5ldyB1cGxvYWRzLFxuICAgIC8vIGFuZCBjbGVhciByZWNvdmVyZWRTdGF0ZVxuICAgIGlmIChPYmplY3Qua2V5cyh1cGRhdGVkRmlsZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc3RhdGVVcGRhdGUuYWxsb3dOZXdVcGxvYWQgPSB0cnVlXG4gICAgICBzdGF0ZVVwZGF0ZS5lcnJvciA9IG51bGxcbiAgICAgIHN0YXRlVXBkYXRlLnJlY292ZXJlZFN0YXRlID0gbnVsbFxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoc3RhdGVVcGRhdGUpXG4gICAgdGhpcy5jYWxjdWxhdGVUb3RhbFByb2dyZXNzKClcblxuICAgIGNvbnN0IHJlbW92ZWRGaWxlSURzID0gT2JqZWN0LmtleXMocmVtb3ZlZEZpbGVzKVxuICAgIHJlbW92ZWRGaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdmaWxlLXJlbW92ZWQnLCByZW1vdmVkRmlsZXNbZmlsZUlEXSwgcmVhc29uKVxuICAgIH0pXG5cbiAgICBpZiAocmVtb3ZlZEZpbGVJRHMubGVuZ3RoID4gNSkge1xuICAgICAgdGhpcy5sb2coYFJlbW92ZWQgJHtyZW1vdmVkRmlsZUlEcy5sZW5ndGh9IGZpbGVzYClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2coYFJlbW92ZWQgZmlsZXM6ICR7cmVtb3ZlZEZpbGVJRHMuam9pbignLCAnKX1gKVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUZpbGUgKGZpbGVJRCwgcmVhc29uID0gbnVsbCkge1xuICAgIHRoaXMucmVtb3ZlRmlsZXMoW2ZpbGVJRF0sIHJlYXNvbilcbiAgfVxuXG4gIHBhdXNlUmVzdW1lIChmaWxlSUQpIHtcbiAgICBpZiAoIXRoaXMuZ2V0U3RhdGUoKS5jYXBhYmlsaXRpZXMucmVzdW1hYmxlVXBsb2Fkc1xuICAgICAgICAgfHwgdGhpcy5nZXRGaWxlKGZpbGVJRCkudXBsb2FkQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCB3YXNQYXVzZWQgPSB0aGlzLmdldEZpbGUoZmlsZUlEKS5pc1BhdXNlZCB8fCBmYWxzZVxuICAgIGNvbnN0IGlzUGF1c2VkID0gIXdhc1BhdXNlZFxuXG4gICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZUlELCB7XG4gICAgICBpc1BhdXNlZCxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCd1cGxvYWQtcGF1c2UnLCBmaWxlSUQsIGlzUGF1c2VkKVxuXG4gICAgcmV0dXJuIGlzUGF1c2VkXG4gIH1cblxuICBwYXVzZUFsbCAoKSB7XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGNvbnN0IGluUHJvZ3Jlc3NVcGRhdGVkRmlsZXMgPSBPYmplY3Qua2V5cyh1cGRhdGVkRmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICF1cGRhdGVkRmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGVcbiAgICAgICAgICAgICAmJiB1cGRhdGVkRmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgIH0pXG5cbiAgICBpblByb2dyZXNzVXBkYXRlZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlID0geyAuLi51cGRhdGVkRmlsZXNbZmlsZV0sIGlzUGF1c2VkOiB0cnVlIH1cbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlXSA9IHVwZGF0ZWRGaWxlXG4gICAgfSlcblxuICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlczogdXBkYXRlZEZpbGVzIH0pXG4gICAgdGhpcy5lbWl0KCdwYXVzZS1hbGwnKVxuICB9XG5cbiAgcmVzdW1lQWxsICgpIHtcbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgY29uc3QgaW5Qcm9ncmVzc1VwZGF0ZWRGaWxlcyA9IE9iamVjdC5rZXlzKHVwZGF0ZWRGaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gIXVwZGF0ZWRGaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgICAgICAgICAgICYmIHVwZGF0ZWRGaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGluUHJvZ3Jlc3NVcGRhdGVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbGUgPSB7XG4gICAgICAgIC4uLnVwZGF0ZWRGaWxlc1tmaWxlXSxcbiAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlXSA9IHVwZGF0ZWRGaWxlXG4gICAgfSlcbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXM6IHVwZGF0ZWRGaWxlcyB9KVxuXG4gICAgdGhpcy5lbWl0KCdyZXN1bWUtYWxsJylcbiAgfVxuXG4gIHJldHJ5QWxsICgpIHtcbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgY29uc3QgZmlsZXNUb1JldHJ5ID0gT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5maWx0ZXIoZmlsZSA9PiB7XG4gICAgICByZXR1cm4gdXBkYXRlZEZpbGVzW2ZpbGVdLmVycm9yXG4gICAgfSlcblxuICAgIGZpbGVzVG9SZXRyeS5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkRmlsZSA9IHtcbiAgICAgICAgLi4udXBkYXRlZEZpbGVzW2ZpbGVdLFxuICAgICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfVxuICAgICAgdXBkYXRlZEZpbGVzW2ZpbGVdID0gdXBkYXRlZEZpbGVcbiAgICB9KVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZmlsZXM6IHVwZGF0ZWRGaWxlcyxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ3JldHJ5LWFsbCcsIGZpbGVzVG9SZXRyeSlcblxuICAgIGlmIChmaWxlc1RvUmV0cnkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgc3VjY2Vzc2Z1bDogW10sXG4gICAgICAgIGZhaWxlZDogW10sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHVwbG9hZElEID0gdGhpcy4jY3JlYXRlVXBsb2FkKGZpbGVzVG9SZXRyeSwge1xuICAgICAgZm9yY2VBbGxvd05ld1VwbG9hZDogdHJ1ZSwgLy8gY3JlYXRlIG5ldyB1cGxvYWQgZXZlbiBpZiBhbGxvd05ld1VwbG9hZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLiNydW5VcGxvYWQodXBsb2FkSUQpXG4gIH1cblxuICBjYW5jZWxBbGwgKCkge1xuICAgIHRoaXMuZW1pdCgnY2FuY2VsLWFsbCcpXG5cbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyhmaWxlcylcbiAgICBpZiAoZmlsZUlEcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlRmlsZXMoZmlsZUlEcywgJ2NhbmNlbC1hbGwnKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdG90YWxQcm9ncmVzczogMCxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgcmVjb3ZlcmVkU3RhdGU6IG51bGwsXG4gICAgfSlcbiAgfVxuXG4gIHJldHJ5VXBsb2FkIChmaWxlSUQpIHtcbiAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlSUQsIHtcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ3VwbG9hZC1yZXRyeScsIGZpbGVJRClcblxuICAgIGNvbnN0IHVwbG9hZElEID0gdGhpcy4jY3JlYXRlVXBsb2FkKFtmaWxlSURdLCB7XG4gICAgICBmb3JjZUFsbG93TmV3VXBsb2FkOiB0cnVlLCAvLyBjcmVhdGUgbmV3IHVwbG9hZCBldmVuIGlmIGFsbG93TmV3VXBsb2FkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuI3J1blVwbG9hZCh1cGxvYWRJRClcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLmNhbmNlbEFsbCgpXG4gIH1cblxuICBsb2dvdXQgKCkge1xuICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMocGx1Z2luID0+IHtcbiAgICAgIGlmIChwbHVnaW4ucHJvdmlkZXIgJiYgcGx1Z2luLnByb3ZpZGVyLmxvZ291dCkge1xuICAgICAgICBwbHVnaW4ucHJvdmlkZXIubG9nb3V0KClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2FsY3VsYXRlUHJvZ3Jlc3MgKGZpbGUsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGJ5dGVzVG90YWwgbWF5IGJlIG51bGwgb3IgemVybzsgaW4gdGhhdCBjYXNlIHdlIGNhbid0IGRpdmlkZSBieSBpdFxuICAgIGNvbnN0IGNhbkhhdmVQZXJjZW50YWdlID0gTnVtYmVyLmlzRmluaXRlKGRhdGEuYnl0ZXNUb3RhbCkgJiYgZGF0YS5ieXRlc1RvdGFsID4gMFxuICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgIC4uLnRoaXMuZ2V0RmlsZShmaWxlLmlkKS5wcm9ncmVzcyxcbiAgICAgICAgYnl0ZXNVcGxvYWRlZDogZGF0YS5ieXRlc1VwbG9hZGVkLFxuICAgICAgICBieXRlc1RvdGFsOiBkYXRhLmJ5dGVzVG90YWwsXG4gICAgICAgIHBlcmNlbnRhZ2U6IGNhbkhhdmVQZXJjZW50YWdlXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKChkYXRhLmJ5dGVzVXBsb2FkZWQgLyBkYXRhLmJ5dGVzVG90YWwpICogMTAwKVxuICAgICAgICAgIDogMCxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gIH1cblxuICBjYWxjdWxhdGVUb3RhbFByb2dyZXNzICgpIHtcbiAgICAvLyBjYWxjdWxhdGUgdG90YWwgcHJvZ3Jlc3MsIHVzaW5nIHRoZSBudW1iZXIgb2YgZmlsZXMgY3VycmVudGx5IHVwbG9hZGluZyxcbiAgICAvLyBtdWx0aXBsaWVkIGJ5IDEwMCBhbmQgdGhlIHN1bW0gb2YgaW5kaXZpZHVhbCBwcm9ncmVzcyBvZiBlYWNoIGZpbGVcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgICAgICB8fCBmaWxlLnByb2dyZXNzLnByZXByb2Nlc3NcbiAgICAgICAgfHwgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICBpZiAoaW5Qcm9ncmVzcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCAwKVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3M6IDAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNpemVkRmlsZXMgPSBpblByb2dyZXNzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5wcm9ncmVzcy5ieXRlc1RvdGFsICE9IG51bGwpXG4gICAgY29uc3QgdW5zaXplZEZpbGVzID0gaW5Qcm9ncmVzcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUucHJvZ3Jlc3MuYnl0ZXNUb3RhbCA9PSBudWxsKVxuXG4gICAgaWYgKHNpemVkRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBwcm9ncmVzc01heCA9IGluUHJvZ3Jlc3MubGVuZ3RoICogMTAwXG4gICAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB1bnNpemVkRmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjYyArIGZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZVxuICAgICAgfSwgMClcbiAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKChjdXJyZW50UHJvZ3Jlc3MgLyBwcm9ncmVzc01heCkgKiAxMDApXG4gICAgICB0aGlzLnNldFN0YXRlKHsgdG90YWxQcm9ncmVzcyB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRvdGFsU2l6ZSA9IHNpemVkRmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBhY2MgKyBmaWxlLnByb2dyZXNzLmJ5dGVzVG90YWxcbiAgICB9LCAwKVxuICAgIGNvbnN0IGF2ZXJhZ2VTaXplID0gdG90YWxTaXplIC8gc2l6ZWRGaWxlcy5sZW5ndGhcbiAgICB0b3RhbFNpemUgKz0gYXZlcmFnZVNpemUgKiB1bnNpemVkRmlsZXMubGVuZ3RoXG5cbiAgICBsZXQgdXBsb2FkZWRTaXplID0gMFxuICAgIHNpemVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgdXBsb2FkZWRTaXplICs9IGZpbGUucHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZFxuICAgIH0pXG4gICAgdW5zaXplZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHVwbG9hZGVkU2l6ZSArPSAoYXZlcmFnZVNpemUgKiAoZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlIHx8IDApKSAvIDEwMFxuICAgIH0pXG5cbiAgICBsZXQgdG90YWxQcm9ncmVzcyA9IHRvdGFsU2l6ZSA9PT0gMFxuICAgICAgPyAwXG4gICAgICA6IE1hdGgucm91bmQoKHVwbG9hZGVkU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDApXG5cbiAgICAvLyBob3QgZml4LCBiZWNhdXNlOlxuICAgIC8vIHVwbG9hZGVkU2l6ZSBlbmRlZCB1cCBsYXJnZXIgdGhhbiB0b3RhbFNpemUsIHJlc3VsdGluZyBpbiAxMzI1JSB0b3RhbFxuICAgIGlmICh0b3RhbFByb2dyZXNzID4gMTAwKSB7XG4gICAgICB0b3RhbFByb2dyZXNzID0gMTAwXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3MgfSlcbiAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdG90YWxQcm9ncmVzcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgbGlzdGVuZXJzIGZvciBhbGwgZ2xvYmFsIGFjdGlvbnMsIGxpa2U6XG4gICAqIGBlcnJvcmAsIGBmaWxlLXJlbW92ZWRgLCBgdXBsb2FkLXByb2dyZXNzYFxuICAgKi9cbiAgI2FkZExpc3RlbmVycyAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2ZpbGVdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtyZXNwb25zZV1cbiAgICAgKi9cbiAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZXJyb3IsIGZpbGUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBsZXQgZXJyb3JNc2cgPSBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ1xuICAgICAgaWYgKGVycm9yLmRldGFpbHMpIHtcbiAgICAgICAgZXJyb3JNc2cgKz0gYCAke2Vycm9yLmRldGFpbHN9YFxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IGVycm9yTXNnIH0pXG5cbiAgICAgIGlmIChmaWxlICE9IG51bGwgJiYgZmlsZS5pZCBpbiB0aGlzLmdldFN0YXRlKCkuZmlsZXMpIHtcbiAgICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICAgIGVycm9yOiBlcnJvck1zZyxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIGVycm9ySGFuZGxlcilcblxuICAgIHRoaXMub24oJ3VwbG9hZC1lcnJvcicsIChmaWxlLCBlcnJvciwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGVycm9ySGFuZGxlcihlcnJvciwgZmlsZSwgcmVzcG9uc2UpXG5cbiAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgbmV3RXJyb3IuZGV0YWlscyA9IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgaWYgKGVycm9yLmRldGFpbHMpIHtcbiAgICAgICAgICBuZXdFcnJvci5kZXRhaWxzICs9IGAgJHtlcnJvci5kZXRhaWxzfWBcbiAgICAgICAgfVxuICAgICAgICBuZXdFcnJvci5tZXNzYWdlID0gdGhpcy5pMThuKCdmYWlsZWRUb1VwbG9hZCcsIHsgZmlsZTogZmlsZS5uYW1lIH0pXG4gICAgICAgIHRoaXMuI3Nob3dPckxvZ0Vycm9yQW5kVGhyb3cobmV3RXJyb3IsIHtcbiAgICAgICAgICB0aHJvd0VycjogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNzaG93T3JMb2dFcnJvckFuZFRocm93KGVycm9yLCB7XG4gICAgICAgICAgdGhyb3dFcnI6IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCd1cGxvYWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IG51bGwgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbigndXBsb2FkLXN0YXJ0ZWQnLCAoZmlsZSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmdldEZpbGUoZmlsZS5pZCkpIHtcbiAgICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7XG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgdXBsb2FkU3RhcnRlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGxvYWRDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgICAgICBieXRlc1VwbG9hZGVkOiAwLFxuICAgICAgICAgIGJ5dGVzVG90YWw6IGZpbGUuc2l6ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3VwbG9hZC1wcm9ncmVzcycsIHRoaXMuY2FsY3VsYXRlUHJvZ3Jlc3MpXG5cbiAgICB0aGlzLm9uKCd1cGxvYWQtc3VjY2VzcycsIChmaWxlLCB1cGxvYWRSZXNwKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgY3VycmVudFByb2dyZXNzID0gdGhpcy5nZXRGaWxlKGZpbGUuaWQpLnByb2dyZXNzXG4gICAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7XG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgLi4uY3VycmVudFByb2dyZXNzLFxuICAgICAgICAgIHBvc3Rwcm9jZXNzOiB0aGlzLiNwb3N0UHJvY2Vzc29ycy5zaXplID4gMCA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgICB1cGxvYWRDb21wbGV0ZTogdHJ1ZSxcbiAgICAgICAgICBwZXJjZW50YWdlOiAxMDAsXG4gICAgICAgICAgYnl0ZXNVcGxvYWRlZDogY3VycmVudFByb2dyZXNzLmJ5dGVzVG90YWwsXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNlOiB1cGxvYWRSZXNwLFxuICAgICAgICB1cGxvYWRVUkw6IHVwbG9hZFJlc3AudXBsb2FkVVJMLFxuICAgICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgICB9KVxuXG4gICAgICAvLyBSZW1vdGUgcHJvdmlkZXJzIHNvbWV0aW1lcyBkb24ndCB0ZWxsIHVzIHRoZSBmaWxlIHNpemUsXG4gICAgICAvLyBidXQgd2UgY2FuIGtub3cgaG93IG1hbnkgYnl0ZXMgd2UgdXBsb2FkZWQgb25jZSB0aGUgdXBsb2FkIGlzIGNvbXBsZXRlLlxuICAgICAgaWYgKGZpbGUuc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgICBzaXplOiB1cGxvYWRSZXNwLmJ5dGVzVXBsb2FkZWQgfHwgY3VycmVudFByb2dyZXNzLmJ5dGVzVG90YWwsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3ByZXByb2Nlc3MtcHJvZ3Jlc3MnLCAoZmlsZSwgcHJvZ3Jlc3MpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICBwcm9ncmVzczogeyAuLi50aGlzLmdldEZpbGUoZmlsZS5pZCkucHJvZ3Jlc3MsIHByZXByb2Nlc3M6IHByb2dyZXNzIH0sXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwcmVwcm9jZXNzLWNvbXBsZXRlJywgKGZpbGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgZmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgICBmaWxlc1tmaWxlLmlkXSA9IHsgLi4uZmlsZXNbZmlsZS5pZF0sIHByb2dyZXNzOiB7IC4uLmZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzIH0gfVxuICAgICAgZGVsZXRlIGZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzLnByZXByb2Nlc3NcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3Bvc3Rwcm9jZXNzLXByb2dyZXNzJywgKGZpbGUsIHByb2dyZXNzKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzLCBwb3N0cHJvY2VzczogcHJvZ3Jlc3MgfSxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3Bvc3Rwcm9jZXNzLWNvbXBsZXRlJywgKGZpbGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgZmlsZXMgPSB7XG4gICAgICAgIC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyxcbiAgICAgIH1cbiAgICAgIGZpbGVzW2ZpbGUuaWRdID0ge1xuICAgICAgICAuLi5maWxlc1tmaWxlLmlkXSxcbiAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAuLi5maWxlc1tmaWxlLmlkXS5wcm9ncmVzcyxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBmaWxlc1tmaWxlLmlkXS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXMgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbigncmVzdG9yZWQnLCAoKSA9PiB7XG4gICAgICAvLyBGaWxlcyBtYXkgaGF2ZSBjaGFuZ2VkLS1lbnN1cmUgcHJvZ3Jlc3MgaXMgc3RpbGwgYWNjdXJhdGUuXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsUHJvZ3Jlc3MoKVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdkYXNoYm9hcmQ6ZmlsZS1lZGl0LWNvbXBsZXRlJywgKGZpbGUpID0+IHtcbiAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrUmVxdWlyZWRNZXRhRmllbGRzT25GaWxlKGZpbGUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHNob3cgaW5mb3JtZXIgaWYgb2ZmbGluZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuI3VwZGF0ZU9ubGluZVN0YXR1cylcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgdGhpcy4jdXBkYXRlT25saW5lU3RhdHVzKVxuICAgICAgc2V0VGltZW91dCh0aGlzLiN1cGRhdGVPbmxpbmVTdGF0dXMsIDMwMDApXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlT25saW5lU3RhdHVzICgpIHtcbiAgICBjb25zdCBvbmxpbmUgPSB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvci5vbkxpbmUgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lXG4gICAgICA6IHRydWVcbiAgICBpZiAoIW9ubGluZSkge1xuICAgICAgdGhpcy5lbWl0KCdpcy1vZmZsaW5lJylcbiAgICAgIHRoaXMuaW5mbyh0aGlzLmkxOG4oJ25vSW50ZXJuZXRDb25uZWN0aW9uJyksICdlcnJvcicsIDApXG4gICAgICB0aGlzLndhc09mZmxpbmUgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgnaXMtb25saW5lJylcbiAgICAgIGlmICh0aGlzLndhc09mZmxpbmUpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdiYWNrLW9ubGluZScpXG4gICAgICAgIHRoaXMuaW5mbyh0aGlzLmkxOG4oJ2Nvbm5lY3RlZFRvSW50ZXJuZXQnKSwgJ3N1Y2Nlc3MnLCAzMDAwKVxuICAgICAgICB0aGlzLndhc09mZmxpbmUgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICN1cGRhdGVPbmxpbmVTdGF0dXMgPSB0aGlzLnVwZGF0ZU9ubGluZVN0YXR1cy5iaW5kKHRoaXMpXG5cbiAgZ2V0SUQgKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHMuaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBwbHVnaW4gd2l0aCBDb3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luIG9iamVjdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIG9iamVjdCB3aXRoIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIFBsdWdpblxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZWxmIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICB1c2UgKFBsdWdpbiwgb3B0cykge1xuICAgIGlmICh0eXBlb2YgUGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgYSBwbHVnaW4gY2xhc3MsIGJ1dCBnb3QgJHtQbHVnaW4gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgUGx1Z2lufS5gXG4gICAgICAgICsgJyBQbGVhc2UgdmVyaWZ5IHRoYXQgdGhlIHBsdWdpbiB3YXMgaW1wb3J0ZWQgYW5kIHNwZWxsZWQgY29ycmVjdGx5LidcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKVxuICAgIH1cblxuICAgIC8vIEluc3RhbnRpYXRlXG4gICAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIGNvbnN0IHBsdWdpbklkID0gcGx1Z2luLmlkXG5cbiAgICBpZiAoIXBsdWdpbklkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgcGx1Z2luIG11c3QgaGF2ZSBhbiBpZCcpXG4gICAgfVxuXG4gICAgaWYgKCFwbHVnaW4udHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIHBsdWdpbiBtdXN0IGhhdmUgYSB0eXBlJylcbiAgICB9XG5cbiAgICBjb25zdCBleGlzdHNQbHVnaW5BbHJlYWR5ID0gdGhpcy5nZXRQbHVnaW4ocGx1Z2luSWQpXG4gICAgaWYgKGV4aXN0c1BsdWdpbkFscmVhZHkpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBBbHJlYWR5IGZvdW5kIGEgcGx1Z2luIG5hbWVkICcke2V4aXN0c1BsdWdpbkFscmVhZHkuaWR9Jy4gYFxuICAgICAgICArIGBUcmllZCB0byB1c2U6ICcke3BsdWdpbklkfScuXFxuYFxuICAgICAgICArICdVcHB5IHBsdWdpbnMgbXVzdCBoYXZlIHVuaXF1ZSBgaWRgIG9wdGlvbnMuIFNlZSBodHRwczovL3VwcHkuaW8vZG9jcy9wbHVnaW5zLyNpZC4nXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICAgIH1cblxuICAgIGlmIChQbHVnaW4uVkVSU0lPTikge1xuICAgICAgdGhpcy5sb2coYFVzaW5nICR7cGx1Z2luSWR9IHYke1BsdWdpbi5WRVJTSU9OfWApXG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbi50eXBlIGluIHRoaXMuI3BsdWdpbnMpIHtcbiAgICAgIHRoaXMuI3BsdWdpbnNbcGx1Z2luLnR5cGVdLnB1c2gocGx1Z2luKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNwbHVnaW5zW3BsdWdpbi50eXBlXSA9IFtwbHVnaW5dXG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRmluZCBvbmUgUGx1Z2luIGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBwbHVnaW4gaWRcbiAgICogQHJldHVybnMge0Jhc2VQbHVnaW58dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0UGx1Z2luIChpZCkge1xuICAgIGZvciAoY29uc3QgcGx1Z2lucyBvZiBPYmplY3QudmFsdWVzKHRoaXMuI3BsdWdpbnMpKSB7XG4gICAgICBjb25zdCBmb3VuZFBsdWdpbiA9IHBsdWdpbnMuZmluZChwbHVnaW4gPT4gcGx1Z2luLmlkID09PSBpZClcbiAgICAgIGlmIChmb3VuZFBsdWdpbiAhPSBudWxsKSByZXR1cm4gZm91bmRQbHVnaW5cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgW1N5bWJvbC5mb3IoJ3VwcHkgdGVzdDogZ2V0UGx1Z2lucycpXSAodHlwZSkge1xuICAgIHJldHVybiB0aGlzLiNwbHVnaW5zW3R5cGVdXG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBgdXNlYGQgcGx1Z2lucy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIHRoYXQgd2lsbCBiZSBydW4gb24gZWFjaCBwbHVnaW5cbiAgICovXG4gIGl0ZXJhdGVQbHVnaW5zIChtZXRob2QpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuI3BsdWdpbnMpLmZsYXQoMSkuZm9yRWFjaChtZXRob2QpXG4gIH1cblxuICAvKipcbiAgICogVW5pbnN0YWxsIGFuZCByZW1vdmUgYSBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0YW5jZSBUaGUgcGx1Z2luIGluc3RhbmNlIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZVBsdWdpbiAoaW5zdGFuY2UpIHtcbiAgICB0aGlzLmxvZyhgUmVtb3ZpbmcgcGx1Z2luICR7aW5zdGFuY2UuaWR9YClcbiAgICB0aGlzLmVtaXQoJ3BsdWdpbi1yZW1vdmUnLCBpbnN0YW5jZSlcblxuICAgIGlmIChpbnN0YW5jZS51bmluc3RhbGwpIHtcbiAgICAgIGluc3RhbmNlLnVuaW5zdGFsbCgpXG4gICAgfVxuXG4gICAgY29uc3QgbGlzdCA9IHRoaXMuI3BsdWdpbnNbaW5zdGFuY2UudHlwZV1cbiAgICAvLyBsaXN0LmluZGV4T2YgZmFpbGVkIGhlcmUsIGJlY2F1c2UgVnVlMyBjb252ZXJ0ZWQgdGhlIHBsdWdpbiBpbnN0YW5jZVxuICAgIC8vIHRvIGEgUHJveHkgb2JqZWN0LCB3aGljaCBmYWlsZWQgdGhlIHN0cmljdCBjb21wYXJpc29uIHRlc3Q6XG4gICAgLy8gb2JqICE9PSBvYmpQcm94eVxuICAgIGNvbnN0IGluZGV4ID0gbGlzdC5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmlkID09PSBpbnN0YW5jZS5pZClcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBsaXN0LnNwbGljZShpbmRleCwgMSlcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZSA9IHtcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgLi4uc3RhdGUucGx1Z2lucyxcbiAgICAgICAgW2luc3RhbmNlLmlkXTogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh1cGRhdGVkU3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogVW5pbnN0YWxsIGFsbCBwbHVnaW5zIGFuZCBjbG9zZSBkb3duIHRoaXMgVXBweSBpbnN0YW5jZS5cbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLmxvZyhgQ2xvc2luZyBVcHB5IGluc3RhbmNlICR7dGhpcy5vcHRzLmlkfTogcmVtb3ZpbmcgYWxsIGZpbGVzIGFuZCB1bmluc3RhbGxpbmcgcGx1Z2luc2ApXG5cbiAgICB0aGlzLnJlc2V0KClcblxuICAgIHRoaXMuI3N0b3JlVW5zdWJzY3JpYmUoKVxuXG4gICAgdGhpcy5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZVBsdWdpbihwbHVnaW4pXG4gICAgfSlcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuI3VwZGF0ZU9ubGluZVN0YXR1cylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgdGhpcy4jdXBkYXRlT25saW5lU3RhdHVzKVxuICAgIH1cbiAgfVxuXG4gIGhpZGVJbmZvICgpIHtcbiAgICBjb25zdCB7IGluZm8gfSA9IHRoaXMuZ2V0U3RhdGUoKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGluZm86IGluZm8uc2xpY2UoMSkgfSlcblxuICAgIHRoaXMuZW1pdCgnaW5mby1oaWRkZW4nKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbmZvIG1lc3NhZ2UgaW4gYHN0YXRlLmluZm9gLCBzbyB0aGF0IFVJIHBsdWdpbnMgbGlrZSBgSW5mb3JtZXJgXG4gICAqIGNhbiBkaXNwbGF5IHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG9iamVjdH0gbWVzc2FnZSBNZXNzYWdlIHRvIGJlIGRpc3BsYXllZCBieSB0aGUgaW5mb3JtZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXVxuICAgKi9cbiAgaW5mbyAobWVzc2FnZSwgdHlwZSA9ICdpbmZvJywgZHVyYXRpb24gPSAzMDAwKSB7XG4gICAgY29uc3QgaXNDb21wbGV4TWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0J1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpbmZvOiBbXG4gICAgICAgIC4uLnRoaXMuZ2V0U3RhdGUoKS5pbmZvLFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBtZXNzYWdlOiBpc0NvbXBsZXhNZXNzYWdlID8gbWVzc2FnZS5tZXNzYWdlIDogbWVzc2FnZSxcbiAgICAgICAgICBkZXRhaWxzOiBpc0NvbXBsZXhNZXNzYWdlID8gbWVzc2FnZS5kZXRhaWxzIDogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSlcblxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oaWRlSW5mbygpLCBkdXJhdGlvbilcblxuICAgIHRoaXMuZW1pdCgnaW5mby12aXNpYmxlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzZXMgbWVzc2FnZXMgdG8gYSBmdW5jdGlvbiwgcHJvdmlkZWQgaW4gYG9wdHMubG9nZ2VyYC5cbiAgICogSWYgYG9wdHMubG9nZ2VyOiBVcHB5LmRlYnVnTG9nZ2VyYCBvciBgb3B0cy5kZWJ1ZzogdHJ1ZWAsIGxvZ3MgdG8gdGhlIGJyb3dzZXIgY29uc29sZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBtZXNzYWdlIHRvIGxvZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG9wdGlvbmFsIGBlcnJvcmAgb3IgYHdhcm5pbmdgXG4gICAqL1xuICBsb2cgKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICBjb25zdCB7IGxvZ2dlciB9ID0gdGhpcy5vcHRzXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdlcnJvcic6IGxvZ2dlci5lcnJvcihtZXNzYWdlKTsgYnJlYWtcbiAgICAgIGNhc2UgJ3dhcm5pbmcnOiBsb2dnZXIud2FybihtZXNzYWdlKTsgYnJlYWtcbiAgICAgIGRlZmF1bHQ6IGxvZ2dlci5kZWJ1ZyhtZXNzYWdlKTsgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBhbiB1cGxvYWQgYnkgaXRzIElELlxuICAgKi9cbiAgcmVzdG9yZSAodXBsb2FkSUQpIHtcbiAgICB0aGlzLmxvZyhgQ29yZTogYXR0ZW1wdGluZyB0byByZXN0b3JlIHVwbG9hZCBcIiR7dXBsb2FkSUR9XCJgKVxuXG4gICAgaWYgKCF0aGlzLmdldFN0YXRlKCkuY3VycmVudFVwbG9hZHNbdXBsb2FkSURdKSB7XG4gICAgICB0aGlzLiNyZW1vdmVVcGxvYWQodXBsb2FkSUQpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdOb25leGlzdGVudCB1cGxvYWQnKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jcnVuVXBsb2FkKHVwbG9hZElEKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiB1cGxvYWQgZm9yIGEgYnVuY2ggb2YgZmlsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZmlsZUlEcyBGaWxlIElEcyB0byBpbmNsdWRlIGluIHRoaXMgdXBsb2FkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBJRCBvZiB0aGlzIHVwbG9hZC5cbiAgICovXG4gICNjcmVhdGVVcGxvYWQgKGZpbGVJRHMsIG9wdHMgPSB7fSkge1xuICAgIC8vIHVwcHkucmV0cnlBbGwgc2V0cyB0aGlzIHRvIHRydWUg4oCUIHdoZW4gcmV0cnlpbmcgd2Ugd2FudCB0byBpZ25vcmUgYGFsbG93TmV3VXBsb2FkOiBmYWxzZWBcbiAgICBjb25zdCB7IGZvcmNlQWxsb3dOZXdVcGxvYWQgPSBmYWxzZSB9ID0gb3B0c1xuXG4gICAgY29uc3QgeyBhbGxvd05ld1VwbG9hZCwgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGlmICghYWxsb3dOZXdVcGxvYWQgJiYgIWZvcmNlQWxsb3dOZXdVcGxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhIG5ldyB1cGxvYWQ6IGFscmVhZHkgdXBsb2FkaW5nLicpXG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkSUQgPSBuYW5vaWQoKVxuXG4gICAgdGhpcy5lbWl0KCd1cGxvYWQnLCB7XG4gICAgICBpZDogdXBsb2FkSUQsXG4gICAgICBmaWxlSURzLFxuICAgIH0pXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFsbG93TmV3VXBsb2FkOiB0aGlzLm9wdHMuYWxsb3dNdWx0aXBsZVVwbG9hZEJhdGNoZXMgIT09IGZhbHNlICYmIHRoaXMub3B0cy5hbGxvd011bHRpcGxlVXBsb2FkcyAhPT0gZmFsc2UsXG5cbiAgICAgIGN1cnJlbnRVcGxvYWRzOiB7XG4gICAgICAgIC4uLmN1cnJlbnRVcGxvYWRzLFxuICAgICAgICBbdXBsb2FkSURdOiB7XG4gICAgICAgICAgZmlsZUlEcyxcbiAgICAgICAgICBzdGVwOiAwLFxuICAgICAgICAgIHJlc3VsdDoge30sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICByZXR1cm4gdXBsb2FkSURcbiAgfVxuXG4gIFtTeW1ib2wuZm9yKCd1cHB5IHRlc3Q6IGNyZWF0ZVVwbG9hZCcpXSAoLi4uYXJncykgeyByZXR1cm4gdGhpcy4jY3JlYXRlVXBsb2FkKC4uLmFyZ3MpIH1cblxuICAjZ2V0VXBsb2FkICh1cGxvYWRJRCkge1xuICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuXG4gICAgcmV0dXJuIGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhIHRvIGFuIHVwbG9hZCdzIHJlc3VsdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cGxvYWRJRCBUaGUgSUQgb2YgdGhlIHVwbG9hZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBwcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgcmVzdWx0IG9iamVjdC5cbiAgICovXG4gIGFkZFJlc3VsdERhdGEgKHVwbG9hZElELCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLiNnZXRVcGxvYWQodXBsb2FkSUQpKSB7XG4gICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcmVzdWx0IGZvciBhbiB1cGxvYWQgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke3VwbG9hZElEfWApXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgY29uc3QgY3VycmVudFVwbG9hZCA9IHsgLi4uY3VycmVudFVwbG9hZHNbdXBsb2FkSURdLCByZXN1bHQ6IHsgLi4uY3VycmVudFVwbG9hZHNbdXBsb2FkSURdLnJlc3VsdCwgLi4uZGF0YSB9IH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRVcGxvYWRzOiB7IC4uLmN1cnJlbnRVcGxvYWRzLCBbdXBsb2FkSURdOiBjdXJyZW50VXBsb2FkIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gdXBsb2FkLCBlZy4gaWYgaXQgaGFzIGJlZW4gY2FuY2VsZWQgb3IgY29tcGxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXBsb2FkSUQgVGhlIElEIG9mIHRoZSB1cGxvYWQuXG4gICAqL1xuICAjcmVtb3ZlVXBsb2FkICh1cGxvYWRJRCkge1xuICAgIGNvbnN0IGN1cnJlbnRVcGxvYWRzID0geyAuLi50aGlzLmdldFN0YXRlKCkuY3VycmVudFVwbG9hZHMgfVxuICAgIGRlbGV0ZSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY3VycmVudFVwbG9hZHMsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gYW4gdXBsb2FkLiBUaGlzIHBpY2tzIHVwIHdoZXJlIGl0IGxlZnQgb2ZmIGluIGNhc2UgdGhlIHVwbG9hZCBpcyBiZWluZyByZXN0b3JlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jICNydW5VcGxvYWQgKHVwbG9hZElEKSB7XG4gICAgbGV0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGxldCBjdXJyZW50VXBsb2FkID0gY3VycmVudFVwbG9hZHNbdXBsb2FkSURdXG4gICAgY29uc3QgcmVzdG9yZVN0ZXAgPSBjdXJyZW50VXBsb2FkLnN0ZXAgfHwgMFxuXG4gICAgY29uc3Qgc3RlcHMgPSBbXG4gICAgICAuLi5BcnJheS5mcm9tKHRoaXMuI3ByZVByb2Nlc3NvcnMpLFxuICAgICAgLi4uQXJyYXkuZnJvbSh0aGlzLiN1cGxvYWRlcnMpLFxuICAgICAgLi4uQXJyYXkuZnJvbSh0aGlzLiNwb3N0UHJvY2Vzc29ycyksXG4gICAgXVxuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBzdGVwID0gcmVzdG9yZVN0ZXA7IHN0ZXAgPCBzdGVwcy5sZW5ndGg7IHN0ZXArKykge1xuICAgICAgICBpZiAoIWN1cnJlbnRVcGxvYWQpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZuID0gc3RlcHNbc3RlcF1cblxuICAgICAgICBjb25zdCB1cGRhdGVkVXBsb2FkID0ge1xuICAgICAgICAgIC4uLmN1cnJlbnRVcGxvYWQsXG4gICAgICAgICAgc3RlcCxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGN1cnJlbnRVcGxvYWRzOiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50VXBsb2FkcyxcbiAgICAgICAgICAgIFt1cGxvYWRJRF06IHVwZGF0ZWRVcGxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBUT0RPIGdpdmUgdGhpcyB0aGUgYHVwZGF0ZWRVcGxvYWRgIG9iamVjdCBhcyBpdHMgb25seSBwYXJhbWV0ZXIgbWF5YmU/XG4gICAgICAgIC8vIE90aGVyd2lzZSB3aGVuIG1vcmUgbWV0YWRhdGEgbWF5IGJlIGFkZGVkIHRvIHRoZSB1cGxvYWQgdGhpcyB3b3VsZCBrZWVwIGdldHRpbmcgbW9yZSBwYXJhbWV0ZXJzXG4gICAgICAgIGF3YWl0IGZuKHVwZGF0ZWRVcGxvYWQuZmlsZUlEcywgdXBsb2FkSUQpXG5cbiAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnRVcGxvYWQgdmFsdWUgaW4gY2FzZSBpdCB3YXMgbW9kaWZpZWQgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgIGN1cnJlbnRVcGxvYWRzID0gdGhpcy5nZXRTdGF0ZSgpLmN1cnJlbnRVcGxvYWRzXG4gICAgICAgIGN1cnJlbnRVcGxvYWQgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB0aGlzLiNyZW1vdmVVcGxvYWQodXBsb2FkSUQpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICAvLyBTZXQgcmVzdWx0IGRhdGEuXG4gICAgaWYgKGN1cnJlbnRVcGxvYWQpIHtcbiAgICAgIC8vIE1hcmsgcG9zdHByb2Nlc3Npbmcgc3RlcCBhcyBjb21wbGV0ZSBpZiBuZWNlc3Nhcnk7IHRoaXMgYWRkcmVzc2VzIGEgY2FzZSB3aGVyZSB3ZSBtaWdodCBnZXRcbiAgICAgIC8vIHN0dWNrIGluIHRoZSBwb3N0cHJvY2Vzc2luZyBVSSB3aGlsZSB0aGUgdXBsb2FkIGlzIGZ1bGx5IGNvbXBsZXRlLlxuICAgICAgLy8gSWYgdGhlIHBvc3Rwcm9jZXNzaW5nIHN0ZXBzIGRvIG5vdCBkbyBhbnkgd29yaywgdGhleSBtYXkgbm90IGVtaXQgcG9zdHByb2Nlc3NpbmcgZXZlbnRzIGF0XG4gICAgICAvLyBhbGwsIGFuZCBuZXZlciBtYXJrIHRoZSBwb3N0cHJvY2Vzc2luZyBhcyBjb21wbGV0ZS4gVGhpcyBpcyBmaW5lIG9uIGl0cyBvd24gYnV0IHdlXG4gICAgICAvLyBpbnRyb2R1Y2VkIGNvZGUgaW4gdGhlIEB1cHB5L2NvcmUgdXBsb2FkLXN1Y2Nlc3MgaGFuZGxlciB0byBwcmVwYXJlIHBvc3Rwcm9jZXNzaW5nIHByb2dyZXNzXG4gICAgICAvLyBzdGF0ZSBpZiBhbnkgcG9zdHByb2Nlc3NvcnMgYXJlIHJlZ2lzdGVyZWQuIFRoYXQgaXMgdG8gYXZvaWQgYSBcImZsYXNoIG9mIGNvbXBsZXRlZCBzdGF0ZVwiXG4gICAgICAvLyBiZWZvcmUgdGhlIHBvc3Rwcm9jZXNzaW5nIHBsdWdpbnMgY2FuIGVtaXQgZXZlbnRzLlxuICAgICAgLy9cbiAgICAgIC8vIFNvLCBqdXN0IGluIGNhc2UgYW4gdXBsb2FkIHdpdGggcG9zdHByb2Nlc3NpbmcgcGx1Z2lucyAqaGFzKiBjb21wbGV0ZWQgKndpdGhvdXQqIGVtaXR0aW5nXG4gICAgICAvLyBwb3N0cHJvY2Vzc2luZyBjb21wbGV0aW9uLCB3ZSBkbyBpdCBpbnN0ZWFkLlxuICAgICAgY3VycmVudFVwbG9hZC5maWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlKGZpbGVJRClcbiAgICAgICAgaWYgKGZpbGUgJiYgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzcykge1xuICAgICAgICAgIHRoaXMuZW1pdCgncG9zdHByb2Nlc3MtY29tcGxldGUnLCBmaWxlKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBjb25zdCBmaWxlcyA9IGN1cnJlbnRVcGxvYWQuZmlsZUlEcy5tYXAoKGZpbGVJRCkgPT4gdGhpcy5nZXRGaWxlKGZpbGVJRCkpXG4gICAgICBjb25zdCBzdWNjZXNzZnVsID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiAhZmlsZS5lcnJvcilcbiAgICAgIGNvbnN0IGZhaWxlZCA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5lcnJvcilcbiAgICAgIGF3YWl0IHRoaXMuYWRkUmVzdWx0RGF0YSh1cGxvYWRJRCwgeyBzdWNjZXNzZnVsLCBmYWlsZWQsIHVwbG9hZElEIH0pXG5cbiAgICAgIC8vIFVwZGF0ZSBjdXJyZW50VXBsb2FkIHZhbHVlIGluIGNhc2UgaXQgd2FzIG1vZGlmaWVkIGFzeW5jaHJvbm91c2x5LlxuICAgICAgY3VycmVudFVwbG9hZHMgPSB0aGlzLmdldFN0YXRlKCkuY3VycmVudFVwbG9hZHNcbiAgICAgIGN1cnJlbnRVcGxvYWQgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICB9XG4gICAgLy8gRW1pdCBjb21wbGV0aW9uIGV2ZW50cy5cbiAgICAvLyBUaGlzIGlzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gdGhhdCB0aGUgYGN1cnJlbnRVcGxvYWRzYCB2YXJpYWJsZVxuICAgIC8vIGFsd2F5cyByZWZlcnMgdG8gdGhlIGxhdGVzdCBzdGF0ZS4gSW4gdGhlIGhhbmRsZXIgcmlnaHQgYWJvdmUgaXQgcmVmZXJzXG4gICAgLy8gdG8gYW4gb3V0ZGF0ZWQgb2JqZWN0IHdpdGhvdXQgdGhlIGAucmVzdWx0YCBwcm9wZXJ0eS5cbiAgICBsZXQgcmVzdWx0XG4gICAgaWYgKGN1cnJlbnRVcGxvYWQpIHtcbiAgICAgIHJlc3VsdCA9IGN1cnJlbnRVcGxvYWQucmVzdWx0XG4gICAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgcmVzdWx0KVxuXG4gICAgICB0aGlzLiNyZW1vdmVVcGxvYWQodXBsb2FkSUQpXG4gICAgfVxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHJlc3VsdCBmb3IgYW4gdXBsb2FkIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHt1cGxvYWRJRH1gKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYW4gdXBsb2FkIGZvciBhbGwgdGhlIGZpbGVzIHRoYXQgYXJlIG5vdCBjdXJyZW50bHkgYmVpbmcgdXBsb2FkZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgdXBsb2FkICgpIHtcbiAgICBpZiAoIXRoaXMuI3BsdWdpbnMudXBsb2FkZXI/Lmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2coJ05vIHVwbG9hZGVyIHR5cGUgcGx1Z2lucyBhcmUgdXNlZCcsICd3YXJuaW5nJylcbiAgICB9XG5cbiAgICBsZXQgeyBmaWxlcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG5cbiAgICBjb25zdCBvbkJlZm9yZVVwbG9hZFJlc3VsdCA9IHRoaXMub3B0cy5vbkJlZm9yZVVwbG9hZChmaWxlcylcblxuICAgIGlmIChvbkJlZm9yZVVwbG9hZFJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vdCBzdGFydGluZyB0aGUgdXBsb2FkIGJlY2F1c2Ugb25CZWZvcmVVcGxvYWQgcmV0dXJuZWQgZmFsc2UnKSlcbiAgICB9XG5cbiAgICBpZiAob25CZWZvcmVVcGxvYWRSZXN1bHQgJiYgdHlwZW9mIG9uQmVmb3JlVXBsb2FkUmVzdWx0ID09PSAnb2JqZWN0Jykge1xuICAgICAgZmlsZXMgPSBvbkJlZm9yZVVwbG9hZFJlc3VsdFxuICAgICAgLy8gVXBkYXRpbmcgZmlsZXMgaW4gc3RhdGUsIGJlY2F1c2UgdXBsb2FkZXIgcGx1Z2lucyByZWNlaXZlIGZpbGUgSURzLFxuICAgICAgLy8gYW5kIHRoZW4gZmV0Y2ggdGhlIGFjdHVhbCBmaWxlIG9iamVjdCBmcm9tIHN0YXRlXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZmlsZXMsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLiNjaGVja01pbk51bWJlck9mRmlsZXMoZmlsZXMpXG4gICAgICAgIHRoaXMuI2NoZWNrUmVxdWlyZWRNZXRhRmllbGRzKGZpbGVzKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuI3Nob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyKVxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBhcmUgY3VycmVudGx5IGFzc2lnbmVkIHRvIHVwbG9hZHNcbiAgICAgICAgY29uc3QgY3VycmVudGx5VXBsb2FkaW5nRmlsZXMgPSBPYmplY3QudmFsdWVzKGN1cnJlbnRVcGxvYWRzKS5mbGF0TWFwKGN1cnIgPT4gY3Vyci5maWxlSURzKVxuXG4gICAgICAgIGNvbnN0IHdhaXRpbmdGaWxlSURzID0gW11cbiAgICAgICAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGUoZmlsZUlEKVxuICAgICAgICAgIC8vIGlmIHRoZSBmaWxlIGhhc24ndCBzdGFydGVkIHVwbG9hZGluZyBhbmQgaGFzbid0IGFscmVhZHkgYmVlbiBhc3NpZ25lZCB0byBhbiB1cGxvYWQuLlxuICAgICAgICAgIGlmICgoIWZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCkgJiYgKGN1cnJlbnRseVVwbG9hZGluZ0ZpbGVzLmluZGV4T2YoZmlsZUlEKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICB3YWl0aW5nRmlsZUlEcy5wdXNoKGZpbGUuaWQpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZElEID0gdGhpcy4jY3JlYXRlVXBsb2FkKHdhaXRpbmdGaWxlSURzKVxuICAgICAgICByZXR1cm4gdGhpcy4jcnVuVXBsb2FkKHVwbG9hZElEKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuI3Nob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyLCB7XG4gICAgICAgICAgc2hvd0luZm9ybWVyOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVcHB5XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVOYW1lIChmaWxlVHlwZSwgZmlsZURlc2NyaXB0b3IpIHtcbiAgaWYgKGZpbGVEZXNjcmlwdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gZmlsZURlc2NyaXB0b3IubmFtZVxuICB9XG5cbiAgaWYgKGZpbGVUeXBlLnNwbGl0KCcvJylbMF0gPT09ICdpbWFnZScpIHtcbiAgICByZXR1cm4gYCR7ZmlsZVR5cGUuc3BsaXQoJy8nKVswXX0uJHtmaWxlVHlwZS5zcGxpdCgnLycpWzFdfWBcbiAgfVxuXG4gIHJldHVybiAnbm9uYW1lJ1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFVwcHkgPSByZXF1aXJlKCcuL1VwcHknKVxuY29uc3QgVUlQbHVnaW4gPSByZXF1aXJlKCcuL1VJUGx1Z2luJylcbmNvbnN0IEJhc2VQbHVnaW4gPSByZXF1aXJlKCcuL0Jhc2VQbHVnaW4nKVxuY29uc3QgeyBkZWJ1Z0xvZ2dlciB9ID0gcmVxdWlyZSgnLi9sb2dnZXJzJylcblxubW9kdWxlLmV4cG9ydHMgPSBVcHB5XG5tb2R1bGUuZXhwb3J0cy5VcHB5ID0gVXBweVxubW9kdWxlLmV4cG9ydHMuVUlQbHVnaW4gPSBVSVBsdWdpblxubW9kdWxlLmV4cG9ydHMuQmFzZVBsdWdpbiA9IEJhc2VQbHVnaW5cbm1vZHVsZS5leHBvcnRzLmRlYnVnTG9nZ2VyID0gZGVidWdMb2dnZXJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdzOiB7XG4gICAgYWRkQnVsa0ZpbGVzRmFpbGVkOiB7XG4gICAgICAwOiAnRmFpbGVkIHRvIGFkZCAle3NtYXJ0X2NvdW50fSBmaWxlIGR1ZSB0byBhbiBpbnRlcm5hbCBlcnJvcicsXG4gICAgICAxOiAnRmFpbGVkIHRvIGFkZCAle3NtYXJ0X2NvdW50fSBmaWxlcyBkdWUgdG8gaW50ZXJuYWwgZXJyb3JzJyxcbiAgICB9LFxuICAgIHlvdUNhbk9ubHlVcGxvYWRYOiB7XG4gICAgICAwOiAnWW91IGNhbiBvbmx5IHVwbG9hZCAle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgIDE6ICdZb3UgY2FuIG9ubHkgdXBsb2FkICV7c21hcnRfY291bnR9IGZpbGVzJyxcbiAgICB9LFxuICAgIHlvdUhhdmVUb0F0TGVhc3RTZWxlY3RYOiB7XG4gICAgICAwOiAnWW91IGhhdmUgdG8gc2VsZWN0IGF0IGxlYXN0ICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgMTogJ1lvdSBoYXZlIHRvIHNlbGVjdCBhdCBsZWFzdCAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgfSxcbiAgICBleGNlZWRzU2l6ZTogJyV7ZmlsZX0gZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiAle3NpemV9JyxcbiAgICBtaXNzaW5nUmVxdWlyZWRNZXRhRmllbGQ6ICdNaXNzaW5nIHJlcXVpcmVkIG1ldGEgZmllbGRzJyxcbiAgICBtaXNzaW5nUmVxdWlyZWRNZXRhRmllbGRPbkZpbGU6XG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBtZXRhIGZpZWxkcyBpbiAle2ZpbGVOYW1lfScsXG4gICAgaW5mZXJpb3JTaXplOiAnVGhpcyBmaWxlIGlzIHNtYWxsZXIgdGhhbiB0aGUgYWxsb3dlZCBzaXplIG9mICV7c2l6ZX0nLFxuICAgIHlvdUNhbk9ubHlVcGxvYWRGaWxlVHlwZXM6ICdZb3UgY2FuIG9ubHkgdXBsb2FkOiAle3R5cGVzfScsXG4gICAgbm9Nb3JlRmlsZXNBbGxvd2VkOiAnQ2Fubm90IGFkZCBtb3JlIGZpbGVzJyxcbiAgICBub0R1cGxpY2F0ZXM6XG4gICAgICBcIkNhbm5vdCBhZGQgdGhlIGR1cGxpY2F0ZSBmaWxlICcle2ZpbGVOYW1lfScsIGl0IGFscmVhZHkgZXhpc3RzXCIsXG4gICAgY29tcGFuaW9uRXJyb3I6ICdDb25uZWN0aW9uIHdpdGggQ29tcGFuaW9uIGZhaWxlZCcsXG4gICAgYXV0aEFib3J0ZWQ6ICdBdXRoZW50aWNhdGlvbiBhYm9ydGVkJyxcbiAgICBjb21wYW5pb25VbmF1dGhvcml6ZUhpbnQ6XG4gICAgICAnVG8gdW5hdXRob3JpemUgdG8geW91ciAle3Byb3ZpZGVyfSBhY2NvdW50LCBwbGVhc2UgZ28gdG8gJXt1cmx9JyxcbiAgICBmYWlsZWRUb1VwbG9hZDogJ0ZhaWxlZCB0byB1cGxvYWQgJXtmaWxlfScsXG4gICAgbm9JbnRlcm5ldENvbm5lY3Rpb246ICdObyBJbnRlcm5ldCBjb25uZWN0aW9uJyxcbiAgICBjb25uZWN0ZWRUb0ludGVybmV0OiAnQ29ubmVjdGVkIHRvIHRoZSBJbnRlcm5ldCcsXG4gICAgLy8gU3RyaW5ncyBmb3IgcmVtb3RlIHByb3ZpZGVyc1xuICAgIG5vRmlsZXNGb3VuZDogJ1lvdSBoYXZlIG5vIGZpbGVzIG9yIGZvbGRlcnMgaGVyZScsXG4gICAgc2VsZWN0WDoge1xuICAgICAgMDogJ1NlbGVjdCAle3NtYXJ0X2NvdW50fScsXG4gICAgICAxOiAnU2VsZWN0ICV7c21hcnRfY291bnR9JyxcbiAgICB9LFxuICAgIGFsbEZpbGVzRnJvbUZvbGRlck5hbWVkOiAnQWxsIGZpbGVzIGZyb20gZm9sZGVyICV7bmFtZX0nLFxuICAgIG9wZW5Gb2xkZXJOYW1lZDogJ09wZW4gZm9sZGVyICV7bmFtZX0nLFxuICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgbG9nT3V0OiAnTG9nIG91dCcsXG4gICAgZmlsdGVyOiAnRmlsdGVyJyxcbiAgICByZXNldEZpbHRlcjogJ1Jlc2V0IGZpbHRlcicsXG4gICAgbG9hZGluZzogJ0xvYWRpbmcuLi4nLFxuICAgIGF1dGhlbnRpY2F0ZVdpdGhUaXRsZTpcbiAgICAgICdQbGVhc2UgYXV0aGVudGljYXRlIHdpdGggJXtwbHVnaW5OYW1lfSB0byBzZWxlY3QgZmlsZXMnLFxuICAgIGF1dGhlbnRpY2F0ZVdpdGg6ICdDb25uZWN0IHRvICV7cGx1Z2luTmFtZX0nLFxuICAgIHNpZ25JbldpdGhHb29nbGU6ICdTaWduIGluIHdpdGggR29vZ2xlJyxcbiAgICBzZWFyY2hJbWFnZXM6ICdTZWFyY2ggZm9yIGltYWdlcycsXG4gICAgZW50ZXJUZXh0VG9TZWFyY2g6ICdFbnRlciB0ZXh0IHRvIHNlYXJjaCBmb3IgaW1hZ2VzJyxcbiAgICBiYWNrVG9TZWFyY2g6ICdCYWNrIHRvIFNlYXJjaCcsXG4gICAgZW1wdHlGb2xkZXJBZGRlZDogJ05vIGZpbGVzIHdlcmUgYWRkZWQgZnJvbSBlbXB0eSBmb2xkZXInLFxuICAgIGZvbGRlckFscmVhZHlBZGRlZDogJ1RoZSBmb2xkZXIgXCIle2ZvbGRlcn1cIiB3YXMgYWxyZWFkeSBhZGRlZCcsXG4gICAgZm9sZGVyQWRkZWQ6IHtcbiAgICAgIDA6ICdBZGRlZCAle3NtYXJ0X2NvdW50fSBmaWxlIGZyb20gJXtmb2xkZXJ9JyxcbiAgICAgIDE6ICdBZGRlZCAle3NtYXJ0X2NvdW50fSBmaWxlcyBmcm9tICV7Zm9sZGVyfScsXG4gICAgfSxcbiAgfSxcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmNvbnN0IGdldFRpbWVTdGFtcCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRUaW1lU3RhbXAnKVxuXG4vLyBTd2FsbG93IGFsbCBsb2dzLCBleGNlcHQgZXJyb3JzLlxuLy8gZGVmYXVsdCBpZiBsb2dnZXIgaXMgbm90IHNldCBvciBkZWJ1ZzogZmFsc2VcbmNvbnN0IGp1c3RFcnJvcnNMb2dnZXIgPSB7XG4gIGRlYnVnOiAoKSA9PiB7fSxcbiAgd2FybjogKCkgPT4ge30sXG4gIGVycm9yOiAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvcihgW1VwcHldIFske2dldFRpbWVTdGFtcCgpfV1gLCAuLi5hcmdzKSxcbn1cblxuLy8gUHJpbnQgbG9ncyB0byBjb25zb2xlIHdpdGggbmFtZXNwYWNlICsgdGltZXN0YW1wLFxuLy8gc2V0IGJ5IGxvZ2dlcjogVXBweS5kZWJ1Z0xvZ2dlciBvciBkZWJ1ZzogdHJ1ZVxuY29uc3QgZGVidWdMb2dnZXIgPSB7XG4gIGRlYnVnOiAoLi4uYXJncykgPT4gY29uc29sZS5kZWJ1ZyhgW1VwcHldIFske2dldFRpbWVTdGFtcCgpfV1gLCAuLi5hcmdzKSxcbiAgd2FybjogKC4uLmFyZ3MpID0+IGNvbnNvbGUud2FybihgW1VwcHldIFske2dldFRpbWVTdGFtcCgpfV1gLCAuLi5hcmdzKSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGBbVXBweV0gWyR7Z2V0VGltZVN0YW1wKCl9XWAsIC4uLmFyZ3MpLFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAganVzdEVycm9yc0xvZ2dlcixcbiAgZGVidWdMb2dnZXIsXG59XG4iLCIvLyBFZGdlIDE1LnggZG9lcyBub3QgZmlyZSAncHJvZ3Jlc3MnIGV2ZW50cyBvbiB1cGxvYWRzLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlcy85NDVcbi8vIEFuZCBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjIyNDUxMC9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyAodXNlckFnZW50KSB7XG4gIC8vIEFsbG93IHBhc3NpbmcgaW4gdXNlckFnZW50IGZvciB0ZXN0c1xuICBpZiAodXNlckFnZW50ID09IG51bGwpIHtcbiAgICB1c2VyQWdlbnQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiBudWxsXG4gIH1cbiAgLy8gQXNzdW1lIGl0IHdvcmtzIGJlY2F1c2UgYmFzaWNhbGx5IGV2ZXJ5dGhpbmcgc3VwcG9ydHMgcHJvZ3Jlc3MgZXZlbnRzLlxuICBpZiAoIXVzZXJBZ2VudCkgcmV0dXJuIHRydWVcblxuICBjb25zdCBtID0gL0VkZ2VcXC8oXFxkK1xcLlxcZCspLy5leGVjKHVzZXJBZ2VudClcbiAgaWYgKCFtKSByZXR1cm4gdHJ1ZVxuXG4gIGNvbnN0IGVkZ2VWZXJzaW9uID0gbVsxXVxuICBsZXQgW21ham9yLCBtaW5vcl0gPSBlZGdlVmVyc2lvbi5zcGxpdCgnLicpXG4gIG1ham9yID0gcGFyc2VJbnQobWFqb3IsIDEwKVxuICBtaW5vciA9IHBhcnNlSW50KG1pbm9yLCAxMClcblxuICAvLyBXb3JrZWQgYmVmb3JlOlxuICAvLyBFZGdlIDQwLjE1MDYzLjAuMFxuICAvLyBNaWNyb3NvZnQgRWRnZUhUTUwgMTUuMTUwNjNcbiAgaWYgKG1ham9yIDwgMTUgfHwgKG1ham9yID09PSAxNSAmJiBtaW5vciA8IDE1MDYzKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBGaXhlZCBpbjpcbiAgLy8gTWljcm9zb2Z0IEVkZ2VIVE1MIDE4LjE4MjE4XG4gIGlmIChtYWpvciA+IDE4IHx8IChtYWpvciA9PT0gMTggJiYgbWlub3IgPj0gMTgyMTgpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIG90aGVyIHZlcnNpb25zIGRvbid0IHdvcmsuXG4gIHJldHVybiBmYWxzZVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNsYXNzIEFkZEZpbGVzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgdHJpZ2dlckZpbGVJbnB1dENsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMuZmlsZUlucHV0LmNsaWNrKClcbiAgfVxuXG4gIHRyaWdnZXJGb2xkZXJJbnB1dENsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMuZm9sZGVySW5wdXQuY2xpY2soKVxuICB9XG5cbiAgb25GaWxlSW5wdXRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICB0aGlzLnByb3BzLmhhbmRsZUlucHV0Q2hhbmdlKGV2ZW50KVxuXG4gICAgLy8gV2UgY2xlYXIgdGhlIGlucHV0IGFmdGVyIGEgZmlsZSBpcyBzZWxlY3RlZCwgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyBjaGFuZ2UgZXZlbnQgaXMgbm90IGZpcmVkIGluIENocm9tZSBhbmQgU2FmYXJpIHdoZW4gYSBmaWxlXG4gICAgLy8gd2l0aCB0aGUgc2FtZSBuYW1lIGlzIHNlbGVjdGVkLlxuICAgIC8vIF9fX1doeSBub3QgdXNlIHZhbHVlPVwiXCIgb24gPGlucHV0Lz4gaW5zdGVhZD9cbiAgICAvLyAgICBCZWNhdXNlIGlmIHdlIHVzZSB0aGF0IG1ldGhvZCBvZiBjbGVhcmluZyB0aGUgaW5wdXQsXG4gICAgLy8gICAgQ2hyb21lIHdpbGwgbm90IHRyaWdnZXIgY2hhbmdlIGlmIHdlIGRyb3AgdGhlIHNhbWUgZmlsZSB0d2ljZSAoSXNzdWUgIzc2OCkuXG4gICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gbnVsbFxuICB9XG5cbiAgcmVuZGVySGlkZGVuSW5wdXQgPSAoaXNGb2xkZXIsIHJlZkNhbGxiYWNrKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1pbnB1dFwiXG4gICAgICAgIGhpZGRlblxuICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICB0YWJJbmRleD17LTF9XG4gICAgICAgIHdlYmtpdGRpcmVjdG9yeT17aXNGb2xkZXJ9XG4gICAgICAgIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgbmFtZT1cImZpbGVzW11cIlxuICAgICAgICBtdWx0aXBsZT17dGhpcy5wcm9wcy5tYXhOdW1iZXJPZkZpbGVzICE9PSAxfVxuICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkZpbGVJbnB1dENoYW5nZX1cbiAgICAgICAgYWNjZXB0PXt0aGlzLnByb3BzLmFsbG93ZWRGaWxlVHlwZXN9XG4gICAgICAgIHJlZj17cmVmQ2FsbGJhY2t9XG4gICAgICAvPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlck15RGV2aWNlQWNxdWlyZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRUYWJcIlxuICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgZGF0YS11cHB5LWFjcXVpcmVyLWlkPVwiTXlEZXZpY2VcIlxuICAgICAgPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1EYXNoYm9hcmRUYWItYnRuXCJcbiAgICAgICAgICByb2xlPVwidGFiXCJcbiAgICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgICAgb25DbGljaz17dGhpcy50cmlnZ2VyRmlsZUlucHV0Q2xpY2t9XG4gICAgICAgID5cbiAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiBmaWxsPVwiIzIyNzVEN1wiIC8+XG4gICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjEuOTczIDIxLjE1Mkg5Ljg2M2wtMS4xMDgtNS4wODdoMTQuNDY0bC0xLjI0NiA1LjA4N3pNOS45MzUgMTEuMzdoMy45NThsLjg4NiAxLjQ0NGEuNjczLjY3MyAwIDAgMCAuNTg1LjMxNmg2LjUwNnYxLjM3SDkuOTM1di0zLjEzem0xNC44OTggMy40NGEuNzkzLjc5MyAwIDAgMC0uNjE2LS4zMWgtLjk3OHYtMi4xMjZjMC0uMzc5LS4yNzUtLjYxMy0uNjUzLS42MTNIMTUuNzVsLS44ODYtMS40NDVhLjY3My42NzMgMCAwIDAtLjU4NS0uMzE2SDkuMjMyYy0uMzc4IDAtLjY2Ny4yMDktLjY2Ny41ODdWMTQuNWgtLjc4MmEuNzkzLjc5MyAwIDAgMC0uNjEuMzAzLjc5NS43OTUgMCAwIDAtLjE1NS42NjNsMS40NSA2LjYzM2MuMDc4LjM2LjM5Ni42MTguNzY0LjYxOGgxMy4zNTRjLjM2IDAgLjY3NC0uMjQ2Ljc2LS41OTVsMS42MzEtNi42MzZhLjc5NS43OTUgMCAwIDAtLjE0NC0uNjc1elwiIGZpbGw9XCIjRkZGXCIgLz5cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkVGFiLW5hbWVcIj57dGhpcy5wcm9wcy5pMThuKCdteURldmljZScpfTwvZGl2PlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIHJlbmRlckJyb3dzZUJ1dHRvbiA9ICh0ZXh0LCBvbkNsaWNrRm4pID0+IHtcbiAgICBjb25zdCBudW1iZXJPZkFjcXVpcmVycyA9IHRoaXMucHJvcHMuYWNxdWlyZXJzLmxlbmd0aFxuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtYnJvd3NlXCJcbiAgICAgICAgb25DbGljaz17b25DbGlja0ZufVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlPXtudW1iZXJPZkFjcXVpcmVycyA9PT0gMH1cbiAgICAgID5cbiAgICAgICAge3RleHR9XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZW5kZXJEcm9wUGFzdGVCcm93c2VUYWdsaW5lID0gKCkgPT4ge1xuICAgIGNvbnN0IG51bWJlck9mQWNxdWlyZXJzID0gdGhpcy5wcm9wcy5hY3F1aXJlcnMubGVuZ3RoXG4gICAgY29uc3QgYnJvd3NlRmlsZXMgPSB0aGlzLnJlbmRlckJyb3dzZUJ1dHRvbih0aGlzLnByb3BzLmkxOG4oJ2Jyb3dzZUZpbGVzJyksIHRoaXMudHJpZ2dlckZpbGVJbnB1dENsaWNrKVxuICAgIGNvbnN0IGJyb3dzZUZvbGRlcnMgPSB0aGlzLnJlbmRlckJyb3dzZUJ1dHRvbih0aGlzLnByb3BzLmkxOG4oJ2Jyb3dzZUZvbGRlcnMnKSwgdGhpcy50cmlnZ2VyRm9sZGVySW5wdXRDbGljaylcblxuICAgIC8vIGluIG9yZGVyIHRvIGtlZXAgdGhlIGkxOG4gQ2FtZWxDYXNlIGFuZCBvcHRpb25zIGxvd2VyIChhcyBhcmUgZGVmYXVsdHMpIHdlIHdpbGwgd2FudCB0byB0cmFuc2Zvcm0gYSBsb3dlclxuICAgIC8vIHRvIENhbWVsXG4gICAgY29uc3QgbG93ZXJGTVNlbGVjdGlvblR5cGUgPSB0aGlzLnByb3BzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZVxuICAgIGNvbnN0IGNhbWVsRk1TZWxlY3Rpb25UeXBlID0gbG93ZXJGTVNlbGVjdGlvblR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsb3dlckZNU2VsZWN0aW9uVHlwZS5zbGljZSgxKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZC1BZGRGaWxlcy10aXRsZVwiPlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgdGhpcy5wcm9wcy5kaXNhYmxlTG9jYWxGaWxlcyA/IHRoaXMucHJvcHMuaTE4bignaW1wb3J0RmlsZXMnKVxuICAgICAgICAgICAgOiBudW1iZXJPZkFjcXVpcmVycyA+IDBcbiAgICAgICAgICAgICAgPyB0aGlzLnByb3BzLmkxOG5BcnJheShgZHJvcFBhc3RlSW1wb3J0JHtjYW1lbEZNU2VsZWN0aW9uVHlwZX1gLCB7IGJyb3dzZUZpbGVzLCBicm93c2VGb2xkZXJzLCBicm93c2U6IGJyb3dzZUZpbGVzIH0pXG4gICAgICAgICAgICAgIDogdGhpcy5wcm9wcy5pMThuQXJyYXkoYGRyb3BQYXN0ZSR7Y2FtZWxGTVNlbGVjdGlvblR5cGV9YCwgeyBicm93c2VGaWxlcywgYnJvd3NlRm9sZGVycywgYnJvd3NlOiBicm93c2VGaWxlcyB9KVxuICAgICAgICB9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBbU3ltYm9sLmZvcigndXBweSB0ZXN0OiBkaXNhYmxlIHVudXNlZCBsb2NhbGUga2V5IHdhcm5pbmcnKV0gKCkge1xuICAgIC8vIFRob3NlIGFyZSBhY3R1YWxseSB1c2VkIGluIGByZW5kZXJEcm9wUGFzdGVCcm93c2VUYWdsaW5lYCBtZXRob2QuXG4gICAgdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZUJvdGgnKVxuICAgIHRoaXMucHJvcHMuaTE4bkFycmF5KCdkcm9wUGFzdGVGaWxlcycpXG4gICAgdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZUZvbGRlcnMnKVxuICAgIHRoaXMucHJvcHMuaTE4bkFycmF5KCdkcm9wUGFzdGVJbXBvcnRCb3RoJylcbiAgICB0aGlzLnByb3BzLmkxOG5BcnJheSgnZHJvcFBhc3RlSW1wb3J0RmlsZXMnKVxuICAgIHRoaXMucHJvcHMuaTE4bkFycmF5KCdkcm9wUGFzdGVJbXBvcnRGb2xkZXJzJylcbiAgfVxuXG4gIHJlbmRlckFjcXVpcmVyID0gKGFjcXVpcmVyKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRUYWJcIlxuICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgZGF0YS11cHB5LWFjcXVpcmVyLWlkPXthY3F1aXJlci5pZH1cbiAgICAgID5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktRGFzaGJvYXJkVGFiLWJ0blwiXG4gICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgICAgYXJpYS1jb250cm9scz17YHVwcHktRGFzaGJvYXJkQ29udGVudC1wYW5lbC0tJHthY3F1aXJlci5pZH1gfVxuICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9e3RoaXMucHJvcHMuYWN0aXZlUGlja2VyUGFuZWwuaWQgPT09IGFjcXVpcmVyLmlkfVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB0aGlzLnByb3BzLnNob3dQYW5lbChhY3F1aXJlci5pZCl9XG4gICAgICAgID5cbiAgICAgICAgICB7YWNxdWlyZXIuaWNvbigpfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRUYWItbmFtZVwiPnthY3F1aXJlci5uYW1lfTwvZGl2PlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIHJlbmRlckFjcXVpcmVycyA9IChhY3F1aXJlcnMsIGRpc2FibGVMb2NhbEZpbGVzKSA9PiB7XG4gICAgLy8gR3JvdXAgbGFzdCB0d28gYnV0dG9ucywgc28gd2UgZG9u4oCZdCBlbmQgdXAgd2l0aFxuICAgIC8vIGp1c3Qgb25lIGJ1dHRvbiBvbiBhIG5ldyBsaW5lXG4gICAgY29uc3QgYWNxdWlyZXJzV2l0aG91dExhc3RUd28gPSBbLi4uYWNxdWlyZXJzXVxuICAgIGNvbnN0IGxhc3RUd29BY3F1aXJlcnMgPSBhY3F1aXJlcnNXaXRob3V0TGFzdFR3by5zcGxpY2UoYWNxdWlyZXJzLmxlbmd0aCAtIDIsIGFjcXVpcmVycy5sZW5ndGgpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1BZGRGaWxlcy1saXN0XCIgcm9sZT1cInRhYmxpc3RcIj5cbiAgICAgICAgeyFkaXNhYmxlTG9jYWxGaWxlcyAmJiB0aGlzLnJlbmRlck15RGV2aWNlQWNxdWlyZXIoKX1cbiAgICAgICAge2FjcXVpcmVyc1dpdGhvdXRMYXN0VHdvLm1hcCgoYWNxdWlyZXIpID0+IHRoaXMucmVuZGVyQWNxdWlyZXIoYWNxdWlyZXIpKX1cbiAgICAgICAgPHNwYW4gcm9sZT1cInByZXNlbnRhdGlvblwiIHN0eWxlPXt7ICd3aGl0ZS1zcGFjZSc6ICdub3dyYXAnIH19PlxuICAgICAgICAgIHtsYXN0VHdvQWNxdWlyZXJzLm1hcCgoYWNxdWlyZXIpID0+IHRoaXMucmVuZGVyQWNxdWlyZXIoYWNxdWlyZXIpKX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyUG93ZXJlZEJ5VXBweSAoKSB7XG4gICAgY29uc3QgeyBpMThuQXJyYXkgfSA9IHRoaXMucHJvcHNcblxuICAgIGNvbnN0IHVwcHlCcmFuZGluZyA9IChcbiAgICAgIDxzcGFuPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb24gdXBweS1EYXNoYm9hcmQtcG93ZXJlZEJ5SWNvblwiIHdpZHRoPVwiMTFcIiBoZWlnaHQ9XCIxMVwiIHZpZXdCb3g9XCIwIDAgMTEgMTFcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTcuMzY1IDEwLjVsLS4wMS00LjA0NWgyLjYxMkw1LjUuODA2bC00LjQ2NyA1LjY1aDIuNjA0bC4wMSA0LjA0NGgzLjcxOHpcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtcG93ZXJlZEJ5VXBweVwiPlVwcHk8L3NwYW4+XG4gICAgICA8L3NwYW4+XG4gICAgKVxuXG4gICAgY29uc3QgbGlua1RleHQgPSBpMThuQXJyYXkoJ3Bvd2VyZWRCeScsIHsgdXBweTogdXBweUJyYW5kaW5nIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGFcbiAgICAgICAgdGFiSW5kZXg9XCItMVwiXG4gICAgICAgIGhyZWY9XCJodHRwczovL3VwcHkuaW9cIlxuICAgICAgICByZWw9XCJub3JlZmVycmVyIG5vb3BlbmVyXCJcbiAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtcG93ZXJlZEJ5XCJcbiAgICAgID5cbiAgICAgICAge2xpbmtUZXh0fVxuICAgICAgPC9hPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtQWRkRmlsZXNcIj5cbiAgICAgICAge3RoaXMucmVuZGVySGlkZGVuSW5wdXQoZmFsc2UsIChyZWYpID0+IHsgdGhpcy5maWxlSW5wdXQgPSByZWYgfSl9XG4gICAgICAgIHt0aGlzLnJlbmRlckhpZGRlbklucHV0KHRydWUsIChyZWYpID0+IHsgdGhpcy5mb2xkZXJJbnB1dCA9IHJlZiB9KX1cbiAgICAgICAge3RoaXMucmVuZGVyRHJvcFBhc3RlQnJvd3NlVGFnbGluZSgpfVxuICAgICAgICB7dGhpcy5wcm9wcy5hY3F1aXJlcnMubGVuZ3RoID4gMCAmJiB0aGlzLnJlbmRlckFjcXVpcmVycyh0aGlzLnByb3BzLmFjcXVpcmVycywgdGhpcy5wcm9wcy5kaXNhYmxlTG9jYWxGaWxlcyl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtQWRkRmlsZXMtaW5mb1wiPlxuICAgICAgICAgIHt0aGlzLnByb3BzLm5vdGUgJiYgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1ub3RlXCI+e3RoaXMucHJvcHMubm90ZX08L2Rpdj59XG4gICAgICAgICAge3RoaXMucHJvcHMucHJvdWRseURpc3BsYXlQb3dlcmVkQnlVcHB5ICYmIHRoaXMucmVuZGVyUG93ZXJlZEJ5VXBweSh0aGlzLnByb3BzKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZGRGaWxlc1xuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3QgQWRkRmlsZXMgPSByZXF1aXJlKCcuL0FkZEZpbGVzJylcblxuY29uc3QgQWRkRmlsZXNQYW5lbCA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1EYXNoYm9hcmQtQWRkRmlsZXNQYW5lbCcsIHByb3BzLmNsYXNzTmFtZSl9XG4gICAgICBkYXRhLXVwcHktcGFuZWxUeXBlPVwiQWRkRmlsZXNcIlxuICAgICAgYXJpYS1oaWRkZW49e3Byb3BzLnNob3dBZGRGaWxlc1BhbmVsfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgICB7cHJvcHMuaTE4bignYWRkaW5nTW9yZUZpbGVzJyl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWwoZmFsc2UpfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2JhY2snKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IC8+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZGRGaWxlc1BhbmVsXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBpc0RyYWdEcm9wU3VwcG9ydGVkID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzRHJhZ0Ryb3BTdXBwb3J0ZWQnKVxuY29uc3QgRmlsZUxpc3QgPSByZXF1aXJlKCcuL0ZpbGVMaXN0JylcbmNvbnN0IEFkZEZpbGVzID0gcmVxdWlyZSgnLi9BZGRGaWxlcycpXG5jb25zdCBBZGRGaWxlc1BhbmVsID0gcmVxdWlyZSgnLi9BZGRGaWxlc1BhbmVsJylcbmNvbnN0IFBpY2tlclBhbmVsQ29udGVudCA9IHJlcXVpcmUoJy4vUGlja2VyUGFuZWxDb250ZW50JylcbmNvbnN0IEVkaXRvclBhbmVsID0gcmVxdWlyZSgnLi9FZGl0b3JQYW5lbCcpXG5jb25zdCBQYW5lbFRvcEJhciA9IHJlcXVpcmUoJy4vUGlja2VyUGFuZWxUb3BCYXInKVxuY29uc3QgRmlsZUNhcmQgPSByZXF1aXJlKCcuL0ZpbGVDYXJkJylcbmNvbnN0IFNsaWRlID0gcmVxdWlyZSgnLi9TbGlkZScpXG5cbi8vIGh0dHA6Ly9kZXYuZWRlbnNwaWVrZXJtYW5uLmNvbS8yMDE2LzAyLzExL2ludHJvZHVjaW5nLWFjY2Vzc2libGUtbW9kYWwtZGlhbG9nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2hvc2gvbWljcm9tb2RhbFxuXG5jb25zdCBXSURUSF9YTCA9IDkwMFxuY29uc3QgV0lEVEhfTEcgPSA3MDBcbmNvbnN0IFdJRFRIX01EID0gNTc2XG5jb25zdCBIRUlHSFRfTUQgPSA0MDBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEYXNoYm9hcmQgKHByb3BzKSB7XG4gIGNvbnN0IG5vRmlsZXMgPSBwcm9wcy50b3RhbEZpbGVDb3VudCA9PT0gMFxuICBjb25zdCBpc1NpemVNRCA9IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTURcblxuICBjb25zdCB3cmFwcGVyQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgJ3VwcHktUm9vdCc6IHByb3BzLmlzVGFyZ2V0RE9NRWwsXG4gIH0pXG5cbiAgY29uc3QgZGFzaGJvYXJkQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgJ3VwcHktRGFzaGJvYXJkJzogdHJ1ZSxcbiAgICAndXBweS1EYXNoYm9hcmQtLWlzRGlzYWJsZWQnOiBwcm9wcy5kaXNhYmxlZCxcbiAgICAndXBweS1EYXNoYm9hcmQtLWFuaW1hdGVPcGVuQ2xvc2UnOiBwcm9wcy5hbmltYXRlT3BlbkNsb3NlLFxuICAgICd1cHB5LURhc2hib2FyZC0taXNDbG9zaW5nJzogcHJvcHMuaXNDbG9zaW5nLFxuICAgICd1cHB5LURhc2hib2FyZC0taXNEcmFnZ2luZ092ZXInOiBwcm9wcy5pc0RyYWdnaW5nT3ZlcixcbiAgICAndXBweS1EYXNoYm9hcmQtLW1vZGFsJzogIXByb3BzLmlubGluZSxcbiAgICAndXBweS1zaXplLS1tZCc6IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTUQsXG4gICAgJ3VwcHktc2l6ZS0tbGcnOiBwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX0xHLFxuICAgICd1cHB5LXNpemUtLXhsJzogcHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9YTCxcbiAgICAndXBweS1zaXplLS1oZWlnaHQtbWQnOiBwcm9wcy5jb250YWluZXJIZWlnaHQgPiBIRUlHSFRfTUQsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0FkZEZpbGVzUGFuZWxWaXNpYmxlJzogcHJvcHMuc2hvd0FkZEZpbGVzUGFuZWwsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0lubmVyV3JhcFZpc2libGUnOiBwcm9wcy5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZSxcbiAgfSlcblxuICAvLyBJbXBvcnRhbnQ6IGtlZXAgdGhlc2UgaW4gc3luYyB3aXRoIHRoZSBwZXJjZW50IHdpZHRoIHZhbHVlcyBpbiBgc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vaW5kZXguc2Nzc2AuXG4gIGxldCBpdGVtc1BlclJvdyA9IDEgLy8gbW9iaWxlXG4gIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX1hMKSB7XG4gICAgaXRlbXNQZXJSb3cgPSA1XG4gIH0gZWxzZSBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9MRykge1xuICAgIGl0ZW1zUGVyUm93ID0gNFxuICB9IGVsc2UgaWYgKHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTUQpIHtcbiAgICBpdGVtc1BlclJvdyA9IDNcbiAgfVxuXG4gIGNvbnN0IHNob3dGaWxlTGlzdCA9IHByb3BzLnNob3dTZWxlY3RlZEZpbGVzICYmICFub0ZpbGVzXG5cbiAgY29uc3QgbnVtYmVyT2ZGaWxlc0ZvclJlY292ZXJ5ID0gcHJvcHMucmVjb3ZlcmVkU3RhdGUgPyBPYmplY3Qua2V5cyhwcm9wcy5yZWNvdmVyZWRTdGF0ZS5maWxlcykubGVuZ3RoIDogbnVsbFxuICBjb25zdCBudW1iZXJPZkdob3N0cyA9IHByb3BzLmZpbGVzID8gT2JqZWN0LmtleXMocHJvcHMuZmlsZXMpLmZpbHRlcigoZmlsZUlEKSA9PiBwcm9wcy5maWxlc1tmaWxlSURdLmlzR2hvc3QpLmxlbmd0aCA6IG51bGxcblxuICBjb25zdCByZW5kZXJSZXN0b3JlZFRleHQgPSAoKSA9PiB7XG4gICAgaWYgKG51bWJlck9mR2hvc3RzID4gMCkge1xuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3JlY292ZXJlZFhGaWxlcycsIHtcbiAgICAgICAgc21hcnRfY291bnQ6IG51bWJlck9mR2hvc3RzLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMuaTE4bigncmVjb3ZlcmVkQWxsRmlsZXMnKVxuICB9XG5cbiAgY29uc3QgZGFzaGJvYXJkID0gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17ZGFzaGJvYXJkQ2xhc3NOYW1lfVxuICAgICAgZGF0YS11cHB5LXRoZW1lPXtwcm9wcy50aGVtZX1cbiAgICAgIGRhdGEtdXBweS1udW0tYWNxdWlyZXJzPXtwcm9wcy5hY3F1aXJlcnMubGVuZ3RofVxuICAgICAgZGF0YS11cHB5LWRyYWctZHJvcC1zdXBwb3J0ZWQ9eyFwcm9wcy5kaXNhYmxlTG9jYWxGaWxlcyAmJiBpc0RyYWdEcm9wU3VwcG9ydGVkKCl9XG4gICAgICBhcmlhLWhpZGRlbj17cHJvcHMuaW5saW5lID8gJ2ZhbHNlJyA6IHByb3BzLmlzSGlkZGVufVxuICAgICAgYXJpYS1kaXNhYmxlZD17cHJvcHMuZGlzYWJsZWR9XG4gICAgICBhcmlhLWxhYmVsPXshcHJvcHMuaW5saW5lID8gcHJvcHMuaTE4bignZGFzaGJvYXJkV2luZG93VGl0bGUnKSA6IHByb3BzLmkxOG4oJ2Rhc2hib2FyZFRpdGxlJyl9XG4gICAgICBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX1cbiAgICAgIG9uRHJhZ092ZXI9e3Byb3BzLmhhbmRsZURyYWdPdmVyfVxuICAgICAgb25EcmFnTGVhdmU9e3Byb3BzLmhhbmRsZURyYWdMZWF2ZX1cbiAgICAgIG9uRHJvcD17cHJvcHMuaGFuZGxlRHJvcH1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLW92ZXJsYXlcIlxuICAgICAgICB0YWJJbmRleD17LTF9XG4gICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhhbmRsZUNsaWNrT3V0c2lkZX1cbiAgICAgIC8+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtaW5uZXJcIlxuICAgICAgICBhcmlhLW1vZGFsPXshcHJvcHMuaW5saW5lICYmICd0cnVlJ31cbiAgICAgICAgcm9sZT17IXByb3BzLmlubGluZSAmJiAnZGlhbG9nJ31cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogcHJvcHMuaW5saW5lICYmIHByb3BzLndpZHRoID8gcHJvcHMud2lkdGggOiAnJyxcbiAgICAgICAgICBoZWlnaHQ6IHByb3BzLmlubGluZSAmJiBwcm9wcy5oZWlnaHQgPyBwcm9wcy5oZWlnaHQgOiAnJyxcbiAgICAgICAgfX1cbiAgICAgID5cblxuICAgICAgICB7IXByb3BzLmlubGluZSA/IChcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtY2xvc2VcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdjbG9zZU1vZGFsJyl9XG4gICAgICAgICAgICB0aXRsZT17cHJvcHMuaTE4bignY2xvc2VNb2RhbCcpfVxuICAgICAgICAgICAgb25DbGljaz17cHJvcHMuY2xvc2VNb2RhbH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApIDogbnVsbH1cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLWlubmVyV3JhcFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtZHJvcEZpbGVzSGVyZUhpbnRcIj5cbiAgICAgICAgICAgIHtwcm9wcy5pMThuKCdkcm9wSGludCcpfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAge3Nob3dGaWxlTGlzdCAmJiA8UGFuZWxUb3BCYXIgey4uLnByb3BzfSAvPn1cblxuICAgICAgICAgIHtudW1iZXJPZkZpbGVzRm9yUmVjb3ZlcnkgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnXCI+XG4gICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtc2VydmljZU1zZy1pY29uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjIxXCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDE5XCI+XG4gICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAgLTEpXCIgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTIuODU3IDEuNDNsMTAuMjM0IDE3LjA1NkExIDEgMCAwMTIyLjIzNCAyMEgxLjc2NmExIDEgMCAwMS0uODU3LTEuNTE0TDExLjE0MyAxLjQyOWExIDEgMCAwMTEuNzE0IDB6XCIgZmlsbD1cIiNGRkQzMDBcIiAvPlxuICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIiMwMDBcIiBkPVwiTTExIDZoMmwtLjMgOGgtMS40elwiIC8+XG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjMDAwXCIgY3g9XCIxMlwiIGN5PVwiMTdcIiByPVwiMVwiIC8+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgPHN0cm9uZyBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAge3Byb3BzLmkxOG4oJ3Nlc3Npb25SZXN0b3JlZCcpfVxuICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnLXRleHRcIj5cbiAgICAgICAgICAgICAgICB7cmVuZGVyUmVzdG9yZWRUZXh0KCl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cblxuICAgICAgICAgIHtzaG93RmlsZUxpc3QgPyAoXG4gICAgICAgICAgICA8RmlsZUxpc3RcbiAgICAgICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgICAgICBpdGVtc1BlclJvdz17aXRlbXNQZXJSb3d9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8QWRkRmlsZXMgey4uLnByb3BzfSBpc1NpemVNRD17aXNTaXplTUR9IC8+XG4gICAgICAgICAgKX1cblxuICAgICAgICAgIDxTbGlkZT5cbiAgICAgICAgICAgIHtwcm9wcy5zaG93QWRkRmlsZXNQYW5lbCA/IDxBZGRGaWxlc1BhbmVsIGtleT1cIkFkZEZpbGVzXCIgey4uLnByb3BzfSBpc1NpemVNRD17aXNTaXplTUR9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1NsaWRlPlxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLmZpbGVDYXJkRm9yID8gPEZpbGVDYXJkIGtleT1cIkZpbGVDYXJkXCIgey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICAgICAgPC9TbGlkZT5cblxuICAgICAgICAgIDxTbGlkZT5cbiAgICAgICAgICAgIHtwcm9wcy5hY3RpdmVQaWNrZXJQYW5lbCA/IDxQaWNrZXJQYW5lbENvbnRlbnQga2V5PVwiUGlja2VyXCIgey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICAgICAgPC9TbGlkZT5cblxuICAgICAgICAgIDxTbGlkZT5cbiAgICAgICAgICAgIHtwcm9wcy5zaG93RmlsZUVkaXRvciA/IDxFZGl0b3JQYW5lbCBrZXk9XCJFZGl0b3JcIiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1NsaWRlPlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1wcm9ncmVzc2luZGljYXRvcnNcIj5cbiAgICAgICAgICAgIHtwcm9wcy5wcm9ncmVzc2luZGljYXRvcnMubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnVwcHkuZ2V0UGx1Z2luKHRhcmdldC5pZCkucmVuZGVyKHByb3BzLnN0YXRlKVxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcblxuICByZXR1cm4gKFxuICAgIC8vIFdyYXAgaXQgZm9yIFJUTCBsYW5ndWFnZSBzdXBwb3J0XG4gICAgPGRpdiBjbGFzc05hbWU9e3dyYXBwZXJDbGFzc05hbWV9IGRpcj17cHJvcHMuZGlyZWN0aW9ufT5cbiAgICAgIHtkYXNoYm9hcmR9XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcblxuZnVuY3Rpb24gRWRpdG9yUGFuZWwgKHByb3BzKSB7XG4gIGNvbnN0IGZpbGUgPSBwcm9wcy5maWxlc1twcm9wcy5maWxlQ2FyZEZvcl1cblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsJywgcHJvcHMuY2xhc3NOYW1lKX1cbiAgICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgICBkYXRhLXVwcHktcGFuZWxUeXBlPVwiRmlsZUVkaXRvclwiXG4gICAgICBpZD1cInVwcHktRGFzaGJvYXJkQ29udGVudC1wYW5lbC0tZWRpdG9yXCJcbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCIxXCI+XG4gICAgICAgICAge3Byb3BzLmkxOG5BcnJheSgnZWRpdGluZycsIHtcbiAgICAgICAgICAgIGZpbGU6IDxzcGFuIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZUZpbGVcIj57ZmlsZS5tZXRhID8gZmlsZS5tZXRhLm5hbWUgOiBmaWxlLm5hbWV9PC9zcGFuPixcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17cHJvcHMuaGlkZUFsbFBhbmVsc31cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtc2F2ZVwiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17cHJvcHMuc2F2ZUZpbGVFZGl0b3J9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuaTE4bignc2F2ZScpfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWxCb2R5XCI+XG4gICAgICAgIHtwcm9wcy5lZGl0b3JzLm1hcCgodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnVwcHkuZ2V0UGx1Z2luKHRhcmdldC5pZCkucmVuZGVyKHByb3BzLnN0YXRlKVxuICAgICAgICB9KX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRWRpdG9yUGFuZWxcbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3QgeyBuYW5vaWQgfSA9IHJlcXVpcmUoJ25hbm9pZCcpXG5jb25zdCBnZXRGaWxlVHlwZUljb24gPSByZXF1aXJlKCcuLi8uLi91dGlscy9nZXRGaWxlVHlwZUljb24nKVxuY29uc3QgaWdub3JlRXZlbnQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZ25vcmVFdmVudC5qcycpXG5jb25zdCBGaWxlUHJldmlldyA9IHJlcXVpcmUoJy4uL0ZpbGVQcmV2aWV3JylcblxuY2xhc3MgRmlsZUNhcmQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuXG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZXNbdGhpcy5wcm9wcy5maWxlQ2FyZEZvcl1cbiAgICBjb25zdCBtZXRhRmllbGRzID0gdGhpcy5nZXRNZXRhRmllbGRzKCkgfHwgW11cblxuICAgIGNvbnN0IHN0b3JlZE1ldGFEYXRhID0ge31cbiAgICBtZXRhRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICBzdG9yZWRNZXRhRGF0YVtmaWVsZC5pZF0gPSBmaWxlLm1ldGFbZmllbGQuaWRdIHx8ICcnXG4gICAgfSlcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBmb3JtU3RhdGU6IHN0b3JlZE1ldGFEYXRhLFxuICAgIH1cblxuICAgIHRoaXMuZm9ybS5pZCA9IG5hbm9pZCgpXG4gIH1cblxuICAvLyBUT0RPKGFkdWg5NSk6IG1vdmUgdGhpcyB0byBgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudGAgd2hlbiB1cGRhdGluZyB0byBQcmVhY3QgWCsuXG4gIGNvbXBvbmVudFdpbGxNb3VudCAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tZGVwcmVjYXRlZFxuICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCB0aGlzLmhhbmRsZVNhdmUpXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmZvcm0pXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgdGhpcy5mb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuaGFuZGxlU2F2ZSlcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuZm9ybSlcbiAgfVxuXG4gIGdldE1ldGFGaWVsZHMgKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wcm9wcy5tZXRhRmllbGRzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHRoaXMucHJvcHMubWV0YUZpZWxkcyh0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdKVxuICAgICAgOiB0aGlzLnByb3BzLm1ldGFGaWVsZHNcbiAgfVxuXG4gIHVwZGF0ZU1ldGEgPSAobmV3VmFsLCBuYW1lKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoeyBmb3JtU3RhdGUgfSkgPT4gKHtcbiAgICAgIGZvcm1TdGF0ZToge1xuICAgICAgICAuLi5mb3JtU3RhdGUsXG4gICAgICAgIFtuYW1lXTogbmV3VmFsLFxuICAgICAgfSxcbiAgICB9KSlcbiAgfVxuXG4gIGhhbmRsZVNhdmUgPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGNvbnN0IGZpbGVJRCA9IHRoaXMucHJvcHMuZmlsZUNhcmRGb3JcbiAgICB0aGlzLnByb3BzLnNhdmVGaWxlQ2FyZCh0aGlzLnN0YXRlLmZvcm1TdGF0ZSwgZmlsZUlEKVxuICB9XG5cbiAgaGFuZGxlQ2FuY2VsID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMudG9nZ2xlRmlsZUNhcmQoZmFsc2UpXG4gIH1cblxuICBzYXZlT25FbnRlciA9IChldikgPT4ge1xuICAgIGlmIChldi5rZXlDb2RlID09PSAxMykge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdXG4gICAgICB0aGlzLnByb3BzLnNhdmVGaWxlQ2FyZCh0aGlzLnN0YXRlLmZvcm1TdGF0ZSwgZmlsZS5pZClcbiAgICB9XG4gIH1cblxuICByZW5kZXJNZXRhRmllbGRzID0gKCkgPT4ge1xuICAgIGNvbnN0IG1ldGFGaWVsZHMgPSB0aGlzLmdldE1ldGFGaWVsZHMoKSB8fCBbXVxuICAgIGNvbnN0IGZpZWxkQ1NTQ2xhc3NlcyA9IHtcbiAgICAgIHRleHQ6ICd1cHB5LXUtcmVzZXQgdXBweS1jLXRleHRJbnB1dCB1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1pbnB1dCcsXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGFGaWVsZHMubWFwKChmaWVsZCkgPT4ge1xuICAgICAgY29uc3QgaWQgPSBgdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtaW5wdXQtJHtmaWVsZC5pZH1gXG4gICAgICBjb25zdCByZXF1aXJlZCA9IHRoaXMucHJvcHMucmVxdWlyZWRNZXRhRmllbGRzLmluY2x1ZGVzKGZpZWxkLmlkKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGZpZWxkc2V0IGtleT17ZmllbGQuaWR9IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWZpZWxkc2V0XCI+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWxhYmVsXCIgaHRtbEZvcj17aWR9PntmaWVsZC5uYW1lfTwvbGFiZWw+XG4gICAgICAgICAge2ZpZWxkLnJlbmRlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGZpZWxkLnJlbmRlcih7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmZvcm1TdGF0ZVtmaWVsZC5pZF0sXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiAobmV3VmFsKSA9PiB0aGlzLnVwZGF0ZU1ldGEobmV3VmFsLCBmaWVsZC5pZCksXG4gICAgICAgICAgICAgIGZpZWxkQ1NTQ2xhc3NlcyxcbiAgICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICAgIGZvcm06IHRoaXMuZm9ybS5pZCxcbiAgICAgICAgICAgIH0sIGgpXG4gICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtmaWVsZENTU0NsYXNzZXMudGV4dH1cbiAgICAgICAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgICAgICAgZm9ybT17dGhpcy5mb3JtLmlkfVxuICAgICAgICAgICAgICAgIHR5cGU9e2ZpZWxkLnR5cGUgfHwgJ3RleHQnfVxuICAgICAgICAgICAgICAgIHJlcXVpcmVkPXtyZXF1aXJlZH1cbiAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS5mb3JtU3RhdGVbZmllbGQuaWRdfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtmaWVsZC5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAvLyBJZiBgZm9ybWAgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIG5lZWQgdG8gY2FwdHVyZSBwcmVzc2luZyBFbnRlciB0byBhdm9pZCBidWJibGluZyBpbiBjYXNlIFVwcHkgaXNcbiAgICAgICAgICAgICAgICAvLyBlbWJlZGRlZCBpbnNpZGUgYSA8Zm9ybT4uXG4gICAgICAgICAgICAgICAgb25LZXlVcD17J2Zvcm0nIGluIEhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlID8gdW5kZWZpbmVkIDogdGhpcy5zYXZlT25FbnRlcn1cbiAgICAgICAgICAgICAgICBvbktleURvd249eydmb3JtJyBpbiBIVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSA/IHVuZGVmaW5lZCA6IHRoaXMuc2F2ZU9uRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25LZXlQcmVzcz17J2Zvcm0nIGluIEhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlID8gdW5kZWZpbmVkIDogdGhpcy5zYXZlT25FbnRlcn1cbiAgICAgICAgICAgICAgICBvbklucHV0PXtldiA9PiB0aGlzLnVwZGF0ZU1ldGEoZXYudGFyZ2V0LnZhbHVlLCBmaWVsZC5pZCl9XG4gICAgICAgICAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgPC9maWVsZHNldD5cbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5wcm9wcy5maWxlc1t0aGlzLnByb3BzLmZpbGVDYXJkRm9yXVxuICAgIGNvbnN0IHNob3dFZGl0QnV0dG9uID0gdGhpcy5wcm9wcy5jYW5FZGl0RmlsZShmaWxlKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCd1cHB5LURhc2hib2FyZC1GaWxlQ2FyZCcsIHRoaXMucHJvcHMuY2xhc3NOYW1lKX1cbiAgICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIkZpbGVDYXJkXCJcbiAgICAgICAgb25EcmFnT3Zlcj17aWdub3JlRXZlbnR9XG4gICAgICAgIG9uRHJhZ0xlYXZlPXtpZ25vcmVFdmVudH1cbiAgICAgICAgb25Ecm9wPXtpZ25vcmVFdmVudH1cbiAgICAgICAgb25QYXN0ZT17aWdub3JlRXZlbnR9XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlXCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxldmVsPVwiMVwiPlxuICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bkFycmF5KCdlZGl0aW5nJywge1xuICAgICAgICAgICAgICBmaWxlOiA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVGaWxlXCI+e2ZpbGUubWV0YSA/IGZpbGUubWV0YS5uYW1lIDogZmlsZS5uYW1lfTwvc3Bhbj4sXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGZvcm09e3RoaXMuZm9ybS5pZH1cbiAgICAgICAgICAgIHRpdGxlPXt0aGlzLnByb3BzLmkxOG4oJ2ZpbmlzaEVkaXRpbmdGaWxlJyl9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNhbmNlbH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1pbm5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtcHJldmlld1wiIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogZ2V0RmlsZVR5cGVJY29uKGZpbGUudHlwZSkuY29sb3IgfX0+XG4gICAgICAgICAgICA8RmlsZVByZXZpZXcgZmlsZT17ZmlsZX0gLz5cbiAgICAgICAgICAgIHtzaG93RWRpdEJ1dHRvblxuICAgICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1lZGl0XCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB0aGlzLnByb3BzLm9wZW5GaWxlRWRpdG9yKGZpbGUpfVxuICAgICAgICAgICAgICAgIGZvcm09e3RoaXMuZm9ybS5pZH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG4oJ2VkaXRGaWxlJyl9XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1pbmZvXCI+XG4gICAgICAgICAgICB7dGhpcy5yZW5kZXJNZXRhRmllbGRzKCl9XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWFjdGlvbnNcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1jLWJ0bi1wcmltYXJ5IHVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWFjdGlvbnNCdG5cIlxuICAgICAgICAgICAgICAvLyBJZiBgZm9ybWAgYXR0cmlidXRlIGlzIHN1cHBvcnRlZCwgd2Ugd2FudCBhIHN1Ym1pdCBidXR0b24gdG8gdHJpZ2dlciB0aGUgZm9ybSB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGZhbGxiYWNrIHRvIGEgY2xhc3NpYyBidXR0b24gd2l0aCBhIG9uQ2xpY2sgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICAgICAgdHlwZT17J2Zvcm0nIGluIEhUTUxCdXR0b25FbGVtZW50LnByb3RvdHlwZSA/ICdzdWJtaXQnIDogJ2J1dHRvbid9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eydmb3JtJyBpbiBIVE1MQnV0dG9uRWxlbWVudC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiB0aGlzLmhhbmRsZVNhdmV9XG4gICAgICAgICAgICAgIGZvcm09e3RoaXMuZm9ybS5pZH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bignc2F2ZUNoYW5nZXMnKX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLWxpbmsgdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtYWN0aW9uc0J0blwiXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNhbmNlbH1cbiAgICAgICAgICAgICAgZm9ybT17dGhpcy5mb3JtLmlkfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVDYXJkXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjb3B5VG9DbGlwYm9hcmQgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9jb3B5VG9DbGlwYm9hcmQnKVxuXG5mdW5jdGlvbiBFZGl0QnV0dG9uICh7XG4gIGZpbGUsXG4gIHVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlLFxuICBtZXRhRmllbGRzLFxuICBjYW5FZGl0RmlsZSxcbiAgaTE4bixcbiAgb25DbGljayxcbn0pIHtcbiAgaWYgKFxuICAgICghdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGUgJiYgbWV0YUZpZWxkcyAmJiBtZXRhRmllbGRzLmxlbmd0aCA+IDApXG4gICAgfHwgKCF1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSAmJiBjYW5FZGl0RmlsZShmaWxlKSlcbiAgKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uIHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uLS1lZGl0XCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ2VkaXRGaWxlV2l0aEZpbGVuYW1lJywgeyBmaWxlOiBmaWxlLm1ldGEubmFtZSB9KX1cbiAgICAgICAgdGl0bGU9e2kxOG4oJ2VkaXRGaWxlV2l0aEZpbGVuYW1lJywgeyBmaWxlOiBmaWxlLm1ldGEubmFtZSB9KX1cbiAgICAgICAgb25DbGljaz17KCkgPT4gb25DbGljaygpfVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB2aWV3Qm94PVwiMCAwIDE0IDE0XCI+XG4gICAgICAgICAgPGcgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTEuNSAxMC43OTNoMi43OTNBMSAxIDAgMCAwIDUgMTAuNUwxMS41IDRhMSAxIDAgMCAwIDAtMS40MTRMOS43MDcuNzkzYTEgMSAwIDAgMC0xLjQxNCAwbC02LjUgNi41QTEgMSAwIDAgMCAxLjUgOHYyLjc5M3ptMS0xVjhMOSAxLjVsMS43OTMgMS43OTMtNi41IDYuNUgyLjV6XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgICAgIDxyZWN0IHg9XCIxXCIgeT1cIjEyLjI5M1wiIHdpZHRoPVwiMTFcIiBoZWlnaHQ9XCIxXCIgcng9XCIuNVwiIC8+XG4gICAgICAgICAgICA8cGF0aCBmaWxsUnVsZT1cIm5vbnplcm9cIiBkPVwiTTYuNzkzIDIuNUw5LjUgNS4yMDdsLjcwNy0uNzA3TDcuNSAxLjc5M3pcIiAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gUmVtb3ZlQnV0dG9uICh7IGkxOG4sIG9uQ2xpY2ssIGZpbGUgfSkge1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1JdGVtLWFjdGlvbiB1cHB5LURhc2hib2FyZC1JdGVtLWFjdGlvbi0tcmVtb3ZlXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgYXJpYS1sYWJlbD17aTE4bigncmVtb3ZlRmlsZScsIHsgZmlsZTogZmlsZS5tZXRhLm5hbWUgfSl9XG4gICAgICB0aXRsZT17aTE4bigncmVtb3ZlRmlsZScsIHsgZmlsZTogZmlsZS5tZXRhLm5hbWUgfSl9XG4gICAgICBvbkNsaWNrPXsoKSA9PiBvbkNsaWNrKCl9XG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxOFwiIGhlaWdodD1cIjE4XCIgdmlld0JveD1cIjAgMCAxOCAxOFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTkgMEM0LjAzNCAwIDAgNC4wMzQgMCA5czQuMDM0IDkgOSA5IDktNC4wMzQgOS05LTQuMDM0LTktOS05elwiIC8+XG4gICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGXCIgZD1cIk0xMyAxMi4yMjJsLS43NzguNzc4TDkgOS43NzggNS43NzggMTMgNSAxMi4yMjIgOC4yMjIgOSA1IDUuNzc4IDUuNzc4IDUgOSA4LjIyMiAxMi4yMjIgNWwuNzc4Ljc3OEw5Ljc3OCA5elwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5jb25zdCBjb3B5TGlua1RvQ2xpcGJvYXJkID0gKGV2ZW50LCBwcm9wcykgPT4ge1xuICBjb3B5VG9DbGlwYm9hcmQocHJvcHMuZmlsZS51cGxvYWRVUkwsIHByb3BzLmkxOG4oJ2NvcHlMaW5rVG9DbGlwYm9hcmRGYWxsYmFjaycpKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHByb3BzLnVwcHkubG9nKCdMaW5rIGNvcGllZCB0byBjbGlwYm9hcmQuJylcbiAgICAgIHByb3BzLnVwcHkuaW5mbyhwcm9wcy5pMThuKCdjb3B5TGlua1RvQ2xpcGJvYXJkU3VjY2VzcycpLCAnaW5mbycsIDMwMDApXG4gICAgfSlcbiAgICAuY2F0Y2gocHJvcHMudXBweS5sb2cpXG4gICAgLy8gYXZvaWQgbG9zaW5nIGZvY3VzXG4gICAgLnRoZW4oKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KSlcbn1cblxuZnVuY3Rpb24gQ29weUxpbmtCdXR0b24gKHByb3BzKSB7XG4gIGNvbnN0IHsgaTE4biB9ID0gcHJvcHNcblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1JdGVtLWFjdGlvbiB1cHB5LURhc2hib2FyZC1JdGVtLWFjdGlvbi0tY29weUxpbmtcIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBhcmlhLWxhYmVsPXtpMThuKCdjb3B5TGluaycpfVxuICAgICAgdGl0bGU9e2kxOG4oJ2NvcHlMaW5rJyl9XG4gICAgICBvbkNsaWNrPXsoZXZlbnQpID0+IGNvcHlMaW5rVG9DbGlwYm9hcmQoZXZlbnQsIHByb3BzKX1cbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB2aWV3Qm94PVwiMCAwIDE0IDEyXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNy45NCA3LjcwM2EyLjYxMyAyLjYxMyAwIDAgMS0uNjI2IDIuNjgxbC0uODUyLjg1MWEyLjU5NyAyLjU5NyAwIDAgMS0xLjg0OS43NjZBMi42MTYgMi42MTYgMCAwIDEgMi43NjQgNy41NGwuODUyLS44NTJhMi41OTYgMi41OTYgMCAwIDEgMi42OS0uNjI1TDUuMjY3IDcuMDk5YTEuNDQgMS40NCAwIDAgMC0uODMzLjQwN2wtLjg1Mi44NTFhMS40NTggMS40NTggMCAwIDAgMS4wMyAyLjQ4NmMuMzkgMCAuNzU1LS4xNTIgMS4wMy0uNDI2bC44NTItLjg1MmMuMjMxLS4yMzEuMzYzLS41MjIuNDA2LS44MjRsMS4wNC0xLjAzOHptNC4yOTUtNS45MzdBMi41OTYgMi41OTYgMCAwIDAgMTAuMzg3IDFjLS42OTggMC0xLjM1NS4yNzItMS44NDkuNzY2bC0uODUyLjg1MWEyLjYxNCAyLjYxNCAwIDAgMC0uNjI0IDIuNjg4bDEuMDM2LTEuMDM2Yy4wNDEtLjMwNC4xNzMtLjYuNDA3LS44MzNsLjg1Mi0uODUyYy4yNzUtLjI3NS42NC0uNDI2IDEuMDMtLjQyNmExLjQ1OCAxLjQ1OCAwIDAgMSAxLjAzIDIuNDg2bC0uODUyLjg1MWExLjQ0MiAxLjQ0MiAwIDAgMS0uODI0LjQwNmwtMS4wNCAxLjA0YTIuNTk2IDIuNTk2IDAgMCAwIDIuNjgzLS42MjhsLjg1MS0uODVhMi42MTYgMi42MTYgMCAwIDAgMC0zLjY5N3ptLTYuODggNi44ODNhLjU3Ny41NzcgMCAwIDAgLjgyIDBsMy40NzQtMy40NzRhLjU3OS41NzkgMCAxIDAtLjgxOS0uODJMNS4zNTUgNy44M2EuNTc5LjU3OSAwIDAgMCAwIC44MTl6XCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQnV0dG9ucyAocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHVwcHksXG4gICAgZmlsZSxcbiAgICB1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSxcbiAgICBjYW5FZGl0RmlsZSxcbiAgICBtZXRhRmllbGRzLFxuICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0LFxuICAgIHNob3dSZW1vdmVCdXR0b24sXG4gICAgaTE4bixcbiAgICB0b2dnbGVGaWxlQ2FyZCxcbiAgICBvcGVuRmlsZUVkaXRvcixcbiAgfSA9IHByb3BzXG5cbiAgY29uc3QgZWRpdEFjdGlvbiA9ICgpID0+IHtcbiAgICBpZiAobWV0YUZpZWxkcyAmJiBtZXRhRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRvZ2dsZUZpbGVDYXJkKHRydWUsIGZpbGUuaWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZW5GaWxlRWRpdG9yKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uV3JhcHBlclwiPlxuICAgICAgPEVkaXRCdXR0b25cbiAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGU9e3VwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlfVxuICAgICAgICBjYW5FZGl0RmlsZT17Y2FuRWRpdEZpbGV9XG4gICAgICAgIG1ldGFGaWVsZHM9e21ldGFGaWVsZHN9XG4gICAgICAgIG9uQ2xpY2s9e2VkaXRBY3Rpb259XG4gICAgICAvPlxuICAgICAge3Nob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0ICYmIGZpbGUudXBsb2FkVVJMID8gKFxuICAgICAgICA8Q29weUxpbmtCdXR0b25cbiAgICAgICAgICBmaWxlPXtmaWxlfVxuICAgICAgICAgIHVwcHk9e3VwcHl9XG4gICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgLz5cbiAgICAgICkgOiBudWxsfVxuICAgICAge3Nob3dSZW1vdmVCdXR0b24gPyAoXG4gICAgICAgIDxSZW1vdmVCdXR0b25cbiAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgdXBweT17dXBweX1cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBwcm9wcy51cHB5LnJlbW92ZUZpbGUoZmlsZS5pZCwgJ3JlbW92ZWQtYnktdXNlcicpfVxuICAgICAgICAvPlxuICAgICAgKSA6IG51bGx9XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCwgRnJhZ21lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBwcmV0dGllckJ5dGVzID0gcmVxdWlyZSgnQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzJylcbmNvbnN0IE1ldGFFcnJvck1lc3NhZ2UgPSByZXF1aXJlKCcuLi9NZXRhRXJyb3JNZXNzYWdlJylcbmNvbnN0IHRydW5jYXRlU3RyaW5nID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RydW5jYXRlU3RyaW5nJylcblxuY29uc3QgcmVuZGVyRmlsZU5hbWUgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBhdXRob3IsIG5hbWUgfSA9IHByb3BzLmZpbGUubWV0YVxuXG4gIGZ1bmN0aW9uIGdldE1heE5hbWVMZW5ndGggKCkge1xuICAgIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA8PSAzNTIpIHtcbiAgICAgIHJldHVybiAzNVxuICAgIH1cbiAgICBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPD0gNTc2KSB7XG4gICAgICByZXR1cm4gNjBcbiAgICB9XG4gICAgLy8gV2hlbiBgYXV0aG9yYCBpcyBwcmVzZW50LCB3ZSB3YW50IHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZSBmaWxlIG5hbWUgZml0cyBvbiBvbmUgbGluZSBzbyB3ZSBjYW4gcGxhY2VcbiAgICAvLyB0aGUgYXV0aG9yIG9uIHRoZSBzZWNvbmQgbGluZS5cbiAgICByZXR1cm4gYXV0aG9yID8gMjAgOiAzMFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tbmFtZVwiIHRpdGxlPXtuYW1lfT5cbiAgICAgIHt0cnVuY2F0ZVN0cmluZyhuYW1lLCBnZXRNYXhOYW1lTGVuZ3RoKCkpfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IHJlbmRlckF1dGhvciA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGF1dGhvciB9ID0gcHJvcHMuZmlsZS5tZXRhXG4gIGNvbnN0IHsgcHJvdmlkZXJOYW1lIH0gPSBwcm9wcy5maWxlLnJlbW90ZVxuICBjb25zdCBkb3QgPSBgXFx1MDBCN2BcblxuICBpZiAoIWF1dGhvcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1hdXRob3JcIj5cbiAgICAgIDxhXG4gICAgICAgIGhyZWY9e2Ake2F1dGhvci51cmx9P3V0bV9zb3VyY2U9Q29tcGFuaW9uJnV0bV9tZWRpdW09cmVmZXJyYWxgfVxuICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCJcbiAgICAgID5cbiAgICAgICAge3RydW5jYXRlU3RyaW5nKGF1dGhvci5uYW1lLCAxMyl9XG4gICAgICA8L2E+XG4gICAgICB7cHJvdmlkZXJOYW1lID8gKFxuICAgICAgICA8RnJhZ21lbnQ+XG4gICAgICAgICAge2AgJHtkb3R9IGB9XG4gICAgICAgICAge3Byb3ZpZGVyTmFtZX1cbiAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICkgOiBudWxsfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IHJlbmRlckZpbGVTaXplID0gKHByb3BzKSA9PiBwcm9wcy5maWxlLnNpemUgJiYgKFxuICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tc3RhdHVzU2l6ZVwiPlxuICAgIHtwcmV0dGllckJ5dGVzKHByb3BzLmZpbGUuc2l6ZSl9XG4gIDwvZGl2PlxuKVxuXG5jb25zdCBSZVNlbGVjdEJ1dHRvbiA9IChwcm9wcykgPT4gcHJvcHMuZmlsZS5pc0dob3N0ICYmIChcbiAgPHNwYW4+XG4gICAgeycgXFx1MjAyMiAnfVxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktRGFzaGJvYXJkLUl0ZW0tcmVTZWxlY3RcIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBvbkNsaWNrPXtwcm9wcy50b2dnbGVBZGRGaWxlc1BhbmVsfVxuICAgID5cbiAgICAgIHtwcm9wcy5pMThuKCdyZVNlbGVjdCcpfVxuICAgIDwvYnV0dG9uPlxuICA8L3NwYW4+XG4pXG5cbmNvbnN0IEVycm9yQnV0dG9uID0gKHsgZmlsZSwgb25DbGljayB9KSA9PiB7XG4gIGlmIChmaWxlLmVycm9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLUl0ZW0tZXJyb3JEZXRhaWxzXCJcbiAgICAgICAgYXJpYS1sYWJlbD17ZmlsZS5lcnJvcn1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cImJvdHRvbVwiXG4gICAgICAgIGRhdGEtbWljcm90aXAtc2l6ZT1cIm1lZGl1bVwiXG4gICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgPlxuICAgICAgICA/XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlSW5mbyAocHJvcHMpIHtcbiAgY29uc3QgeyBmaWxlIH0gPSBwcm9wc1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tZmlsZUluZm9cIlxuICAgICAgZGF0YS11cHB5LWZpbGUtc291cmNlPXtmaWxlLnNvdXJjZX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tZmlsZU5hbWVcIj5cbiAgICAgICAge3JlbmRlckZpbGVOYW1lKHByb3BzKX1cbiAgICAgICAgPEVycm9yQnV0dG9uXG4gICAgICAgICAgZmlsZT17cHJvcHMuZmlsZX1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYWxlcnRcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBhbGVydChwcm9wcy5maWxlLmVycm9yKX0gLy8gVE9ETzogbW92ZSB0byBhIGN1c3RvbSBhbGVydCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tc3RhdHVzXCI+XG4gICAgICAgIHtyZW5kZXJBdXRob3IocHJvcHMpfVxuICAgICAgICB7cmVuZGVyRmlsZVNpemUocHJvcHMpfVxuICAgICAgICB7UmVTZWxlY3RCdXR0b24ocHJvcHMpfVxuICAgICAgPC9kaXY+XG4gICAgICA8TWV0YUVycm9yTWVzc2FnZVxuICAgICAgICBmaWxlPXtwcm9wcy5maWxlfVxuICAgICAgICBpMThuPXtwcm9wcy5pMThufVxuICAgICAgICB0b2dnbGVGaWxlQ2FyZD17cHJvcHMudG9nZ2xlRmlsZUNhcmR9XG4gICAgICAgIG1ldGFGaWVsZHM9e3Byb3BzLm1ldGFGaWVsZHN9XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBGaWxlUHJldmlldyA9IHJlcXVpcmUoJy4uLy4uL0ZpbGVQcmV2aWV3JylcbmNvbnN0IE1ldGFFcnJvck1lc3NhZ2UgPSByZXF1aXJlKCcuLi9NZXRhRXJyb3JNZXNzYWdlJylcbmNvbnN0IGdldEZpbGVUeXBlSWNvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2dldEZpbGVUeXBlSWNvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRmlsZVByZXZpZXdBbmRMaW5rIChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJldmlld0lubmVyV3JhcFwiXG4gICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IGdldEZpbGVUeXBlSWNvbihwcm9wcy5maWxlLnR5cGUpLmNvbG9yIH19XG4gICAgPlxuICAgICAge1xuICAgICAgICBwcm9wcy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdFxuICAgICAgICAmJiBwcm9wcy5maWxlLnVwbG9hZFVSTFxuICAgICAgICAgICYmIChcbiAgICAgICAgICA8YVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3TGlua1wiXG4gICAgICAgICAgICBocmVmPXtwcm9wcy5maWxlLnVwbG9hZFVSTH1cbiAgICAgICAgICAgIHJlbD1cIm5vcmVmZXJyZXIgbm9vcGVuZXJcIlxuICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmZpbGUubWV0YS5uYW1lfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGhpZGRlbj57cHJvcHMuZmlsZS5tZXRhLm5hbWV9PC9zcGFuPlxuICAgICAgICAgIDwvYT5cbiAgICAgICAgICApXG4gICAgICB9XG4gICAgICA8RmlsZVByZXZpZXcgZmlsZT17cHJvcHMuZmlsZX0gLz5cbiAgICAgIDxNZXRhRXJyb3JNZXNzYWdlXG4gICAgICAgIGZpbGU9e3Byb3BzLmZpbGV9XG4gICAgICAgIGkxOG49e3Byb3BzLmkxOG59XG4gICAgICAgIHRvZ2dsZUZpbGVDYXJkPXtwcm9wcy50b2dnbGVGaWxlQ2FyZH1cbiAgICAgICAgbWV0YUZpZWxkcz17cHJvcHMubWV0YUZpZWxkc31cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gb25QYXVzZVJlc3VtZUNhbmNlbFJldHJ5IChwcm9wcykge1xuICBpZiAocHJvcHMuaXNVcGxvYWRlZCkgcmV0dXJuXG5cbiAgaWYgKHByb3BzLmVycm9yICYmICFwcm9wcy5oaWRlUmV0cnlCdXR0b24pIHtcbiAgICBwcm9wcy51cHB5LnJldHJ5VXBsb2FkKHByb3BzLmZpbGUuaWQpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvcHMucmVzdW1hYmxlVXBsb2FkcyAmJiAhcHJvcHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uKSB7XG4gICAgcHJvcHMudXBweS5wYXVzZVJlc3VtZShwcm9wcy5maWxlLmlkKVxuICB9IGVsc2UgaWYgKHByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24gJiYgIXByb3BzLmhpZGVDYW5jZWxCdXR0b24pIHtcbiAgICBwcm9wcy51cHB5LnJlbW92ZUZpbGUocHJvcHMuZmlsZS5pZClcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9ncmVzc0luZGljYXRvclRpdGxlIChwcm9wcykge1xuICBpZiAocHJvcHMuaXNVcGxvYWRlZCkge1xuICAgIHJldHVybiBwcm9wcy5pMThuKCd1cGxvYWRDb21wbGV0ZScpXG4gIH1cblxuICBpZiAocHJvcHMuZXJyb3IpIHtcbiAgICByZXR1cm4gcHJvcHMuaTE4bigncmV0cnlVcGxvYWQnKVxuICB9XG5cbiAgaWYgKHByb3BzLnJlc3VtYWJsZVVwbG9hZHMpIHtcbiAgICBpZiAocHJvcHMuZmlsZS5pc1BhdXNlZCkge1xuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3Jlc3VtZVVwbG9hZCcpXG4gICAgfVxuICAgIHJldHVybiBwcm9wcy5pMThuKCdwYXVzZVVwbG9hZCcpXG4gIH0gaWYgKHByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24pIHtcbiAgICByZXR1cm4gcHJvcHMuaTE4bignY2FuY2VsVXBsb2FkJylcbiAgfVxuXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBQcm9ncmVzc0luZGljYXRvckJ1dHRvbiAocHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NcIj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJbmRpY2F0b3JcIlxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgYXJpYS1sYWJlbD17cHJvZ3Jlc3NJbmRpY2F0b3JUaXRsZShwcm9wcyl9XG4gICAgICAgIHRpdGxlPXtwcm9ncmVzc0luZGljYXRvclRpdGxlKHByb3BzKX1cbiAgICAgICAgb25DbGljaz17KCkgPT4gb25QYXVzZVJlc3VtZUNhbmNlbFJldHJ5KHByb3BzKX1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZnVuY3Rpb24gUHJvZ3Jlc3NDaXJjbGVDb250YWluZXIgKHsgY2hpbGRyZW4gfSkge1xuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICB3aWR0aD1cIjcwXCJcbiAgICAgIGhlaWdodD1cIjcwXCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMzYgMzZcIlxuICAgICAgY2xhc3NOYW1lPVwidXBweS1jLWljb24gdXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0ljb24tLWNpcmNsZVwiXG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIFByb2dyZXNzQ2lyY2xlICh7IHByb2dyZXNzIH0pIHtcbiAgLy8gY2lyY2xlIGxlbmd0aCBlcXVhbHMgMiAqIFBJICogUlxuICBjb25zdCBjaXJjbGVMZW5ndGggPSAyICogTWF0aC5QSSAqIDE1XG5cbiAgcmV0dXJuIChcbiAgICA8Zz5cbiAgICAgIDxjaXJjbGVcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0ljb24tLWJnXCJcbiAgICAgICAgcj1cIjE1XCJcbiAgICAgICAgY3g9XCIxOFwiXG4gICAgICAgIGN5PVwiMThcIlxuICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgLz5cbiAgICAgIDxjaXJjbGVcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0ljb24tLXByb2dyZXNzXCJcbiAgICAgICAgcj1cIjE1XCJcbiAgICAgICAgY3g9XCIxOFwiXG4gICAgICAgIGN5PVwiMThcIlxuICAgICAgICB0cmFuc2Zvcm09XCJyb3RhdGUoLTkwLCAxOCwgMTgpXCJcbiAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheT17Y2lyY2xlTGVuZ3RofVxuICAgICAgICBzdHJva2UtZGFzaG9mZnNldD17Y2lyY2xlTGVuZ3RoIC0gKChjaXJjbGVMZW5ndGggLyAxMDApICogcHJvZ3Jlc3MpfVxuICAgICAgLz5cbiAgICA8L2c+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlUHJvZ3Jlc3MgKHByb3BzKSB7XG4gIC8vIE5vdGhpbmcgaWYgdXBsb2FkIGhhcyBub3Qgc3RhcnRlZFxuICBpZiAoIXByb3BzLmZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBHcmVlbiBjaGVja21hcmsgd2hlbiBjb21wbGV0ZVxuICBpZiAocHJvcHMuaXNVcGxvYWRlZCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSW5kaWNhdG9yXCI+XG4gICAgICAgICAgPFByb2dyZXNzQ2lyY2xlQ29udGFpbmVyPlxuICAgICAgICAgICAgPGNpcmNsZSByPVwiMTVcIiBjeD1cIjE4XCIgY3k9XCIxOFwiIGZpbGw9XCIjMWJiMjQwXCIgLz5cbiAgICAgICAgICAgIDxwb2x5Z29uIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1jaGVja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyLCAzKVwiIHBvaW50cz1cIjE0IDIyLjUgNyAxNS4yNDU3MDY1IDguOTk5ODU4NTcgMTMuMTczMjgxNSAxNCAxOC4zNTQ3MTA0IDIyLjk3Mjk4ODMgOSAyNSAxMS4xMDA1NjM0XCIgLz5cbiAgICAgICAgICA8L1Byb2dyZXNzQ2lyY2xlQ29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIGlmIChwcm9wcy5yZWNvdmVyZWRTdGF0ZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gUmV0cnkgYnV0dG9uIGZvciBlcnJvclxuICBpZiAocHJvcHMuZXJyb3IgJiYgIXByb3BzLmhpZGVSZXRyeUJ1dHRvbikge1xuICAgIHJldHVybiAoXG4gICAgICA8UHJvZ3Jlc3NJbmRpY2F0b3JCdXR0b24gey4uLnByb3BzfT5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uIHVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1yZXRyeVwiIHdpZHRoPVwiMjhcIiBoZWlnaHQ9XCIzMVwiIHZpZXdCb3g9XCIwIDAgMTYgMTlcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE2IDExYTggOCAwIDEgMS04LTh2MmE2IDYgMCAxIDAgNiA2aDJ6XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTcuOSAzSDEwdjJINy45elwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk04LjUzNi41bDMuNTM1IDMuNTM2LTEuNDE0IDEuNDE0TDcuMTIgMS45MTR6XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTEwLjY1NyAyLjYyMWwxLjQxNCAxLjQxNUw4LjUzNiA3LjU3IDcuMTIgNi4xNTd6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L1Byb2dyZXNzSW5kaWNhdG9yQnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIC8vIFBhdXNlL3Jlc3VtZSBidXR0b24gZm9yIHJlc3VtYWJsZSB1cGxvYWRzXG4gIGlmIChwcm9wcy5yZXN1bWFibGVVcGxvYWRzICYmICFwcm9wcy5oaWRlUGF1c2VSZXN1bWVCdXR0b24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgPFByb2dyZXNzSW5kaWNhdG9yQnV0dG9uIHsuLi5wcm9wc30+XG4gICAgICAgIDxQcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgICAgICA8UHJvZ3Jlc3NDaXJjbGUgcHJvZ3Jlc3M9e3Byb3BzLmZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZX0gLz5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm9wcy5maWxlLmlzUGF1c2VkXG4gICAgICAgICAgICAgID8gPHBvbHlnb24gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0ljb24tLXBsYXlcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMywgMylcIiBwb2ludHM9XCIxMiAyMCAxMiAxMCAyMCAxNVwiIC8+XG4gICAgICAgICAgICAgIDogKFxuICAgICAgICAgICAgICAgIDxnIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1wYXVzZVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNC41LCAxMylcIj5cbiAgICAgICAgICAgICAgICAgIDxyZWN0IHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjJcIiBoZWlnaHQ9XCIxMFwiIHJ4PVwiMFwiIC8+XG4gICAgICAgICAgICAgICAgICA8cmVjdCB4PVwiNVwiIHk9XCIwXCIgd2lkdGg9XCIyXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjBcIiAvPlxuICAgICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgPC9Qcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgIDwvUHJvZ3Jlc3NJbmRpY2F0b3JCdXR0b24+XG4gICAgKVxuICB9XG5cbiAgLy8gQ2FuY2VsIGJ1dHRvbiBmb3Igbm9uLXJlc3VtYWJsZSB1cGxvYWRzIGlmIGluZGl2aWR1YWxDYW5jZWxsYXRpb24gaXMgc3VwcG9ydGVkIChub3QgYnVuZGxlZClcbiAgaWYgKCFwcm9wcy5yZXN1bWFibGVVcGxvYWRzICYmIHByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24gJiYgIXByb3BzLmhpZGVDYW5jZWxCdXR0b24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgPFByb2dyZXNzSW5kaWNhdG9yQnV0dG9uIHsuLi5wcm9wc30+XG4gICAgICAgIDxQcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgICAgICA8UHJvZ3Jlc3NDaXJjbGUgcHJvZ3Jlc3M9e3Byb3BzLmZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZX0gLz5cbiAgICAgICAgICA8cG9seWdvbiBjbGFzc05hbWU9XCJjYW5jZWxcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMiwgMilcIiBwb2ludHM9XCIxOS44ODU2NTE2IDExLjA2MjUgMTYgMTQuOTQ4MTUxNiAxMi4xMDE5NzM3IDExLjA2MjUgMTEuMDYyNSAxMi4xMTQzNDg0IDE0Ljk0ODE1MTYgMTYgMTEuMDYyNSAxOS44OTgwMjYzIDEyLjEwMTk3MzcgMjAuOTM3NSAxNiAxNy4wNTE4NDg0IDE5Ljg4NTY1MTYgMjAuOTM3NSAyMC45Mzc1IDE5Ljg5ODAyNjMgMTcuMDUxODQ4NCAxNiAyMC45Mzc1IDEyXCIgLz5cbiAgICAgICAgPC9Qcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgIDwvUHJvZ3Jlc3NJbmRpY2F0b3JCdXR0b24+XG4gICAgKVxuICB9XG5cbiAgLy8gSnVzdCBwcm9ncmVzcyB3aGVuIGJ1dHRvbnMgYXJlIGRpc2FibGVkXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJbmRpY2F0b3JcIj5cbiAgICAgICAgPFByb2dyZXNzQ2lyY2xlQ29udGFpbmVyPlxuICAgICAgICAgIDxQcm9ncmVzc0NpcmNsZSBwcm9ncmVzcz17cHJvcHMuZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlfSAvPlxuICAgICAgICA8L1Byb2dyZXNzQ2lyY2xlQ29udGFpbmVyPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3QgbWV0YUZpZWxkSWRUb05hbWUgPSAobWV0YUZpZWxkSWQsIG1ldGFGaWVsZHMpID0+IHtcbiAgY29uc3QgZmllbGQgPSBtZXRhRmllbGRzLmZpbHRlcihmID0+IGYuaWQgPT09IG1ldGFGaWVsZElkKVxuICByZXR1cm4gZmllbGRbMF0ubmFtZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbmRlck1pc3NpbmdNZXRhRmllbGRzRXJyb3IgKHByb3BzKSB7XG4gIGNvbnN0IHsgZmlsZSwgdG9nZ2xlRmlsZUNhcmQsIGkxOG4sIG1ldGFGaWVsZHMgfSA9IHByb3BzXG4gIGNvbnN0IHsgbWlzc2luZ1JlcXVpcmVkTWV0YUZpZWxkcyB9ID0gZmlsZVxuICBpZiAoIW1pc3NpbmdSZXF1aXJlZE1ldGFGaWVsZHM/Lmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBtZXRhRmllbGRzU3RyaW5nID0gbWlzc2luZ1JlcXVpcmVkTWV0YUZpZWxkcy5tYXAobWlzc2luZ01ldGFGaWVsZCA9PiAoXG4gICAgbWV0YUZpZWxkSWRUb05hbWUobWlzc2luZ01ldGFGaWVsZCwgbWV0YUZpZWxkcylcbiAgKSkuam9pbignLCAnKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLWVycm9yTWVzc2FnZVwiPlxuICAgICAge2kxOG4oJ21pc3NpbmdSZXF1aXJlZE1ldGFGaWVsZHMnLCB7XG4gICAgICAgIHNtYXJ0X2NvdW50OiBtaXNzaW5nUmVxdWlyZWRNZXRhRmllbGRzLmxlbmd0aCxcbiAgICAgICAgZmllbGRzOiBtZXRhRmllbGRzU3RyaW5nLFxuICAgICAgfSl9XG4gICAgICB7JyAnfVxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtSXRlbS1lcnJvck1lc3NhZ2VCdG5cIlxuICAgICAgICBvbkNsaWNrPXsoKSA9PiB0b2dnbGVGaWxlQ2FyZCh0cnVlLCBmaWxlLmlkKX1cbiAgICAgID5cbiAgICAgICAge2kxOG4oJ2VkaXRGaWxlJyl9XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdpcy1zaGFsbG93LWVxdWFsJylcbmNvbnN0IEZpbGVQcmV2aWV3QW5kTGluayA9IHJlcXVpcmUoJy4vRmlsZVByZXZpZXdBbmRMaW5rJylcbmNvbnN0IEZpbGVQcm9ncmVzcyA9IHJlcXVpcmUoJy4vRmlsZVByb2dyZXNzJylcbmNvbnN0IEZpbGVJbmZvID0gcmVxdWlyZSgnLi9GaWxlSW5mbycpXG5jb25zdCBCdXR0b25zID0gcmVxdWlyZSgnLi9CdXR0b25zJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGaWxlSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBjb25zdCB7IGZpbGUgfSA9IHRoaXMucHJvcHNcbiAgICBpZiAoIWZpbGUucHJldmlldykge1xuICAgICAgdGhpcy5wcm9wcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpXG4gIH1cblxuICAvLyBWaXJ0dWFsTGlzdCBtb3VudHMgRmlsZUl0ZW1zIGFnYWluIGFuZCB0aGV5IGVtaXQgYHRodW1ibmFpbDpyZXF1ZXN0YFxuICAvLyBPdGhlcndpc2UgdGh1bWJuYWlscyBhcmUgYnJva2VuIG9yIG1pc3NpbmcgYWZ0ZXIgR29sZGVuIFJldHJpZXZlciByZXN0b3JlcyBmaWxlc1xuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIGNvbnN0IHsgZmlsZSB9ID0gdGhpcy5wcm9wc1xuICAgIGlmICghZmlsZS5wcmV2aWV3KSB7XG4gICAgICB0aGlzLnByb3BzLmhhbmRsZVJlcXVlc3RUaHVtYm5haWwoZmlsZSlcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgY29uc3QgeyBmaWxlIH0gPSB0aGlzLnByb3BzXG4gICAgaWYgKCFmaWxlLnByZXZpZXcpIHtcbiAgICAgIHRoaXMucHJvcHMuaGFuZGxlQ2FuY2VsVGh1bWJuYWlsKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCB7IGZpbGUgfSA9IHRoaXMucHJvcHNcblxuICAgIGNvbnN0IGlzUHJvY2Vzc2luZyA9IGZpbGUucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzXG4gICAgY29uc3QgaXNVcGxvYWRlZCA9IGZpbGUucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUgJiYgIWlzUHJvY2Vzc2luZyAmJiAhZmlsZS5lcnJvclxuICAgIGNvbnN0IHVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlID0gZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8IGlzUHJvY2Vzc2luZ1xuICAgIGNvbnN0IHVwbG9hZEluUHJvZ3Jlc3MgPSAoZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkICYmICFmaWxlLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlKSB8fCBpc1Byb2Nlc3NpbmdcbiAgICBjb25zdCBlcnJvciA9IGZpbGUuZXJyb3IgfHwgZmFsc2VcblxuICAgIC8vIEZpbGUgdGhhdCBHb2xkZW4gUmV0cmlldmVyIHdhcyBhYmxlIHRvIHBhcnRseSByZXN0b3JlIChvbmx5IG1ldGEsIG5vdCBibG9iKSxcbiAgICAvLyB1c2VycyBzdGlsbCBuZWVkIHRvIHJlLWFkZCBpdCwgc28gaXTigJlzIGEgZ2hvc3RcbiAgICBjb25zdCB7IGlzR2hvc3QgfSA9IGZpbGVcblxuICAgIGxldCBzaG93UmVtb3ZlQnV0dG9uID0gdGhpcy5wcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uXG4gICAgICA/ICFpc1VwbG9hZGVkXG4gICAgICA6ICF1cGxvYWRJblByb2dyZXNzICYmICFpc1VwbG9hZGVkXG5cbiAgICBpZiAoaXNVcGxvYWRlZCAmJiB0aGlzLnByb3BzLnNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlKSB7XG4gICAgICBzaG93UmVtb3ZlQnV0dG9uID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGRhc2hib2FyZEl0ZW1DbGFzcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgJ3VwcHktRGFzaGJvYXJkLUl0ZW0nOiB0cnVlLFxuICAgICAgJ2lzLWlucHJvZ3Jlc3MnOiB1cGxvYWRJblByb2dyZXNzICYmICF0aGlzLnByb3BzLnJlY292ZXJlZFN0YXRlLFxuICAgICAgJ2lzLXByb2Nlc3NpbmcnOiBpc1Byb2Nlc3NpbmcsXG4gICAgICAnaXMtY29tcGxldGUnOiBpc1VwbG9hZGVkLFxuICAgICAgJ2lzLWVycm9yJzogISFlcnJvcixcbiAgICAgICdpcy1yZXN1bWFibGUnOiB0aGlzLnByb3BzLnJlc3VtYWJsZVVwbG9hZHMsXG4gICAgICAnaXMtbm9JbmRpdmlkdWFsQ2FuY2VsbGF0aW9uJzogIXRoaXMucHJvcHMuaW5kaXZpZHVhbENhbmNlbGxhdGlvbixcbiAgICAgICdpcy1naG9zdCc6IGlzR2hvc3QsXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17ZGFzaGJvYXJkSXRlbUNsYXNzfVxuICAgICAgICBpZD17YHVwcHlfJHtmaWxlLmlkfWB9XG4gICAgICAgIHJvbGU9e3RoaXMucHJvcHMucm9sZX1cbiAgICAgID5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdcIj5cbiAgICAgICAgICA8RmlsZVByZXZpZXdBbmRMaW5rXG4gICAgICAgICAgICBmaWxlPXtmaWxlfVxuICAgICAgICAgICAgc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQ9e3RoaXMucHJvcHMuc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHR9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnByb3BzLmkxOG59XG4gICAgICAgICAgICB0b2dnbGVGaWxlQ2FyZD17dGhpcy5wcm9wcy50b2dnbGVGaWxlQ2FyZH1cbiAgICAgICAgICAgIG1ldGFGaWVsZHM9e3RoaXMucHJvcHMubWV0YUZpZWxkc31cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxGaWxlUHJvZ3Jlc3NcbiAgICAgICAgICAgIHVwcHk9e3RoaXMucHJvcHMudXBweX1cbiAgICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgICBlcnJvcj17ZXJyb3J9XG4gICAgICAgICAgICBpc1VwbG9hZGVkPXtpc1VwbG9hZGVkfVxuICAgICAgICAgICAgaGlkZVJldHJ5QnV0dG9uPXt0aGlzLnByb3BzLmhpZGVSZXRyeUJ1dHRvbn1cbiAgICAgICAgICAgIGhpZGVDYW5jZWxCdXR0b249e3RoaXMucHJvcHMuaGlkZUNhbmNlbEJ1dHRvbn1cbiAgICAgICAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbj17dGhpcy5wcm9wcy5oaWRlUGF1c2VSZXN1bWVCdXR0b259XG4gICAgICAgICAgICByZWNvdmVyZWRTdGF0ZT17dGhpcy5wcm9wcy5yZWNvdmVyZWRTdGF0ZX1cbiAgICAgICAgICAgIHNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlPXt0aGlzLnByb3BzLnNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlfVxuICAgICAgICAgICAgcmVzdW1hYmxlVXBsb2Fkcz17dGhpcy5wcm9wcy5yZXN1bWFibGVVcGxvYWRzfVxuICAgICAgICAgICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbj17dGhpcy5wcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9ufVxuICAgICAgICAgICAgaTE4bj17dGhpcy5wcm9wcy5pMThufVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1maWxlSW5mb0FuZEJ1dHRvbnNcIj5cbiAgICAgICAgICA8RmlsZUluZm9cbiAgICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgICBpZD17dGhpcy5wcm9wcy5pZH1cbiAgICAgICAgICAgIGFjcXVpcmVycz17dGhpcy5wcm9wcy5hY3F1aXJlcnN9XG4gICAgICAgICAgICBjb250YWluZXJXaWR0aD17dGhpcy5wcm9wcy5jb250YWluZXJXaWR0aH1cbiAgICAgICAgICAgIGkxOG49e3RoaXMucHJvcHMuaTE4bn1cbiAgICAgICAgICAgIHRvZ2dsZUFkZEZpbGVzUGFuZWw9e3RoaXMucHJvcHMudG9nZ2xlQWRkRmlsZXNQYW5lbH1cbiAgICAgICAgICAgIHRvZ2dsZUZpbGVDYXJkPXt0aGlzLnByb3BzLnRvZ2dsZUZpbGVDYXJkfVxuICAgICAgICAgICAgbWV0YUZpZWxkcz17dGhpcy5wcm9wcy5tZXRhRmllbGRzfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEJ1dHRvbnNcbiAgICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgICBtZXRhRmllbGRzPXt0aGlzLnByb3BzLm1ldGFGaWVsZHN9XG4gICAgICAgICAgICBzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdD17dGhpcy5wcm9wcy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdH1cbiAgICAgICAgICAgIHNob3dSZW1vdmVCdXR0b249e3Nob3dSZW1vdmVCdXR0b259XG4gICAgICAgICAgICBjYW5FZGl0RmlsZT17dGhpcy5wcm9wcy5jYW5FZGl0RmlsZX1cbiAgICAgICAgICAgIHVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlPXt1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZX1cbiAgICAgICAgICAgIHRvZ2dsZUZpbGVDYXJkPXt0aGlzLnByb3BzLnRvZ2dsZUZpbGVDYXJkfVxuICAgICAgICAgICAgb3BlbkZpbGVFZGl0b3I9e3RoaXMucHJvcHMub3BlbkZpbGVFZGl0b3J9XG4gICAgICAgICAgICB1cHB5PXt0aGlzLnByb3BzLnVwcHl9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnByb3BzLmkxOG59XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cbiIsImNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IEZpbGVJdGVtID0gcmVxdWlyZSgnLi9GaWxlSXRlbS9pbmRleC5qcycpXG5jb25zdCBWaXJ0dWFsTGlzdCA9IHJlcXVpcmUoJy4vVmlydHVhbExpc3QnKVxuXG5mdW5jdGlvbiBjaHVua3MgKGxpc3QsIHNpemUpIHtcbiAgY29uc3QgY2h1bmtlZCA9IFtdXG4gIGxldCBjdXJyZW50Q2h1bmsgPSBbXVxuICBsaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGl0ZW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmspXG4gICAgICBjdXJyZW50Q2h1bmsgPSBbaXRlbV1cbiAgICB9XG4gIH0pXG4gIGlmIChjdXJyZW50Q2h1bmsubGVuZ3RoKSBjaHVua2VkLnB1c2goY3VycmVudENodW5rKVxuICByZXR1cm4gY2h1bmtlZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBub0ZpbGVzID0gcHJvcHMudG90YWxGaWxlQ291bnQgPT09IDBcbiAgY29uc3QgZGFzaGJvYXJkRmlsZXNDbGFzcyA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktRGFzaGJvYXJkLWZpbGVzJyxcbiAgICB7ICd1cHB5LURhc2hib2FyZC1maWxlcy0tbm9GaWxlcyc6IG5vRmlsZXMgfSxcbiAgKVxuXG4gIC8vIEl0J3Mgbm90IGdyZWF0IHRoYXQgdGhpcyBpcyBoYXJkY29kZWQhXG4gIC8vIEl0J3MgRVNQRUNJQUxMWSBub3QgZ3JlYXQgdGhhdCB0aGlzIGlzIGNoZWNraW5nIGFnYWluc3QgYGl0ZW1zUGVyUm93YCFcbiAgY29uc3Qgcm93SGVpZ2h0ID0gcHJvcHMuaXRlbXNQZXJSb3cgPT09IDFcbiAgICAvLyBNb2JpbGVcbiAgICA/IDcxXG4gICAgLy8gMTkwcHggaGVpZ2h0ICsgMiAqIDVweCBtYXJnaW5cbiAgICA6IDIwMFxuXG4gIGNvbnN0IGZpbGVQcm9wcyA9IHtcbiAgICAvLyBGSVhNRSBUaGlzIGlzIGNvbmZ1c2luZywgaXQncyBhY3R1YWxseSB0aGUgRGFzaGJvYXJkJ3MgcGx1Z2luIElEXG4gICAgaWQ6IHByb3BzLmlkLFxuICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBjb250ZXh0XG4gICAgaTE4bjogcHJvcHMuaTE4bixcbiAgICB1cHB5OiBwcm9wcy51cHB5LFxuICAgIC8vIGZlYXR1cmVzXG4gICAgYWNxdWlyZXJzOiBwcm9wcy5hY3F1aXJlcnMsXG4gICAgcmVzdW1hYmxlVXBsb2FkczogcHJvcHMucmVzdW1hYmxlVXBsb2FkcyxcbiAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uOiBwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uLFxuICAgIC8vIHZpc3VhbCBvcHRpb25zXG4gICAgaGlkZVJldHJ5QnV0dG9uOiBwcm9wcy5oaWRlUmV0cnlCdXR0b24sXG4gICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiBwcm9wcy5oaWRlUGF1c2VSZXN1bWVCdXR0b24sXG4gICAgaGlkZUNhbmNlbEJ1dHRvbjogcHJvcHMuaGlkZUNhbmNlbEJ1dHRvbixcbiAgICBzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdDogcHJvcHMuc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQsXG4gICAgc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGU6IHByb3BzLnNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlLFxuICAgIGlzV2lkZTogcHJvcHMuaXNXaWRlLFxuICAgIG1ldGFGaWVsZHM6IHByb3BzLm1ldGFGaWVsZHMsXG4gICAgcmVjb3ZlcmVkU3RhdGU6IHByb3BzLnJlY292ZXJlZFN0YXRlLFxuICAgIC8vIGNhbGxiYWNrc1xuICAgIHRvZ2dsZUZpbGVDYXJkOiBwcm9wcy50b2dnbGVGaWxlQ2FyZCxcbiAgICBoYW5kbGVSZXF1ZXN0VGh1bWJuYWlsOiBwcm9wcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsLFxuICAgIGhhbmRsZUNhbmNlbFRodW1ibmFpbDogcHJvcHMuaGFuZGxlQ2FuY2VsVGh1bWJuYWlsLFxuICB9XG5cbiAgY29uc3Qgc29ydEJ5R2hvc3RDb21lc0ZpcnN0ID0gKGZpbGUxLCBmaWxlMikgPT4ge1xuICAgIHJldHVybiBwcm9wcy5maWxlc1tmaWxlMl0uaXNHaG9zdCAtIHByb3BzLmZpbGVzW2ZpbGUxXS5pc0dob3N0XG4gIH1cblxuICAvLyBTb3J0IGZpbGVzIGJ5IGZpbGUuaXNHaG9zdCwgZ2hvc3QgZmlsZXMgZmlyc3QsIG9ubHkgaWYgcmVjb3ZlcmVkU3RhdGUgaXMgcHJlc2VudFxuICBjb25zdCBmaWxlcyA9IE9iamVjdC5rZXlzKHByb3BzLmZpbGVzKVxuICBpZiAocHJvcHMucmVjb3ZlcmVkU3RhdGUpIGZpbGVzLnNvcnQoc29ydEJ5R2hvc3RDb21lc0ZpcnN0KVxuICBjb25zdCByb3dzID0gY2h1bmtzKGZpbGVzLCBwcm9wcy5pdGVtc1BlclJvdylcblxuICBjb25zdCByZW5kZXJSb3cgPSAocm93KSA9PiAoXG4gICAgLy8gVGhlIGByb2xlPVwicHJlc2VudGF0aW9uYCBhdHRyaWJ1dGUgZW5zdXJlcyB0aGF0IHRoZSBsaXN0IGl0ZW1zIGFyZSBwcm9wZXJseVxuICAgIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGUgYFZpcnR1YWxMaXN0YCBlbGVtZW50LlxuICAgIC8vIFdlIHVzZSB0aGUgZmlyc3QgZmlsZSBJRCBhcyB0aGUga2V54oCUdGhpcyBzaG91bGQgbm90IGNoYW5nZSBhY3Jvc3Mgc2Nyb2xsIHJlcmVuZGVyc1xuICAgIDxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGtleT17cm93WzBdfT5cbiAgICAgIHtyb3cubWFwKChmaWxlSUQpID0+IChcbiAgICAgICAgPEZpbGVJdGVtXG4gICAgICAgICAga2V5PXtmaWxlSUR9XG4gICAgICAgICAgdXBweT17cHJvcHMudXBweX1cbiAgICAgICAgICB7Li4uZmlsZVByb3BzfVxuICAgICAgICAgIHJvbGU9XCJsaXN0aXRlbVwiXG4gICAgICAgICAgb3BlbkZpbGVFZGl0b3I9e3Byb3BzLm9wZW5GaWxlRWRpdG9yfVxuICAgICAgICAgIGNhbkVkaXRGaWxlPXtwcm9wcy5jYW5FZGl0RmlsZX1cbiAgICAgICAgICB0b2dnbGVBZGRGaWxlc1BhbmVsPXtwcm9wcy50b2dnbGVBZGRGaWxlc1BhbmVsfVxuICAgICAgICAgIGZpbGU9e3Byb3BzLmZpbGVzW2ZpbGVJRF19XG4gICAgICAgIC8+XG4gICAgICApKX1cbiAgICA8L2Rpdj5cbiAgKVxuXG4gIHJldHVybiAoXG4gICAgPFZpcnR1YWxMaXN0XG4gICAgICBjbGFzcz17ZGFzaGJvYXJkRmlsZXNDbGFzc31cbiAgICAgIHJvbGU9XCJsaXN0XCJcbiAgICAgIGRhdGE9e3Jvd3N9XG4gICAgICByZW5kZXJSb3c9e3JlbmRlclJvd31cbiAgICAgIHJvd0hlaWdodD17cm93SGVpZ2h0fVxuICAgIC8+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGdldEZpbGVUeXBlSWNvbiA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldEZpbGVUeXBlSWNvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRmlsZVByZXZpZXcgKHByb3BzKSB7XG4gIGNvbnN0IHsgZmlsZSB9ID0gcHJvcHNcblxuICBpZiAoZmlsZS5wcmV2aWV3KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxpbWdcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SW1nXCJcbiAgICAgICAgYWx0PXtmaWxlLm5hbWV9XG4gICAgICAgIHNyYz17ZmlsZS5wcmV2aWV3fVxuICAgICAgLz5cbiAgICApXG4gIH1cblxuICBjb25zdCB7IGNvbG9yLCBpY29uIH0gPSBnZXRGaWxlVHlwZUljb24oZmlsZS50eXBlKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdJY29uV3JhcFwiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SWNvblwiIHN0eWxlPXt7IGNvbG9yIH19PntpY29ufTwvc3Bhbj5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdJY29uQmdcIiB3aWR0aD1cIjU4XCIgaGVpZ2h0PVwiNzZcIiB2aWV3Qm94PVwiMCAwIDU4IDc2XCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjRkZGXCIgd2lkdGg9XCI1OFwiIGhlaWdodD1cIjc2XCIgcng9XCIzXCIgZmlsbFJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBpZ25vcmVFdmVudCA9IHJlcXVpcmUoJy4uL3V0aWxzL2lnbm9yZUV2ZW50LmpzJylcblxuZnVuY3Rpb24gUGlja2VyUGFuZWxDb250ZW50IChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsJywgcHJvcHMuY2xhc3NOYW1lKX1cbiAgICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgICBkYXRhLXVwcHktcGFuZWxUeXBlPVwiUGlja2VyUGFuZWxcIlxuICAgICAgaWQ9e2B1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLSR7cHJvcHMuYWN0aXZlUGlja2VyUGFuZWwuaWR9YH1cbiAgICAgIG9uRHJhZ092ZXI9e2lnbm9yZUV2ZW50fVxuICAgICAgb25EcmFnTGVhdmU9e2lnbm9yZUV2ZW50fVxuICAgICAgb25Ecm9wPXtpZ25vcmVFdmVudH1cbiAgICAgIG9uUGFzdGU9e2lnbm9yZUV2ZW50fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgICB7cHJvcHMuaTE4bignaW1wb3J0RnJvbScsIHsgbmFtZTogcHJvcHMuYWN0aXZlUGlja2VyUGFuZWwubmFtZSB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17cHJvcHMuaGlkZUFsbFBhbmVsc31cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsQm9keVwiPlxuICAgICAgICB7cHJvcHMudXBweS5nZXRQbHVnaW4ocHJvcHMuYWN0aXZlUGlja2VyUGFuZWwuaWQpLnJlbmRlcihwcm9wcy5zdGF0ZSl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBpY2tlclBhbmVsQ29udGVudFxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jb25zdCB1cGxvYWRTdGF0ZXMgPSB7XG4gIFNUQVRFX0VSUk9SOiAnZXJyb3InLFxuICBTVEFURV9XQUlUSU5HOiAnd2FpdGluZycsXG4gIFNUQVRFX1BSRVBST0NFU1NJTkc6ICdwcmVwcm9jZXNzaW5nJyxcbiAgU1RBVEVfVVBMT0FESU5HOiAndXBsb2FkaW5nJyxcbiAgU1RBVEVfUE9TVFBST0NFU1NJTkc6ICdwb3N0cHJvY2Vzc2luZycsXG4gIFNUQVRFX0NPTVBMRVRFOiAnY29tcGxldGUnLFxuICBTVEFURV9QQVVTRUQ6ICdwYXVzZWQnLFxufVxuXG5mdW5jdGlvbiBnZXRVcGxvYWRpbmdTdGF0ZSAoaXNBbGxFcnJvcmVkLCBpc0FsbENvbXBsZXRlLCBpc0FsbFBhdXNlZCwgZmlsZXMgPSB7fSkge1xuICBpZiAoaXNBbGxFcnJvcmVkKSB7XG4gICAgcmV0dXJuIHVwbG9hZFN0YXRlcy5TVEFURV9FUlJPUlxuICB9XG5cbiAgaWYgKGlzQWxsQ29tcGxldGUpIHtcbiAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX0NPTVBMRVRFXG4gIH1cblxuICBpZiAoaXNBbGxQYXVzZWQpIHtcbiAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX1BBVVNFRFxuICB9XG5cbiAgbGV0IHN0YXRlID0gdXBsb2FkU3RhdGVzLlNUQVRFX1dBSVRJTkdcbiAgY29uc3QgZmlsZUlEcyA9IE9iamVjdC5rZXlzKGZpbGVzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVJRHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IHByb2dyZXNzIH0gPSBmaWxlc1tmaWxlSURzW2ldXVxuICAgIC8vIElmIEFOWSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQgcmlnaHQgbm93LCBzaG93IHRoZSB1cGxvYWRpbmcgc3RhdGUuXG4gICAgaWYgKHByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQgJiYgIXByb2dyZXNzLnVwbG9hZENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX1VQTE9BRElOR1xuICAgIH1cbiAgICAvLyBJZiBmaWxlcyBhcmUgYmVpbmcgcHJlcHJvY2Vzc2VkIEFORCBwb3N0cHJvY2Vzc2VkIGF0IHRoaXMgdGltZSwgd2Ugc2hvdyB0aGVcbiAgICAvLyBwcmVwcm9jZXNzIHN0YXRlLiBJZiBhbnkgZmlsZXMgYXJlIGJlaW5nIHVwbG9hZGVkIHdlIHNob3cgdXBsb2FkaW5nLlxuICAgIGlmIChwcm9ncmVzcy5wcmVwcm9jZXNzICYmIHN0YXRlICE9PSB1cGxvYWRTdGF0ZXMuU1RBVEVfVVBMT0FESU5HKSB7XG4gICAgICBzdGF0ZSA9IHVwbG9hZFN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HXG4gICAgfVxuICAgIC8vIElmIE5PIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgb3IgdXBsb2FkZWQgcmlnaHQgbm93LCBidXQgc29tZSBmaWxlcyBhcmVcbiAgICAvLyBiZWluZyBwb3N0cHJvY2Vzc2VkLCBzaG93IHRoZSBwb3N0cHJvY2VzcyBzdGF0ZS5cbiAgICBpZiAocHJvZ3Jlc3MucG9zdHByb2Nlc3MgJiYgc3RhdGUgIT09IHVwbG9hZFN0YXRlcy5TVEFURV9VUExPQURJTkcgJiYgc3RhdGUgIT09IHVwbG9hZFN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HKSB7XG4gICAgICBzdGF0ZSA9IHVwbG9hZFN0YXRlcy5TVEFURV9QT1NUUFJPQ0VTU0lOR1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGVcbn1cblxuZnVuY3Rpb24gVXBsb2FkU3RhdHVzIChwcm9wcykge1xuICBjb25zdCB1cGxvYWRpbmdTdGF0ZSA9IGdldFVwbG9hZGluZ1N0YXRlKFxuICAgIHByb3BzLmlzQWxsRXJyb3JlZCxcbiAgICBwcm9wcy5pc0FsbENvbXBsZXRlLFxuICAgIHByb3BzLmlzQWxsUGF1c2VkLFxuICAgIHByb3BzLmZpbGVzLFxuICApXG5cbiAgc3dpdGNoICh1cGxvYWRpbmdTdGF0ZSkge1xuICAgIGNhc2UgJ3VwbG9hZGluZyc6XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigndXBsb2FkaW5nWEZpbGVzJywgeyBzbWFydF9jb3VudDogcHJvcHMuaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzLmxlbmd0aCB9KVxuICAgIGNhc2UgJ3ByZXByb2Nlc3NpbmcnOlxuICAgIGNhc2UgJ3Bvc3Rwcm9jZXNzaW5nJzpcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCdwcm9jZXNzaW5nWEZpbGVzJywgeyBzbWFydF9jb3VudDogcHJvcHMucHJvY2Vzc2luZ0ZpbGVzLmxlbmd0aCB9KVxuICAgIGNhc2UgJ3BhdXNlZCc6XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigndXBsb2FkUGF1c2VkJylcbiAgICBjYXNlICd3YWl0aW5nJzpcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCd4RmlsZXNTZWxlY3RlZCcsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzLmxlbmd0aCB9KVxuICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCd1cGxvYWRDb21wbGV0ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gUGFuZWxUb3BCYXIgKHByb3BzKSB7XG4gIGxldCB7IGFsbG93TmV3VXBsb2FkIH0gPSBwcm9wc1xuICAvLyBUT0RPIG1heWJlIHRoaXMgc2hvdWxkIGJlIGRvbmUgaW4gLi4vaW5kZXguanMsIHRoZW4ganVzdCBwYXNzIHRoYXQgZG93biBhcyBgYWxsb3dOZXdVcGxvYWRgXG4gIGlmIChhbGxvd05ld1VwbG9hZCAmJiBwcm9wcy5tYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgYWxsb3dOZXdVcGxvYWQgPSBwcm9wcy50b3RhbEZpbGVDb3VudCA8IHByb3BzLm1heE51bWJlck9mRmlsZXNcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFyXCI+XG4gICAgICB7IXByb3BzLmlzQWxsQ29tcGxldGUgJiYgIXByb3BzLmhpZGVDYW5jZWxCdXR0b24gPyAoXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gcHJvcHMudXBweS5jYW5jZWxBbGwoKX1cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IC8+XG4gICAgICApfVxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgPFVwbG9hZFN0YXR1cyB7Li4ucHJvcHN9IC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAge2FsbG93TmV3VXBsb2FkID8gKFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWFkZE1vcmVcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2FkZE1vcmVGaWxlcycpfVxuICAgICAgICAgIHRpdGxlPXtwcm9wcy5pMThuKCdhZGRNb3JlRmlsZXMnKX1cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBwcm9wcy50b2dnbGVBZGRGaWxlc1BhbmVsKHRydWUpfVxuICAgICAgICA+XG4gICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjE1XCIgdmlld0JveD1cIjAgMCAxNSAxNVwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk04IDYuNWg2YS41LjUgMCAwIDEgLjUuNXYuNWEuNS41IDAgMCAxLS41LjVIOHY2YS41LjUgMCAwIDEtLjUuNUg3YS41LjUgMCAwIDEtLjUtLjVWOGgtNmEuNS41IDAgMCAxLS41LS41VjdhLjUuNSAwIDAgMSAuNS0uNWg2di02QS41LjUgMCAwIDEgNyAwaC41YS41LjUgMCAwIDEgLjUuNXY2elwiIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWFkZE1vcmVDYXB0aW9uXCI+e3Byb3BzLmkxOG4oJ2FkZE1vcmUnKX08L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiAvPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhbmVsVG9wQmFyXG4iLCJjb25zdCB7IGNsb25lRWxlbWVudCwgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5cbmNvbnN0IHRyYW5zaXRpb25OYW1lID0gJ3VwcHktdHJhbnNpdGlvbi1zbGlkZURvd25VcCdcbmNvbnN0IGR1cmF0aW9uID0gMjUwXG5cbi8qKlxuICogVmVydGljYWwgc2xpZGUgdHJhbnNpdGlvbi5cbiAqXG4gKiBUaGlzIGNhbiB0YWtlIGEgX3NpbmdsZV8gY2hpbGQgY29tcG9uZW50LCB3aGljaCBfbXVzdF8gYWNjZXB0IGEgYGNsYXNzTmFtZWAgcHJvcC5cbiAqXG4gKiBDdXJyZW50bHkgdGhpcyBpcyBzcGVjaWZpYyB0byB0aGUgYHVwcHktdHJhbnNpdGlvbi1zbGlkZURvd25VcGAgdHJhbnNpdGlvbixcbiAqIGJ1dCBpdCBzaG91bGQgYmUgc2ltcGxlIHRvIGV4dGVuZCB0aGlzIGZvciBhbnkgdHlwZSBvZiBzaW5nbGUtZWxlbWVudFxuICogdHJhbnNpdGlvbiBieSBzZXR0aW5nIHRoZSBDU1MgbmFtZSBhbmQgZHVyYXRpb24gYXMgcHJvcHMuXG4gKi9cbmNsYXNzIFNsaWRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY2FjaGVkQ2hpbGRyZW46IG51bGwsXG4gICAgICBjbGFzc05hbWU6ICcnLFxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IHJlZmFjdG9yIHRvIHN0YWJsZSBsaWZlY3ljbGUgbWV0aG9kXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBjb21wb25lbnRXaWxsVXBkYXRlIChuZXh0UHJvcHMpIHtcbiAgICBjb25zdCB7IGNhY2hlZENoaWxkcmVuIH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3QgY2hpbGQgPSB0b0NoaWxkQXJyYXkobmV4dFByb3BzLmNoaWxkcmVuKVswXVxuXG4gICAgaWYgKGNhY2hlZENoaWxkcmVuID09PSBjaGlsZCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IHBhdGNoID0ge1xuICAgICAgY2FjaGVkQ2hpbGRyZW46IGNoaWxkLFxuICAgIH1cblxuICAgIC8vIEVudGVyIHRyYW5zaXRpb25cbiAgICBpZiAoY2hpbGQgJiYgIWNhY2hlZENoaWxkcmVuKSB7XG4gICAgICBwYXRjaC5jbGFzc05hbWUgPSBgJHt0cmFuc2l0aW9uTmFtZX0tZW50ZXJgXG5cbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5sZWF2ZVRpbWVvdXQpXG4gICAgICB0aGlzLmxlYXZlVGltZW91dCA9IHVuZGVmaW5lZFxuXG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgLy8gRm9yY2UgaXQgdG8gcmVuZGVyIGJlZm9yZSB3ZSBhZGQgdGhlIGFjdGl2ZSBjbGFzc1xuICAgICAgICAvLyB0aGlzLmJhc2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjbGFzc05hbWU6IGAke3RyYW5zaXRpb25OYW1lfS1lbnRlciAke3RyYW5zaXRpb25OYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuZW50ZXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNsYXNzTmFtZTogJycgfSlcbiAgICAgICAgfSwgZHVyYXRpb24pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIExlYXZlIHRyYW5zaXRpb25cbiAgICBpZiAoY2FjaGVkQ2hpbGRyZW4gJiYgIWNoaWxkICYmIHRoaXMubGVhdmVUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhdGNoLmNhY2hlZENoaWxkcmVuID0gY2FjaGVkQ2hpbGRyZW5cbiAgICAgIHBhdGNoLmNsYXNzTmFtZSA9IGAke3RyYW5zaXRpb25OYW1lfS1sZWF2ZWBcblxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZSlcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVudGVyVGltZW91dClcbiAgICAgIHRoaXMuZW50ZXJUaW1lb3V0ID0gdW5kZWZpbmVkXG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBgJHt0cmFuc2l0aW9uTmFtZX0tbGVhdmUgJHt0cmFuc2l0aW9uTmFtZX0tbGVhdmUtYWN0aXZlYCxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmxlYXZlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY2FjaGVkQ2hpbGRyZW46IG51bGwsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0sIGR1cmF0aW9uKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB0aGlzLnNldFN0YXRlKHBhdGNoKVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCB7IGNhY2hlZENoaWxkcmVuLCBjbGFzc05hbWUgfSA9IHRoaXMuc3RhdGVcblxuICAgIGlmICghY2FjaGVkQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjYWNoZWRDaGlsZHJlbiwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNsYXNzTmFtZSwgY2FjaGVkQ2hpbGRyZW4ucHJvcHMuY2xhc3NOYW1lKSxcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVcbiIsIi8qKlxuICogQWRhcHRlZCBmcm9tIHByZWFjdC12aXJ0dWFsLWxpc3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0LXZpcnR1YWwtbGlzdFxuICpcbiAqIMKpIDIwMTYgSmFzb24gTWlsbGVyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBBZGFwdGF0aW9uczpcbiAqIC0gQWRkZWQgcm9sZT1wcmVzZW50YXRpb24gdG8gaGVscGVyIGVsZW1lbnRzXG4gKiAtIFR3ZWFrZWQgc3R5bGVzIGZvciBVcHB5J3MgRGFzaGJvYXJkIHVzZSBjYXNlXG4gKi9cblxuY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IFNUWUxFX0lOTkVSID0ge1xuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgLy8gRGlzYWJsZWQgZm9yIG91ciB1c2UgY2FzZTogdGhlIHdyYXBwZXIgZWxlbWVudHMgYXJvdW5kIEZpbGVMaXN0IGFscmVhZHkgZGVhbCB3aXRoIG92ZXJmbG93LFxuICAvLyBhbmQgdGhpcyBhZGRpdGlvbmFsIHByb3BlcnR5IHdvdWxkIGhpZGUgdGhpbmdzIHRoYXQgd2Ugd2FudCB0byBzaG93LlxuICAvL1xuICAvLyBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHdpZHRoOiAnMTAwJScsXG4gIG1pbkhlaWdodDogJzEwMCUnLFxufVxuXG5jb25zdCBTVFlMRV9DT05URU5UID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgdG9wOiAwLFxuICBsZWZ0OiAwLFxuICAvLyBCZWNhdXNlIHRoZSBgdG9wYCB2YWx1ZSBnZXRzIHNldCB0byBzb21lIG9mZnNldCwgdGhpcyBgaGVpZ2h0YCBiZWluZyAxMDAlIHdvdWxkIG1ha2UgdGhlIHNjcm9sbGJhclxuICAvLyBzdHJldGNoIGZhciBiZXlvbmQgdGhlIGNvbnRlbnQuIEZvciBvdXIgdXNlIGNhc2UsIHRoZSBjb250ZW50IGRpdiBhY3R1YWxseSBjYW4gZ2V0IGl0cyBoZWlnaHQgZnJvbVxuICAvLyB0aGUgZWxlbWVudHMgaW5zaWRlIGl0LCBzbyB3ZSBkb24ndCBuZWVkIHRvIHNwZWNpZnkgYSBgaGVpZ2h0YCBwcm9wZXJ0eSBhdCBhbGwuXG4gIC8vXG4gIC8vIGhlaWdodDogJzEwMCUnLFxuICB3aWR0aDogJzEwMCUnLFxuICBvdmVyZmxvdzogJ3Zpc2libGUnLFxufVxuXG5jbGFzcyBWaXJ0dWFsTGlzdCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgLy8gVGhlIGN1cnJlbnRseSBmb2N1c2VkIG5vZGUsIHVzZWQgdG8gcmV0YWluIGZvY3VzIHdoZW4gdGhlIHZpc2libGUgcm93cyBjaGFuZ2UuXG4gICAgLy8gVG8gYXZvaWQgdXBkYXRlIGxvb3BzLCB0aGlzIHNob3VsZCBub3QgY2F1c2Ugc3RhdGUgdXBkYXRlcywgc28gaXQncyBrZXB0IGFzIGEgcGxhaW4gcHJvcGVydHkuXG4gICAgdGhpcy5mb2N1c0VsZW1lbnQgPSBudWxsXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLnJlc2l6ZSgpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKVxuICB9XG5cbiAgLy8gVE9ETzogcmVmYWN0b3IgdG8gc3RhYmxlIGxpZmVjeWNsZSBtZXRob2RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUgKCkge1xuICAgIGlmICh0aGlzLmJhc2UuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuZm9jdXNFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgLy8gTWFpbnRhaW4gZm9jdXMgd2hlbiByb3dzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbiAgICBpZiAodGhpcy5mb2N1c0VsZW1lbnQgJiYgdGhpcy5mb2N1c0VsZW1lbnQucGFyZW50Tm9kZVxuICAgICAgICAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0aGlzLmZvY3VzRWxlbWVudCkge1xuICAgICAgdGhpcy5mb2N1c0VsZW1lbnQuZm9jdXMoKVxuICAgIH1cbiAgICB0aGlzLmZvY3VzRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnJlc2l6ZSgpXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBvZmZzZXQ6IHRoaXMuYmFzZS5zY3JvbGxUb3AgfSlcbiAgfVxuXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLnJlc2l6ZSgpXG4gIH1cblxuICByZXNpemUgKCkge1xuICAgIGNvbnN0IHsgaGVpZ2h0IH0gPSB0aGlzLnN0YXRlXG5cbiAgICBpZiAoaGVpZ2h0ICE9PSB0aGlzLmJhc2Uub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmJhc2Uub2Zmc2V0SGVpZ2h0LFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZW5kZXIgKHtcbiAgICBkYXRhLFxuICAgIHJvd0hlaWdodCxcbiAgICByZW5kZXJSb3csXG4gICAgb3ZlcnNjYW5Db3VudCA9IDEwLFxuICAgIC4uLnByb3BzXG4gIH0pIHtcbiAgICBjb25zdCB7IG9mZnNldCwgaGVpZ2h0IH0gPSB0aGlzLnN0YXRlXG4gICAgLy8gZmlyc3QgdmlzaWJsZSByb3cgaW5kZXhcbiAgICBsZXQgc3RhcnQgPSBNYXRoLmZsb29yKG9mZnNldCAvIHJvd0hlaWdodClcblxuICAgIC8vIGFjdHVhbCBudW1iZXIgb2YgdmlzaWJsZSByb3dzICh3aXRob3V0IG92ZXJzY2FuKVxuICAgIGxldCB2aXNpYmxlUm93Q291bnQgPSBNYXRoLmZsb29yKGhlaWdodCAvIHJvd0hlaWdodClcblxuICAgIC8vIE92ZXJzY2FuOiByZW5kZXIgYmxvY2tzIG9mIHJvd3MgbW9kdWxvIGFuIG92ZXJzY2FuIHJvdyBjb3VudFxuICAgIC8vIFRoaXMgZHJhbWF0aWNhbGx5IHJlZHVjZXMgRE9NIHdyaXRlcyBkdXJpbmcgc2Nyb2xsaW5nXG4gICAgaWYgKG92ZXJzY2FuQ291bnQpIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSAoc3RhcnQgJSBvdmVyc2NhbkNvdW50KSlcbiAgICAgIHZpc2libGVSb3dDb3VudCArPSBvdmVyc2NhbkNvdW50XG4gICAgfVxuXG4gICAgLy8gbGFzdCB2aXNpYmxlICsgb3ZlcnNjYW4gcm93IGluZGV4ICsgcGFkZGluZyB0byBhbGxvdyBrZXlib2FyZCBmb2N1cyB0byB0cmF2ZWwgcGFzdCB0aGUgdmlzaWJsZSBhcmVhXG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyB2aXNpYmxlUm93Q291bnQgKyA0XG5cbiAgICAvLyBkYXRhIHNsaWNlIGN1cnJlbnRseSBpbiB2aWV3cG9ydCBwbHVzIG92ZXJzY2FuIGl0ZW1zXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZGF0YS5zbGljZShzdGFydCwgZW5kKVxuXG4gICAgY29uc3Qgc3R5bGVJbm5lciA9IHsgLi4uU1RZTEVfSU5ORVIsIGhlaWdodDogZGF0YS5sZW5ndGggKiByb3dIZWlnaHQgfVxuICAgIGNvbnN0IHN0eWxlQ29udGVudCA9IHsgLi4uU1RZTEVfQ09OVEVOVCwgdG9wOiBzdGFydCAqIHJvd0hlaWdodCB9XG5cbiAgICAvLyBUaGUgYHJvbGU9XCJwcmVzZW50YXRpb25cImAgYXR0cmlidXRlcyBlbnN1cmUgdGhhdCB0aGVzZSB3cmFwcGVyIGVsZW1lbnRzIGFyZSBub3QgdHJlYXRlZCBhcyBsaXN0XG4gICAgLy8gaXRlbXMgYnkgYWNjZXNzaWJpbGl0eSBhbmQgb3V0bGluZSB0b29scy5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBvblNjcm9sbD17dGhpcy5oYW5kbGVTY3JvbGx9IHsuLi5wcm9wc30+XG4gICAgICAgIDxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIHN0eWxlPXtzdHlsZUlubmVyfT5cbiAgICAgICAgICA8ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBzdHlsZT17c3R5bGVDb250ZW50fT5cbiAgICAgICAgICAgIHtzZWxlY3Rpb24ubWFwKHJlbmRlclJvdyl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmlydHVhbExpc3RcbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IHsgVUlQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgU3RhdHVzQmFyID0gcmVxdWlyZSgnQHVwcHkvc3RhdHVzLWJhcicpXG5jb25zdCBJbmZvcm1lciA9IHJlcXVpcmUoJ0B1cHB5L2luZm9ybWVyJylcbmNvbnN0IFRodW1ibmFpbEdlbmVyYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3RodW1ibmFpbC1nZW5lcmF0b3InKVxuY29uc3QgZmluZEFsbERPTUVsZW1lbnRzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZpbmRBbGxET01FbGVtZW50cycpXG5jb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RvQXJyYXknKVxuY29uc3QgZ2V0RHJvcHBlZEZpbGVzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldERyb3BwZWRGaWxlcycpXG5jb25zdCBnZXRUZXh0RGlyZWN0aW9uID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldFRleHREaXJlY3Rpb24nKVxuY29uc3QgeyBuYW5vaWQgfSA9IHJlcXVpcmUoJ25hbm9pZCcpXG5jb25zdCB0cmFwRm9jdXMgPSByZXF1aXJlKCcuL3V0aWxzL3RyYXBGb2N1cycpXG5jb25zdCBjcmVhdGVTdXBlckZvY3VzID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTdXBlckZvY3VzJylcbmNvbnN0IG1lbW9pemUgPSByZXF1aXJlKCdtZW1vaXplLW9uZScpLmRlZmF1bHQgfHwgcmVxdWlyZSgnbWVtb2l6ZS1vbmUnKVxuY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0ZPQ1VTQUJMRV9FTEVNRU5UUycpXG5jb25zdCBEYXNoYm9hcmRVSSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9EYXNoYm9hcmQnKVxuXG5jb25zdCBsb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZScpXG5cbmNvbnN0IFRBQl9LRVkgPSA5XG5jb25zdCBFU0NfS0VZID0gMjdcblxuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZSAoKSB7XG4gIGNvbnN0IG8gPSB7fVxuICBvLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgby5yZXNvbHZlID0gcmVzb2x2ZVxuICAgIG8ucmVqZWN0ID0gcmVqZWN0XG4gIH0pXG4gIHJldHVybiBvXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQaWNrZXJJY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMFwiIGhlaWdodD1cIjMwXCIgdmlld0JveD1cIjAgMCAzMCAzMFwiPlxuICAgICAgPHBhdGggZD1cIk0xNSAzMGM4LjI4NCAwIDE1LTYuNzE2IDE1LTE1IDAtOC4yODQtNi43MTYtMTUtMTUtMTVDNi43MTYgMCAwIDYuNzE2IDAgMTVjMCA4LjI4NCA2LjcxNiAxNSAxNSAxNXptNC4yNTgtMTIuNjc2djYuODQ2aC04LjQyNnYtNi44NDZINS4yMDRsOS44Mi0xMi4zNjQgOS44MiAxMi4zNjRIMTkuMjZ6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG4vKipcbiAqIERhc2hib2FyZCBVSSB3aXRoIHByZXZpZXdzLCBtZXRhZGF0YSBlZGl0aW5nLCB0YWJzIGZvciB2YXJpb3VzIHNlcnZpY2VzIGFuZCBtb3JlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRGFzaGJvYXJkIGV4dGVuZHMgVUlQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnRGFzaGJvYXJkJ1xuICAgIHRoaXMudGl0bGUgPSAnRGFzaGJvYXJkJ1xuICAgIHRoaXMudHlwZSA9ICdvcmNoZXN0cmF0b3InXG4gICAgdGhpcy5tb2RhbE5hbWUgPSBgdXBweS1EYXNoYm9hcmQtJHtuYW5vaWQoKX1gXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBsb2NhbGVcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRhcmdldDogJ2JvZHknLFxuICAgICAgbWV0YUZpZWxkczogW10sXG4gICAgICB0cmlnZ2VyOiBudWxsLFxuICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgIHdpZHRoOiA3NTAsXG4gICAgICBoZWlnaHQ6IDU1MCxcbiAgICAgIHRodW1ibmFpbFdpZHRoOiAyODAsXG4gICAgICB0aHVtYm5haWxUeXBlOiAnaW1hZ2UvanBlZycsXG4gICAgICB3YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZDogZmFsc2UsXG4gICAgICBkZWZhdWx0UGlja2VySWNvbixcbiAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0OiBmYWxzZSxcbiAgICAgIHNob3dQcm9ncmVzc0RldGFpbHM6IGZhbHNlLFxuICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlQ2FuY2VsQnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVSZXRyeUJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVByb2dyZXNzQWZ0ZXJGaW5pc2g6IGZhbHNlLFxuICAgICAgZG9uZUJ1dHRvbkhhbmRsZXI6ICgpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LnJlc2V0KClcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q2xvc2VNb2RhbCgpXG4gICAgICB9LFxuICAgICAgbm90ZTogbnVsbCxcbiAgICAgIGNsb3NlTW9kYWxPbkNsaWNrT3V0c2lkZTogZmFsc2UsXG4gICAgICBjbG9zZUFmdGVyRmluaXNoOiBmYWxzZSxcbiAgICAgIGRpc2FibGVTdGF0dXNCYXI6IGZhbHNlLFxuICAgICAgZGlzYWJsZUluZm9ybWVyOiBmYWxzZSxcbiAgICAgIGRpc2FibGVUaHVtYm5haWxHZW5lcmF0b3I6IGZhbHNlLFxuICAgICAgZGlzYWJsZVBhZ2VTY3JvbGxXaGVuTW9kYWxPcGVuOiB0cnVlLFxuICAgICAgYW5pbWF0ZU9wZW5DbG9zZTogdHJ1ZSxcbiAgICAgIGZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZTogJ2ZpbGVzJyxcbiAgICAgIHByb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweTogdHJ1ZSxcbiAgICAgIG9uUmVxdWVzdENsb3NlTW9kYWw6ICgpID0+IHRoaXMuY2xvc2VNb2RhbCgpLFxuICAgICAgc2hvd1NlbGVjdGVkRmlsZXM6IHRydWUsXG4gICAgICBzaG93UmVtb3ZlQnV0dG9uQWZ0ZXJDb21wbGV0ZTogZmFsc2UsXG4gICAgICBicm93c2VyQmFja0J1dHRvbkNsb3NlOiBmYWxzZSxcbiAgICAgIHRoZW1lOiAnbGlnaHQnLFxuICAgICAgYXV0b09wZW5GaWxlRWRpdG9yOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIGRpc2FibGVMb2NhbEZpbGVzOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG5cbiAgICB0aGlzLnN1cGVyRm9jdXMgPSBjcmVhdGVTdXBlckZvY3VzKClcbiAgICB0aGlzLmlmRm9jdXNlZE9uVXBweVJlY2VudGx5ID0gZmFsc2VcblxuICAgIC8vIFRpbWVvdXRzXG4gICAgdGhpcy5tYWtlRGFzaGJvYXJkSW5zaWRlc1Zpc2libGVBbnl3YXlUaW1lb3V0ID0gbnVsbFxuICAgIHRoaXMucmVtb3ZlRHJhZ092ZXJDbGFzc1RpbWVvdXQgPSBudWxsXG4gIH1cblxuICByZW1vdmVUYXJnZXQgPSAocGx1Z2luKSA9PiB7XG4gICAgY29uc3QgcGx1Z2luU3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICAvLyBmaWx0ZXIgb3V0IHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmVcbiAgICBjb25zdCBuZXdUYXJnZXRzID0gcGx1Z2luU3RhdGUudGFyZ2V0cy5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC5pZCAhPT0gcGx1Z2luLmlkKVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICB0YXJnZXRzOiBuZXdUYXJnZXRzLFxuICAgIH0pXG4gIH1cblxuICBhZGRUYXJnZXQgPSAocGx1Z2luKSA9PiB7XG4gICAgY29uc3QgY2FsbGVyUGx1Z2luSWQgPSBwbHVnaW4uaWQgfHwgcGx1Z2luLmNvbnN0cnVjdG9yLm5hbWVcbiAgICBjb25zdCBjYWxsZXJQbHVnaW5OYW1lID0gcGx1Z2luLnRpdGxlIHx8IGNhbGxlclBsdWdpbklkXG4gICAgY29uc3QgY2FsbGVyUGx1Z2luVHlwZSA9IHBsdWdpbi50eXBlXG5cbiAgICBpZiAoY2FsbGVyUGx1Z2luVHlwZSAhPT0gJ2FjcXVpcmVyJ1xuICAgICAgICAmJiBjYWxsZXJQbHVnaW5UeXBlICE9PSAncHJvZ3Jlc3NpbmRpY2F0b3InXG4gICAgICAgICYmIGNhbGxlclBsdWdpblR5cGUgIT09ICdlZGl0b3InKSB7XG4gICAgICBjb25zdCBtc2cgPSAnRGFzaGJvYXJkOiBjYW4gb25seSBiZSB0YXJnZXRlZCBieSBwbHVnaW5zIG9mIHR5cGVzOiBhY3F1aXJlciwgcHJvZ3Jlc3NpbmRpY2F0b3IsIGVkaXRvcidcbiAgICAgIHRoaXMudXBweS5sb2cobXNnLCAnZXJyb3InKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0ge1xuICAgICAgaWQ6IGNhbGxlclBsdWdpbklkLFxuICAgICAgbmFtZTogY2FsbGVyUGx1Z2luTmFtZSxcbiAgICAgIHR5cGU6IGNhbGxlclBsdWdpblR5cGUsXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBuZXdUYXJnZXRzID0gc3RhdGUudGFyZ2V0cy5zbGljZSgpXG4gICAgbmV3VGFyZ2V0cy5wdXNoKHRhcmdldClcblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgdGFyZ2V0czogbmV3VGFyZ2V0cyxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXMuZWxcbiAgfVxuXG4gIGhpZGVBbGxQYW5lbHMgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICBhY3RpdmVQaWNrZXJQYW5lbDogZmFsc2UsXG4gICAgICBzaG93QWRkRmlsZXNQYW5lbDogZmFsc2UsXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogbnVsbCxcbiAgICAgIGZpbGVDYXJkRm9yOiBudWxsLFxuICAgICAgc2hvd0ZpbGVFZGl0b3I6IGZhbHNlLFxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5hY3RpdmVQaWNrZXJQYW5lbCA9PT0gdXBkYXRlLmFjdGl2ZVBpY2tlclBhbmVsXG4gICAgICAgICYmIHN0YXRlLnNob3dBZGRGaWxlc1BhbmVsID09PSB1cGRhdGUuc2hvd0FkZEZpbGVzUGFuZWxcbiAgICAgICAgJiYgc3RhdGUuc2hvd0ZpbGVFZGl0b3IgPT09IHVwZGF0ZS5zaG93RmlsZUVkaXRvclxuICAgICAgICAmJiBzdGF0ZS5hY3RpdmVPdmVybGF5VHlwZSA9PT0gdXBkYXRlLmFjdGl2ZU92ZXJsYXlUeXBlKSB7XG4gICAgICAvLyBhdm9pZCBkb2luZyBhIHN0YXRlIHVwZGF0ZSBpZiBub3RoaW5nIGNoYW5nZWRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUodXBkYXRlKVxuICB9XG5cbiAgc2hvd1BhbmVsID0gKGlkKSA9PiB7XG4gICAgY29uc3QgeyB0YXJnZXRzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcblxuICAgIGNvbnN0IGFjdGl2ZVBpY2tlclBhbmVsID0gdGFyZ2V0cy5maWx0ZXIoKHRhcmdldCkgPT4ge1xuICAgICAgcmV0dXJuIHRhcmdldC50eXBlID09PSAnYWNxdWlyZXInICYmIHRhcmdldC5pZCA9PT0gaWRcbiAgICB9KVswXVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBhY3RpdmVQaWNrZXJQYW5lbCxcbiAgICAgIGFjdGl2ZU92ZXJsYXlUeXBlOiAnUGlja2VyUGFuZWwnLFxuICAgIH0pXG4gIH1cblxuICBjYW5FZGl0RmlsZSA9IChmaWxlKSA9PiB7XG4gICAgY29uc3QgeyB0YXJnZXRzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBlZGl0b3JzID0gdGhpcy4jZ2V0RWRpdG9ycyh0YXJnZXRzKVxuXG4gICAgcmV0dXJuIGVkaXRvcnMuc29tZSgodGFyZ2V0KSA9PiAoXG4gICAgICB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRhcmdldC5pZCkuY2FuRWRpdEZpbGUoZmlsZSlcbiAgICApKVxuICB9XG5cbiAgb3BlbkZpbGVFZGl0b3IgPSAoZmlsZSkgPT4ge1xuICAgIGNvbnN0IHsgdGFyZ2V0cyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgZWRpdG9ycyA9IHRoaXMuI2dldEVkaXRvcnModGFyZ2V0cylcblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgc2hvd0ZpbGVFZGl0b3I6IHRydWUsXG4gICAgICBmaWxlQ2FyZEZvcjogZmlsZS5pZCB8fCBudWxsLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6ICdGaWxlRWRpdG9yJyxcbiAgICB9KVxuXG4gICAgZWRpdG9ycy5mb3JFYWNoKChlZGl0b3IpID0+IHtcbiAgICAgIHRoaXMudXBweS5nZXRQbHVnaW4oZWRpdG9yLmlkKS5zZWxlY3RGaWxlKGZpbGUpXG4gICAgfSlcbiAgfVxuXG4gIHNhdmVGaWxlRWRpdG9yID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdGFyZ2V0cyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgZWRpdG9ycyA9IHRoaXMuI2dldEVkaXRvcnModGFyZ2V0cylcblxuICAgIGVkaXRvcnMuZm9yRWFjaCgoZWRpdG9yKSA9PiB7XG4gICAgICB0aGlzLnVwcHkuZ2V0UGx1Z2luKGVkaXRvci5pZCkuc2F2ZSgpXG4gICAgfSlcblxuICAgIHRoaXMuaGlkZUFsbFBhbmVscygpXG4gIH1cblxuICBvcGVuTW9kYWwgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVQcm9taXNlKClcbiAgICAvLyBzYXZlIHNjcm9sbCBwb3NpdGlvblxuICAgIHRoaXMuc2F2ZWRTY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIC8vIHNhdmUgYWN0aXZlIGVsZW1lbnQsIHNvIHdlIGNhbiByZXN0b3JlIGZvY3VzIHdoZW4gbW9kYWwgaXMgY2xvc2VkXG4gICAgdGhpcy5zYXZlZEFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVQYWdlU2Nyb2xsV2hlbk1vZGFsT3Blbikge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCd1cHB5LURhc2hib2FyZC1pc0ZpeGVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmFuaW1hdGVPcGVuQ2xvc2UgJiYgdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmlzQ2xvc2luZykge1xuICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgaXNIaWRkZW46IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc0hpZGRlbjogZmFsc2UsXG4gICAgICB9KVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5icm93c2VyQmFja0J1dHRvbkNsb3NlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJyb3dzZXJIaXN0b3J5KClcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgRVNDIGFuZCBUQUIga2V5cyBpbiBtb2RhbCBkaWFsb2dcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duSW5Nb2RhbClcblxuICAgIHRoaXMudXBweS5lbWl0KCdkYXNoYm9hcmQ6bW9kYWwtb3BlbicpXG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgY2xvc2VNb2RhbCA9IChvcHRzID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAvLyBXaGV0aGVyIHRoZSBtb2RhbCBpcyBiZWluZyBjbG9zZWQgYnkgdGhlIHVzZXIgKGB0cnVlYCkgb3IgYnkgb3RoZXIgbWVhbnMgKGUuZy4gYnJvd3NlciBiYWNrIGJ1dHRvbilcbiAgICAgIG1hbnVhbENsb3NlID0gdHJ1ZSxcbiAgICB9ID0gb3B0c1xuXG4gICAgY29uc3QgeyBpc0hpZGRlbiwgaXNDbG9zaW5nIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBpZiAoaXNIaWRkZW4gfHwgaXNDbG9zaW5nKSB7XG4gICAgICAvLyBzaG9ydC1jaXJjdWl0IGlmIGFuaW1hdGlvbiBpcyBvbmdvaW5nXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZVByb21pc2UoKVxuXG4gICAgaWYgKHRoaXMub3B0cy5kaXNhYmxlUGFnZVNjcm9sbFdoZW5Nb2RhbE9wZW4pIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgndXBweS1EYXNoYm9hcmQtaXNGaXhlZCcpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5hbmltYXRlT3BlbkNsb3NlKSB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgaXNDbG9zaW5nOiB0cnVlLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAgIGlzSGlkZGVuOiB0cnVlLFxuICAgICAgICAgIGlzQ2xvc2luZzogZmFsc2UsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5zdXBlckZvY3VzLmNhbmNlbCgpXG4gICAgICAgIHRoaXMuc2F2ZWRBY3RpdmVFbGVtZW50LmZvY3VzKClcblxuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuc3VwZXJGb2N1cy5jYW5jZWwoKVxuICAgICAgdGhpcy5zYXZlZEFjdGl2ZUVsZW1lbnQuZm9jdXMoKVxuXG4gICAgICByZXNvbHZlKClcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgRVNDIGFuZCBUQUIga2V5cyBpbiBtb2RhbCBkaWFsb2dcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duSW5Nb2RhbClcblxuICAgIGlmIChtYW51YWxDbG9zZSkge1xuICAgICAgaWYgKHRoaXMub3B0cy5icm93c2VyQmFja0J1dHRvbkNsb3NlKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBsYXRlc3QgZW50cnkgaW4gdGhlIGhpc3Rvcnkgc3RhdGUgaXMgb3VyIG1vZGFsIG5hbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICBpZiAoaGlzdG9yeS5zdGF0ZT8uW3RoaXMubW9kYWxOYW1lXSkge1xuICAgICAgICAgIC8vIEdvIGJhY2sgaW4gaGlzdG9yeSB0byBjbGVhciBvdXQgdGhlIGVudHJ5IHdlIGNyZWF0ZWQgKHVsdGltYXRlbHkgY2xvc2luZyB0aGUgbW9kYWwpXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgIGhpc3RvcnkuYmFjaygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwcHkuZW1pdCgnZGFzaGJvYXJkOm1vZGFsLWNsb3NlZCcpXG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgaXNNb2RhbE9wZW4gPSAoKSA9PiB7XG4gICAgcmV0dXJuICF0aGlzLmdldFBsdWdpblN0YXRlKCkuaXNIaWRkZW4gfHwgZmFsc2VcbiAgfVxuXG4gIHJlcXVlc3RDbG9zZU1vZGFsID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLm9wdHMub25SZXF1ZXN0Q2xvc2VNb2RhbCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0cy5vblJlcXVlc3RDbG9zZU1vZGFsKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VNb2RhbCgpXG4gIH1cblxuICBzZXREYXJrTW9kZUNhcGFiaWxpdHkgPSAoaXNEYXJrTW9kZU9uKSA9PiB7XG4gICAgY29uc3QgeyBjYXBhYmlsaXRpZXMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICAuLi5jYXBhYmlsaXRpZXMsXG4gICAgICAgIGRhcmtNb2RlOiBpc0RhcmtNb2RlT24sXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVTeXN0ZW1EYXJrTW9kZUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGlzRGFya01vZGVPbk5vdyA9IGV2ZW50Lm1hdGNoZXNcbiAgICB0aGlzLnVwcHkubG9nKGBbRGFzaGJvYXJkXSBEYXJrIG1vZGUgaXMgJHtpc0RhcmtNb2RlT25Ob3cgPyAnb24nIDogJ29mZid9YClcbiAgICB0aGlzLnNldERhcmtNb2RlQ2FwYWJpbGl0eShpc0RhcmtNb2RlT25Ob3cpXG4gIH1cblxuICB0b2dnbGVGaWxlQ2FyZCA9IChzaG93LCBmaWxlSUQpID0+IHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgIGlmIChzaG93KSB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgnZGFzaGJvYXJkOmZpbGUtZWRpdC1zdGFydCcsIGZpbGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCdkYXNoYm9hcmQ6ZmlsZS1lZGl0LWNvbXBsZXRlJywgZmlsZSlcbiAgICB9XG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGZpbGVDYXJkRm9yOiBzaG93ID8gZmlsZUlEIDogbnVsbCxcbiAgICAgIGFjdGl2ZU92ZXJsYXlUeXBlOiBzaG93ID8gJ0ZpbGVDYXJkJyA6IG51bGwsXG4gICAgfSlcbiAgfVxuXG4gIHRvZ2dsZUFkZEZpbGVzUGFuZWwgPSAoc2hvdykgPT4ge1xuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgc2hvd0FkZEZpbGVzUGFuZWw6IHNob3csXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogc2hvdyA/ICdBZGRGaWxlcycgOiBudWxsLFxuICAgIH0pXG4gIH1cblxuICBhZGRGaWxlcyA9IChmaWxlcykgPT4ge1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsZXMubWFwKChmaWxlKSA9PiAoe1xuICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgZGF0YTogZmlsZSxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLy8gcGF0aCBvZiB0aGUgZmlsZSByZWxhdGl2ZSB0byB0aGUgYW5jZXN0b3IgZGlyZWN0b3J5IHRoZSB1c2VyIHNlbGVjdGVkLlxuICAgICAgICAvLyBlLmcuICdkb2NzL09sZCBQcmFndWUvYWlyYm5iLnBkZidcbiAgICAgICAgcmVsYXRpdmVQYXRoOiBmaWxlLnJlbGF0aXZlUGF0aCB8fCBudWxsLFxuICAgICAgfSxcbiAgICB9KSlcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwcHkuYWRkRmlsZXMoZGVzY3JpcHRvcnMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICB9XG4gIH1cblxuICAvLyBfX19XaHkgbWFrZSBpbnNpZGVzIG9mIERhc2hib2FyZCBpbnZpc2libGUgdW50aWwgZmlyc3QgUmVzaXplT2JzZXJ2ZXIgZXZlbnQgaXMgZW1pdHRlZD9cbiAgLy8gICAgUmVzaXplT2JlcnNlcnZlciBkb2Vzbid0IGVtaXQgdGhlIGZpcnN0IHJlc2l6ZSBldmVudCBmYXN0IGVub3VnaCwgdXNlcnMgY2FuIHNlZSB0aGUganVtcCBmcm9tIG9uZSAudXBweS1zaXplLS0gdG9cbiAgLy8gICAgYW5vdGhlciAoZS5nLiBpbiBTYWZhcmkpXG4gIC8vIF9fX1doeSBub3QgYXBwbHkgdmlzaWJpbGl0eSBwcm9wZXJ0eSB0byAudXBweS1EYXNoYm9hcmQtaW5uZXI/XG4gIC8vICAgIEJlY2F1c2UgaWRlYWxseSwgYWNjIHRvIHNwZWNzLCBSZXNpemVPYnNlcnZlciBzaG91bGQgc2VlIGludmlzaWJsZSBlbGVtZW50cyBhcyBvZiB3aWR0aCAwLiBTbyBldmVuIHRob3VnaCBhcHBseWluZ1xuICAvLyAgICBpbnZpc2liaWxpdHkgdG8gLnVwcHktRGFzaGJvYXJkLWlubmVyIHdvcmtzIG5vdywgaXQgbWF5IG5vdCB3b3JrIGluIHRoZSBmdXR1cmUuXG4gIHN0YXJ0TGlzdGVuaW5nVG9SZXNpemUgPSAoKSA9PiB7XG4gICAgLy8gV2F0Y2ggZm9yIERhc2hib2FyZCBjb250YWluZXIgKGAudXBweS1EYXNoYm9hcmQtaW5uZXJgKSByZXNpemVcbiAgICAvLyBhbmQgdXBkYXRlIGNvbnRhaW5lcldpZHRoL2NvbnRhaW5lckhlaWdodCBpbiBwbHVnaW4gc3RhdGUgYWNjb3JkaW5nbHkuXG4gICAgLy8gRW1pdHMgZmlyc3QgZXZlbnQgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgY29uc3QgdXBweURhc2hib2FyZElubmVyRWwgPSBlbnRyaWVzWzBdXG5cbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdXBweURhc2hib2FyZElubmVyRWwuY29udGVudFJlY3RcblxuICAgICAgdGhpcy51cHB5LmxvZyhgW0Rhc2hib2FyZF0gcmVzaXplZDogJHt3aWR0aH0gLyAke2hlaWdodH1gLCAnZGVidWcnKVxuXG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGU6IHRydWUsXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnVwcHktRGFzaGJvYXJkLWlubmVyJykpXG5cbiAgICAvLyBJZiBSZXNpemVPYnNlcnZlciBmYWlscyB0byBlbWl0IGFuIGV2ZW50IHRlbGxpbmcgdXMgd2hhdCBzaXplIHRvIHVzZSAtIGRlZmF1bHQgdG8gdGhlIG1vYmlsZSB2aWV3XG4gICAgdGhpcy5tYWtlRGFzaGJvYXJkSW5zaWRlc1Zpc2libGVBbnl3YXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgY29uc3QgaXNNb2RhbEFuZENsb3NlZCA9ICF0aGlzLm9wdHMuaW5saW5lICYmIHBsdWdpblN0YXRlLmlzSGlkZGVuXG4gICAgICBpZiAoXG4gICAgICAgIC8vIGlmIFJlc2l6ZU9ic2VydmVyIGhhc24ndCB5ZXQgZmlyZWQsXG4gICAgICAgICFwbHVnaW5TdGF0ZS5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZVxuICAgICAgICAvLyBhbmQgaXQncyBub3QgZHVlIHRvIHRoZSBtb2RhbCBiZWluZyBjbG9zZWRcbiAgICAgICAgJiYgIWlzTW9kYWxBbmRDbG9zZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLnVwcHkubG9nKFwiW0Rhc2hib2FyZF0gcmVzaXplIGV2ZW50IGRpZG4ndCBmaXJlIG9uIHRpbWU6IGRlZmF1bHRlZCB0byBtb2JpbGUgbGF5b3V0XCIsICdkZWJ1ZycpXG5cbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgMTAwMClcbiAgfVxuXG4gIHN0b3BMaXN0ZW5pbmdUb1Jlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubWFrZURhc2hib2FyZEluc2lkZXNWaXNpYmxlQW55d2F5VGltZW91dClcbiAgfVxuXG4gIC8vIFJlY29yZHMgd2hldGhlciB3ZSBoYXZlIGJlZW4gaW50ZXJhY3Rpbmcgd2l0aCB1cHB5IHJpZ2h0IG5vdyxcbiAgLy8gd2hpY2ggaXMgdGhlbiB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHN0YXRlIHVwZGF0ZXMgc2hvdWxkIHRyaWdnZXIgYSByZWZvY3VzaW5nLlxuICByZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSA9IChldmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmVsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkgPSBmYWxzZVxuICAgICAgLy8gX19fV2h5IHJ1biB0aGlzLnN1cGVyRm9jdXMuY2FuY2VsIGhlcmUgd2hlbiBpdCBhbHJlYWR5IHJ1bnMgaW4gc3VwZXJGb2N1c09uRWFjaFVwZGF0ZT9cbiAgICAgIC8vICAgIEJlY2F1c2Ugc3VwZXJGb2N1cyBpcyBkZWJvdW5jZWQsIHdoZW4gd2UgbW92ZSBmcm9tIFVwcHkgdG8gc29tZSBvdGhlciBlbGVtZW50IG9uIHRoZSBwYWdlLFxuICAgICAgLy8gICAgcHJldmlvdXNseSBydW4gc3VwZXJGb2N1cyBzb21ldGltZXMgaGl0cyBhbmQgbW92ZXMgZm9jdXMgYmFjayB0byBVcHB5LlxuICAgICAgdGhpcy5zdXBlckZvY3VzLmNhbmNlbCgpXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZUFsbEZvY3VzYWJsZUVsZW1lbnRzID0gKGRpc2FibGUpID0+IHtcbiAgICBjb25zdCBmb2N1c2FibGVOb2RlcyA9IHRvQXJyYXkodGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUykpXG4gICAgaWYgKGRpc2FibGUpIHtcbiAgICAgIGZvY3VzYWJsZU5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgLy8gc2F2ZSBwcmV2aW91cyB0YWJpbmRleCBpbiBhIGRhdGEtYXR0cmlidXRlLCB0byByZXN0b3JlIHdoZW4gZW5hYmxpbmdcbiAgICAgICAgY29uc3QgY3VycmVudFRhYkluZGV4ID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JylcbiAgICAgICAgaWYgKGN1cnJlbnRUYWJJbmRleCkge1xuICAgICAgICAgIG5vZGUuZGF0YXNldC5pbmVydFRhYmluZGV4ID0gY3VycmVudFRhYkluZGV4XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvY3VzYWJsZU5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCdpbmVydFRhYmluZGV4JyBpbiBub2RlLmRhdGFzZXQpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCBub2RlLmRhdGFzZXQuaW5lcnRUYWJpbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLmRhc2hib2FyZElzRGlzYWJsZWQgPSBkaXNhYmxlXG4gIH1cblxuICB1cGRhdGVCcm93c2VySGlzdG9yeSA9ICgpID0+IHtcbiAgICAvLyBFbnN1cmUgaGlzdG9yeSBzdGF0ZSBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gb3VyIG1vZGFsIG5hbWUgdG8gYXZvaWQgZG91YmxlLXB1c2hpbmdcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKCFoaXN0b3J5LnN0YXRlPy5bdGhpcy5tb2RhbE5hbWVdKSB7XG4gICAgICAvLyBQdXNoIHRvIGhpc3Rvcnkgc28gdGhhdCB0aGUgcGFnZSBpcyBub3QgbG9zdCBvbiBicm93c2VyIGJhY2sgYnV0dG9uIHByZXNzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgLi4uaGlzdG9yeS5zdGF0ZSxcbiAgICAgICAgW3RoaXMubW9kYWxOYW1lXTogdHJ1ZSxcbiAgICAgIH0sICcnKVxuICAgIH1cblxuICAgIC8vIExpc3RlbiBmb3IgYmFjayBidXR0b24gcHJlc3Nlc1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wU3RhdGUsIGZhbHNlKVxuICB9XG5cbiAgaGFuZGxlUG9wU3RhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBDbG9zZSB0aGUgbW9kYWwgaWYgdGhlIGhpc3Rvcnkgc3RhdGUgbm8gbG9uZ2VyIGNvbnRhaW5zIG91ciBtb2RhbCBuYW1lXG4gICAgaWYgKHRoaXMuaXNNb2RhbE9wZW4oKSAmJiAoIWV2ZW50LnN0YXRlIHx8ICFldmVudC5zdGF0ZVt0aGlzLm1vZGFsTmFtZV0pKSB7XG4gICAgICB0aGlzLmNsb3NlTW9kYWwoeyBtYW51YWxDbG9zZTogZmFsc2UgfSlcbiAgICB9XG5cbiAgICAvLyBXaGVuIHRoZSBicm93c2VyIGJhY2sgYnV0dG9uIGlzIHByZXNzZWQgYW5kIHVwcHkgaXMgbm93IHRoZSBsYXRlc3QgZW50cnlcbiAgICAvLyBpbiB0aGUgaGlzdG9yeSBidXQgdGhlIG1vZGFsIGlzIGNsb3NlZCwgZml4IHRoZSBoaXN0b3J5IGJ5IHJlbW92aW5nIHRoZVxuICAgIC8vIHVwcHkgaGlzdG9yeSBlbnRyeS5cbiAgICAvLyBUaGlzIG9jY3VycyB3aGVuIGFub3RoZXIgZW50cnkgaXMgYWRkZWQgaW50byB0aGUgaGlzdG9yeSBzdGF0ZSB3aGlsZSB0aGVcbiAgICAvLyBtb2RhbCBpcyBvcGVuLCBhbmQgdGhlbiB0aGUgbW9kYWwgZ2V0cyBtYW51YWxseSBjbG9zZWQuXG4gICAgLy8gU29sdmVzIFBSICM1NzUgKGh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L3B1bGwvNTc1KVxuICAgIGlmICghdGhpcy5pc01vZGFsT3BlbigpICYmIGV2ZW50LnN0YXRlPy5bdGhpcy5tb2RhbE5hbWVdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICBoaXN0b3J5LmJhY2soKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUtleURvd25Jbk1vZGFsID0gKGV2ZW50KSA9PiB7XG4gICAgLy8gY2xvc2UgbW9kYWwgb24gZXNjIGtleSBwcmVzc1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NfS0VZKSB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsKGV2ZW50KVxuICAgIC8vIHRyYXAgZm9jdXMgb24gdGFiIGtleSBwcmVzc1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBUQUJfS0VZKSB0cmFwRm9jdXMuZm9yTW9kYWwoZXZlbnQsIHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5hY3RpdmVPdmVybGF5VHlwZSwgdGhpcy5lbClcbiAgfVxuXG4gIGhhbmRsZUNsaWNrT3V0c2lkZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5vcHRzLmNsb3NlTW9kYWxPbkNsaWNrT3V0c2lkZSkgdGhpcy5yZXF1ZXN0Q2xvc2VNb2RhbCgpXG4gIH1cblxuICBoYW5kbGVQYXN0ZSA9IChldmVudCkgPT4ge1xuICAgIC8vIExldCBhbnkgYWNxdWlyZXIgcGx1Z2luIChVcmwvV2ViY2FtL2V0Yy4pIGhhbmRsZSBwYXN0ZXMgdG8gdGhlIHJvb3RcbiAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgaWYgKHBsdWdpbi50eXBlID09PSAnYWNxdWlyZXInKSB7XG4gICAgICAgIC8vIEV2ZXJ5IFBsdWdpbiB3aXRoIC50eXBlIGFjcXVpcmVyIGNhbiBkZWZpbmUgaGFuZGxlUm9vdFBhc3RlKGV2ZW50KVxuICAgICAgICBwbHVnaW4uaGFuZGxlUm9vdFBhc3RlPy4oZXZlbnQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEFkZCBhbGwgZHJvcHBlZCBmaWxlc1xuICAgIGNvbnN0IGZpbGVzID0gdG9BcnJheShldmVudC5jbGlwYm9hcmREYXRhLmZpbGVzKVxuICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbRGFzaGJvYXJkXSBGaWxlcyBwYXN0ZWQnKVxuICAgICAgdGhpcy5hZGRGaWxlcyhmaWxlcylcbiAgICB9XG4gIH1cblxuICBoYW5kbGVJbnB1dENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBjb25zdCBmaWxlcyA9IHRvQXJyYXkoZXZlbnQudGFyZ2V0LmZpbGVzKVxuICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbRGFzaGJvYXJkXSBGaWxlcyBzZWxlY3RlZCB0aHJvdWdoIGlucHV0JylcbiAgICAgIHRoaXMuYWRkRmlsZXMoZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRHJhZ092ZXIgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIC8vIENoZWNrIGlmIHNvbWUgcGx1Z2luIGNhbiBoYW5kbGUgdGhlIGRhdGF0cmFuc2ZlciB3aXRob3V0IGZpbGVzIOKAlFxuICAgIC8vIGZvciBpbnN0YW5jZSwgdGhlIFVybCBwbHVnaW4gY2FuIGltcG9ydCBhIHVybFxuICAgIGNvbnN0IGNhblNvbWVQbHVnaW5IYW5kbGVSb290RHJvcCA9ICgpID0+IHtcbiAgICAgIGxldCBzb21lUGx1Z2luQ2FuSGFuZGxlUm9vdERyb3AgPSB0cnVlXG4gICAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgICBpZiAocGx1Z2luLmNhbkhhbmRsZVJvb3REcm9wPy4oZXZlbnQpKSB7XG4gICAgICAgICAgc29tZVBsdWdpbkNhbkhhbmRsZVJvb3REcm9wID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIHNvbWVQbHVnaW5DYW5IYW5kbGVSb290RHJvcFxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBcInR5cGVcIiBvZiB0aGUgZGF0YXRyYW5zZmVyIG9iamVjdCBpbmNsdWRlcyBmaWxlc1xuICAgIGNvbnN0IGRvZXNFdmVudEhhdmVGaWxlcyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdHlwZXMgfSA9IGV2ZW50LmRhdGFUcmFuc2ZlclxuICAgICAgcmV0dXJuIHR5cGVzLnNvbWUodHlwZSA9PiB0eXBlID09PSAnRmlsZXMnKVxuICAgIH1cblxuICAgIC8vIERlbnkgZHJvcCwgaWYgbm8gcGx1Z2lucyBjYW4gaGFuZGxlIGRhdGF0cmFuc2ZlciwgdGhlcmUgYXJlIG5vIGZpbGVzLFxuICAgIC8vIG9yIHdoZW4gb3B0cy5kaXNhYmxlZCBpcyBzZXQsIG9yIG5ldyB1cGxvYWRzIGFyZSBub3QgYWxsb3dlZFxuICAgIGNvbnN0IHNvbWVQbHVnaW5DYW5IYW5kbGVSb290RHJvcCA9IGNhblNvbWVQbHVnaW5IYW5kbGVSb290RHJvcChldmVudClcbiAgICBjb25zdCBoYXNGaWxlcyA9IGRvZXNFdmVudEhhdmVGaWxlcyhldmVudClcbiAgICBpZiAoXG4gICAgICAoIXNvbWVQbHVnaW5DYW5IYW5kbGVSb290RHJvcCAmJiAhaGFzRmlsZXMpXG4gICAgICB8fCB0aGlzLm9wdHMuZGlzYWJsZWRcbiAgICAgIC8vIG9wdHMuZGlzYWJsZUxvY2FsRmlsZXMgc2hvdWxkIG9ubHkgYmUgdGFrZW4gaW50byBhY2NvdW50IGlmIG5vIHBsdWdpbnNcbiAgICAgIC8vIGNhbiBoYW5kbGUgdGhlIGRhdGF0cmFuc2ZlclxuICAgICAgfHwgKHRoaXMub3B0cy5kaXNhYmxlTG9jYWxGaWxlcyAmJiAoaGFzRmlsZXMgfHwgIXNvbWVQbHVnaW5DYW5IYW5kbGVSb290RHJvcCkpXG4gICAgICB8fCAhdGhpcy51cHB5LmdldFN0YXRlKCkuYWxsb3dOZXdVcGxvYWRcbiAgICApIHtcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ25vbmUnXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEFkZCBhIHNtYWxsICgrKSBpY29uIG9uIGRyb3BcbiAgICAvLyAoYW5kIHByZXZlbnQgYnJvd3NlcnMgZnJvbSBpbnRlcnByZXRpbmcgdGhpcyBhcyBmaWxlcyBiZWluZyBfbW92ZWRfIGludG8gdGhlXG4gICAgLy8gYnJvd3NlciwgaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzLzE5NzgpLlxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknXG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgaXNEcmFnZ2luZ092ZXI6IHRydWUgfSlcblxuICAgIHRoaXMub3B0cy5vbkRyYWdPdmVyPy4oZXZlbnQpXG4gIH1cblxuICBoYW5kbGVEcmFnTGVhdmUgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0KVxuICAgIC8vIFRpbWVvdXQgYWdhaW5zdCBmbGlja2VyaW5nLCB0aGlzIHNvbHV0aW9uIGlzIHRha2VuIGZyb20gZHJhZy1kcm9wIGxpYnJhcnkuXG4gICAgLy8gU29sdXRpb24gd2l0aCAncG9pbnRlci1ldmVudHM6IG5vbmUnIGRpZG4ndCB3b3JrIGFjcm9zcyBicm93c2Vycy5cbiAgICB0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgaXNEcmFnZ2luZ092ZXI6IGZhbHNlIH0pXG4gICAgfSwgNTApXG5cbiAgICB0aGlzLm9wdHMub25EcmFnTGVhdmU/LihldmVudClcbiAgfVxuXG4gIGhhbmRsZURyb3AgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0KVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7IGlzRHJhZ2dpbmdPdmVyOiBmYWxzZSB9KVxuXG4gICAgLy8gTGV0IGFueSBhY3F1aXJlciBwbHVnaW4gKFVybC9XZWJjYW0vZXRjLikgaGFuZGxlIGRyb3BzIHRvIHRoZSByb290XG4gICAgdGhpcy51cHB5Lml0ZXJhdGVQbHVnaW5zKChwbHVnaW4pID0+IHtcbiAgICAgIGlmIChwbHVnaW4udHlwZSA9PT0gJ2FjcXVpcmVyJykge1xuICAgICAgICAvLyBFdmVyeSBQbHVnaW4gd2l0aCAudHlwZSBhY3F1aXJlciBjYW4gZGVmaW5lIGhhbmRsZVJvb3REcm9wKGV2ZW50KVxuICAgICAgICBwbHVnaW4uaGFuZGxlUm9vdERyb3A/LihldmVudClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gQWRkIGFsbCBkcm9wcGVkIGZpbGVzXG4gICAgbGV0IGV4ZWN1dGVkRHJvcEVycm9yT25jZSA9IGZhbHNlXG4gICAgY29uc3QgbG9nRHJvcEVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGVycm9yLCAnZXJyb3InKVxuXG4gICAgICAvLyBJbiBwcmFjdGljZSBhbGwgZHJvcCBlcnJvcnMgYXJlIG1vc3QgbGlrZWx5IHRoZSBzYW1lLFxuICAgICAgLy8gc28gbGV0J3MganVzdCBzaG93IG9uZSB0byBhdm9pZCBvdmVyd2hlbG1pbmcgdGhlIHVzZXJcbiAgICAgIGlmICghZXhlY3V0ZWREcm9wRXJyb3JPbmNlKSB7XG4gICAgICAgIHRoaXMudXBweS5pbmZvKGVycm9yLm1lc3NhZ2UsICdlcnJvcicpXG4gICAgICAgIGV4ZWN1dGVkRHJvcEVycm9yT25jZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGRyb3BwZWQgZmlsZXNcbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IGdldERyb3BwZWRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIsIHsgbG9nRHJvcEVycm9yIH0pXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tEYXNoYm9hcmRdIEZpbGVzIGRyb3BwZWQnKVxuICAgICAgdGhpcy5hZGRGaWxlcyhmaWxlcylcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMub25Ecm9wPy4oZXZlbnQpXG4gIH1cblxuICBoYW5kbGVSZXF1ZXN0VGh1bWJuYWlsID0gKGZpbGUpID0+IHtcbiAgICBpZiAoIXRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCkge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3RodW1ibmFpbDpyZXF1ZXN0JywgZmlsZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2UgY2FuY2VsIHRodW1ibmFpbCByZXF1ZXN0cyB3aGVuIGEgZmlsZSBpdGVtIGNvbXBvbmVudCB1bm1vdW50cyB0byBhdm9pZFxuICAgKiBjbG9nZ2luZyB1cCB0aGUgcXVldWUgd2hlbiB0aGUgdXNlciBzY3JvbGxzIHBhc3QgbWFueSBlbGVtZW50cy5cbiAgICovXG4gIGhhbmRsZUNhbmNlbFRodW1ibmFpbCA9IChmaWxlKSA9PiB7XG4gICAgaWYgKCF0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6Y2FuY2VsJywgZmlsZSlcbiAgICB9XG4gIH1cblxuICBoYW5kbGVLZXlEb3duSW5JbmxpbmUgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBUcmFwIGZvY3VzIG9uIHRhYiBrZXkgcHJlc3MuXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IFRBQl9LRVkpIHRyYXBGb2N1cy5mb3JJbmxpbmUoZXZlbnQsIHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5hY3RpdmVPdmVybGF5VHlwZSwgdGhpcy5lbClcbiAgfVxuXG4gIC8vIF9fX1doeSBkbyB3ZSBsaXN0ZW4gdG8gdGhlICdwYXN0ZScgZXZlbnQgb24gYSBkb2N1bWVudCBpbnN0ZWFkIG9mIG9uUGFzdGU9e3Byb3BzLmhhbmRsZVBhc3RlfSBwcm9wLFxuICAvLyAgICBvciB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJyk/XG4gIC8vICAgIEJlY2F1c2UgKGF0IGxlYXN0KSBDaHJvbWUgZG9lc24ndCBoYW5kbGUgcGFzdGUgaWYgZm9jdXMgaXMgb24gc29tZSBidXR0b24sIGUuZy4gJ015IERldmljZScuXG4gIC8vICAgID0+IFRoZXJlZm9yZSwgdGhlIGJlc3Qgb3B0aW9uIGlzIHRvIGxpc3RlbiB0byBhbGwgJ3Bhc3RlJyBldmVudHMsIGFuZCBvbmx5IHJlYWN0IHRvIHRoZW0gd2hlbiB3ZSBhcmUgZm9jdXNlZCBvbiBvdXJcbiAgLy8gICAgICAgcGFydGljdWxhciBVcHB5IGluc3RhbmNlLlxuICAvLyBfX19XaHkgZG8gd2Ugc3RpbGwgbmVlZCBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX0gZm9yIHRoZSBEYXNoYm9hcmRVaT9cbiAgLy8gICAgQmVjYXVzZSBpZiB3ZSBjbGljayBvbiB0aGUgJ0Ryb3AgZmlsZXMgaGVyZScgY2FwdGlvbiBlLmcuLCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgd2lsbCBiZSAnYm9keScuIFdoaWNoIG1lYW5zIG91clxuICAvLyAgICBzdGFuZGFyZCBkZXRlcm1pbmF0aW9uIG9mIHdoZXRoZXIgd2UncmUgcGFzdGluZyBpbnRvIG91ciBVcHB5IGluc3RhbmNlIHdvbid0IHdvcmsuXG4gIC8vICAgID0+IFRoZXJlZm9yZSwgd2UgbmVlZCBhIHRyYWRpdGlvbmFsIG9uUGFzdGU9e3Byb3BzLmhhbmRsZVBhc3RlfSBoYW5kbGVyIHRvby5cbiAgaGFuZGxlUGFzdGVPbkJvZHkgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc0ZvY3VzSW5PdmVybGF5ID0gdGhpcy5lbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIGlmIChpc0ZvY3VzSW5PdmVybGF5KSB7XG4gICAgICB0aGlzLmhhbmRsZVBhc3RlKGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNvbXBsZXRlID0gKHsgZmFpbGVkIH0pID0+IHtcbiAgICBpZiAodGhpcy5vcHRzLmNsb3NlQWZ0ZXJGaW5pc2ggJiYgZmFpbGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQWxsIHVwbG9hZHMgYXJlIGRvbmVcbiAgICAgIHRoaXMucmVxdWVzdENsb3NlTW9kYWwoKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNhbmNlbFJlc3RvcmUgPSAoKSA9PiB7XG4gICAgdGhpcy51cHB5LmVtaXQoJ3Jlc3RvcmUtY2FuY2VsZWQnKVxuICB9XG5cbiAgI29wZW5GaWxlRWRpdG9yV2hlbkZpbGVzQWRkZWQgPSAoZmlsZXMpID0+IHtcbiAgICBjb25zdCBmaXJzdEZpbGUgPSBmaWxlc1swXVxuICAgIGlmICh0aGlzLmNhbkVkaXRGaWxlKGZpcnN0RmlsZSkpIHtcbiAgICAgIHRoaXMub3BlbkZpbGVFZGl0b3IoZmlyc3RGaWxlKVxuICAgIH1cbiAgfVxuXG4gIGluaXRFdmVudHMgPSAoKSA9PiB7XG4gICAgLy8gTW9kYWwgb3BlbiBidXR0b25cbiAgICBpZiAodGhpcy5vcHRzLnRyaWdnZXIgJiYgIXRoaXMub3B0cy5pbmxpbmUpIHtcbiAgICAgIGNvbnN0IHNob3dNb2RhbFRyaWdnZXIgPSBmaW5kQWxsRE9NRWxlbWVudHModGhpcy5vcHRzLnRyaWdnZXIpXG4gICAgICBpZiAoc2hvd01vZGFsVHJpZ2dlcikge1xuICAgICAgICBzaG93TW9kYWxUcmlnZ2VyLmZvckVhY2godHJpZ2dlciA9PiB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vcGVuTW9kYWwpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZygnRGFzaGJvYXJkIG1vZGFsIHRyaWdnZXIgbm90IGZvdW5kLiBNYWtlIHN1cmUgYHRyaWdnZXJgIGlzIHNldCBpbiBEYXNoYm9hcmQgb3B0aW9ucywgdW5sZXNzIHlvdSBhcmUgcGxhbm5pbmcgdG8gY2FsbCBgZGFzaGJvYXJkLm9wZW5Nb2RhbCgpYCBtZXRob2QgeW91cnNlbGYnLCAnd2FybmluZycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydExpc3RlbmluZ1RvUmVzaXplKClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGVPbkJvZHkpXG5cbiAgICB0aGlzLnVwcHkub24oJ3BsdWdpbi1yZW1vdmUnLCB0aGlzLnJlbW92ZVRhcmdldClcbiAgICB0aGlzLnVwcHkub24oJ2ZpbGUtYWRkZWQnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9uKCdkYXNoYm9hcmQ6bW9kYWwtY2xvc2VkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vbignZmlsZS1lZGl0b3I6Y29tcGxldGUnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9uKCdjb21wbGV0ZScsIHRoaXMuaGFuZGxlQ29tcGxldGUpXG5cbiAgICAvLyBfX19XaHkgZmlyZSBvbiBjYXB0dXJlP1xuICAgIC8vICAgIEJlY2F1c2UgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSBuZWVkcyB0byBjaGFuZ2UgYmVmb3JlIG9uVXBkYXRlKCkgZmlyZXMuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5LCB0cnVlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSwgdHJ1ZSlcblxuICAgIGlmICh0aGlzLm9wdHMuaW5saW5lKSB7XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25JbklubGluZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmF1dG9PcGVuRmlsZUVkaXRvcikge1xuICAgICAgdGhpcy51cHB5Lm9uKCdmaWxlcy1hZGRlZCcsIHRoaXMuI29wZW5GaWxlRWRpdG9yV2hlbkZpbGVzQWRkZWQpXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRXZlbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHNob3dNb2RhbFRyaWdnZXIgPSBmaW5kQWxsRE9NRWxlbWVudHModGhpcy5vcHRzLnRyaWdnZXIpXG4gICAgaWYgKCF0aGlzLm9wdHMuaW5saW5lICYmIHNob3dNb2RhbFRyaWdnZXIpIHtcbiAgICAgIHNob3dNb2RhbFRyaWdnZXIuZm9yRWFjaCh0cmlnZ2VyID0+IHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9wZW5Nb2RhbCkpXG4gICAgfVxuXG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nVG9SZXNpemUoKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgdGhpcy5oYW5kbGVQYXN0ZU9uQm9keSlcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wU3RhdGUsIGZhbHNlKVxuICAgIHRoaXMudXBweS5vZmYoJ3BsdWdpbi1yZW1vdmUnLCB0aGlzLnJlbW92ZVRhcmdldClcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLWFkZGVkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vZmYoJ2Rhc2hib2FyZDptb2RhbC1jbG9zZWQnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9mZignZmlsZS1lZGl0b3I6Y29tcGxldGUnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9mZignY29tcGxldGUnLCB0aGlzLmhhbmRsZUNvbXBsZXRlKVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5KVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSlcblxuICAgIGlmICh0aGlzLm9wdHMuaW5saW5lKSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25JbklubGluZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmF1dG9PcGVuRmlsZUVkaXRvcikge1xuICAgICAgdGhpcy51cHB5Lm9mZignZmlsZXMtYWRkZWQnLCB0aGlzLiNvcGVuRmlsZUVkaXRvcldoZW5GaWxlc0FkZGVkKVxuICAgIH1cbiAgfVxuXG4gIHN1cGVyRm9jdXNPbkVhY2hVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgaXNGb2N1c0luVXBweSA9IHRoaXMuZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAvLyBXaGVuIGZvY3VzIGlzIGxvc3Qgb24gdGhlIHBhZ2UgKD09IGZvY3VzIGlzIG9uIGJvZHkgZm9yIG1vc3QgYnJvd3NlcnMsIG9yIGZvY3VzIGlzIG51bGwgZm9yIElFMTEpXG4gICAgY29uc3QgaXNGb2N1c05vd2hlcmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IG51bGxcbiAgICBjb25zdCBpc0luZm9ybWVySGlkZGVuID0gdGhpcy51cHB5LmdldFN0YXRlKCkuaW5mby5pc0hpZGRlblxuICAgIGNvbnN0IGlzTW9kYWwgPSAhdGhpcy5vcHRzLmlubGluZVxuXG4gICAgaWYgKFxuICAgICAgLy8gSWYgdXBkYXRlIGlzIGNvbm5lY3RlZCB0byBzaG93aW5nIHRoZSBJbmZvcm1lciAtIGxldCB0aGUgc2NyZWVuIHJlYWRlciBjYWxtbHkgcmVhZCBpdC5cbiAgICAgIGlzSW5mb3JtZXJIaWRkZW5cbiAgICAgICYmIChcbiAgICAgICAgLy8gSWYgd2UgYXJlIGluIGEgbW9kYWwgLSBhbHdheXMgc3VwZXJmb2N1cyB3aXRob3V0IGNvbmNlcm4gZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgIC8vIG9uIHRoZSBwYWdlICh1c2VyIGlzIHVubGlrZWx5IHRvIHdhbnQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcGFnZSlcbiAgICAgICAgaXNNb2RhbFxuICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbnNpZGUgb2YgVXBweSwgb3JcbiAgICAgICAgfHwgaXNGb2N1c0luVXBweVxuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGZvY3VzZWQgb24gYW55dGhpbmcgQlVUIHdlIGhhdmUgYWxyZWFkeSwgYXQgbGVhc3Qgb25jZSwgZm9jdXNlZCBvbiB1cHB5XG4gICAgICAgIC8vICAgMS4gV2UgZm9jdXMgd2hlbiBpc0ZvY3VzTm93aGVyZSwgYmVjYXVzZSB3aGVuIHRoZSBlbGVtZW50IHdlIHdlcmUgZm9jdXNlZFxuICAgICAgICAvLyAgICAgIG9uIGRpc2FwcGVhcnMgKGUuZy4gYW4gb3ZlcmxheSksIC0gZm9jdXMgZ2V0cyBsb3N0LiBJZiB1c2VyIGlzIHR5cGluZ1xuICAgICAgICAvLyAgICAgIHNvbWV0aGluZyBzb21ld2hlcmUgZWxzZSBvbiB0aGUgcGFnZSwgLSBmb2N1cyB3b24ndCBiZSAnbm93aGVyZScuXG4gICAgICAgIC8vICAgMi4gV2Ugb25seSBmb2N1cyB3aGVuIGZvY3VzIGlzIG5vd2hlcmUgQU5EIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHksXG4gICAgICAgIC8vICAgICAgdG8gYXZvaWQgZm9jdXMganVtcHMgaWYgd2UgZG8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHBhZ2UuXG4gICAgICAgIC8vICAgW1ByYWN0aWNhbCBjaGVja10gV2l0aG91dCAnJiYgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseScsIGluIFNhZmFyaSwgaW4gaW5saW5lIG1vZGUsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgd2hlbiBmaWxlIGlzIHVwbG9hZGluZywgLSBuYXZpZ2F0ZSB2aWEgdGFiIHRvIHRoZSBjaGVja2JveCxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB0cnkgdG8gcHJlc3Mgc3BhY2UgbXVsdGlwbGUgdGltZXMuIEZvY3VzIHdpbGwganVtcCB0byBVcHB5LlxuICAgICAgICB8fCAoaXNGb2N1c05vd2hlcmUgJiYgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSlcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMuc3VwZXJGb2N1cyh0aGlzLmVsLCB0aGlzLmdldFBsdWdpblN0YXRlKCkuYWN0aXZlT3ZlcmxheVR5cGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3VwZXJGb2N1cy5jYW5jZWwoKVxuICAgIH1cbiAgfVxuXG4gIGFmdGVyVXBkYXRlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZWQgJiYgIXRoaXMuZGFzaGJvYXJkSXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlQWxsRm9jdXNhYmxlRWxlbWVudHModHJ1ZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVkICYmIHRoaXMuZGFzaGJvYXJkSXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlQWxsRm9jdXNhYmxlRWxlbWVudHMoZmFsc2UpXG4gICAgfVxuXG4gICAgdGhpcy5zdXBlckZvY3VzT25FYWNoVXBkYXRlKClcbiAgfVxuXG4gIHNhdmVGaWxlQ2FyZCA9IChtZXRhLCBmaWxlSUQpID0+IHtcbiAgICB0aGlzLnVwcHkuc2V0RmlsZU1ldGEoZmlsZUlELCBtZXRhKVxuICAgIHRoaXMudG9nZ2xlRmlsZUNhcmQoZmFsc2UsIGZpbGVJRClcbiAgfVxuXG4gICNhdHRhY2hSZW5kZXJGdW5jdGlvblRvVGFyZ2V0ID0gKHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKVxuICAgIHJldHVybiB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBpY29uOiBwbHVnaW4uaWNvbiB8fCB0aGlzLm9wdHMuZGVmYXVsdFBpY2tlckljb24sXG4gICAgICByZW5kZXI6IHBsdWdpbi5yZW5kZXIsXG4gICAgfVxuICB9XG5cbiAgI2lzVGFyZ2V0U3VwcG9ydGVkID0gKHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKVxuICAgIC8vIElmIHRoZSBwbHVnaW4gZG9lcyBub3QgcHJvdmlkZSBhIGBzdXBwb3J0ZWRgIGNoZWNrLCBhc3N1bWUgdGhlIHBsdWdpbiB3b3JrcyBldmVyeXdoZXJlLlxuICAgIGlmICh0eXBlb2YgcGx1Z2luLmlzU3VwcG9ydGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luLmlzU3VwcG9ydGVkKClcbiAgfVxuXG4gICNnZXRBY3F1aXJlcnMgPSBtZW1vaXplKCh0YXJnZXRzKSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldHNcbiAgICAgIC5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC50eXBlID09PSAnYWNxdWlyZXInICYmIHRoaXMuI2lzVGFyZ2V0U3VwcG9ydGVkKHRhcmdldCkpXG4gICAgICAubWFwKHRoaXMuI2F0dGFjaFJlbmRlckZ1bmN0aW9uVG9UYXJnZXQpXG4gIH0pXG5cbiAgI2dldFByb2dyZXNzSW5kaWNhdG9ycyA9IG1lbW9pemUoKHRhcmdldHMpID0+IHtcbiAgICByZXR1cm4gdGFyZ2V0c1xuICAgICAgLmZpbHRlcih0YXJnZXQgPT4gdGFyZ2V0LnR5cGUgPT09ICdwcm9ncmVzc2luZGljYXRvcicpXG4gICAgICAubWFwKHRoaXMuI2F0dGFjaFJlbmRlckZ1bmN0aW9uVG9UYXJnZXQpXG4gIH0pXG5cbiAgI2dldEVkaXRvcnMgPSBtZW1vaXplKCh0YXJnZXRzKSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldHNcbiAgICAgIC5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC50eXBlID09PSAnZWRpdG9yJylcbiAgICAgIC5tYXAodGhpcy4jYXR0YWNoUmVuZGVyRnVuY3Rpb25Ub1RhcmdldClcbiAgfSlcblxuICByZW5kZXIgPSAoc3RhdGUpID0+IHtcbiAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IHsgZmlsZXMsIGNhcGFiaWxpdGllcywgYWxsb3dOZXdVcGxvYWQgfSA9IHN0YXRlXG4gICAgY29uc3Qge1xuICAgICAgbmV3RmlsZXMsXG4gICAgICB1cGxvYWRTdGFydGVkRmlsZXMsXG4gICAgICBjb21wbGV0ZUZpbGVzLFxuICAgICAgZXJyb3JlZEZpbGVzLFxuICAgICAgaW5Qcm9ncmVzc0ZpbGVzLFxuICAgICAgaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzLFxuICAgICAgcHJvY2Vzc2luZ0ZpbGVzLFxuXG4gICAgICBpc1VwbG9hZFN0YXJ0ZWQsXG4gICAgICBpc0FsbENvbXBsZXRlLFxuICAgICAgaXNBbGxFcnJvcmVkLFxuICAgICAgaXNBbGxQYXVzZWQsXG4gICAgfSA9IHRoaXMudXBweS5nZXRPYmplY3RPZkZpbGVzUGVyU3RhdGUoKVxuXG4gICAgY29uc3QgYWNxdWlyZXJzID0gdGhpcy4jZ2V0QWNxdWlyZXJzKHBsdWdpblN0YXRlLnRhcmdldHMpXG4gICAgY29uc3QgcHJvZ3Jlc3NpbmRpY2F0b3JzID0gdGhpcy4jZ2V0UHJvZ3Jlc3NJbmRpY2F0b3JzKHBsdWdpblN0YXRlLnRhcmdldHMpXG4gICAgY29uc3QgZWRpdG9ycyA9IHRoaXMuI2dldEVkaXRvcnMocGx1Z2luU3RhdGUudGFyZ2V0cylcblxuICAgIGxldCB0aGVtZVxuICAgIGlmICh0aGlzLm9wdHMudGhlbWUgPT09ICdhdXRvJykge1xuICAgICAgdGhlbWUgPSBjYXBhYmlsaXRpZXMuZGFya01vZGUgPyAnZGFyaycgOiAnbGlnaHQnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZW1lID0gdGhpcy5vcHRzLnRoZW1lXG4gICAgfVxuXG4gICAgaWYgKFsnZmlsZXMnLCAnZm9sZGVycycsICdib3RoJ10uaW5kZXhPZih0aGlzLm9wdHMuZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlKSA8IDApIHtcbiAgICAgIHRoaXMub3B0cy5maWxlTWFuYWdlclNlbGVjdGlvblR5cGUgPSAnZmlsZXMnXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBvcHRpb24gZm9yIFwiZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlXCIuIFVzaW5nIGRlZmF1bHQgb2YgXCIke3RoaXMub3B0cy5maWxlTWFuYWdlclNlbGVjdGlvblR5cGV9XCIuYClcbiAgICB9XG5cbiAgICByZXR1cm4gRGFzaGJvYXJkVUkoe1xuICAgICAgc3RhdGUsXG4gICAgICBpc0hpZGRlbjogcGx1Z2luU3RhdGUuaXNIaWRkZW4sXG4gICAgICBmaWxlcyxcbiAgICAgIG5ld0ZpbGVzLFxuICAgICAgdXBsb2FkU3RhcnRlZEZpbGVzLFxuICAgICAgY29tcGxldGVGaWxlcyxcbiAgICAgIGVycm9yZWRGaWxlcyxcbiAgICAgIGluUHJvZ3Jlc3NGaWxlcyxcbiAgICAgIGluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcyxcbiAgICAgIHByb2Nlc3NpbmdGaWxlcyxcbiAgICAgIGlzVXBsb2FkU3RhcnRlZCxcbiAgICAgIGlzQWxsQ29tcGxldGUsXG4gICAgICBpc0FsbEVycm9yZWQsXG4gICAgICBpc0FsbFBhdXNlZCxcbiAgICAgIHRvdGFsRmlsZUNvdW50OiBPYmplY3Qua2V5cyhmaWxlcykubGVuZ3RoLFxuICAgICAgdG90YWxQcm9ncmVzczogc3RhdGUudG90YWxQcm9ncmVzcyxcbiAgICAgIGFsbG93TmV3VXBsb2FkLFxuICAgICAgYWNxdWlyZXJzLFxuICAgICAgdGhlbWUsXG4gICAgICBkaXNhYmxlZDogdGhpcy5vcHRzLmRpc2FibGVkLFxuICAgICAgZGlzYWJsZUxvY2FsRmlsZXM6IHRoaXMub3B0cy5kaXNhYmxlTG9jYWxGaWxlcyxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5vcHRzLmRpcmVjdGlvbixcbiAgICAgIGFjdGl2ZVBpY2tlclBhbmVsOiBwbHVnaW5TdGF0ZS5hY3RpdmVQaWNrZXJQYW5lbCxcbiAgICAgIHNob3dGaWxlRWRpdG9yOiBwbHVnaW5TdGF0ZS5zaG93RmlsZUVkaXRvcixcbiAgICAgIHNhdmVGaWxlRWRpdG9yOiB0aGlzLnNhdmVGaWxlRWRpdG9yLFxuICAgICAgZGlzYWJsZUFsbEZvY3VzYWJsZUVsZW1lbnRzOiB0aGlzLmRpc2FibGVBbGxGb2N1c2FibGVFbGVtZW50cyxcbiAgICAgIGFuaW1hdGVPcGVuQ2xvc2U6IHRoaXMub3B0cy5hbmltYXRlT3BlbkNsb3NlLFxuICAgICAgaXNDbG9zaW5nOiBwbHVnaW5TdGF0ZS5pc0Nsb3NpbmcsXG4gICAgICBwcm9ncmVzc2luZGljYXRvcnMsXG4gICAgICBlZGl0b3JzLFxuICAgICAgYXV0b1Byb2NlZWQ6IHRoaXMudXBweS5vcHRzLmF1dG9Qcm9jZWVkLFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBjbG9zZU1vZGFsOiB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsLFxuICAgICAgaGFuZGxlQ2xpY2tPdXRzaWRlOiB0aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSxcbiAgICAgIGhhbmRsZUlucHV0Q2hhbmdlOiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlLFxuICAgICAgaGFuZGxlUGFzdGU6IHRoaXMuaGFuZGxlUGFzdGUsXG4gICAgICBpbmxpbmU6IHRoaXMub3B0cy5pbmxpbmUsXG4gICAgICBzaG93UGFuZWw6IHRoaXMuc2hvd1BhbmVsLFxuICAgICAgaGlkZUFsbFBhbmVsczogdGhpcy5oaWRlQWxsUGFuZWxzLFxuICAgICAgaTE4bjogdGhpcy5pMThuLFxuICAgICAgaTE4bkFycmF5OiB0aGlzLmkxOG5BcnJheSxcbiAgICAgIHVwcHk6IHRoaXMudXBweSxcbiAgICAgIG5vdGU6IHRoaXMub3B0cy5ub3RlLFxuICAgICAgcmVjb3ZlcmVkU3RhdGU6IHN0YXRlLnJlY292ZXJlZFN0YXRlLFxuICAgICAgbWV0YUZpZWxkczogcGx1Z2luU3RhdGUubWV0YUZpZWxkcyxcbiAgICAgIHJlc3VtYWJsZVVwbG9hZHM6IGNhcGFiaWxpdGllcy5yZXN1bWFibGVVcGxvYWRzIHx8IGZhbHNlLFxuICAgICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbjogY2FwYWJpbGl0aWVzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24sXG4gICAgICBpc01vYmlsZURldmljZTogY2FwYWJpbGl0aWVzLmlzTW9iaWxlRGV2aWNlLFxuICAgICAgZmlsZUNhcmRGb3I6IHBsdWdpblN0YXRlLmZpbGVDYXJkRm9yLFxuICAgICAgdG9nZ2xlRmlsZUNhcmQ6IHRoaXMudG9nZ2xlRmlsZUNhcmQsXG4gICAgICB0b2dnbGVBZGRGaWxlc1BhbmVsOiB0aGlzLnRvZ2dsZUFkZEZpbGVzUGFuZWwsXG4gICAgICBzaG93QWRkRmlsZXNQYW5lbDogcGx1Z2luU3RhdGUuc2hvd0FkZEZpbGVzUGFuZWwsXG4gICAgICBzYXZlRmlsZUNhcmQ6IHRoaXMuc2F2ZUZpbGVDYXJkLFxuICAgICAgb3BlbkZpbGVFZGl0b3I6IHRoaXMub3BlbkZpbGVFZGl0b3IsXG4gICAgICBjYW5FZGl0RmlsZTogdGhpcy5jYW5FZGl0RmlsZSxcbiAgICAgIHdpZHRoOiB0aGlzLm9wdHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMub3B0cy5oZWlnaHQsXG4gICAgICBzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdDogdGhpcy5vcHRzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0LFxuICAgICAgZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlOiB0aGlzLm9wdHMuZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlLFxuICAgICAgcHJvdWRseURpc3BsYXlQb3dlcmVkQnlVcHB5OiB0aGlzLm9wdHMucHJvdWRseURpc3BsYXlQb3dlcmVkQnlVcHB5LFxuICAgICAgaGlkZUNhbmNlbEJ1dHRvbjogdGhpcy5vcHRzLmhpZGVDYW5jZWxCdXR0b24sXG4gICAgICBoaWRlUmV0cnlCdXR0b246IHRoaXMub3B0cy5oaWRlUmV0cnlCdXR0b24sXG4gICAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b246IHRoaXMub3B0cy5oaWRlUGF1c2VSZXN1bWVCdXR0b24sXG4gICAgICBzaG93UmVtb3ZlQnV0dG9uQWZ0ZXJDb21wbGV0ZTogdGhpcy5vcHRzLnNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlLFxuICAgICAgY29udGFpbmVyV2lkdGg6IHBsdWdpblN0YXRlLmNvbnRhaW5lcldpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0OiBwbHVnaW5TdGF0ZS5jb250YWluZXJIZWlnaHQsXG4gICAgICBhcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZTogcGx1Z2luU3RhdGUuYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGUsXG4gICAgICBpc1RhcmdldERPTUVsOiB0aGlzLmlzVGFyZ2V0RE9NRWwsXG4gICAgICBwYXJlbnRFbGVtZW50OiB0aGlzLmVsLFxuICAgICAgYWxsb3dlZEZpbGVUeXBlczogdGhpcy51cHB5Lm9wdHMucmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMsXG4gICAgICBtYXhOdW1iZXJPZkZpbGVzOiB0aGlzLnVwcHkub3B0cy5yZXN0cmljdGlvbnMubWF4TnVtYmVyT2ZGaWxlcyxcbiAgICAgIHJlcXVpcmVkTWV0YUZpZWxkczogdGhpcy51cHB5Lm9wdHMucmVzdHJpY3Rpb25zLnJlcXVpcmVkTWV0YUZpZWxkcyxcbiAgICAgIHNob3dTZWxlY3RlZEZpbGVzOiB0aGlzLm9wdHMuc2hvd1NlbGVjdGVkRmlsZXMsXG4gICAgICBoYW5kbGVDYW5jZWxSZXN0b3JlOiB0aGlzLmhhbmRsZUNhbmNlbFJlc3RvcmUsXG4gICAgICBoYW5kbGVSZXF1ZXN0VGh1bWJuYWlsOiB0aGlzLmhhbmRsZVJlcXVlc3RUaHVtYm5haWwsXG4gICAgICBoYW5kbGVDYW5jZWxUaHVtYm5haWw6IHRoaXMuaGFuZGxlQ2FuY2VsVGh1bWJuYWlsLFxuICAgICAgLy8gZHJhZyBwcm9wc1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IHBsdWdpblN0YXRlLmlzRHJhZ2dpbmdPdmVyLFxuICAgICAgaGFuZGxlRHJhZ092ZXI6IHRoaXMuaGFuZGxlRHJhZ092ZXIsXG4gICAgICBoYW5kbGVEcmFnTGVhdmU6IHRoaXMuaGFuZGxlRHJhZ0xlYXZlLFxuICAgICAgaGFuZGxlRHJvcDogdGhpcy5oYW5kbGVEcm9wLFxuICAgIH0pXG4gIH1cblxuICBkaXNjb3ZlclByb3ZpZGVyUGx1Z2lucyA9ICgpID0+IHtcbiAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgaWYgKHBsdWdpbiAmJiAhcGx1Z2luLnRhcmdldCAmJiBwbHVnaW4ub3B0cyAmJiBwbHVnaW4ub3B0cy50YXJnZXQgPT09IHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5hZGRUYXJnZXQocGx1Z2luKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICAvLyBTZXQgdGhlIHRleHQgZGlyZWN0aW9uIGlmIHRoZSBwYWdlIGhhcyBub3QgZGVmaW5lZCBvbmUuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBnZXRUZXh0RGlyZWN0aW9uKGVsZW1lbnQpXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIGVsZW1lbnQuZGlyID0gJ2x0cidcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsID0gKCkgPT4ge1xuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRlIGZvciBEYXNoYm9hcmRcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGlzSGlkZGVuOiB0cnVlLFxuICAgICAgZmlsZUNhcmRGb3I6IG51bGwsXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogbnVsbCxcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBmYWxzZSxcbiAgICAgIGFjdGl2ZVBpY2tlclBhbmVsOiBmYWxzZSxcbiAgICAgIHNob3dGaWxlRWRpdG9yOiBmYWxzZSxcbiAgICAgIG1ldGFGaWVsZHM6IHRoaXMub3B0cy5tZXRhRmllbGRzLFxuICAgICAgdGFyZ2V0czogW10sXG4gICAgICAvLyBXZSdsbCBtYWtlIHRoZW0gdmlzaWJsZSBvbmNlIC5jb250YWluZXJXaWR0aCBpcyBkZXRlcm1pbmVkXG4gICAgICBhcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZTogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nT3ZlcjogZmFsc2UsXG4gICAgfSlcblxuICAgIGNvbnN0IHsgaW5saW5lLCBjbG9zZUFmdGVyRmluaXNoIH0gPSB0aGlzLm9wdHNcbiAgICBpZiAoaW5saW5lICYmIGNsb3NlQWZ0ZXJGaW5pc2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0Rhc2hib2FyZF0gYGNsb3NlQWZ0ZXJGaW5pc2g6IHRydWVgIGNhbm5vdCBiZSB1c2VkIG9uIGFuIGlubGluZSBEYXNoYm9hcmQsIGJlY2F1c2UgYW4gaW5saW5lIERhc2hib2FyZCBjYW5ub3QgYmUgY2xvc2VkIGF0IGFsbC4gRWl0aGVyIHNldCBgaW5saW5lOiBmYWxzZWAsIG9yIGRpc2FibGUgdGhlIGBjbG9zZUFmdGVyRmluaXNoYCBvcHRpb24uJylcbiAgICB9XG5cbiAgICBjb25zdCB7IGFsbG93TXVsdGlwbGVVcGxvYWRzLCBhbGxvd011bHRpcGxlVXBsb2FkQmF0Y2hlcyB9ID0gdGhpcy51cHB5Lm9wdHNcbiAgICBpZiAoKGFsbG93TXVsdGlwbGVVcGxvYWRzIHx8IGFsbG93TXVsdGlwbGVVcGxvYWRCYXRjaGVzKSAmJiBjbG9zZUFmdGVyRmluaXNoKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbRGFzaGJvYXJkXSBXaGVuIHVzaW5nIGBjbG9zZUFmdGVyRmluaXNoYCwgd2UgcmVjb21tZW5kZWQgc2V0dGluZyB0aGUgYGFsbG93TXVsdGlwbGVVcGxvYWRCYXRjaGVzYCBvcHRpb24gdG8gYGZhbHNlYCBpbiB0aGUgVXBweSBjb25zdHJ1Y3Rvci4gU2VlIGh0dHBzOi8vdXBweS5pby9kb2NzL3VwcHkvI2FsbG93TXVsdGlwbGVVcGxvYWRzLXRydWUnLCAnd2FybmluZycpXG4gICAgfVxuXG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMub3B0c1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMub3B0cy5wbHVnaW5zIHx8IFtdXG5cbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbklEKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHBsdWdpbklEKVxuICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICBwbHVnaW4ubW91bnQodGhpcywgcGx1Z2luKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlU3RhdHVzQmFyKSB7XG4gICAgICB0aGlzLnVwcHkudXNlKFN0YXR1c0Jhciwge1xuICAgICAgICBpZDogYCR7dGhpcy5pZH06U3RhdHVzQmFyYCxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICBoaWRlVXBsb2FkQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVVwbG9hZEJ1dHRvbixcbiAgICAgICAgaGlkZVJldHJ5QnV0dG9uOiB0aGlzLm9wdHMuaGlkZVJldHJ5QnV0dG9uLFxuICAgICAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b246IHRoaXMub3B0cy5oaWRlUGF1c2VSZXN1bWVCdXR0b24sXG4gICAgICAgIGhpZGVDYW5jZWxCdXR0b246IHRoaXMub3B0cy5oaWRlQ2FuY2VsQnV0dG9uLFxuICAgICAgICBzaG93UHJvZ3Jlc3NEZXRhaWxzOiB0aGlzLm9wdHMuc2hvd1Byb2dyZXNzRGV0YWlscyxcbiAgICAgICAgaGlkZUFmdGVyRmluaXNoOiB0aGlzLm9wdHMuaGlkZVByb2dyZXNzQWZ0ZXJGaW5pc2gsXG4gICAgICAgIGxvY2FsZTogdGhpcy5vcHRzLmxvY2FsZSxcbiAgICAgICAgZG9uZUJ1dHRvbkhhbmRsZXI6IHRoaXMub3B0cy5kb25lQnV0dG9uSGFuZGxlcixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZUluZm9ybWVyKSB7XG4gICAgICB0aGlzLnVwcHkudXNlKEluZm9ybWVyLCB7XG4gICAgICAgIGlkOiBgJHt0aGlzLmlkfTpJbmZvcm1lcmAsXG4gICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVRodW1ibmFpbEdlbmVyYXRvcikge1xuICAgICAgdGhpcy51cHB5LnVzZShUaHVtYm5haWxHZW5lcmF0b3IsIHtcbiAgICAgICAgaWQ6IGAke3RoaXMuaWR9OlRodW1ibmFpbEdlbmVyYXRvcmAsXG4gICAgICAgIHRodW1ibmFpbFdpZHRoOiB0aGlzLm9wdHMudGh1bWJuYWlsV2lkdGgsXG4gICAgICAgIHRodW1ibmFpbFR5cGU6IHRoaXMub3B0cy50aHVtYm5haWxUeXBlLFxuICAgICAgICB3YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZDogdGhpcy5vcHRzLndhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkLFxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBibG9jayBvbiB0aHVtYm5haWxzLCB3ZSBjYW4gbGF6aWx5IGdlbmVyYXRlIHRoZW1cbiAgICAgICAgbGF6eTogIXRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gRGFyayBNb2RlIC8gdGhlbWVcbiAgICB0aGlzLmRhcmtNb2RlTWVkaWFRdWVyeSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubWF0Y2hNZWRpYSlcbiAgICAgID8gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKVxuICAgICAgOiBudWxsXG5cbiAgICBjb25zdCBpc0RhcmtNb2RlT25Gcm9tVGhlU3RhcnQgPSB0aGlzLmRhcmtNb2RlTWVkaWFRdWVyeSA/IHRoaXMuZGFya01vZGVNZWRpYVF1ZXJ5Lm1hdGNoZXMgOiBmYWxzZVxuICAgIHRoaXMudXBweS5sb2coYFtEYXNoYm9hcmRdIERhcmsgbW9kZSBpcyAke2lzRGFya01vZGVPbkZyb21UaGVTdGFydCA/ICdvbicgOiAnb2ZmJ31gKVxuICAgIHRoaXMuc2V0RGFya01vZGVDYXBhYmlsaXR5KGlzRGFya01vZGVPbkZyb21UaGVTdGFydClcblxuICAgIGlmICh0aGlzLm9wdHMudGhlbWUgPT09ICdhdXRvJykge1xuICAgICAgdGhpcy5kYXJrTW9kZU1lZGlhUXVlcnkuYWRkTGlzdGVuZXIodGhpcy5oYW5kbGVTeXN0ZW1EYXJrTW9kZUNoYW5nZSlcbiAgICB9XG5cbiAgICB0aGlzLmRpc2NvdmVyUHJvdmlkZXJQbHVnaW5zKClcbiAgICB0aGlzLmluaXRFdmVudHMoKVxuICB9XG5cbiAgdW5pbnN0YWxsID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVJbmZvcm1lcikge1xuICAgICAgY29uc3QgaW5mb3JtZXIgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OkluZm9ybWVyYClcbiAgICAgIC8vIENoZWNraW5nIGlmIHRoaXMgcGx1Z2luIGV4aXN0cywgaW4gY2FzZSBpdCB3YXMgcmVtb3ZlZCBieSB1cHB5LWNvcmVcbiAgICAgIC8vIGJlZm9yZSB0aGUgRGFzaGJvYXJkIHdhcy5cbiAgICAgIGlmIChpbmZvcm1lcikgdGhpcy51cHB5LnJlbW92ZVBsdWdpbihpbmZvcm1lcilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlU3RhdHVzQmFyKSB7XG4gICAgICBjb25zdCBzdGF0dXNCYXIgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OlN0YXR1c0JhcmApXG4gICAgICBpZiAoc3RhdHVzQmFyKSB0aGlzLnVwcHkucmVtb3ZlUGx1Z2luKHN0YXR1c0JhcilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlVGh1bWJuYWlsR2VuZXJhdG9yKSB7XG4gICAgICBjb25zdCB0aHVtYm5haWwgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OlRodW1ibmFpbEdlbmVyYXRvcmApXG4gICAgICBpZiAodGh1bWJuYWlsKSB0aGlzLnVwcHkucmVtb3ZlUGx1Z2luKHRodW1ibmFpbClcbiAgICB9XG5cbiAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5vcHRzLnBsdWdpbnMgfHwgW11cbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbklEKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHBsdWdpbklEKVxuICAgICAgaWYgKHBsdWdpbikgcGx1Z2luLnVubW91bnQoKVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5vcHRzLnRoZW1lID09PSAnYXV0bycpIHtcbiAgICAgIHRoaXMuZGFya01vZGVNZWRpYVF1ZXJ5LnJlbW92ZUxpc3RlbmVyKHRoaXMuaGFuZGxlU3lzdGVtRGFya01vZGVDaGFuZ2UpXG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50KClcbiAgICB0aGlzLnJlbW92ZUV2ZW50cygpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdzOiB7XG4gICAgLy8gV2hlbiBgaW5saW5lOiBmYWxzZWAsIHVzZWQgYXMgdGhlIHNjcmVlbiByZWFkZXIgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBjbG9zZXMgdGhlIG1vZGFsLlxuICAgIGNsb3NlTW9kYWw6ICdDbG9zZSBNb2RhbCcsXG4gICAgLy8gVXNlZCBhcyB0aGUgc2NyZWVuIHJlYWRlciBsYWJlbCBmb3IgdGhlIHBsdXMgKCspIGJ1dHRvbiB0aGF0IHNob3dzIHRoZSDigJxBZGQgbW9yZSBmaWxlc+KAnSBzY3JlZW5cbiAgICBhZGRNb3JlRmlsZXM6ICdBZGQgbW9yZSBmaWxlcycsXG4gICAgYWRkaW5nTW9yZUZpbGVzOiAnQWRkaW5nIG1vcmUgZmlsZXMnLFxuICAgIC8vIFVzZWQgYXMgdGhlIGhlYWRlciBmb3IgaW1wb3J0IHBhbmVscywgZS5nLiwg4oCcSW1wb3J0IGZyb20gR29vZ2xlIERyaXZl4oCdLlxuICAgIGltcG9ydEZyb206ICdJbXBvcnQgZnJvbSAle25hbWV9JyxcbiAgICAvLyBXaGVuIGBpbmxpbmU6IGZhbHNlYCwgdXNlZCBhcyB0aGUgc2NyZWVuIHJlYWRlciBsYWJlbCBmb3IgdGhlIGRhc2hib2FyZCBtb2RhbC5cbiAgICBkYXNoYm9hcmRXaW5kb3dUaXRsZTogJ1VwcHkgRGFzaGJvYXJkIFdpbmRvdyAoUHJlc3MgZXNjYXBlIHRvIGNsb3NlKScsXG4gICAgLy8gV2hlbiBgaW5saW5lOiB0cnVlYCwgdXNlZCBhcyB0aGUgc2NyZWVuIHJlYWRlciBsYWJlbCBmb3IgdGhlIGRhc2hib2FyZCBhcmVhLlxuICAgIGRhc2hib2FyZFRpdGxlOiAnVXBweSBEYXNoYm9hcmQnLFxuICAgIC8vIFNob3duIGluIHRoZSBJbmZvcm1lciB3aGVuIGEgbGluayB0byBhIGZpbGUgd2FzIGNvcGllZCB0byB0aGUgY2xpcGJvYXJkLlxuICAgIGNvcHlMaW5rVG9DbGlwYm9hcmRTdWNjZXNzOiAnTGluayBjb3BpZWQgdG8gY2xpcGJvYXJkLicsXG4gICAgLy8gVXNlZCB3aGVuIGEgbGluayBjYW5ub3QgYmUgY29waWVkIGF1dG9tYXRpY2FsbHkg4oCUIHRoZSB1c2VyIGhhcyB0byBzZWxlY3QgdGhlIHRleHQgZnJvbSB0aGVcbiAgICAvLyBpbnB1dCBlbGVtZW50IGJlbG93IHRoaXMgc3RyaW5nLlxuICAgIGNvcHlMaW5rVG9DbGlwYm9hcmRGYWxsYmFjazogJ0NvcHkgdGhlIFVSTCBiZWxvdycsXG4gICAgLy8gVXNlZCBhcyB0aGUgaG92ZXIgdGl0bGUgYW5kIHNjcmVlbiByZWFkZXIgbGFiZWwgZm9yIGJ1dHRvbnMgdGhhdCBjb3B5IGEgZmlsZSBsaW5rLlxuICAgIGNvcHlMaW5rOiAnQ29weSBsaW5rJyxcbiAgICBiYWNrOiAnQmFjaycsXG4gICAgLy8gVXNlZCBhcyB0aGUgc2NyZWVuIHJlYWRlciBsYWJlbCBmb3IgYnV0dG9ucyB0aGF0IHJlbW92ZSBhIGZpbGUuXG4gICAgcmVtb3ZlRmlsZTogJ1JlbW92ZSBmaWxlJyxcbiAgICAvLyBVc2VkIGFzIHRoZSBzY3JlZW4gcmVhZGVyIGxhYmVsIGZvciBidXR0b25zIHRoYXQgb3BlbiB0aGUgbWV0YWRhdGEgZWRpdG9yIHBhbmVsIGZvciBhIGZpbGUuXG4gICAgZWRpdEZpbGU6ICdFZGl0IGZpbGUnLFxuICAgIC8vIFNob3duIGluIHRoZSBwYW5lbCBoZWFkZXIgZm9yIHRoZSBtZXRhZGF0YSBlZGl0b3IuIFJlbmRlcmVkIGFzIOKAnEVkaXRpbmcgaW1hZ2UucG5n4oCdLlxuICAgIGVkaXRpbmc6ICdFZGl0aW5nICV7ZmlsZX0nLFxuICAgIC8vIFVzZWQgYXMgdGhlIHNjcmVlbiByZWFkZXIgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBzYXZlcyBtZXRhZGF0YSBlZGl0cyBhbmQgcmV0dXJucyB0byB0aGVcbiAgICAvLyBmaWxlIGxpc3Qgdmlldy5cbiAgICBmaW5pc2hFZGl0aW5nRmlsZTogJ0ZpbmlzaCBlZGl0aW5nIGZpbGUnLFxuICAgIHNhdmVDaGFuZ2VzOiAnU2F2ZSBjaGFuZ2VzJyxcbiAgICAvLyBVc2VkIGFzIHRoZSBsYWJlbCBmb3IgdGhlIHRhYiBidXR0b24gdGhhdCBvcGVucyB0aGUgc3lzdGVtIGZpbGUgc2VsZWN0aW9uIGRpYWxvZy5cbiAgICBteURldmljZTogJ015IERldmljZScsXG4gICAgZHJvcEhpbnQ6ICdEcm9wIHlvdXIgZmlsZXMgaGVyZScsXG4gICAgLy8gVXNlZCBhcyB0aGUgaG92ZXIgdGV4dCBhbmQgc2NyZWVuIHJlYWRlciBsYWJlbCBmb3IgZmlsZSBwcm9ncmVzcyBpbmRpY2F0b3JzIHdoZW5cbiAgICAvLyB0aGV5IGhhdmUgYmVlbiBmdWxseSB1cGxvYWRlZC5cbiAgICB1cGxvYWRDb21wbGV0ZTogJ1VwbG9hZCBjb21wbGV0ZScsXG4gICAgdXBsb2FkUGF1c2VkOiAnVXBsb2FkIHBhdXNlZCcsXG4gICAgLy8gVXNlZCBhcyB0aGUgaG92ZXIgdGV4dCBhbmQgc2NyZWVuIHJlYWRlciBsYWJlbCBmb3IgdGhlIGJ1dHRvbnMgdG8gcmVzdW1lIHBhdXNlZCB1cGxvYWRzLlxuICAgIHJlc3VtZVVwbG9hZDogJ1Jlc3VtZSB1cGxvYWQnLFxuICAgIC8vIFVzZWQgYXMgdGhlIGhvdmVyIHRleHQgYW5kIHNjcmVlbiByZWFkZXIgbGFiZWwgZm9yIHRoZSBidXR0b25zIHRvIHBhdXNlIHVwbG9hZHMuXG4gICAgcGF1c2VVcGxvYWQ6ICdQYXVzZSB1cGxvYWQnLFxuICAgIC8vIFVzZWQgYXMgdGhlIGhvdmVyIHRleHQgYW5kIHNjcmVlbiByZWFkZXIgbGFiZWwgZm9yIHRoZSBidXR0b25zIHRvIHJldHJ5IGZhaWxlZCB1cGxvYWRzLlxuICAgIHJldHJ5VXBsb2FkOiAnUmV0cnkgdXBsb2FkJyxcbiAgICAvLyBVc2VkIGFzIHRoZSBob3ZlciB0ZXh0IGFuZCBzY3JlZW4gcmVhZGVyIGxhYmVsIGZvciB0aGUgYnV0dG9ucyB0byBjYW5jZWwgdXBsb2Fkcy5cbiAgICBjYW5jZWxVcGxvYWQ6ICdDYW5jZWwgdXBsb2FkJyxcbiAgICAvLyBVc2VkIGluIGEgdGl0bGUsIGhvdyBtYW55IGZpbGVzIGFyZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICB4RmlsZXNTZWxlY3RlZDoge1xuICAgICAgMDogJyV7c21hcnRfY291bnR9IGZpbGUgc2VsZWN0ZWQnLFxuICAgICAgMTogJyV7c21hcnRfY291bnR9IGZpbGVzIHNlbGVjdGVkJyxcbiAgICB9LFxuICAgIHVwbG9hZGluZ1hGaWxlczoge1xuICAgICAgMDogJ1VwbG9hZGluZyAle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgIDE6ICdVcGxvYWRpbmcgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgIH0sXG4gICAgcHJvY2Vzc2luZ1hGaWxlczoge1xuICAgICAgMDogJ1Byb2Nlc3NpbmcgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAxOiAnUHJvY2Vzc2luZyAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgfSxcbiAgICAvLyBUaGUgXCJwb3dlcmVkIGJ5IFVwcHlcIiBsaW5rIGF0IHRoZSBib3R0b20gb2YgdGhlIERhc2hib2FyZC5cbiAgICBwb3dlcmVkQnk6ICdQb3dlcmVkIGJ5ICV7dXBweX0nLFxuICAgIGFkZE1vcmU6ICdBZGQgbW9yZScsXG4gICAgZWRpdEZpbGVXaXRoRmlsZW5hbWU6ICdFZGl0IGZpbGUgJXtmaWxlfScsXG4gICAgc2F2ZTogJ1NhdmUnLFxuICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgZHJvcFBhc3RlRmlsZXM6ICdEcm9wIGZpbGVzIGhlcmUgb3IgJXticm93c2VGaWxlc30nLFxuICAgIGRyb3BQYXN0ZUZvbGRlcnM6ICdEcm9wIGZpbGVzIGhlcmUgb3IgJXticm93c2VGb2xkZXJzfScsXG4gICAgZHJvcFBhc3RlQm90aDogJ0Ryb3AgZmlsZXMgaGVyZSwgJXticm93c2VGaWxlc30gb3IgJXticm93c2VGb2xkZXJzfScsXG4gICAgZHJvcFBhc3RlSW1wb3J0RmlsZXM6ICdEcm9wIGZpbGVzIGhlcmUsICV7YnJvd3NlRmlsZXN9IG9yIGltcG9ydCBmcm9tOicsXG4gICAgZHJvcFBhc3RlSW1wb3J0Rm9sZGVyczogJ0Ryb3AgZmlsZXMgaGVyZSwgJXticm93c2VGb2xkZXJzfSBvciBpbXBvcnQgZnJvbTonLFxuICAgIGRyb3BQYXN0ZUltcG9ydEJvdGg6XG4gICAgICAnRHJvcCBmaWxlcyBoZXJlLCAle2Jyb3dzZUZpbGVzfSwgJXticm93c2VGb2xkZXJzfSBvciBpbXBvcnQgZnJvbTonLFxuICAgIGltcG9ydEZpbGVzOiAnSW1wb3J0IGZpbGVzIGZyb206JyxcbiAgICBicm93c2VGaWxlczogJ2Jyb3dzZSBmaWxlcycsXG4gICAgYnJvd3NlRm9sZGVyczogJ2Jyb3dzZSBmb2xkZXJzJyxcbiAgICByZWNvdmVyZWRYRmlsZXM6IHtcbiAgICAgIDA6ICdXZSBjb3VsZCBub3QgZnVsbHkgcmVjb3ZlciAxIGZpbGUuIFBsZWFzZSByZS1zZWxlY3QgaXQgYW5kIHJlc3VtZSB0aGUgdXBsb2FkLicsXG4gICAgICAxOiAnV2UgY291bGQgbm90IGZ1bGx5IHJlY292ZXIgJXtzbWFydF9jb3VudH0gZmlsZXMuIFBsZWFzZSByZS1zZWxlY3QgdGhlbSBhbmQgcmVzdW1lIHRoZSB1cGxvYWQuJyxcbiAgICB9LFxuICAgIHJlY292ZXJlZEFsbEZpbGVzOiAnV2UgcmVzdG9yZWQgYWxsIGZpbGVzLiBZb3UgY2FuIG5vdyByZXN1bWUgdGhlIHVwbG9hZC4nLFxuICAgIHNlc3Npb25SZXN0b3JlZDogJ1Nlc3Npb24gcmVzdG9yZWQnLFxuICAgIHJlU2VsZWN0OiAnUmUtc2VsZWN0JyxcbiAgICBtaXNzaW5nUmVxdWlyZWRNZXRhRmllbGRzOiB7XG4gICAgICAwOiAnTWlzc2luZyByZXF1aXJlZCBtZXRhIGZpZWxkOiAle2ZpZWxkc30uJyxcbiAgICAgIDE6ICdNaXNzaW5nIHJlcXVpcmVkIG1ldGEgZmllbGRzOiAle2ZpZWxkc30uJyxcbiAgICB9LFxuICB9LFxufVxuIiwiLyoqXG4gKiBDb3BpZXMgdGV4dCB0byBjbGlwYm9hcmQgYnkgY3JlYXRpbmcgYW4gYWxtb3N0IGludmlzaWJsZSB0ZXh0YXJlYSxcbiAqIGFkZGluZyB0ZXh0IHRoZXJlLCB0aGVuIHJ1bm5pbmcgZXhlY0NvbW1hbmQoJ2NvcHknKS5cbiAqIEZhbGxzIGJhY2sgdG8gcHJvbXB0KCkgd2hlbiB0aGUgZWFzeSB3YXkgZmFpbHMgKGhlbGxvLCBTYWZhcmkhKVxuICogRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMDgxMDMyMlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0VG9Db3B5XG4gKiBAcGFyYW0ge3N0cmluZ30gZmFsbGJhY2tTdHJpbmdcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZCAodGV4dFRvQ29weSwgZmFsbGJhY2tTdHJpbmcpIHtcbiAgZmFsbGJhY2tTdHJpbmcgPSBmYWxsYmFja1N0cmluZyB8fCAnQ29weSB0aGUgVVJMIGJlbG93J1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHRleHRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKVxuICAgIHRleHRBcmVhLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogJzJlbScsXG4gICAgICBoZWlnaHQ6ICcyZW0nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgYm94U2hhZG93OiAnbm9uZScsXG4gICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgIH0pXG5cbiAgICB0ZXh0QXJlYS52YWx1ZSA9IHRleHRUb0NvcHlcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRBcmVhKVxuICAgIHRleHRBcmVhLnNlbGVjdCgpXG5cbiAgICBjb25zdCBtYWdpY0NvcHlGYWlsZWQgPSAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWFsZXJ0XG4gICAgICB3aW5kb3cucHJvbXB0KGZhbGxiYWNrU3RyaW5nLCB0ZXh0VG9Db3B5KVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpXG4gICAgICBpZiAoIXN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgcmV0dXJuIG1hZ2ljQ29weUZhaWxlZCgnY29weSBjb21tYW5kIHVuYXZhaWxhYmxlJylcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpXG4gICAgICByZXR1cm4gcmVzb2x2ZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKVxuICAgICAgcmV0dXJuIG1hZ2ljQ29weUZhaWxlZChlcnIpXG4gICAgfVxuICB9KVxufVxuIiwiY29uc3QgZGVib3VuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKVxuY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0ZPQ1VTQUJMRV9FTEVNRU5UUycpXG5jb25zdCBnZXRBY3RpdmVPdmVybGF5RWwgPSByZXF1aXJlKCcuL2dldEFjdGl2ZU92ZXJsYXlFbCcpXG5cbi8qXG4gIEZvY3VzZXMgb24gc29tZSBlbGVtZW50IGluIHRoZSBjdXJyZW50bHkgdG9wbW9zdCBvdmVybGF5LlxuXG4gIDEuIElmIHRoZXJlIGFyZSBzb21lIFtkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXSBlbGVtZW50cyByZW5kZXJlZCBhbHJlYWR5IC0gZm9jdXNlc1xuICAgICBvbiB0aGUgZmlyc3Qgc3VwZXJmb2N1c2FibGUgZWxlbWVudCwgYW5kIGxlYXZlcyBmb2N1cyB1cCB0byB0aGUgY29udHJvbCBvZlxuICAgICBhIHVzZXIgKHVudGlsIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgZGlzYXBwZWFycyBmcm9tIHRoZSBzY3JlZW4gW3doaWNoXG4gICAgIGNhbiBoYXBwZW4gd2hlbiBvdmVybGF5IGNoYW5nZXMsIG9yLCBlLmcuLCB3aGVuIHdlIGNsaWNrIG9uIGEgZm9sZGVyIGluIGdvb2dsZWRyaXZlXSkuXG4gIDIuIElmIHRoZXJlIGFyZSBubyBbZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZV0gZWxlbWVudHMgeWV0IChvciBldmVyKSAtIGZvY3VzZXNcbiAgICAgb24gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50LCBidXQgc3dpdGNoZXMgZm9jdXMgaWYgc3VwZXJmb2N1c2FibGUgZWxlbWVudHMgYXBwZWFyIG9uIG5leHQgcmVuZGVyLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlU3VwZXJGb2N1cyAoKSB7XG4gIGxldCBsYXN0Rm9jdXNXYXNPblN1cGVyRm9jdXNhYmxlRWwgPSBmYWxzZVxuXG4gIGNvbnN0IHN1cGVyRm9jdXMgPSAoZGFzaGJvYXJkRWwsIGFjdGl2ZU92ZXJsYXlUeXBlKSA9PiB7XG4gICAgY29uc3Qgb3ZlcmxheUVsID0gZ2V0QWN0aXZlT3ZlcmxheUVsKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSlcblxuICAgIGNvbnN0IGlzRm9jdXNJbk92ZXJsYXkgPSBvdmVybGF5RWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAvLyBJZiBmb2N1cyBpcyBhbHJlYWR5IGluIHRoZSB0b3Btb3N0IG92ZXJsYXksIEFORCBvbiBsYXN0IHVwZGF0ZSB3ZSBmb2N1c2VkIG9uIHRoZSBzdXBlcmZvY3VzYWJsZVxuICAgIC8vIGVsZW1lbnQgLSB0aGVuIGxlYXZlIGZvY3VzIHVwIHRvIHRoZSB1c2VyLlxuICAgIC8vIFtQcmFjdGljYWwgY2hlY2tdIHdpdGhvdXQgdGhpcyBsaW5lLCB0eXBpbmcgaW4gdGhlIHNlYXJjaCBpbnB1dCBpbiBnb29nbGVkcml2ZSBvdmVybGF5IHdvbid0IHdvcmsuXG4gICAgaWYgKGlzRm9jdXNJbk92ZXJsYXkgJiYgbGFzdEZvY3VzV2FzT25TdXBlckZvY3VzYWJsZUVsKSByZXR1cm5cblxuICAgIGNvbnN0IHN1cGVyRm9jdXNhYmxlRWwgPSBvdmVybGF5RWwucXVlcnlTZWxlY3RvcignW2RhdGEtdXBweS1zdXBlci1mb2N1c2FibGVdJylcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbiB0aGUgdG9wbW9zdCBvdmVybGF5LCBBTkQgdGhlcmUgYXJlIG5vIHN1cGVyIGZvY3VzYWJsZSBlbGVtZW50cyB5ZXQsIC0gbGVhdmUgZm9jdXMgdXAgdG8gdGhlIHVzZXIuXG4gICAgLy8gW1ByYWN0aWNhbCBjaGVja10gd2l0aG91dCB0aGlzIGxpbmUsIGlmIHlvdSBhcmUgaW4gYW4gZW1wdHkgZm9sZGVyIGluIGdvb2dsZSBkcml2ZSwgYW5kIHNvbWV0aGluZydzIHVwbG9hZGluZyBpbiB0aGVcbiAgICAvLyBiZywgLSBmb2N1cyB3aWxsIGJlIGp1bXBpbmcgdG8gRG9uZSBhbGwgdGhlIHRpbWUuXG4gICAgaWYgKGlzRm9jdXNJbk92ZXJsYXkgJiYgIXN1cGVyRm9jdXNhYmxlRWwpIHJldHVyblxuXG4gICAgaWYgKHN1cGVyRm9jdXNhYmxlRWwpIHtcbiAgICAgIHN1cGVyRm9jdXNhYmxlRWwuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pXG4gICAgICBsYXN0Rm9jdXNXYXNPblN1cGVyRm9jdXNhYmxlRWwgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0RWwgPSBvdmVybGF5RWwucXVlcnlTZWxlY3RvcihGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICBmaXJzdEVsPy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSlcbiAgICAgIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gX19fV2h5IGRvIHdlIG5lZWQgdG8gZGVib3VuY2U/XG4gIC8vICAgIDEuIFRvIGRlYWwgd2l0aCBhbmltYXRpb25zOiBvdmVybGF5IGNoYW5nZXMgdmlhIGFuaW1hdGlvbnMsIHdoaWNoIHJlc3VsdHMgaW4gdGhlIERPTSB1cGRhdGluZyBBRlRFUiBwbHVnaW4udXBkYXRlKClcbiAgLy8gICAgICAgYWxyZWFkeSBleGVjdXRlZC5cbiAgLy8gICAgW1ByYWN0aWNhbCBjaGVja10gd2l0aG91dCBkZWJvdW5jZSwgaWYgd2Ugb3BlbiB0aGUgVXJsIG92ZXJsYXksIGFuZCBjbGljayAnRG9uZScsIERhc2hib2FyZCB3b24ndCBnZXQgZm9jdXNlZCBhZ2Fpbi5cbiAgLy8gICAgW1ByYWN0aWNhbCBjaGVja10gaWYgd2UgZGVsYXkgMjUwbXMgaW5zdGVhZCBvZiAyNjBtcyAtIElFMTEgd29uJ3QgZ2V0IGZvY3VzZWQgaW4gc2FtZSBzaXR1YXRpb24uXG4gIC8vICAgIDIuIFBlcmZvcm1hbmNlOiB0aGVyZSBjYW4gYmUgbWFueSBzdGF0ZSB1cGRhdGUoKXMgaW4gYSBzZWNvbmQsIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lLlxuICByZXR1cm4gZGVib3VuY2Uoc3VwZXJGb2N1cywgMjYwKVxufVxuIiwiLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IC0gZWl0aGVyIGRhc2hib2FyZCBlbGVtZW50LCBvciB0aGUgb3ZlcmxheSB0aGF0J3MgbW9zdCBvbiB0b3BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRBY3RpdmVPdmVybGF5RWwgKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSkge1xuICBpZiAoYWN0aXZlT3ZlcmxheVR5cGUpIHtcbiAgICBjb25zdCBvdmVybGF5RWwgPSBkYXNoYm9hcmRFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS11cHB5LXBhbmVsdHlwZT1cIiR7YWN0aXZlT3ZlcmxheVR5cGV9XCJdYClcbiAgICAvLyBpZiBhbiBvdmVybGF5IGlzIGFscmVhZHkgbW91bnRlZFxuICAgIGlmIChvdmVybGF5RWwpIHJldHVybiBvdmVybGF5RWxcbiAgfVxuICByZXR1cm4gZGFzaGJvYXJkRWxcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gaWNvbkltYWdlICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPGcgZmlsbD1cIiM2ODZERTBcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgPHBhdGggZD1cIk01IDd2MTBoMTVWN0g1em0wLTFoMTVhMSAxIDAgMCAxIDEgMXYxMGExIDEgMCAwIDEtMSAxSDVhMSAxIDAgMCAxLTEtMVY3YTEgMSAwIDAgMSAxLTF6XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk02LjM1IDE3LjE3Mmw0Ljk5NC01LjAyNmEuNS41IDAgMCAxIC43MDcgMGwyLjE2IDIuMTYgMy41MDUtMy41MDVhLjUuNSAwIDAgMSAuNzA3IDBsMi4zMzYgMi4zMS0uNzA3LjcyLTEuOTgzLTEuOTctMy41MDUgMy41MDVhLjUuNSAwIDAgMS0uNzA3IDBsLTIuMTYtMi4xNTktMy45MzggMy45MzktMS40MDkuMDI2elwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDxjaXJjbGUgY3g9XCI3LjVcIiBjeT1cIjkuNVwiIHI9XCIxLjVcIiAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25BdWRpbyAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk05LjUgMTguNjRjMCAxLjE0LTEuMTQ1IDItMi41IDJzLTIuNS0uODYtMi41LTJjMC0xLjE0IDEuMTQ1LTIgMi41LTIgLjU1NyAwIDEuMDc5LjE0NSAxLjUuMzk2VjcuMjVhLjUuNSAwIDAgMSAuMzc5LS40ODVsOS0yLjI1QS41LjUgMCAwIDEgMTguNSA1djExLjY0YzAgMS4xNC0xLjE0NSAyLTIuNSAycy0yLjUtLjg2LTIuNS0yYzAtMS4xNCAxLjE0NS0yIDIuNS0yIC41NTcgMCAxLjA3OS4xNDUgMS41LjM5NlY4LjY3bC04IDJ2Ny45N3ptOC0xMXYtMmwtOCAydjJsOC0yek03IDE5LjY0Yy44NTUgMCAxLjUtLjQ4NCAxLjUtMXMtLjY0NS0xLTEuNS0xLTEuNS40ODQtMS41IDEgLjY0NSAxIDEuNSAxem05LTJjLjg1NSAwIDEuNS0uNDg0IDEuNS0xcy0uNjQ1LTEtMS41LTEtMS41LjQ4NC0xLjUgMSAuNjQ1IDEgMS41IDF6XCIgZmlsbD1cIiMwNDlCQ0ZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25WaWRlbyAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk0xNiAxMS44MzRsNC40ODYtMi42OTFBMSAxIDAgMCAxIDIyIDEwdjZhMSAxIDAgMCAxLTEuNTE0Ljg1N0wxNiAxNC4xNjdWMTdhMSAxIDAgMCAxLTEgMUg1YTEgMSAwIDAgMS0xLTFWOWExIDEgMCAwIDEgMS0xaDEwYTEgMSAwIDAgMSAxIDF2Mi44MzR6TTE1IDlINXY4aDEwVjl6bTEgNGw1IDN2LTZsLTUgM3pcIiBmaWxsPVwiIzE5QUY2N1wiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblBERiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk05Ljc2NiA4LjI5NWMtLjY5MS0xLjg0My0uNTM5LTMuNDAxLjc0Ny0zLjcyNiAxLjY0My0uNDE0IDIuNTA1LjkzOCAyLjM5IDMuMjk5LS4wMzkuNzktLjE5NCAxLjY2Mi0uNTM3IDMuMTQ4LjMyNC40OS42Ni45NjcgMS4wNTUgMS41MS4xNy4yMzEuMzgyLjQ4OC42MjkuNzU3IDEuODY2LS4xMjggMy42NTMuMTE0IDQuOTE4LjY1NSAxLjQ4Ny42MzUgMi4xOTIgMS42ODUgMS42MTQgMi44NC0uNTY2IDEuMTMzLTEuODM5IDEuMDg0LTMuNDE2LjI0OS0xLjE0MS0uNjA0LTIuNDU3LTEuNjM0LTMuNTEtMi43MDdhMTMuNDY3IDEzLjQ2NyAwIDAgMC0yLjIzOC40MjZjLTEuMzkyIDQuMDUxLTQuNTM0IDYuNDUzLTUuNzA3IDQuNTcyLS45ODYtMS41OCAxLjM4LTQuMjA2IDQuOTE0LTUuMzc1LjA5Ny0uMzIyLjE4NS0uNjU2LjI2NC0xLjAwMS4wOC0uMzUzLjMwNi0xLjMxLjQwNy0xLjczNy0uNjc4LTEuMDU5LTEuMi0yLjAzMS0xLjUzLTIuOTF6bTIuMDk4IDQuODdjLS4wMzMuMTQ0LS4wNjguMjg3LS4xMDQuNDI3bC4wMzMtLjAxLS4wMTIuMDM4YTE0LjA2NSAxNC4wNjUgMCAwIDEgMS4wMi0uMTk3bC0uMDMyLS4wMzMuMDUyLS4wMDRhNy45MDIgNy45MDIgMCAwIDEtLjIwOC0uMjcxYy0uMTk3LS4yNy0uMzgtLjUyNi0uNTU1LS43NzVsLS4wMDYuMDI4LS4wMDItLjAwM2MtLjA3Ni4zMjMtLjE0OC42MzItLjE4Ni44em01Ljc3IDIuOTc4YzEuMTQzLjYwNSAxLjgzMi42MzIgMi4wNTQuMTg3LjI2LS41MTktLjA4Ny0xLjAzNC0xLjExMy0xLjQ3My0uOTExLS4zOS0yLjE3NS0uNjA4LTMuNTUtLjYwOC44NDUuNzY2IDEuNzg3IDEuNDU5IDIuNjA5IDEuODk0ek02LjU1OSAxOC43ODljLjE0LjIyMy42OTMuMTYgMS40MjUtLjQxMy44MjctLjY0OCAxLjYxLTEuNzQ3IDIuMjA4LTMuMjA2LTIuNTYzIDEuMDY0LTQuMTAyIDIuODY3LTMuNjMzIDMuNjJ6bTUuMzQ1LTEwLjk3Yy4wODgtMS43OTMtLjM1MS0yLjQ4LTEuMTQ2LTIuMjgtLjQ3My4xMTktLjU2NCAxLjA1LS4wNTYgMi40MDUuMjEzLjU2Ni41MiAxLjE4OC45MDggMS44NTkuMTgtLjg1OC4yNjgtMS40NTMuMjk0LTEuOTg0elwiIGZpbGw9XCIjRTI1MTRBXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uQXJjaGl2ZSAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTAuNDUgMi4wNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNWgtMS4wNWEuNS41IDAgMCAxLS41LS41VjIuNTVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNGgxLjA1YS41LjUgMCAwIDEgLjUuNVYzLjZhLjUuNSAwIDAgMS0uNS41SDEyLjVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNWEuNS41IDAgMCAxIC41LS41di0uMDAxek0xMC40NSAwaDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjVhLjUuNSAwIDAgMS0uNS41aC0xLjA1YS41LjUgMCAwIDEtLjUtLjVWLjVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNUgxMi41YS41LjUgMCAwIDEtLjUtLjV2LS4wMjRhLjUuNSAwIDAgMSAuNS0uNXptLTIuMDUgMy4wNzRoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNWEuNS41IDAgMCAxLS41LjVoLTEuMDVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNWEuNS41IDAgMCAxIC41LS41em0yLjA1IDEuMDI1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjRhLjUuNSAwIDAgMS0uNS41SDEyLjVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNGEuNS41IDAgMCAxIC41LS41em0tMi4wNSAxLjAyNGgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI1YS41LjUgMCAwIDEtLjUuNWgtMS4wNWEuNS41IDAgMCAxLS41LS41di0uMDI1YS41LjUgMCAwIDEgLjUtLjV6bTIuMDUgMS4wMjVoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNWEuNS41IDAgMCAxLS41LjVIMTIuNWEuNS41IDAgMCAxLS41LS41di0uMDI1YS41LjUgMCAwIDEgLjUtLjV6bS0yLjA1IDEuMDI1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjVhLjUuNSAwIDAgMS0uNS41aC0xLjA1YS41LjUgMCAwIDEtLjUtLjV2LS4wMjVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNUgxMi41YS41LjUgMCAwIDEtLjUtLjV2LS4wMjRhLjUuNSAwIDAgMSAuNS0uNXptLTEuNjU2IDMuMDc0bC0uODIgNS45NDZjLjUyLjMwMiAxLjE3NC40NTggMS45NzYuNDU4LjgwMyAwIDEuNDU1LS4xNTYgMS45NzUtLjQ1OGwtLjgyLTUuOTQ2aC0yLjMxMXptMC0xLjAyNWgyLjMxMmMuNTEyIDAgLjk0Ni4zNzggMS4wMTUuODg1bC44MiA1Ljk0NmMuMDU2LjQxMi0uMTQyLjgxNy0uNTAxIDEuMDI2LS42ODYuMzk4LTEuNTE1LjU5Ny0yLjQ5LjU5Ny0uOTc0IDAtMS44MDQtLjE5OS0yLjQ5LS41OTdhMS4wMjUgMS4wMjUgMCAwIDEtLjUtMS4wMjZsLjgxOS01Ljk0NmMuMDctLjUwNy41MDMtLjg4NSAxLjAxNS0uODg1em0uNTQ1IDYuNmEuNS41IDAgMCAxLS4zOTctLjU2MWwuMTQzLS45OTlhLjUuNSAwIDAgMSAuNDk1LS40MjloLjc0YS41LjUgMCAwIDEgLjQ5NS40M2wuMTQzLjk5OGEuNS41IDAgMCAxLS4zOTcuNTYxYy0uNDA0LjA4LS44MTkuMDgtMS4yMjIgMHpcIiBmaWxsPVwiIzAwQzQ2OVwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvbkZpbGUgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxnIGZpbGw9XCIjQTdBRkI3XCIgZmlsbFJ1bGU9XCJub256ZXJvXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNS41IDIyYS41LjUgMCAwIDEtLjUtLjV2LTE4YS41LjUgMCAwIDEgLjUtLjVoMTAuNzE5YS41LjUgMCAwIDEgLjM2Ny4xNmwzLjI4MSAzLjU1NmEuNS41IDAgMCAxIC4xMzMuMzM5VjIxLjVhLjUuNSAwIDAgMS0uNS41aC0xNHptLjUtMWgxM1Y3LjI1TDE2IDRINnYxN3pcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTE1IDR2M2ExIDEgMCAwIDAgMSAxaDNWN2gtM1Y0aC0xelwiIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblRleHQgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNNC41IDdoMTNhLjUuNSAwIDEgMSAwIDFoLTEzYS41LjUgMCAwIDEgMC0xem0wIDNoMTVhLjUuNSAwIDEgMSAwIDFoLTE1YS41LjUgMCAxIDEgMC0xem0wIDNoMTVhLjUuNSAwIDEgMSAwIDFoLTE1YS41LjUgMCAxIDEgMC0xem0wIDNoMTBhLjUuNSAwIDEgMSAwIDFoLTEwYS41LjUgMCAxIDEgMC0xelwiIGZpbGw9XCIjNUE1RTY5XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEljb25CeU1pbWUgKGZpbGVUeXBlKSB7XG4gIGNvbnN0IGRlZmF1bHRDaG9pY2UgPSB7XG4gICAgY29sb3I6ICcjODM4OTk5JyxcbiAgICBpY29uOiBpY29uRmlsZSgpLFxuICB9XG5cbiAgaWYgKCFmaWxlVHlwZSkgcmV0dXJuIGRlZmF1bHRDaG9pY2VcblxuICBjb25zdCBmaWxlVHlwZUdlbmVyYWwgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzBdXG4gIGNvbnN0IGZpbGVUeXBlU3BlY2lmaWMgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzFdXG5cbiAgLy8gVGV4dFxuICBpZiAoZmlsZVR5cGVHZW5lcmFsID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICcjNWE1ZTY5JyxcbiAgICAgIGljb246IGljb25UZXh0KCksXG4gICAgfVxuICB9XG5cbiAgLy8gSW1hZ2VcbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ2ltYWdlJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyM2ODZkZTAnLFxuICAgICAgaWNvbjogaWNvbkltYWdlKCksXG4gICAgfVxuICB9XG5cbiAgLy8gQXVkaW9cbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ2F1ZGlvJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMwNjhkYmInLFxuICAgICAgaWNvbjogaWNvbkF1ZGlvKCksXG4gICAgfVxuICB9XG5cbiAgLy8gVmlkZW9cbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ3ZpZGVvJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMxOWFmNjcnLFxuICAgICAgaWNvbjogaWNvblZpZGVvKCksXG4gICAgfVxuICB9XG5cbiAgLy8gUERGXG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICdhcHBsaWNhdGlvbicgJiYgZmlsZVR5cGVTcGVjaWZpYyA9PT0gJ3BkZicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICcjZTI1MTQ5JyxcbiAgICAgIGljb246IGljb25QREYoKSxcbiAgICB9XG4gIH1cblxuICAvLyBBcmNoaXZlXG4gIGNvbnN0IGFyY2hpdmVUeXBlcyA9IFsnemlwJywgJ3gtN3otY29tcHJlc3NlZCcsICd4LXJhci1jb21wcmVzc2VkJywgJ3gtdGFyJywgJ3gtZ3ppcCcsICd4LWFwcGxlLWRpc2tpbWFnZSddXG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICdhcHBsaWNhdGlvbicgJiYgYXJjaGl2ZVR5cGVzLmluZGV4T2YoZmlsZVR5cGVTcGVjaWZpYykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnIzAwQzQ2OScsXG4gICAgICBpY29uOiBpY29uQXJjaGl2ZSgpLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0Q2hvaWNlXG59XG4iLCIvLyBpZ25vcmUgZHJvcC9wYXN0ZSBldmVudHMgaWYgdGhleSBhcmUgbm90IGluIGlucHV0IG9yIHRleHRhcmVhIOKAlFxuLy8gb3RoZXJ3aXNlIHdoZW4gVXJsIHBsdWdpbiBhZGRzIGRyb3AvcGFzdGUgbGlzdGVuZXJzIHRvIHRoaXMuZWwsXG4vLyBkcmFnaW5nIFVJIGVsZW1lbnRzIG9yIHBhc3RpbmcgYW55dGhpbmcgaW50byBhbnkgZmllbGQgdHJpZ2dlcnMgdGhvc2UgZXZlbnRzIOKAlFxuLy8gVXJsIHRyZWF0cyB0aGVtIGFzIFVSTHMgdGhhdCBuZWVkIHRvIGJlIGltcG9ydGVkXG5cbmZ1bmN0aW9uIGlnbm9yZUV2ZW50IChldikge1xuICBjb25zdCB7IHRhZ05hbWUgfSA9IGV2LnRhcmdldFxuICBpZiAodGFnTmFtZSA9PT0gJ0lOUFVUJ1xuICAgICAgfHwgdGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgcmV0dXJuXG4gIH1cbiAgZXYucHJldmVudERlZmF1bHQoKVxuICBldi5zdG9wUHJvcGFnYXRpb24oKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlnbm9yZUV2ZW50XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RvQXJyYXknKVxuY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0ZPQ1VTQUJMRV9FTEVNRU5UUycpXG5jb25zdCBnZXRBY3RpdmVPdmVybGF5RWwgPSByZXF1aXJlKCcuL2dldEFjdGl2ZU92ZXJsYXlFbCcpXG5cbmZ1bmN0aW9uIGZvY3VzT25GaXJzdE5vZGUgKGV2ZW50LCBub2Rlcykge1xuICBjb25zdCBub2RlID0gbm9kZXNbMF1cbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmZvY3VzKClcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cbn1cblxuZnVuY3Rpb24gZm9jdXNPbkxhc3ROb2RlIChldmVudCwgbm9kZXMpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdXG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5mb2N1cygpXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG59XG5cbi8vIF9fX1doeSBub3QganVzdCB1c2UgKGZvY3VzZWRJdGVtSW5kZXggPT09IC0xKT9cbi8vICAgIEZpcmVmb3ggdGhpbmtzIDx1bD4gaXMgZm9jdXNhYmxlLCBidXQgd2UgZG9uJ3QgaGF2ZSA8dWw+cyBpbiBvdXIgRk9DVVNBQkxFX0VMRU1FTlRTLiBXaGljaCBtZWFucyB0aGF0IGlmIHdlIHRhYiBpbnRvXG4vLyAgICB0aGUgPHVsPiwgY29kZSB3aWxsIHRoaW5rIHRoYXQgd2UgYXJlIG5vdCBpbiB0aGUgYWN0aXZlIG92ZXJsYXksIGFuZCB3ZSBzaG91bGQgZm9jdXNPbkZpcnN0Tm9kZSgpIG9mIHRoZSBjdXJyZW50bHlcbi8vICAgIGFjdGl2ZSBvdmVybGF5IVxuLy8gICAgW1ByYWN0aWNhbCBjaGVja10gaWYgd2UgdXNlIChmb2N1c2VkSXRlbUluZGV4ID09PSAtMSksIGluc3RhZ3JhbSBwcm92aWRlciBpbiBmaXJlZm94IHdpbGwgbmV2ZXIgZ2V0IGZvY3VzIG9uIGl0cyBwaWNzXG4vLyAgICBpbiB0aGUgPHVsPi5cbmZ1bmN0aW9uIGlzRm9jdXNJbk92ZXJsYXkgKGFjdGl2ZU92ZXJsYXlFbCkge1xuICByZXR1cm4gYWN0aXZlT3ZlcmxheUVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG59XG5cbmZ1bmN0aW9uIHRyYXBGb2N1cyAoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbCkge1xuICBjb25zdCBhY3RpdmVPdmVybGF5RWwgPSBnZXRBY3RpdmVPdmVybGF5RWwoZGFzaGJvYXJkRWwsIGFjdGl2ZU92ZXJsYXlUeXBlKVxuICBjb25zdCBmb2N1c2FibGVOb2RlcyA9IHRvQXJyYXkoYWN0aXZlT3ZlcmxheUVsLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKSlcblxuICBjb25zdCBmb2N1c2VkSXRlbUluZGV4ID0gZm9jdXNhYmxlTm9kZXMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuXG4gIC8vIElmIHdlIHByZXNzZWQgdGFiLCBhbmQgZm9jdXMgaXMgbm90IHlldCB3aXRoaW4gdGhlIGN1cnJlbnQgb3ZlcmxheSAtIGZvY3VzIG9uXG4gIC8vIHRoZSBmaXJzdCBlbGVtZW50IHdpdGhpbiB0aGUgY3VycmVudCBvdmVybGF5LlxuICAvLyBUaGlzIGlzIGEgc2FmZXR5IG1lYXN1cmUgKGZvciB3aGVuIHVzZXIgcmV0dXJucyBmcm9tIGFub3RoZXIgdGFiIGUuZy4pLCBtb3N0XG4gIC8vIHBsdWdpbnMgd2lsbCB0cnkgdG8gZm9jdXMgb24gc29tZSBpbXBvcnRhbnQgZWxlbWVudCBhcyBpdCBsb2Fkcy5cbiAgaWYgKCFpc0ZvY3VzSW5PdmVybGF5KGFjdGl2ZU92ZXJsYXlFbCkpIHtcbiAgICBmb2N1c09uRmlyc3ROb2RlKGV2ZW50LCBmb2N1c2FibGVOb2RlcylcbiAgLy8gSWYgd2UgcHJlc3NlZCBzaGlmdCArIHRhYiwgYW5kIHdlJ3JlIG9uIHRoZSBmaXJzdCBlbGVtZW50IG9mIGEgbW9kYWxcbiAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSAwKSB7XG4gICAgZm9jdXNPbkxhc3ROb2RlKGV2ZW50LCBmb2N1c2FibGVOb2RlcylcbiAgLy8gSWYgd2UgcHJlc3NlZCB0YWIsIGFuZCB3ZSdyZSBvbiB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBtb2RhbFxuICB9IGVsc2UgaWYgKCFldmVudC5zaGlmdEtleSAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSBmb2N1c2FibGVOb2Rlcy5sZW5ndGggLSAxKSB7XG4gICAgZm9jdXNPbkZpcnN0Tm9kZShldmVudCwgZm9jdXNhYmxlTm9kZXMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFRyYXBzIGZvY3VzIGluc2lkZSBvZiB0aGUgY3VycmVudGx5IG9wZW4gb3ZlcmxheSAoZS5nLiBEYXNoYm9hcmQsIG9yIGUuZy4gSW5zdGFncmFtKSxcbiAgLy8gbmV2ZXIgbGV0cyBmb2N1cyBkaXNhcHBlYXIgZnJvbSB0aGUgbW9kYWwuXG4gIGZvck1vZGFsOiAoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbCkgPT4ge1xuICAgIHRyYXBGb2N1cyhldmVudCwgYWN0aXZlT3ZlcmxheVR5cGUsIGRhc2hib2FyZEVsKVxuICB9LFxuXG4gIC8vIFRyYXBzIGZvY3VzIGluc2lkZSBvZiB0aGUgY3VycmVudGx5IG9wZW4gb3ZlcmxheSwgdW5sZXNzIG92ZXJsYXkgaXMgbnVsbCAtIHRoZW4gbGV0IHRoZSB1c2VyIHRhYiBhd2F5LlxuICBmb3JJbmxpbmU6IChldmVudCwgYWN0aXZlT3ZlcmxheVR5cGUsIGRhc2hib2FyZEVsKSA9PiB7XG4gICAgLy8gX19fV2hlbiB3ZSdyZSBpbiB0aGUgYmFyZSAnRHJvcCBmaWxlcyBoZXJlLCBwYXN0ZSwgYnJvd3NlIG9yIGltcG9ydCBmcm9tJyBzY3JlZW5cbiAgICBpZiAoYWN0aXZlT3ZlcmxheVR5cGUgPT09IG51bGwpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgYW5kIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgaXQsIHVzZXIgY2FuIHRhYiBhd2F5IGZyb20gVXBweSB0byBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGFnZVxuICAgIC8vIF9fX1doZW4gdGhlcmUgaXMgc29tZSBvdmVybGF5IHdpdGggJ0RvbmUnIGJ1dHRvblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmFwIHRoZSBmb2N1cyBpbnNpZGUgdGhpcyBvdmVybGF5IVxuICAgICAgLy8gVXNlciBjYW4gY2xvc2UgdGhlIG92ZXJsYXkgKGNsaWNrICdEb25lJykgaWYgdGhleSB3YW50IHRvIHRyYXZlbCBhd2F5IGZyb20gVXBweS5cbiAgICAgIHRyYXBGb2N1cyhldmVudCwgYWN0aXZlT3ZlcmxheVR5cGUsIGRhc2hib2FyZEVsKVxuICAgIH1cbiAgfSxcbn1cbiIsImNvbnN0IEJhc2VQbHVnaW4gPSByZXF1aXJlKCdAdXBweS9jb3JlL2xpYi9CYXNlUGx1Z2luJylcbmNvbnN0IGdldERyb3BwZWRGaWxlcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXREcm9wcGVkRmlsZXMnKVxuY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcblxuLyoqXG4gKiBEcm9wIFRhcmdldCBwbHVnaW5cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRHJvcFRhcmdldCBleHRlbmRzIEJhc2VQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ2FjcXVpcmVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0Ryb3BUYXJnZXQnXG4gICAgdGhpcy50aXRsZSA9ICdEcm9wIFRhcmdldCdcblxuICAgIC8vIERlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRzID0ge1xuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgIH1cblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0cywgLi4ub3B0cyB9XG4gICAgdGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dCA9IG51bGxcbiAgfVxuXG4gIGFkZEZpbGVzID0gKGZpbGVzKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWxlcy5tYXAoKGZpbGUpID0+ICh7XG4gICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbWV0YToge1xuICAgICAgICAvLyBwYXRoIG9mIHRoZSBmaWxlIHJlbGF0aXZlIHRvIHRoZSBhbmNlc3RvciBkaXJlY3RvcnkgdGhlIHVzZXIgc2VsZWN0ZWQuXG4gICAgICAgIC8vIGUuZy4gJ2RvY3MvT2xkIFByYWd1ZS9haXJibmIucGRmJ1xuICAgICAgICByZWxhdGl2ZVBhdGg6IGZpbGUucmVsYXRpdmVQYXRoIHx8IG51bGwsXG4gICAgICB9LFxuICAgIH0pKVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBweS5hZGRGaWxlcyhkZXNjcmlwdG9ycylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURyb3AgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcblxuICAgIC8vIFJlbW92ZSBkcmFnb3ZlciBjbGFzc1xuICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgndXBweS1pcy1kcmFnLW92ZXInKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogZmFsc2UgfSlcblxuICAgIC8vIExldCBhbnkgYWNxdWlyZXIgcGx1Z2luIChVcmwvV2ViY2FtL2V0Yy4pIGhhbmRsZSBkcm9wcyB0byB0aGUgcm9vdFxuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luLnR5cGUgPT09ICdhY3F1aXJlcicpIHtcbiAgICAgICAgLy8gRXZlcnkgUGx1Z2luIHdpdGggLnR5cGUgYWNxdWlyZXIgY2FuIGRlZmluZSBoYW5kbGVSb290RHJvcChldmVudClcbiAgICAgICAgcGx1Z2luLmhhbmRsZVJvb3REcm9wPy4oZXZlbnQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEFkZCBhbGwgZHJvcHBlZCBmaWxlcywgaGFuZGxlIGVycm9yc1xuICAgIGxldCBleGVjdXRlZERyb3BFcnJvck9uY2UgPSBmYWxzZVxuICAgIGNvbnN0IGxvZ0Ryb3BFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhlcnJvciwgJ2Vycm9yJylcblxuICAgICAgLy8gSW4gcHJhY3RpY2UgYWxsIGRyb3AgZXJyb3JzIGFyZSBtb3N0IGxpa2VseSB0aGUgc2FtZSxcbiAgICAgIC8vIHNvIGxldCdzIGp1c3Qgc2hvdyBvbmUgdG8gYXZvaWQgb3ZlcndoZWxtaW5nIHRoZSB1c2VyXG4gICAgICBpZiAoIWV4ZWN1dGVkRHJvcEVycm9yT25jZSkge1xuICAgICAgICB0aGlzLnVwcHkuaW5mbyhlcnJvci5tZXNzYWdlLCAnZXJyb3InKVxuICAgICAgICBleGVjdXRlZERyb3BFcnJvck9uY2UgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCBnZXREcm9wcGVkRmlsZXMoZXZlbnQuZGF0YVRyYW5zZmVyLCB7IGxvZ0Ryb3BFcnJvciB9KVxuICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbRHJvcFRhcmdldF0gRmlsZXMgd2VyZSBkcm9wcGVkJylcbiAgICAgIHRoaXMuYWRkRmlsZXMoZmlsZXMpXG4gICAgfVxuXG4gICAgdGhpcy5vcHRzLm9uRHJvcD8uKGV2ZW50KVxuICB9XG5cbiAgaGFuZGxlRHJhZ092ZXIgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIC8vIEFkZCBhIHNtYWxsICgrKSBpY29uIG9uIGRyb3BcbiAgICAvLyAoYW5kIHByZXZlbnQgYnJvd3NlcnMgZnJvbSBpbnRlcnByZXRpbmcgdGhpcyBhcyBmaWxlcyBiZWluZyBfbW92ZWRfIGludG8gdGhlIGJyb3dzZXIsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzLzE5NzgpXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSdcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0KVxuICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LmFkZCgndXBweS1pcy1kcmFnLW92ZXInKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogdHJ1ZSB9KVxuICAgIHRoaXMub3B0cy5vbkRyYWdPdmVyPy4oZXZlbnQpXG4gIH1cblxuICBoYW5kbGVEcmFnTGVhdmUgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGNvbnN0IHsgY3VycmVudFRhcmdldCB9ID0gZXZlbnRcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0KVxuICAgIC8vIFRpbWVvdXQgYWdhaW5zdCBmbGlja2VyaW5nLCB0aGlzIHNvbHV0aW9uIGlzIHRha2VuIGZyb20gZHJhZy1kcm9wIGxpYnJhcnkuXG4gICAgLy8gU29sdXRpb24gd2l0aCAncG9pbnRlci1ldmVudHM6IG5vbmUnIGRpZG4ndCB3b3JrIGFjcm9zcyBicm93c2Vycy5cbiAgICB0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjdXJyZW50VGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3VwcHktaXMtZHJhZy1vdmVyJylcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogZmFsc2UgfSlcbiAgICB9LCA1MClcbiAgICB0aGlzLm9wdHMub25EcmFnTGVhdmU/LihldmVudClcbiAgfVxuXG4gIGFkZExpc3RlbmVycyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgdGhpcy5ub2RlcyA9IFt0YXJnZXRdXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5ub2RlcyA9IHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5ub2RlcyAmJiAhdGhpcy5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt0YXJnZXR9XCIgZG9lcyBub3QgbWF0Y2ggYW55IEhUTUwgZWxlbWVudHNgKVxuICAgIH1cblxuICAgIHRoaXMubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlRHJhZ092ZXIsIGZhbHNlKVxuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCB0aGlzLmhhbmRsZURyYWdMZWF2ZSwgZmFsc2UpXG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZURyb3AsIGZhbHNlKVxuICAgIH0pXG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpcy5oYW5kbGVEcmFnT3ZlciwgZmFsc2UpXG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgdGhpcy5oYW5kbGVEcmFnTGVhdmUsIGZhbHNlKVxuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZURyb3AsIGZhbHNlKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgaXNEcmFnZ2luZ092ZXI6IGZhbHNlIH0pXG4gICAgdGhpcy5hZGRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpXG4gIH1cbn1cbiIsImNvbnN0IHsgVUlQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3QgbG9jYWxlID0gcmVxdWlyZSgnLi9sb2NhbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERyb3Bib3ggZXh0ZW5kcyBVSVBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdEcm9wYm94J1xuICAgIFByb3ZpZGVyLmluaXRQbHVnaW4odGhpcywgb3B0cylcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdEcm9wYm94J1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIGZpbGw9XCIjMEQyNDgxXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMSA4bDUgMy4xODUtNSAzLjE4Ni01LTMuMTg2TDExIDh6bTEwIDBsNSAzLjE4NS01IDMuMTg2LTUtMy4xODZMMjEgOHpNNiAxNy41NTZsNS0zLjE4NSA1IDMuMTg1LTUgMy4xODYtNS0zLjE4NnptMTUtMy4xODVsNSAzLjE4NS01IDMuMTg2LTUtMy4xODYgNS0zLjE4NXptLTEwIDcuNDMybDUtMy4xODUgNSAzLjE4NS01IDMuMTg2LTUtMy4xODZ6XCIgZmlsbD1cIiNGRkZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICApXG5cbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKHVwcHksIHtcbiAgICAgIGNvbXBhbmlvblVybDogdGhpcy5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgIGNvbXBhbmlvbkhlYWRlcnM6IHRoaXMub3B0cy5jb21wYW5pb25IZWFkZXJzLFxuICAgICAgY29tcGFuaW9uS2V5c1BhcmFtczogdGhpcy5vcHRzLmNvbXBhbmlvbktleXNQYXJhbXMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgICAgcHJvdmlkZXI6ICdkcm9wYm94JyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBsb2NhbGVcblxuICAgIHRoaXMuaTE4bkluaXQoKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLmkxOG4oJ3BsdWdpbk5hbWVEcm9wYm94JylcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMub3B0c1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nczoge1xuICAgIHBsdWdpbk5hbWVEcm9wYm94OiAnRHJvcGJveCcsXG4gIH0sXG59XG4iLCJjb25zdCB7IFVJUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlclZpZXdzIH0gPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IGxvY2FsZSA9IHJlcXVpcmUoJy4vbG9jYWxlLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGYWNlYm9vayBleHRlbmRzIFVJUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0ZhY2Vib29rJ1xuICAgIFByb3ZpZGVyLmluaXRQbHVnaW4odGhpcywgb3B0cylcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdGYWNlYm9vaydcbiAgICB0aGlzLmljb24gPSAoKSA9PiAoXG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxyZWN0IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJJY29uQmdcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgZmlsbD1cIiMzQzVBOTlcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTcuODQyIDI2di04LjY2N2gyLjY1M2wuMzk4LTMuMzc3aC0zLjA1MXYtMi4xNTdjMC0uOTc4LjI0OC0xLjY0NCAxLjUyNy0xLjY0NEgyMVY3LjEzMkExOS45MTQgMTkuOTE0IDAgMCAwIDE4LjYyMyA3Yy0yLjM1MiAwLTMuOTYzIDEuNTc0LTMuOTYzIDQuNDY1djIuNDlIMTJ2My4zNzhoMi42NlYyNmgzLjE4MnpcIiBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ2ZhY2Vib29rJyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBsb2NhbGVcblxuICAgIHRoaXMuaTE4bkluaXQoKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLmkxOG4oJ3BsdWdpbk5hbWVGYWNlYm9vaycpXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgfSlcblxuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLm9wdHNcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldy50ZWFyRG93bigpXG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxuXG4gIG9uRmlyc3RSZW5kZXIgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnByb3ZpZGVyLmZldGNoUHJlQXV0aFRva2VuKCksXG4gICAgICB0aGlzLnZpZXcuZ2V0Rm9sZGVyKCksXG4gICAgXSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICBjb25zdCB2aWV3T3B0aW9ucyA9IHt9XG4gICAgaWYgKHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5maWxlcy5sZW5ndGggJiYgIXRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5mb2xkZXJzLmxlbmd0aCkge1xuICAgICAgdmlld09wdGlvbnMudmlld1R5cGUgPSAnZ3JpZCdcbiAgICAgIHZpZXdPcHRpb25zLnNob3dGaWx0ZXIgPSBmYWxzZVxuICAgICAgdmlld09wdGlvbnMuc2hvd1RpdGxlcyA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlLCB2aWV3T3B0aW9ucylcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZ3M6IHtcbiAgICBwbHVnaW5OYW1lRmFjZWJvb2s6ICdGYWNlYm9vaycsXG4gIH0sXG59XG4iLCJjb25zdCBpbmRleGVkREIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAmJiAod2luZG93LmluZGV4ZWREQiB8fCB3aW5kb3cud2Via2l0SW5kZXhlZERCIHx8IHdpbmRvdy5tb3pJbmRleGVkREIgfHwgd2luZG93Lk9JbmRleGVkREIgfHwgd2luZG93Lm1zSW5kZXhlZERCKVxuXG5jb25zdCBpc1N1cHBvcnRlZCA9ICEhaW5kZXhlZERCXG5cbmNvbnN0IERCX05BTUUgPSAndXBweS1ibG9icydcbmNvbnN0IFNUT1JFX05BTUUgPSAnZmlsZXMnIC8vIG1heWJlIGhhdmUgYSB0aHVtYm5haWwgc3RvcmUgaW4gdGhlIGZ1dHVyZVxuY29uc3QgREVGQVVMVF9FWFBJUlkgPSAyNCAqIDYwICogNjAgKiAxMDAwIC8vIDI0IGhvdXJzXG5jb25zdCBEQl9WRVJTSU9OID0gM1xuXG4vLyBTZXQgZGVmYXVsdCBgZXhwaXJlc2AgZGF0ZXMgb24gZXhpc3Rpbmcgc3RvcmVkIGJsb2JzLlxuZnVuY3Rpb24gbWlncmF0ZUV4cGlyYXRpb24gKHN0b3JlKSB7XG4gIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKClcbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IGN1cnNvci52YWx1ZVxuICAgIGVudHJ5LmV4cGlyZXMgPSBEYXRlLm5vdygpICsgREVGQVVMVF9FWFBJUllcbiAgICBjdXJzb3IudXBkYXRlKGVudHJ5KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3QgKGRiTmFtZSkge1xuICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBEQl9WRVJTSU9OKVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHRcbiAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb24gfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXRcblxuICAgICAgaWYgKGV2ZW50Lm9sZFZlcnNpb24gPCAyKSB7XG4gICAgICAgIC8vIEFkZGVkIGluIHYyOiBEQiBzdHJ1Y3R1cmUgY2hhbmdlZCB0byBhIHNpbmdsZSBzaGFyZWQgb2JqZWN0IHN0b3JlXG4gICAgICAgIGNvbnN0IHN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVfTkFNRSwgeyBrZXlQYXRoOiAnaWQnIH0pXG4gICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KCdzdG9yZScsICdzdG9yZScsIHsgdW5pcXVlOiBmYWxzZSB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQub2xkVmVyc2lvbiA8IDMpIHtcbiAgICAgICAgLy8gQWRkZWQgaW4gdjNcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxuICAgICAgICBzdG9yZS5jcmVhdGVJbmRleCgnZXhwaXJlcycsICdleHBpcmVzJywgeyB1bmlxdWU6IGZhbHNlIH0pXG5cbiAgICAgICAgbWlncmF0ZUV4cGlyYXRpb24oc3RvcmUpXG4gICAgICB9XG5cbiAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoZGIpXG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpXG4gICAgfVxuICAgIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdFxuICB9KVxufVxuXG5mdW5jdGlvbiB3YWl0Rm9yUmVxdWVzdCAocmVxdWVzdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpXG4gICAgfVxuICAgIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdFxuICB9KVxufVxuXG5sZXQgY2xlYW5lZFVwID0gZmFsc2VcbmNsYXNzIEluZGV4ZWREQlN0b3JlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7XG4gICAgICBkYk5hbWU6IERCX05BTUUsXG4gICAgICBzdG9yZU5hbWU6ICdkZWZhdWx0JyxcbiAgICAgIGV4cGlyZXM6IERFRkFVTFRfRVhQSVJZLCAvLyAyNCBob3Vyc1xuICAgICAgbWF4RmlsZVNpemU6IDEwICogMTAyNCAqIDEwMjQsIC8vIDEwIE1CXG4gICAgICBtYXhUb3RhbFNpemU6IDMwMCAqIDEwMjQgKiAxMDI0LCAvLyAzMDAgTUJcbiAgICAgIC4uLm9wdHMsXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5vcHRzLnN0b3JlTmFtZVxuXG4gICAgY29uc3QgY3JlYXRlQ29ubmVjdGlvbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBjb25uZWN0KHRoaXMub3B0cy5kYk5hbWUpXG4gICAgfVxuXG4gICAgaWYgKCFjbGVhbmVkVXApIHtcbiAgICAgIGNsZWFuZWRVcCA9IHRydWVcbiAgICAgIHRoaXMucmVhZHkgPSBJbmRleGVkREJTdG9yZS5jbGVhbnVwKClcbiAgICAgICAgLnRoZW4oY3JlYXRlQ29ubmVjdGlvbiwgY3JlYXRlQ29ubmVjdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkeSA9IGNyZWF0ZUNvbm5lY3Rpb24oKVxuICAgIH1cbiAgfVxuXG4gIGtleSAoZmlsZUlEKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubmFtZX0hJHtmaWxlSUR9YFxuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYWxsIGZpbGUgYmxvYnMgY3VycmVudGx5IGluIHRoZSBzdG9yZS5cbiAgICovXG4gIGxpc3QgKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5LnRoZW4oKGRiKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtTVE9SRV9OQU1FXSwgJ3JlYWRvbmx5JylcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSlcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5pbmRleCgnc3RvcmUnKVxuICAgICAgICAuZ2V0QWxsKElEQktleVJhbmdlLm9ubHkodGhpcy5uYW1lKSlcbiAgICAgIHJldHVybiB3YWl0Rm9yUmVxdWVzdChyZXF1ZXN0KVxuICAgIH0pLnRoZW4oKGZpbGVzKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fVxuICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICByZXN1bHRbZmlsZS5maWxlSURdID0gZmlsZS5kYXRhXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IG9uZSBmaWxlIGJsb2IgZnJvbSB0aGUgc3RvcmUuXG4gICAqL1xuICBnZXQgKGZpbGVJRCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5LnRoZW4oKGRiKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtTVE9SRV9OQU1FXSwgJ3JlYWRvbmx5JylcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxuICAgICAgICAuZ2V0KHRoaXMua2V5KGZpbGVJRCkpXG4gICAgICByZXR1cm4gd2FpdEZvclJlcXVlc3QocmVxdWVzdClcbiAgICB9KS50aGVuKChyZXN1bHQpID0+ICh7XG4gICAgICBpZDogcmVzdWx0LmRhdGEuZmlsZUlELFxuICAgICAgZGF0YTogcmVzdWx0LmRhdGEuZGF0YSxcbiAgICB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRvdGFsIHNpemUgb2YgYWxsIHN0b3JlZCBmaWxlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5LnRoZW4oKGRiKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtTVE9SRV9OQU1FXSwgJ3JlYWRvbmx5JylcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSlcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5pbmRleCgnc3RvcmUnKVxuICAgICAgICAub3BlbkN1cnNvcihJREJLZXlSYW5nZS5vbmx5KHRoaXMubmFtZSkpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgc2l6ZSA9IDBcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgc2l6ZSArPSBjdXJzb3IudmFsdWUuZGF0YS5zaXplXG4gICAgICAgICAgICBjdXJzb3IuY29udGludWUoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHNpemUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgcmV0cmlldmUgc3RvcmVkIGJsb2JzIHNpemUnKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgYSBmaWxlIGluIHRoZSBzdG9yZS5cbiAgICovXG4gIHB1dCAoZmlsZSkge1xuICAgIGlmIChmaWxlLmRhdGEuc2l6ZSA+IHRoaXMub3B0cy5tYXhGaWxlU2l6ZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignRmlsZSBpcyB0b28gYmlnIHRvIHN0b3JlLicpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTaXplKCkudGhlbigoc2l6ZSkgPT4ge1xuICAgICAgaWYgKHNpemUgPiB0aGlzLm9wdHMubWF4VG90YWxTaXplKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vIHNwYWNlIGxlZnQnKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlYWR5XG4gICAgfSkudGhlbigoZGIpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJylcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKS5hZGQoe1xuICAgICAgICBpZDogdGhpcy5rZXkoZmlsZS5pZCksXG4gICAgICAgIGZpbGVJRDogZmlsZS5pZCxcbiAgICAgICAgc3RvcmU6IHRoaXMubmFtZSxcbiAgICAgICAgZXhwaXJlczogRGF0ZS5ub3coKSArIHRoaXMub3B0cy5leHBpcmVzLFxuICAgICAgICBkYXRhOiBmaWxlLmRhdGEsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHdhaXRGb3JSZXF1ZXN0KHJlcXVlc3QpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmaWxlIGJsb2IgZnJvbSB0aGUgc3RvcmUuXG4gICAqL1xuICBkZWxldGUgKGZpbGVJRCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5LnRoZW4oKGRiKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtTVE9SRV9OQU1FXSwgJ3JlYWR3cml0ZScpXG4gICAgICBjb25zdCByZXF1ZXN0ID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSlcbiAgICAgICAgLmRlbGV0ZSh0aGlzLmtleShmaWxlSUQpKVxuICAgICAgcmV0dXJuIHdhaXRGb3JSZXF1ZXN0KHJlcXVlc3QpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIHN0b3JlZCBibG9icyB0aGF0IGhhdmUgYW4gZXhwaXJ5IGRhdGUgdGhhdCBpcyBiZWZvcmUgRGF0ZS5ub3coKS5cbiAgICogVGhpcyBpcyBhIHN0YXRpYyBtZXRob2QgYmVjYXVzZSBpdCBkZWxldGVzIGV4cGlyZWQgYmxvYnMgZnJvbSBfYWxsXyBVcHB5IGluc3RhbmNlcy5cbiAgICovXG4gIHN0YXRpYyBjbGVhbnVwICgpIHtcbiAgICByZXR1cm4gY29ubmVjdChEQl9OQU1FKS50aGVuKChkYikgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbU1RPUkVfTkFNRV0sICdyZWFkd3JpdGUnKVxuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmluZGV4KCdleHBpcmVzJylcbiAgICAgICAgLm9wZW5DdXJzb3IoSURCS2V5UmFuZ2UudXBwZXJCb3VuZChEYXRlLm5vdygpKSlcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdFxuICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgIGN1cnNvci5kZWxldGUoKSAvLyBJZ25vcmluZyByZXR1cm4gdmFsdWUg4oCmIGl0J3Mgbm90IHRlcnJpYmxlIGlmIHRoaXMgZ29lcyB3cm9uZy5cbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdFxuICAgICAgfSlcbiAgICB9KS50aGVuKChkYikgPT4ge1xuICAgICAgZGIuY2xvc2UoKVxuICAgIH0pXG4gIH1cbn1cblxuSW5kZXhlZERCU3RvcmUuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZFxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWREQlN0b3JlXG4iLCIvKipcbiAqIEdldCB1cHB5IGluc3RhbmNlIElEcyBmb3Igd2hpY2ggc3RhdGUgaXMgc3RvcmVkLlxuICovXG5mdW5jdGlvbiBmaW5kVXBweUluc3RhbmNlcyAoKSB7XG4gIGNvbnN0IGluc3RhbmNlcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKVxuICAgIGlmICgvXnVwcHlTdGF0ZTovLnRlc3Qoa2V5KSkge1xuICAgICAgaW5zdGFuY2VzLnB1c2goa2V5LnNsaWNlKCd1cHB5U3RhdGU6Jy5sZW5ndGgpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5zdGFuY2VzXG59XG5cbi8qKlxuICogVHJ5IHRvIEpTT04tcGFyc2UgYSBzdHJpbmcsIHJldHVybiBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbmZ1bmN0aW9uIG1heWJlUGFyc2UgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5sZXQgY2xlYW5lZFVwID0gZmFsc2Vcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWV0YURhdGFTdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgZXhwaXJlczogMjQgKiA2MCAqIDYwICogMTAwMCwgLy8gMjQgaG91cnNcbiAgICAgIC4uLm9wdHMsXG4gICAgfVxuICAgIHRoaXMubmFtZSA9IGB1cHB5U3RhdGU6JHtvcHRzLnN0b3JlTmFtZX1gXG5cbiAgICBpZiAoIWNsZWFuZWRVcCkge1xuICAgICAgY2xlYW5lZFVwID0gdHJ1ZVxuICAgICAgTWV0YURhdGFTdG9yZS5jbGVhbnVwKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGxvYWQgKCkge1xuICAgIGNvbnN0IHNhdmVkU3RhdGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLm5hbWUpXG4gICAgaWYgKCFzYXZlZFN0YXRlKSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IGRhdGEgPSBtYXliZVBhcnNlKHNhdmVkU3RhdGUpXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gVXBncmFkZSBwcmUtMC4yMC4wIHVwcHlTdGF0ZTogaXQgdXNlZCB0byBiZSBqdXN0IGEgZmxhdCBvYmplY3QsXG4gICAgLy8gd2l0aG91dCBgZXhwaXJlc2AuXG4gICAgaWYgKCFkYXRhLm1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnNhdmUoZGF0YSlcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEubWV0YWRhdGFcbiAgfVxuXG4gIHNhdmUgKG1ldGFkYXRhKSB7XG4gICAgY29uc3QgZXhwaXJlcyA9IERhdGUubm93KCkgKyB0aGlzLm9wdHMuZXhwaXJlc1xuICAgIGNvbnN0IHN0YXRlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbWV0YWRhdGEsXG4gICAgICBleHBpcmVzLFxuICAgIH0pXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5uYW1lLCBzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGV4cGlyZWQgc3RhdGUuXG4gICAqL1xuICBzdGF0aWMgY2xlYW51cCAoaW5zdGFuY2VJRCkge1xuICAgIGlmIChpbnN0YW5jZUlEKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShgdXBweVN0YXRlOiR7aW5zdGFuY2VJRH1gKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VJRHMgPSBmaW5kVXBweUluc3RhbmNlcygpXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGluc3RhbmNlSURzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oYHVwcHlTdGF0ZToke2lkfWApXG4gICAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsXG4gICAgICBjb25zdCBvYmogPSBtYXliZVBhcnNlKGRhdGEpXG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG51bGxcblxuICAgICAgaWYgKG9iai5leHBpcmVzICYmIG9iai5leHBpcmVzIDwgbm93KSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGB1cHB5U3RhdGU6JHtpZH1gKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbiIsIi8qZXNsaW50LWRpc2FibGUgKi9cblxuY29uc3QgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yXG5cbmZ1bmN0aW9uIHdhaXRGb3JTZXJ2aWNlV29ya2VyICgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpKVxuICAgIH0gZWxzZSBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgLy8gQSBzZXJ2aWNlV29ya2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBhbmQgYWN0aXZlLlxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRyb2xsZXJjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmNsYXNzIFNlcnZpY2VXb3JrZXJTdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgdGhpcy5yZWFkeSA9IHdhaXRGb3JTZXJ2aWNlV29ya2VyKClcbiAgICB0aGlzLm5hbWUgPSBvcHRzLnN0b3JlTmFtZVxuICB9XG5cbiAgbGlzdCAoKSB7XG4gICAgY29uc3QgZGVmZXIgPSB7fVxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBkZWZlci5yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgZGVmZXIucmVqZWN0ID0gcmVqZWN0XG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIHN0b3JlZCBibG9icyBmcm9tIFNlcnZpY2UgV29ya2VyJylcblxuICAgIGNvbnN0IG9uTWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRhdGEuc3RvcmUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQuZGF0YS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3VwcHkvQUxMX0ZJTEVTJzpcbiAgICAgICAgICBkZWZlci5yZXNvbHZlKGV2ZW50LmRhdGEuZmlsZXMpXG4gICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlZmVyLnJlamVjdCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeS50aGVuKCgpID0+IHtcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpXG5cbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAndXBweS9HRVRfRklMRVMnLFxuICAgICAgICBzdG9yZTogdGhpcy5uYW1lXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgcHV0IChmaWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHkudGhlbigoKSA9PiB7XG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3VwcHkvQUREX0ZJTEUnLFxuICAgICAgICBzdG9yZTogdGhpcy5uYW1lLFxuICAgICAgICBmaWxlOiBmaWxlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBkZWxldGUgKGZpbGVJRCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICd1cHB5L1JFTU9WRV9GSUxFJyxcbiAgICAgICAgc3RvcmU6IHRoaXMubmFtZSxcbiAgICAgICAgZmlsZUlEOiBmaWxlSURcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG5TZXJ2aWNlV29ya2VyU3RvcmUuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZFxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2VXb3JrZXJTdG9yZVxuIiwiY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCdsb2Rhc2gudGhyb3R0bGUnKVxuY29uc3QgQmFzZVBsdWdpbiA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUvbGliL0Jhc2VQbHVnaW4nKVxuY29uc3QgU2VydmljZVdvcmtlclN0b3JlID0gcmVxdWlyZSgnLi9TZXJ2aWNlV29ya2VyU3RvcmUnKVxuY29uc3QgSW5kZXhlZERCU3RvcmUgPSByZXF1aXJlKCcuL0luZGV4ZWREQlN0b3JlJylcbmNvbnN0IE1ldGFEYXRhU3RvcmUgPSByZXF1aXJlKCcuL01ldGFEYXRhU3RvcmUnKVxuXG4vKipcbiAqIFRoZSBHb2xkZW5SZXRyaWV2ZXIgcGx1Z2luIOKAlCByZXN0b3JlcyBzZWxlY3RlZCBmaWxlcyBhbmQgcmVzdW1lcyB1cGxvYWRzXG4gKiBhZnRlciBhIGNsb3NlZCB0YWIgb3IgYSBicm93c2VyIGNyYXNoIVxuICpcbiAqIFVzZXMgbG9jYWxTdG9yYWdlLCBJbmRleGVkREIgYW5kIFNlcnZpY2VXb3JrZXIgdG8gZG8gaXRzIG1hZ2ljLCByZWFkIG1vcmU6XG4gKiBodHRwczovL3VwcHkuaW8vYmxvZy8yMDE3LzA3L2dvbGRlbi1yZXRyaWV2ZXIvXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgR29sZGVuUmV0cmlldmVyIGV4dGVuZHMgQmFzZVBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnR5cGUgPSAnZGVidWdnZXInXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnR29sZGVuUmV0cmlldmVyJ1xuICAgIHRoaXMudGl0bGUgPSAnR29sZGVuIFJldHJpZXZlcidcblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZXhwaXJlczogMjQgKiA2MCAqIDYwICogMTAwMCwgLy8gMjQgaG91cnNcbiAgICAgIHNlcnZpY2VXb3JrZXI6IGZhbHNlLFxuICAgIH1cblxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5NZXRhRGF0YVN0b3JlID0gbmV3IE1ldGFEYXRhU3RvcmUoe1xuICAgICAgZXhwaXJlczogdGhpcy5vcHRzLmV4cGlyZXMsXG4gICAgICBzdG9yZU5hbWU6IHVwcHkuZ2V0SUQoKSxcbiAgICB9KVxuICAgIHRoaXMuU2VydmljZVdvcmtlclN0b3JlID0gbnVsbFxuICAgIGlmICh0aGlzLm9wdHMuc2VydmljZVdvcmtlcikge1xuICAgICAgdGhpcy5TZXJ2aWNlV29ya2VyU3RvcmUgPSBuZXcgU2VydmljZVdvcmtlclN0b3JlKHsgc3RvcmVOYW1lOiB1cHB5LmdldElEKCkgfSlcbiAgICB9XG4gICAgdGhpcy5JbmRleGVkREJTdG9yZSA9IG5ldyBJbmRleGVkREJTdG9yZSh7XG4gICAgICBleHBpcmVzOiB0aGlzLm9wdHMuZXhwaXJlcyxcbiAgICAgIC4uLnRoaXMub3B0cy5pbmRleGVkREIgfHwge30sXG4gICAgICBzdG9yZU5hbWU6IHVwcHkuZ2V0SUQoKSxcbiAgICB9KVxuXG4gICAgdGhpcy5zYXZlRmlsZXNTdGF0ZVRvTG9jYWxTdG9yYWdlID0gdGhyb3R0bGUoXG4gICAgICB0aGlzLnNhdmVGaWxlc1N0YXRlVG9Mb2NhbFN0b3JhZ2UuYmluZCh0aGlzKSxcbiAgICAgIDUwMCxcbiAgICAgIHsgbGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IHRydWUgfSxcbiAgICApXG4gICAgdGhpcy5yZXN0b3JlU3RhdGUgPSB0aGlzLnJlc3RvcmVTdGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5sb2FkRmlsZUJsb2JzRnJvbVNlcnZpY2VXb3JrZXIgPSB0aGlzLmxvYWRGaWxlQmxvYnNGcm9tU2VydmljZVdvcmtlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5sb2FkRmlsZUJsb2JzRnJvbUluZGV4ZWREQiA9IHRoaXMubG9hZEZpbGVCbG9ic0Zyb21JbmRleGVkREIuYmluZCh0aGlzKVxuICAgIHRoaXMub25CbG9ic0xvYWRlZCA9IHRoaXMub25CbG9ic0xvYWRlZC5iaW5kKHRoaXMpXG4gIH1cblxuICByZXN0b3JlU3RhdGUgKCkge1xuICAgIGNvbnN0IHNhdmVkU3RhdGUgPSB0aGlzLk1ldGFEYXRhU3RvcmUubG9hZCgpXG4gICAgaWYgKHNhdmVkU3RhdGUpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tHb2xkZW5SZXRyaWV2ZXJdIFJlY292ZXJlZCBzb21lIHN0YXRlIGZyb20gTG9jYWwgU3RvcmFnZScpXG4gICAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgICBjdXJyZW50VXBsb2Fkczogc2F2ZWRTdGF0ZS5jdXJyZW50VXBsb2FkcyB8fCB7fSxcbiAgICAgICAgZmlsZXM6IHNhdmVkU3RhdGUuZmlsZXMgfHwge30sXG4gICAgICAgIHJlY292ZXJlZFN0YXRlOiBzYXZlZFN0YXRlLFxuICAgICAgfSlcbiAgICAgIHRoaXMuc2F2ZWRQbHVnaW5EYXRhID0gc2F2ZWRTdGF0ZS5wbHVnaW5EYXRhXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWxlIG9iamVjdHMgdGhhdCBhcmUgY3VycmVudGx5IHdhaXRpbmc6IHRoZXkndmUgYmVlbiBzZWxlY3RlZCxcbiAgICogYnV0IGFyZW4ndCB5ZXQgYmVpbmcgdXBsb2FkZWQuXG4gICAqL1xuICBnZXRXYWl0aW5nRmlsZXMgKCkge1xuICAgIGNvbnN0IHdhaXRpbmdGaWxlcyA9IHt9XG5cbiAgICB0aGlzLnVwcHkuZ2V0RmlsZXMoKS5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICBpZiAoIWZpbGUucHJvZ3Jlc3MgfHwgIWZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCkge1xuICAgICAgICB3YWl0aW5nRmlsZXNbZmlsZS5pZF0gPSBmaWxlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB3YWl0aW5nRmlsZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmlsZSBvYmplY3RzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyB1cGxvYWRlZC4gSWYgYSBmaWxlIGhhcyBmaW5pc2hlZFxuICAgKiB1cGxvYWRpbmcsIGJ1dCB0aGUgb3RoZXIgZmlsZXMgaW4gdGhlIHNhbWUgYmF0Y2ggaGF2ZSBub3QsIHRoZSBmaW5pc2hlZFxuICAgKiBmaWxlIGlzIGFsc28gcmV0dXJuZWQuXG4gICAqL1xuICBnZXRVcGxvYWRpbmdGaWxlcyAoKSB7XG4gICAgY29uc3QgdXBsb2FkaW5nRmlsZXMgPSB7fVxuXG4gICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICBpZiAoY3VycmVudFVwbG9hZHMpIHtcbiAgICAgIGNvbnN0IHVwbG9hZElEcyA9IE9iamVjdC5rZXlzKGN1cnJlbnRVcGxvYWRzKVxuICAgICAgdXBsb2FkSURzLmZvckVhY2goKHVwbG9hZElEKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVzSW5VcGxvYWQgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0uZmlsZUlEc1xuICAgICAgICBmaWxlc0luVXBsb2FkLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgICAgIHVwbG9hZGluZ0ZpbGVzW2ZpbGVJRF0gPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB1cGxvYWRpbmdGaWxlc1xuICB9XG5cbiAgc2F2ZUZpbGVzU3RhdGVUb0xvY2FsU3RvcmFnZSAoKSB7XG4gICAgY29uc3QgZmlsZXNUb1NhdmUgPSB7XG4gICAgICAuLi50aGlzLmdldFdhaXRpbmdGaWxlcygpLFxuICAgICAgLi4udGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpLFxuICAgIH1cblxuICAgIC8vIElmIGFsbCBmaWxlcyBoYXZlIGJlZW4gcmVtb3ZlZCBieSB0aGUgdXNlciwgY2xlYXIgcmVjb3Zlcnkgc3RhdGVcbiAgICBpZiAoT2JqZWN0LmtleXMoZmlsZXNUb1NhdmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy51cHB5LnNldFN0YXRlKHsgcmVjb3ZlcmVkU3RhdGU6IG51bGwgfSlcbiAgICAgIE1ldGFEYXRhU3RvcmUuY2xlYW51cCh0aGlzLnVwcHkub3B0cy5pZClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFdlIGRvbnTigJl0IG5lZWQgdG8gc3RvcmUgZmlsZS5kYXRhIG9uIGxvY2FsIGZpbGVzLCBiZWNhdXNlIHRoZSBhY3R1YWwgYmxvYiB3aWxsIGJlIHJlc3RvcmVkIGxhdGVyLFxuICAgIC8vIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGhhdmluZyB3ZWlyZCBwcm9wZXJ0aWVzIGluIHRoZSBzZXJpYWxpemVkIG9iamVjdC5cbiAgICAvLyBBbHNvIGFkZGluZyBmaWxlLmlzUmVzdG9yZWQgdG8gYWxsIGZpbGVzLCBzaW5jZSB0aGV5IHdpbGwgYmUgcmVzdG9yZWQgZnJvbSBsb2NhbCBzdG9yYWdlXG4gICAgY29uc3QgZmlsZXNUb1NhdmVXaXRob3V0RGF0YSA9IHt9XG4gICAgT2JqZWN0LmtleXMoZmlsZXNUb1NhdmUpLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGlmIChmaWxlc1RvU2F2ZVtmaWxlXS5pc1JlbW90ZSkge1xuICAgICAgICBmaWxlc1RvU2F2ZVdpdGhvdXREYXRhW2ZpbGVdID0ge1xuICAgICAgICAgIC4uLmZpbGVzVG9TYXZlW2ZpbGVdLFxuICAgICAgICAgIGlzUmVzdG9yZWQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGVzVG9TYXZlV2l0aG91dERhdGFbZmlsZV0gPSB7XG4gICAgICAgICAgLi4uZmlsZXNUb1NhdmVbZmlsZV0sXG4gICAgICAgICAgaXNSZXN0b3JlZDogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgIHByZXZpZXc6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgcGx1Z2luRGF0YSA9IHt9XG4gICAgLy8gVE9ETyBGaW5kIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzP1xuICAgIC8vIE90aGVyIHBsdWdpbnMgY2FuIGF0dGFjaCBhIHJlc3RvcmU6Z2V0LWRhdGEgbGlzdGVuZXIgdGhhdCByZWNlaXZlcyB0aGlzIGNhbGxiYWNrLlxuICAgIC8vIFBsdWdpbnMgY2FuIHRoZW4gdXNlIHRoaXMgY2FsbGJhY2sgKHN5bmMpIHRvIHByb3ZpZGUgZGF0YSB0byBiZSBzdG9yZWQuXG4gICAgdGhpcy51cHB5LmVtaXQoJ3Jlc3RvcmU6Z2V0LWRhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihwbHVnaW5EYXRhLCBkYXRhKVxuICAgIH0pXG5cbiAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuXG4gICAgdGhpcy5NZXRhRGF0YVN0b3JlLnNhdmUoe1xuICAgICAgY3VycmVudFVwbG9hZHMsXG4gICAgICBmaWxlczogZmlsZXNUb1NhdmVXaXRob3V0RGF0YSxcbiAgICAgIHBsdWdpbkRhdGEsXG4gICAgfSlcbiAgfVxuXG4gIGxvYWRGaWxlQmxvYnNGcm9tU2VydmljZVdvcmtlciAoKSB7XG4gICAgaWYgKCF0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5TZXJ2aWNlV29ya2VyU3RvcmUubGlzdCgpLnRoZW4oKGJsb2JzKSA9PiB7XG4gICAgICBjb25zdCBmaWxlcyA9IHRoaXMudXBweS5nZXRGaWxlcygpXG4gICAgICBjb25zdCBsb2NhbEZpbGVzT25seSA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgICAvLyBtYXliZSAmJiAhZmlsZS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgICAgICByZXR1cm4gIWZpbGUuaXNSZW1vdGVcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IG51bWJlck9mRmlsZXNSZWNvdmVyZWQgPSBPYmplY3Qua2V5cyhibG9icykubGVuZ3RoXG4gICAgICBjb25zdCBudW1iZXJPZkZpbGVzVHJ5aW5nVG9SZWNvdmVyID0gbG9jYWxGaWxlc09ubHkubGVuZ3RoXG5cbiAgICAgIGlmIChudW1iZXJPZkZpbGVzUmVjb3ZlcmVkID09PSBudW1iZXJPZkZpbGVzVHJ5aW5nVG9SZWNvdmVyKSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coYFtHb2xkZW5SZXRyaWV2ZXJdIFN1Y2Nlc3NmdWxseSByZWNvdmVyZWQgJHtudW1iZXJPZkZpbGVzUmVjb3ZlcmVkfSBibG9icyBmcm9tIFNlcnZpY2UgV29ya2VyIWApXG4gICAgICAgIHJldHVybiBibG9ic1xuICAgICAgfVxuICAgICAgdGhpcy51cHB5LmxvZygnW0dvbGRlblJldHJpZXZlcl0gTm8gYmxvYnMgZm91bmQgaW4gU2VydmljZSBXb3JrZXIsIHRyeWluZyBJbmRleGVkREIgbm93Li4uJylcbiAgICAgIHJldHVybiB7fVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tHb2xkZW5SZXRyaWV2ZXJdIEZhaWxlZCB0byByZWNvdmVyIGJsb2JzIGZyb20gU2VydmljZSBXb3JrZXInLCAnd2FybmluZycpXG4gICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgIHJldHVybiB7fVxuICAgIH0pXG4gIH1cblxuICBsb2FkRmlsZUJsb2JzRnJvbUluZGV4ZWREQiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuSW5kZXhlZERCU3RvcmUubGlzdCgpLnRoZW4oKGJsb2JzKSA9PiB7XG4gICAgICBjb25zdCBudW1iZXJPZkZpbGVzUmVjb3ZlcmVkID0gT2JqZWN0LmtleXMoYmxvYnMpLmxlbmd0aFxuXG4gICAgICBpZiAobnVtYmVyT2ZGaWxlc1JlY292ZXJlZCA+IDApIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhgW0dvbGRlblJldHJpZXZlcl0gU3VjY2Vzc2Z1bGx5IHJlY292ZXJlZCAke251bWJlck9mRmlsZXNSZWNvdmVyZWR9IGJsb2JzIGZyb20gSW5kZXhlZERCIWApXG4gICAgICAgIHJldHVybiBibG9ic1xuICAgICAgfVxuICAgICAgdGhpcy51cHB5LmxvZygnW0dvbGRlblJldHJpZXZlcl0gTm8gYmxvYnMgZm91bmQgaW4gSW5kZXhlZERCJylcbiAgICAgIHJldHVybiB7fVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tHb2xkZW5SZXRyaWV2ZXJdIEZhaWxlZCB0byByZWNvdmVyIGJsb2JzIGZyb20gSW5kZXhlZERCJywgJ3dhcm5pbmcnKVxuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgICByZXR1cm4ge31cbiAgICB9KVxuICB9XG5cbiAgb25CbG9ic0xvYWRlZCAoYmxvYnMpIHtcbiAgICBjb25zdCBvYnNvbGV0ZUJsb2JzID0gW11cbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMudXBweS5nZXRTdGF0ZSgpLmZpbGVzIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBibG9icyB0aGF0IHdlIGNhbiByZXN0b3JlLCBhZGQgYmxvYnMgdG8gZmlsZSBvYmplY3RzXG4gICAgT2JqZWN0LmtleXMoYmxvYnMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgaWYgKCFvcmlnaW5hbEZpbGUpIHtcbiAgICAgICAgb2Jzb2xldGVCbG9icy5wdXNoKGZpbGVJRClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBibG9ic1tmaWxlSURdXG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlRGF0YSA9IHtcbiAgICAgICAgZGF0YTogY2FjaGVkRGF0YSxcbiAgICAgICAgaXNSZXN0b3JlZDogdHJ1ZSxcbiAgICAgICAgaXNHaG9zdDogZmFsc2UsXG4gICAgICB9XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZUlEXSA9IHsgLi4ub3JpZ2luYWxGaWxlLCAuLi51cGRhdGVkRmlsZURhdGEgfVxuICAgIH0pXG5cbiAgICAvLyBMb29wIHRocm91Z2ggZmlsZXMgdGhhdCB3ZSBjYW7igJl0IHJlc3RvcmUgZnVsbHkg4oCUIHdlIG9ubHkgaGF2ZSBtZXRhLCBub3QgYmxvYnMsXG4gICAgLy8gc2V0IC5pc0dob3N0IG9uIHRoZW0sIGFsc28gc2V0IGlzUmVzdG9yZWQgdG8gYWxsIGZpbGVzXG4gICAgT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIGlmICh1cGRhdGVkRmlsZXNbZmlsZUlEXS5kYXRhID09PSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlSURdID0ge1xuICAgICAgICAgIC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLFxuICAgICAgICAgIGlzR2hvc3Q6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgfSlcblxuICAgIHRoaXMudXBweS5lbWl0KCdyZXN0b3JlZCcsIHRoaXMuc2F2ZWRQbHVnaW5EYXRhKVxuXG4gICAgaWYgKG9ic29sZXRlQmxvYnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmRlbGV0ZUJsb2JzKG9ic29sZXRlQmxvYnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGBbR29sZGVuUmV0cmlldmVyXSBDbGVhbmVkIHVwICR7b2Jzb2xldGVCbG9icy5sZW5ndGh9IG9sZCBmaWxlc2ApXG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coYFtHb2xkZW5SZXRyaWV2ZXJdIENvdWxkIG5vdCBjbGVhbiB1cCAke29ic29sZXRlQmxvYnMubGVuZ3RofSBvbGQgZmlsZXNgLCAnd2FybmluZycpXG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBkZWxldGVCbG9icyAoZmlsZUlEcykge1xuICAgIGNvbnN0IHByb21pc2VzID0gW11cbiAgICBmaWxlSURzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBpZiAodGhpcy5TZXJ2aWNlV29ya2VyU3RvcmUpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZS5kZWxldGUoaWQpKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuSW5kZXhlZERCU3RvcmUpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLkluZGV4ZWREQlN0b3JlLmRlbGV0ZShpZCkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gIH1cblxuICBhZGRCbG9iVG9TdG9yZXMgPSAoZmlsZSkgPT4ge1xuICAgIGlmIChmaWxlLmlzUmVtb3RlKSByZXR1cm5cblxuICAgIGlmICh0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZSkge1xuICAgICAgdGhpcy5TZXJ2aWNlV29ya2VyU3RvcmUucHV0KGZpbGUpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZygnW0dvbGRlblJldHJpZXZlcl0gQ291bGQgbm90IHN0b3JlIGZpbGUnLCAnd2FybmluZycpXG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLkluZGV4ZWREQlN0b3JlLnB1dChmaWxlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBDb3VsZCBub3Qgc3RvcmUgZmlsZScsICd3YXJuaW5nJylcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgIH0pXG4gIH1cblxuICByZW1vdmVCbG9iRnJvbVN0b3JlcyA9IChmaWxlKSA9PiB7XG4gICAgaWYgKHRoaXMuU2VydmljZVdvcmtlclN0b3JlKSB7XG4gICAgICB0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZS5kZWxldGUoZmlsZS5pZCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBGYWlsZWQgdG8gcmVtb3ZlIGZpbGUnLCAnd2FybmluZycpXG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5JbmRleGVkREJTdG9yZS5kZWxldGUoZmlsZS5pZCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZygnW0dvbGRlblJldHJpZXZlcl0gRmFpbGVkIHRvIHJlbW92ZSBmaWxlJywgJ3dhcm5pbmcnKVxuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgfSlcbiAgfVxuXG4gIHJlcGxhY2VCbG9iSW5TdG9yZXMgPSAoZmlsZSkgPT4ge1xuICAgIHRoaXMucmVtb3ZlQmxvYkZyb21TdG9yZXMoZmlsZSlcbiAgICB0aGlzLmFkZEJsb2JUb1N0b3JlcyhmaWxlKVxuICB9XG5cbiAgaGFuZGxlUmVzdG9yZUNvbmZpcm1lZCA9ICgpID0+IHtcbiAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBSZXN0b3JlIGNvbmZpcm1lZCwgcHJvY2VlZGluZy4uLicpXG4gICAgLy8gc3RhcnQgYWxsIHVwbG9hZHMgYWdhaW4gd2hlbiBmaWxlIGJsb2JzIGFyZSByZXN0b3JlZFxuICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgaWYgKGN1cnJlbnRVcGxvYWRzKSB7XG4gICAgICBPYmplY3Qua2V5cyhjdXJyZW50VXBsb2FkcykuZm9yRWFjaCgodXBsb2FkSWQpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LnJlc3RvcmUodXBsb2FkSWQsIGN1cnJlbnRVcGxvYWRzW3VwbG9hZElkXSlcbiAgICAgIH0pXG4gICAgICB0aGlzLnVwcHkucmVzdW1lQWxsKClcbiAgICB9XG4gICAgdGhpcy51cHB5LnVwbG9hZCgpXG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHsgcmVjb3ZlcmVkU3RhdGU6IG51bGwgfSlcbiAgfVxuXG4gIGFib3J0UmVzdG9yZSA9ICgpID0+IHtcbiAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBBYm9ydGluZyByZXN0b3JlLi4uJylcblxuICAgIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyh0aGlzLnVwcHkuZ2V0U3RhdGUoKS5maWxlcylcbiAgICB0aGlzLmRlbGV0ZUJsb2JzKGZpbGVJRHMpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW0dvbGRlblJldHJpZXZlcl0gUmVtb3ZlZCAke2ZpbGVJRHMubGVuZ3RofSBmaWxlc2ApXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW0dvbGRlblJldHJpZXZlcl0gQ291bGQgbm90IHJlbW92ZSAke2ZpbGVJRHMubGVuZ3RofSBmaWxlc2AsICd3YXJuaW5nJylcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgIH0pXG5cbiAgICB0aGlzLnVwcHkuY2FuY2VsQWxsKClcbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoeyByZWNvdmVyZWRTdGF0ZTogbnVsbCB9KVxuICAgIE1ldGFEYXRhU3RvcmUuY2xlYW51cCh0aGlzLnVwcHkub3B0cy5pZClcbiAgfVxuXG4gIGhhbmRsZUNvbXBsZXRlID0gKHsgc3VjY2Vzc2Z1bCB9KSA9PiB7XG4gICAgY29uc3QgZmlsZUlEcyA9IHN1Y2Nlc3NmdWwubWFwKChmaWxlKSA9PiBmaWxlLmlkKVxuICAgIHRoaXMuZGVsZXRlQmxvYnMoZmlsZUlEcykudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGBbR29sZGVuUmV0cmlldmVyXSBSZW1vdmVkICR7c3VjY2Vzc2Z1bC5sZW5ndGh9IGZpbGVzIHRoYXQgZmluaXNoZWQgdXBsb2FkaW5nYClcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGBbR29sZGVuUmV0cmlldmVyXSBDb3VsZCBub3QgcmVtb3ZlICR7c3VjY2Vzc2Z1bC5sZW5ndGh9IGZpbGVzIHRoYXQgZmluaXNoZWQgdXBsb2FkaW5nYCwgJ3dhcm5pbmcnKVxuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgfSlcblxuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7IHJlY292ZXJlZFN0YXRlOiBudWxsIH0pXG4gICAgTWV0YURhdGFTdG9yZS5jbGVhbnVwKHRoaXMudXBweS5vcHRzLmlkKVxuICB9XG5cbiAgcmVzdG9yZUJsb2JzID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnVwcHkuZ2V0RmlsZXMoKS5sZW5ndGggPiAwKSB7XG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMubG9hZEZpbGVCbG9ic0Zyb21TZXJ2aWNlV29ya2VyKCksXG4gICAgICAgIHRoaXMubG9hZEZpbGVCbG9ic0Zyb21JbmRleGVkREIoKSxcbiAgICAgIF0pLnRoZW4oKHJlc3VsdGluZ0FycmF5T2ZPYmplY3RzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2JzID0geyAuLi5yZXN1bHRpbmdBcnJheU9mT2JqZWN0c1swXSwgLi4ucmVzdWx0aW5nQXJyYXlPZk9iamVjdHNbMV0gfVxuICAgICAgICB0aGlzLm9uQmxvYnNMb2FkZWQoYmxvYnMpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBObyBmaWxlcyBuZWVkIHRvIGJlIGxvYWRlZCwgb25seSByZXN0b3JpbmcgcHJvY2Vzc2luZyBzdGF0ZS4uLicpXG4gICAgICB0aGlzLm9uQmxvYnNMb2FkZWQoW10pXG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy5yZXN0b3JlU3RhdGUoKVxuICAgIHRoaXMucmVzdG9yZUJsb2JzKClcblxuICAgIHRoaXMudXBweS5vbignZmlsZS1hZGRlZCcsIHRoaXMuYWRkQmxvYlRvU3RvcmVzKVxuICAgIHRoaXMudXBweS5vbignZmlsZS1lZGl0b3I6Y29tcGxldGUnLCB0aGlzLnJlcGxhY2VCbG9iSW5TdG9yZXMpXG4gICAgdGhpcy51cHB5Lm9uKCdmaWxlLXJlbW92ZWQnLCB0aGlzLnJlbW92ZUJsb2JGcm9tU3RvcmVzKVxuICAgIHRoaXMudXBweS5vbignc3RhdGUtdXBkYXRlJywgdGhpcy5zYXZlRmlsZXNTdGF0ZVRvTG9jYWxTdG9yYWdlKVxuICAgIHRoaXMudXBweS5vbigncmVzdG9yZS1jb25maXJtZWQnLCB0aGlzLmhhbmRsZVJlc3RvcmVDb25maXJtZWQpXG4gICAgdGhpcy51cHB5Lm9uKCdyZXN0b3JlLWNhbmNlbGVkJywgdGhpcy5hYm9ydFJlc3RvcmUpXG4gICAgdGhpcy51cHB5Lm9uKCdjb21wbGV0ZScsIHRoaXMuaGFuZGxlQ29tcGxldGUpXG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5vZmYoJ2ZpbGUtYWRkZWQnLCB0aGlzLmFkZEJsb2JUb1N0b3JlcylcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLWVkaXRvcjpjb21wbGV0ZScsIHRoaXMucmVwbGFjZUJsb2JJblN0b3JlcylcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLXJlbW92ZWQnLCB0aGlzLnJlbW92ZUJsb2JGcm9tU3RvcmVzKVxuICAgIHRoaXMudXBweS5vZmYoJ3N0YXRlLXVwZGF0ZScsIHRoaXMuc2F2ZUZpbGVzU3RhdGVUb0xvY2FsU3RvcmFnZSlcbiAgICB0aGlzLnVwcHkub2ZmKCdyZXN0b3JlLWNvbmZpcm1lZCcsIHRoaXMuaGFuZGxlUmVzdG9yZUNvbmZpcm1lZClcbiAgICB0aGlzLnVwcHkub2ZmKCdyZXN0b3JlLWNhbmNlbGVkJywgdGhpcy5hYm9ydFJlc3RvcmUpXG4gICAgdGhpcy51cHB5Lm9mZignY29tcGxldGUnLCB0aGlzLmhhbmRsZUNvbXBsZXRlKVxuICB9XG59XG4iLCJjb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEcml2ZVByb3ZpZGVyVmlld3MgZXh0ZW5kcyBQcm92aWRlclZpZXdzIHtcbiAgdG9nZ2xlQ2hlY2tib3ggKGUsIGZpbGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAvLyBTaGFyZWQgRHJpdmVzIGFyZW4ndCBzZWxlY3RhYmxlOyBmb3IgYWxsIGVsc2UsIGRlZmVyIHRvIHRoZSBiYXNlIFByb3ZpZGVyVmlldy5cbiAgICBpZiAoIWZpbGUuY3VzdG9tLmlzU2hhcmVkRHJpdmUpIHtcbiAgICAgIHN1cGVyLnRvZ2dsZUNoZWNrYm94KGUsIGZpbGUpXG4gICAgfVxuICB9XG59XG4iLCJjb25zdCB7IFVJUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgRHJpdmVQcm92aWRlclZpZXdzID0gcmVxdWlyZSgnLi9Ecml2ZVByb3ZpZGVyVmlld3MnKVxuXG5jb25zdCBsb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZScpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgR29vZ2xlRHJpdmUgZXh0ZW5kcyBVSVBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdHb29nbGVEcml2ZSdcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdHb29nbGUgRHJpdmUnXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0dvb2dsZSBEcml2ZSdcbiAgICB0aGlzLmljb24gPSAoKSA9PiAoXG4gICAgICA8c3ZnXG4gICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgICAgd2lkdGg9XCIzMlwiXG4gICAgICAgIGhlaWdodD1cIjMyXCJcbiAgICAgICAgdmlld0JveD1cIjAgMCAzMiAzMlwiXG4gICAgICA+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3RcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJJY29uQmdcIlxuICAgICAgICAgICAgZmlsbD1cIiM0Mjg1RjRcIlxuICAgICAgICAgICAgd2lkdGg9XCIzMlwiXG4gICAgICAgICAgICBoZWlnaHQ9XCIzMlwiXG4gICAgICAgICAgICByeD1cIjE2XCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBkPVwiTTI1LjIxNiAxNy43MzZMMTkuMDQzIDdoLTYuMDg2bDYuMTc1IDEwLjczNmg2LjA4NHptLTExLjI3NS44OTZMMTAuOSAyNGgxMS43MjNsMy4wNC01LjM2OEgxMy45NDJ6bS0xLjc4OS0xMC4yOWwtNS44MTYgMTAuMjlMOS4zOCAyNGw1LjkwNS0xMC4yOS0zLjEzMi01LjM2OXpcIlxuICAgICAgICAgICAgZmlsbD1cIiNGRkZcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ2RyaXZlJyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBsb2NhbGVcblxuICAgIHRoaXMuaTE4bkluaXQoKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLmkxOG4oJ3BsdWdpbk5hbWVHb29nbGVEcml2ZScpXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IERyaXZlUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMub3B0c1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoJ3Jvb3QnLCAnLycpLFxuICAgIF0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdzOiB7XG4gICAgcGx1Z2luTmFtZUdvb2dsZURyaXZlOiAnR29vZ2xlIERyaXZlJyxcbiAgfSxcbn1cbiIsImNvbnN0IENyb3BwZXJJbXBvcnQgPSByZXF1aXJlKCdjcm9wcGVyanMnKVxuY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbi8vIEBUT0RPIEEgc2lsbHkgaGFjayB0aGF0IHdlIGNhbiBnZXQgcmlkIG9mIHdoZW4gbW92aW5nIHRvIEVTTS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuY29uc3QgQ3JvcHBlciA9IENyb3BwZXJJbXBvcnQuX19lc01vZHVsZSA/IENyb3BwZXJJbXBvcnQuZGVmYXVsdCA6IENyb3BwZXJJbXBvcnRcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFZGl0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0geyByb3RhdGlvbkFuZ2xlOiAwLCByb3RhdGlvbkRlbHRhOiAwIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBjb25zdCB7IG9wdHMsIHN0b3JlQ3JvcHBlckluc3RhbmNlIH0gPSB0aGlzLnByb3BzXG4gICAgdGhpcy5jcm9wcGVyID0gbmV3IENyb3BwZXIoXG4gICAgICB0aGlzLmltZ0VsZW1lbnQsXG4gICAgICBvcHRzLmNyb3BwZXJPcHRpb25zLFxuICAgIClcbiAgICBzdG9yZUNyb3BwZXJJbnN0YW5jZSh0aGlzLmNyb3BwZXIpXG5cbiAgICBpZiAob3B0cy5hY3Rpb25zLmdyYW51bGFyUm90YXRlKSB7XG4gICAgICB0aGlzLmltZ0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY3JvcCcsIChldikgPT4ge1xuICAgICAgICBjb25zdCByb3RhdGlvbkFuZ2xlID0gZXYuZGV0YWlsLnJvdGF0ZVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICByb3RhdGlvbkFuZ2xlLFxuICAgICAgICAgIC8vIDQwNSA9PSAzNjAgKyA0NVxuICAgICAgICAgIHJvdGF0aW9uRGVsdGE6ICgocm90YXRpb25BbmdsZSArIDQwNSkgJSA5MCkgLSA0NSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHRoaXMuY3JvcHBlci5kZXN0cm95KClcbiAgfVxuXG4gIHNhdmUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBvcHRzLCBzYXZlLCBjdXJyZW50SW1hZ2UgfSA9IHRoaXMucHJvcHNcblxuICAgIHRoaXMuY3JvcHBlci5nZXRDcm9wcGVkQ2FudmFzKG9wdHMuY3JvcHBlck9wdGlvbnMuY3JvcHBlZENhbnZhc09wdGlvbnMpXG4gICAgICAudG9CbG9iKFxuICAgICAgICAoYmxvYikgPT4gc2F2ZShibG9iKSxcbiAgICAgICAgY3VycmVudEltYWdlLnR5cGUsXG4gICAgICAgIG9wdHMucXVhbGl0eSxcbiAgICAgIClcbiAgfVxuXG4gIGdyYW51bGFyUm90YXRlT25DaGFuZ2UgPSAoZXYpID0+IHtcbiAgICBjb25zdCB7IHJvdGF0aW9uQW5nbGUsIHJvdGF0aW9uRGVsdGEgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBwZW5kaW5nUm90YXRpb25EZWx0YSA9IE51bWJlcihldi50YXJnZXQudmFsdWUpIC0gcm90YXRpb25EZWx0YVxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZ3JhbnVsYXJSb3RhdGVPbklucHV0TmV4dEZyYW1lKVxuICAgIGlmIChwZW5kaW5nUm90YXRpb25EZWx0YSAhPT0gMCkge1xuICAgICAgY29uc3QgcGVuZGluZ1JvdGF0aW9uQW5nbGUgPSByb3RhdGlvbkFuZ2xlICsgcGVuZGluZ1JvdGF0aW9uRGVsdGFcbiAgICAgIHRoaXMuZ3JhbnVsYXJSb3RhdGVPbklucHV0TmV4dEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5jcm9wcGVyLnJvdGF0ZVRvKHBlbmRpbmdSb3RhdGlvbkFuZ2xlKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZW5kZXJHcmFudWxhclJvdGF0ZSAoKSB7XG4gICAgY29uc3QgeyBpMThuIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyByb3RhdGlvbkRlbHRhLCByb3RhdGlvbkFuZ2xlIH0gPSB0aGlzLnN0YXRlXG5cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2xhYmVsLWhhcy1hc3NvY2lhdGVkLWNvbnRyb2xcbiAgICAgIDxsYWJlbFxuICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgICBhcmlhLWxhYmVsPXtgJHtyb3RhdGlvbkFuZ2xlfcK6YH1cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1JbWFnZUNyb3BwZXItcmFuZ2VXcmFwcGVyIHVwcHktdS1yZXNldFwiXG4gICAgICA+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktSW1hZ2VDcm9wcGVyLXJhbmdlIHVwcHktdS1yZXNldFwiXG4gICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICBvbklucHV0PXt0aGlzLmdyYW51bGFyUm90YXRlT25DaGFuZ2V9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuZ3JhbnVsYXJSb3RhdGVPbkNoYW5nZX1cbiAgICAgICAgICB2YWx1ZT17cm90YXRpb25EZWx0YX1cbiAgICAgICAgICBtaW49XCItNDVcIlxuICAgICAgICAgIG1heD1cIjQ0XCJcbiAgICAgICAgICBhcmlhLWxhYmVsPXtpMThuKCdyb3RhdGUnKX1cbiAgICAgICAgLz5cbiAgICAgIDwvbGFiZWw+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyUmV2ZXJ0ICgpIHtcbiAgICBjb25zdCB7IGkxOG4gfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0blwiXG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3JldmVydCcpfVxuICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgIHRoaXMuY3JvcHBlci5yZXNldCgpXG4gICAgICAgICAgdGhpcy5jcm9wcGVyLnNldEFzcGVjdFJhdGlvKDApXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMyAzYy00Ljk3IDAtOSA0LjAzLTkgOUgxbDMuODkgMy44OS4wNy4xNEw5IDEySDZjMC0zLjg3IDMuMTMtNyA3LTdzNyAzLjEzIDcgNy0zLjEzIDctNyA3Yy0xLjkzIDAtMy42OC0uNzktNC45NC0yLjA2bC0xLjQyIDEuNDJDOC4yNyAxOS45OSAxMC41MSAyMSAxMyAyMWM0Ljk3IDAgOS00LjAzIDktOXMtNC4wMy05LTktOXptLTEgNXY1bDQuMjggMi41NC43Mi0xLjIxLTMuNS0yLjA4VjhIMTJ6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZW5kZXJSb3RhdGUgKCkge1xuICAgIGNvbnN0IHsgaTE4biB9ID0gdGhpcy5wcm9wc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuXCJcbiAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5jcm9wcGVyLnJvdGF0ZSgtOTApfVxuICAgICAgICBhcmlhLWxhYmVsPXtpMThuKCdyb3RhdGUnKX1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcFwiXG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMFYwem0wIDBoMjR2MjRIMFYwelwiIGZpbGw9XCJub25lXCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE0IDEwYTIgMiAwIDAxMiAydjdhMiAyIDAgMDEtMiAySDZhMiAyIDAgMDEtMi0ydi03YTIgMiAwIDAxMi0yaDh6bTAgMS43NUg2YS4yNS4yNSAwIDAwLS4yNDMuMTkzTDUuNzUgMTJ2N2EuMjUuMjUgMCAwMC4xOTMuMjQzTDYgMTkuMjVoOGEuMjUuMjUgMCAwMC4yNDMtLjE5M0wxNC4yNSAxOXYtN2EuMjUuMjUgMCAwMC0uMTkzLS4yNDNMMTQgMTEuNzV6TTEyIC43NlY0YzIuMyAwIDQuNjEuODggNi4zNiAyLjY0YTguOTUgOC45NSAwIDAxMi42MzQgNi4wMjVMMjEgMTNhMSAxIDAgMDEtMS45OTMuMTE3TDE5IDEzaC0uMDAzYTYuOTc5IDYuOTc5IDAgMDAtMi4wNDctNC45NSA2Ljk3IDYuOTcgMCAwMC00LjY1Mi0yLjA0NEwxMiA2djMuMjRMNy43NiA1IDEyIC43NnpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlckZsaXAgKCkge1xuICAgIGNvbnN0IHsgaTE4biB9ID0gdGhpcy5wcm9wc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuXCJcbiAgICAgICAgYXJpYS1sYWJlbD17aTE4bignZmxpcEhvcml6b250YWwnKX1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcFwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuY3JvcHBlci5zY2FsZVgoLXRoaXMuY3JvcHBlci5nZXREYXRhKCkuc2NhbGVYIHx8IC0xKX1cbiAgICAgID5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE1IDIxaDJ2LTJoLTJ2MnptNC0xMmgyVjdoLTJ2MnpNMyA1djE0YzAgMS4xLjkgMiAyIDJoNHYtMkg1VjVoNFYzSDVjLTEuMSAwLTIgLjktMiAyem0xNi0ydjJoMmMwLTEuMS0uOS0yLTItMnptLTggMjBoMlYxaC0ydjIyem04LTZoMnYtMmgtMnYyek0xNSA1aDJWM2gtMnYyem00IDhoMnYtMmgtMnYyem0wIDhjMS4xIDAgMi0uOSAyLTJoLTJ2MnpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlclpvb21JbiAoKSB7XG4gICAgY29uc3QgeyBpMThuIH0gPSB0aGlzLnByb3BzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG5cIlxuICAgICAgICBhcmlhLWxhYmVsPXtpMThuKCd6b29tSW4nKX1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcFwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuY3JvcHBlci56b29tKDAuMSl9XG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB3aWR0aD1cIjI0XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMFYwelwiIGZpbGw9XCJub25lXCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTEyIDEwaC0ydjJIOXYtMkg3VjloMlY3aDF2MmgydjF6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZW5kZXJab29tT3V0ICgpIHtcbiAgICBjb25zdCB7IGkxOG4gfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0blwiXG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3pvb21PdXQnKX1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcFwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuY3JvcHBlci56b29tKC0wLjEpfVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDBWMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNS41IDE0aC0uNzlsLS4yOC0uMjdDMTUuNDEgMTIuNTkgMTYgMTEuMTEgMTYgOS41IDE2IDUuOTEgMTMuMDkgMyA5LjUgM1MzIDUuOTEgMyA5LjUgNS45MSAxNiA5LjUgMTZjMS42MSAwIDMuMDktLjU5IDQuMjMtMS41N2wuMjcuMjh2Ljc5bDUgNC45OUwyMC40OSAxOWwtNC45OS01em0tNiAwQzcuMDEgMTQgNSAxMS45OSA1IDkuNVM3LjAxIDUgOS41IDUgMTQgNy4wMSAxNCA5LjUgMTEuOTkgMTQgOS41IDE0ek03IDloNXYxSDd6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZW5kZXJDcm9wU3F1YXJlICgpIHtcbiAgICBjb25zdCB7IGkxOG4gfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0blwiXG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ2FzcGVjdFJhdGlvU3F1YXJlJyl9XG4gICAgICAgIGRhdGEtbWljcm90aXAtcG9zaXRpb249XCJ0b3BcIlxuICAgICAgICBvbkNsaWNrPXsoKSA9PiB0aGlzLmNyb3BwZXIuc2V0QXNwZWN0UmF0aW8oMSl9XG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xOSA1djE0SDVWNWgxNG0wLTJINWMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yelwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyQ3JvcFdpZGVzY3JlZW4gKCkge1xuICAgIGNvbnN0IHsgaTE4biB9ID0gdGhpcy5wcm9wc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuXCJcbiAgICAgICAgYXJpYS1sYWJlbD17aTE4bignYXNwZWN0UmF0aW9MYW5kc2NhcGUnKX1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcFwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuY3JvcHBlci5zZXRBc3BlY3RSYXRpbygxNiAvIDkpfVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNIDE5LDQuOTk5OTk5MiBWIDE3LjAwMDAwMSBIIDQuOTk5OTk5OCBWIDYuOTk5OTk5MiBIIDE5IG0gMCwtMiBIIDQuOTk5OTk5OCBjIC0xLjA5OTk5OTksMCAtMS45OTk5OTk5LDAuOTAwMDAwMSAtMS45OTk5OTk5LDIgViAxNy4wMDAwMDEgYyAwLDEuMSAwLjksMiAxLjk5OTk5OTksMiBIIDE5IGMgMS4xLDAgMiwtMC45IDIsLTIgViA2Ljk5OTk5OTIgYyAwLC0xLjA5OTk5OTkgLTAuOSwtMiAtMiwtMiB6XCIgLz5cbiAgICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZW5kZXJDcm9wV2lkZXNjcmVlblZlcnRpY2FsICgpIHtcbiAgICBjb25zdCB7IGkxOG4gfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0blwiXG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ2FzcGVjdFJhdGlvUG9ydHJhaXQnKX1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcFwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuY3JvcHBlci5zZXRBc3BlY3RSYXRpbyg5IC8gMTYpfVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNIDE5LjAwMDAwMSwxOSBIIDYuOTk5OTk5IFYgNSBoIDEwLjAwMDAwMiB2IDE0IG0gMiwwIFYgNSBjIDAsLTEuMDk5OTk5OSAtMC45LC0xLjk5OTk5OTkgLTIsLTEuOTk5OTk5OSBIIDYuOTk5OTk5IGMgLTEuMSwwIC0yLDAuOSAtMiwxLjk5OTk5OTkgdiAxNCBjIDAsMS4xIDAuOSwyIDIsMiBoIDEwLjAwMDAwMiBjIDEuMSwwIDIsLTAuOSAyLC0yIHpcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50SW1hZ2UsIG9wdHMgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IGFjdGlvbnMgfSA9IG9wdHNcbiAgICBjb25zdCBpbWFnZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoY3VycmVudEltYWdlLmRhdGEpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LUltYWdlQ3JvcHBlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktSW1hZ2VDcm9wcGVyLWNvbnRhaW5lclwiPlxuICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktSW1hZ2VDcm9wcGVyLWltYWdlXCJcbiAgICAgICAgICAgIGFsdD17Y3VycmVudEltYWdlLm5hbWV9XG4gICAgICAgICAgICBzcmM9e2ltYWdlVVJMfVxuICAgICAgICAgICAgcmVmPXtyZWYgPT4geyB0aGlzLmltZ0VsZW1lbnQgPSByZWYgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktSW1hZ2VDcm9wcGVyLWNvbnRyb2xzXCI+XG4gICAgICAgICAge2FjdGlvbnMucmV2ZXJ0ICYmIHRoaXMucmVuZGVyUmV2ZXJ0KCl9XG4gICAgICAgICAge2FjdGlvbnMucm90YXRlICYmIHRoaXMucmVuZGVyUm90YXRlKCl9XG4gICAgICAgICAge2FjdGlvbnMuZ3JhbnVsYXJSb3RhdGUgJiYgdGhpcy5yZW5kZXJHcmFudWxhclJvdGF0ZSgpfVxuICAgICAgICAgIHthY3Rpb25zLmZsaXAgJiYgdGhpcy5yZW5kZXJGbGlwKCl9XG4gICAgICAgICAge2FjdGlvbnMuem9vbUluICYmIHRoaXMucmVuZGVyWm9vbUluKCl9XG4gICAgICAgICAge2FjdGlvbnMuem9vbU91dCAmJiB0aGlzLnJlbmRlclpvb21PdXQoKX1cbiAgICAgICAgICB7YWN0aW9ucy5jcm9wU3F1YXJlICYmIHRoaXMucmVuZGVyQ3JvcFNxdWFyZSgpfVxuICAgICAgICAgIHthY3Rpb25zLmNyb3BXaWRlc2NyZWVuICYmIHRoaXMucmVuZGVyQ3JvcFdpZGVzY3JlZW4oKX1cbiAgICAgICAgICB7YWN0aW9ucy5jcm9wV2lkZXNjcmVlblZlcnRpY2FsICYmIHRoaXMucmVuZGVyQ3JvcFdpZGVzY3JlZW5WZXJ0aWNhbCgpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuIiwiY29uc3QgeyBVSVBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBFZGl0b3IgPSByZXF1aXJlKCcuL0VkaXRvcicpXG5cbmNvbnN0IGxvY2FsZSA9IHJlcXVpcmUoJy4vbG9jYWxlLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbWFnZUVkaXRvciBleHRlbmRzIFVJUGx1Z2luIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlXG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdJbWFnZUVkaXRvcidcbiAgICB0aGlzLnRpdGxlID0gJ0ltYWdlIEVkaXRvcidcbiAgICB0aGlzLnR5cGUgPSAnZWRpdG9yJ1xuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gbG9jYWxlXG5cbiAgICBjb25zdCBkZWZhdWx0Q3JvcHBlck9wdGlvbnMgPSB7XG4gICAgICB2aWV3TW9kZTogMSxcbiAgICAgIGJhY2tncm91bmQ6IGZhbHNlLFxuICAgICAgYXV0b0Nyb3BBcmVhOiAxLFxuICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgIGNyb3BwZWRDYW52YXNPcHRpb25zOiB7fSxcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0QWN0aW9ucyA9IHtcbiAgICAgIHJldmVydDogdHJ1ZSxcbiAgICAgIHJvdGF0ZTogdHJ1ZSxcbiAgICAgIGdyYW51bGFyUm90YXRlOiB0cnVlLFxuICAgICAgZmxpcDogdHJ1ZSxcbiAgICAgIHpvb21JbjogdHJ1ZSxcbiAgICAgIHpvb21PdXQ6IHRydWUsXG4gICAgICBjcm9wU3F1YXJlOiB0cnVlLFxuICAgICAgY3JvcFdpZGVzY3JlZW46IHRydWUsXG4gICAgICBjcm9wV2lkZXNjcmVlblZlcnRpY2FsOiB0cnVlLFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgcXVhbGl0eTogMC44LFxuICAgIH1cblxuICAgIHRoaXMub3B0cyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgLi4uZGVmYXVsdEFjdGlvbnMsXG4gICAgICAgIC4uLm9wdHMuYWN0aW9ucyxcbiAgICAgIH0sXG4gICAgICBjcm9wcGVyT3B0aW9uczoge1xuICAgICAgICAuLi5kZWZhdWx0Q3JvcHBlck9wdGlvbnMsXG4gICAgICAgIC4uLm9wdHMuY3JvcHBlck9wdGlvbnMsXG4gICAgICB9LFxuICAgIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgY2FuRWRpdEZpbGUgKGZpbGUpIHtcbiAgICBpZiAoIWZpbGUudHlwZSB8fCBmaWxlLmlzUmVtb3RlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlVHlwZVNwZWNpZmljID0gZmlsZS50eXBlLnNwbGl0KCcvJylbMV1cblxuICAgIGlmICgvXihqcGU/Z3xnaWZ8cG5nfGJtcHx3ZWJwKSQvLnRlc3QoZmlsZVR5cGVTcGVjaWZpYykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzYXZlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNhdmVCbG9iQ2FsbGJhY2sgPSAoYmxvYikgPT4ge1xuICAgICAgY29uc3QgeyBjdXJyZW50SW1hZ2UgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgICB0aGlzLnVwcHkuc2V0RmlsZVN0YXRlKGN1cnJlbnRJbWFnZS5pZCwge1xuICAgICAgICBkYXRhOiBibG9iLFxuICAgICAgICBzaXplOiBibG9iLnNpemUsXG4gICAgICAgIHByZXZpZXc6IG51bGwsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB1cGRhdGVkRmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGN1cnJlbnRJbWFnZS5pZClcbiAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6cmVxdWVzdCcsIHVwZGF0ZWRGaWxlKVxuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGN1cnJlbnRJbWFnZTogdXBkYXRlZEZpbGUsXG4gICAgICB9KVxuICAgICAgdGhpcy51cHB5LmVtaXQoJ2ZpbGUtZWRpdG9yOmNvbXBsZXRlJywgdXBkYXRlZEZpbGUpXG4gICAgfVxuXG4gICAgY29uc3QgeyBjdXJyZW50SW1hZ2UgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgdGhpcy5jcm9wcGVyLmdldENyb3BwZWRDYW52YXMoKS50b0Jsb2IoXG4gICAgICBzYXZlQmxvYkNhbGxiYWNrLFxuICAgICAgY3VycmVudEltYWdlLnR5cGUsXG4gICAgICB0aGlzLm9wdHMucXVhbGl0eSxcbiAgICApXG4gIH1cblxuICBzdG9yZUNyb3BwZXJJbnN0YW5jZSA9IChjcm9wcGVyKSA9PiB7XG4gICAgdGhpcy5jcm9wcGVyID0gY3JvcHBlclxuICB9XG5cbiAgc2VsZWN0RmlsZSA9IChmaWxlKSA9PiB7XG4gICAgdGhpcy51cHB5LmVtaXQoJ2ZpbGUtZWRpdG9yOnN0YXJ0JywgZmlsZSlcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGN1cnJlbnRJbWFnZTogZmlsZSxcbiAgICB9KVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBjdXJyZW50SW1hZ2U6IG51bGwsXG4gICAgfSlcblxuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLm9wdHNcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgY3VycmVudEltYWdlIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcblxuICAgIGlmIChjdXJyZW50SW1hZ2UgPT09IG51bGwgfHwgY3VycmVudEltYWdlLmlzUmVtb3RlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8RWRpdG9yXG4gICAgICAgIGN1cnJlbnRJbWFnZT17Y3VycmVudEltYWdlfVxuICAgICAgICBzdG9yZUNyb3BwZXJJbnN0YW5jZT17dGhpcy5zdG9yZUNyb3BwZXJJbnN0YW5jZX1cbiAgICAgICAgc2F2ZT17dGhpcy5zYXZlfVxuICAgICAgICBvcHRzPXt0aGlzLm9wdHN9XG4gICAgICAgIGkxOG49e3RoaXMuaTE4bn1cbiAgICAgIC8+XG4gICAgKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nczoge1xuICAgIHJldmVydDogJ1JldmVydCcsXG4gICAgcm90YXRlOiAnUm90YXRlJyxcbiAgICB6b29tSW46ICdab29tIGluJyxcbiAgICB6b29tT3V0OiAnWm9vbSBvdXQnLFxuICAgIGZsaXBIb3Jpem9udGFsOiAnRmxpcCBob3Jpem9udGFsJyxcbiAgICBhc3BlY3RSYXRpb1NxdWFyZTogJ0Nyb3Agc3F1YXJlJyxcbiAgICBhc3BlY3RSYXRpb0xhbmRzY2FwZTogJ0Nyb3AgbGFuZHNjYXBlICgxNjo5KScsXG4gICAgYXNwZWN0UmF0aW9Qb3J0cmFpdDogJ0Nyb3AgcG9ydHJhaXQgKDk6MTYpJyxcbiAgfSxcbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50LCBjcmVhdGVSZWYgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IFRSQU5TSVRJT05fTVMgPSAzMDBcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGYWRlSW4gZXh0ZW5kcyBDb21wb25lbnQge1xuICByZWYgPSBjcmVhdGVSZWYoKTtcblxuICBjb21wb25lbnRXaWxsRW50ZXIgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZWYuY3VycmVudC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgdGhpcy5yZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSdcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBUUkFOU0lUSU9OX01TKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbExlYXZlIChjYWxsYmFjaykge1xuICAgIHRoaXMucmVmLmN1cnJlbnQuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgIHRoaXMucmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoMzUwJSknXG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgVFJBTlNJVElPTl9NUylcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1JbmZvcm1lci1hbmltYXRlZFwiIHJlZj17dGhpcy5yZWZ9PlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QtdHJhbnNpdGlvbi1ncm91cFxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBDb21wb25lbnQsIGNsb25lRWxlbWVudCwgaCwgdG9DaGlsZEFycmF5IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBhc3NpZ24gKG9iaiwgcHJvcHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBwcm9wcylcbn1cbmZ1bmN0aW9uIGdldEtleSAodm5vZGUsIGZhbGxiYWNrKSB7XG4gIHJldHVybiB2bm9kZT8ua2V5ID8/IGZhbGxiYWNrXG59XG5mdW5jdGlvbiBsaW5rUmVmIChjb21wb25lbnQsIG5hbWUpIHtcbiAgY29uc3QgY2FjaGUgPSBjb21wb25lbnQuX3B0Z0xpbmtlZFJlZnMgfHwgKGNvbXBvbmVudC5fcHRnTGlua2VkUmVmcyA9IHt9KVxuICByZXR1cm4gY2FjaGVbbmFtZV0gfHwgKGNhY2hlW25hbWVdID0gYyA9PiB7XG4gICAgY29tcG9uZW50LnJlZnNbbmFtZV0gPSBjXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldENoaWxkTWFwcGluZyAoY2hpbGRyZW4pIHtcbiAgY29uc3Qgb3V0ID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjaGlsZHJlbltpXSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBrZXkgPSBnZXRLZXkoY2hpbGRyZW5baV0sIGkudG9TdHJpbmcoMzYpKVxuICAgICAgb3V0W2tleV0gPSBjaGlsZHJlbltpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2hpbGRNYXBwaW5ncyAocHJldiwgbmV4dCkge1xuICBwcmV2ID0gcHJldiB8fCB7fVxuICBuZXh0ID0gbmV4dCB8fCB7fVxuXG4gIGNvbnN0IGdldFZhbHVlRm9yS2V5ID0ga2V5ID0+IChuZXh0Lmhhc093blByb3BlcnR5KGtleSkgPyBuZXh0W2tleV0gOiBwcmV2W2tleV0pXG5cbiAgLy8gRm9yIGVhY2gga2V5IG9mIGBuZXh0YCwgdGhlIGxpc3Qgb2Yga2V5cyB0byBpbnNlcnQgYmVmb3JlIHRoYXQga2V5IGluXG4gIC8vIHRoZSBjb21iaW5lZCBsaXN0XG4gIGNvbnN0IG5leHRLZXlzUGVuZGluZyA9IHt9XG5cbiAgbGV0IHBlbmRpbmdLZXlzID0gW11cbiAgZm9yIChjb25zdCBwcmV2S2V5IGluIHByZXYpIHtcbiAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eShwcmV2S2V5KSkge1xuICAgICAgaWYgKHBlbmRpbmdLZXlzLmxlbmd0aCkge1xuICAgICAgICBuZXh0S2V5c1BlbmRpbmdbcHJldktleV0gPSBwZW5kaW5nS2V5c1xuICAgICAgICBwZW5kaW5nS2V5cyA9IFtdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdLZXlzLnB1c2gocHJldktleSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBjaGlsZE1hcHBpbmcgPSB7fVxuICBmb3IgKGNvbnN0IG5leHRLZXkgaW4gbmV4dCkge1xuICAgIGlmIChuZXh0S2V5c1BlbmRpbmcuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXNQZW5kaW5nW25leHRLZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdOZXh0S2V5ID0gbmV4dEtleXNQZW5kaW5nW25leHRLZXldW2ldXG4gICAgICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ05leHRLZXkpXG4gICAgICB9XG4gICAgfVxuICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5XSA9IGdldFZhbHVlRm9yS2V5KG5leHRLZXkpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBhZGQgdGhlIGtleXMgd2hpY2ggZGlkbid0IGFwcGVhciBiZWZvcmUgYW55IGtleSBpbiBgbmV4dGBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZW5kaW5nS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTWFwcGluZ1twZW5kaW5nS2V5c1tpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nS2V5c1tpXSlcbiAgfVxuXG4gIHJldHVybiBjaGlsZE1hcHBpbmdcbn1cblxuY29uc3QgaWRlbnRpdHkgPSBpID0+IGlcblxuY2xhc3MgVHJhbnNpdGlvbkdyb3VwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG5cbiAgICB0aGlzLnJlZnMgPSB7fVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZE1hcHBpbmcodG9DaGlsZEFycmF5KHRvQ2hpbGRBcnJheSh0aGlzLnByb3BzLmNoaWxkcmVuKSkgfHwgW10pLFxuICAgIH1cblxuICAgIHRoaXMucGVyZm9ybUFwcGVhciA9IHRoaXMucGVyZm9ybUFwcGVhci5iaW5kKHRoaXMpXG4gICAgdGhpcy5wZXJmb3JtRW50ZXIgPSB0aGlzLnBlcmZvcm1FbnRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5wZXJmb3JtTGVhdmUgPSB0aGlzLnBlcmZvcm1MZWF2ZS5iaW5kKHRoaXMpXG4gIH1cblxuICBjb21wb25lbnRXaWxsTW91bnQgKCkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXMgPSB7fVxuICAgIHRoaXMua2V5c1RvQWJvcnRMZWF2ZSA9IFtdXG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdXG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgY29uc3QgaW5pdGlhbENoaWxkTWFwcGluZyA9IHRoaXMuc3RhdGUuY2hpbGRyZW5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbml0aWFsQ2hpbGRNYXBwaW5nKSB7XG4gICAgICBpZiAoaW5pdGlhbENoaWxkTWFwcGluZ1trZXldKSB7XG4gICAgICAgIC8vIHRoaXMucGVyZm9ybUFwcGVhcihnZXRLZXkoaW5pdGlhbENoaWxkTWFwcGluZ1trZXldLCBrZXkpKTtcbiAgICAgICAgdGhpcy5wZXJmb3JtQXBwZWFyKGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXh0UHJvcHMpIHtcbiAgICBjb25zdCBuZXh0Q2hpbGRNYXBwaW5nID0gZ2V0Q2hpbGRNYXBwaW5nKHRvQ2hpbGRBcnJheShuZXh0UHJvcHMuY2hpbGRyZW4pIHx8IFtdKVxuICAgIGNvbnN0IHByZXZDaGlsZE1hcHBpbmcgPSB0aGlzLnN0YXRlLmNoaWxkcmVuXG5cbiAgICB0aGlzLnNldFN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgY2hpbGRyZW46IG1lcmdlQ2hpbGRNYXBwaW5ncyhwcmV2U3RhdGUuY2hpbGRyZW4sIG5leHRDaGlsZE1hcHBpbmcpLFxuICAgIH0pKVxuXG4gICAgbGV0IGtleVxuXG4gICAgZm9yIChrZXkgaW4gbmV4dENoaWxkTWFwcGluZykge1xuICAgICAgaWYgKG5leHRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb25zdCBoYXNQcmV2ID0gcHJldkNoaWxkTWFwcGluZyAmJiBwcmV2Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgLy8gV2Ugc2hvdWxkIHJlLWVudGVyIHRoZSBjb21wb25lbnQgYW5kIGFib3J0IGl0cyBsZWF2ZSBmdW5jdGlvblxuICAgICAgICBpZiAobmV4dENoaWxkTWFwcGluZ1trZXldICYmIGhhc1ByZXYgJiYgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldKSB7XG4gICAgICAgICAgdGhpcy5rZXlzVG9FbnRlci5wdXNoKGtleSlcbiAgICAgICAgICB0aGlzLmtleXNUb0Fib3J0TGVhdmUucHVzaChrZXkpXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dENoaWxkTWFwcGluZ1trZXldICYmICFoYXNQcmV2ICYmICF0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0pIHtcbiAgICAgICAgICB0aGlzLmtleXNUb0VudGVyLnB1c2goa2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gcHJldkNoaWxkTWFwcGluZykge1xuICAgICAgaWYgKHByZXZDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb25zdCBoYXNOZXh0ID0gbmV4dENoaWxkTWFwcGluZyAmJiBuZXh0Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgaWYgKHByZXZDaGlsZE1hcHBpbmdba2V5XSAmJiAhaGFzTmV4dCAmJiAhdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldKSB7XG4gICAgICAgICAgdGhpcy5rZXlzVG9MZWF2ZS5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgY29uc3QgeyBrZXlzVG9FbnRlciB9ID0gdGhpc1xuICAgIHRoaXMua2V5c1RvRW50ZXIgPSBbXVxuICAgIGtleXNUb0VudGVyLmZvckVhY2godGhpcy5wZXJmb3JtRW50ZXIpXG5cbiAgICBjb25zdCB7IGtleXNUb0xlYXZlIH0gPSB0aGlzXG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdXG4gICAga2V5c1RvTGVhdmUuZm9yRWFjaCh0aGlzLnBlcmZvcm1MZWF2ZSlcbiAgfVxuXG4gIF9maW5pc2hBYm9ydCAoa2V5KSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5rZXlzVG9BYm9ydExlYXZlLmluZGV4T2Yoa2V5KVxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICB0aGlzLmtleXNUb0Fib3J0TGVhdmUuc3BsaWNlKGlkeCwgMSlcbiAgICB9XG4gIH1cblxuICBwZXJmb3JtQXBwZWFyIChrZXkpIHtcbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0gPSB0cnVlXG5cbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XVxuXG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsQXBwZWFyKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50V2lsbEFwcGVhcih0aGlzLl9oYW5kbGVEb25lQXBwZWFyaW5nLmJpbmQodGhpcywga2V5KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlRG9uZUFwcGVhcmluZyhrZXkpXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZURvbmVBcHBlYXJpbmcgKGtleSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldXG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRBcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnREaWRBcHBlYXIoKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV1cbiAgICB0aGlzLl9maW5pc2hBYm9ydChrZXkpXG5cbiAgICBjb25zdCBjdXJyZW50Q2hpbGRNYXBwaW5nID0gZ2V0Q2hpbGRNYXBwaW5nKHRvQ2hpbGRBcnJheSh0aGlzLnByb3BzLmNoaWxkcmVuKSB8fCBbXSlcblxuICAgIGlmICghY3VycmVudENoaWxkTWFwcGluZyB8fCAhY3VycmVudENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBUaGlzIHdhcyByZW1vdmVkIGJlZm9yZSBpdCBoYWQgZnVsbHkgYXBwZWFyZWQuIFJlbW92ZSBpdC5cbiAgICAgIHRoaXMucGVyZm9ybUxlYXZlKGtleSlcbiAgICB9XG4gIH1cblxuICBwZXJmb3JtRW50ZXIgKGtleSkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSA9IHRydWVcblxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldXG5cbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcih0aGlzLl9oYW5kbGVEb25lRW50ZXJpbmcuYmluZCh0aGlzLCBrZXkpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYW5kbGVEb25lRW50ZXJpbmcoa2V5KVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVEb25lRW50ZXJpbmcgKGtleSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldXG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRFbnRlcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudERpZEVudGVyKClcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldXG4gICAgdGhpcy5fZmluaXNoQWJvcnQoa2V5KVxuXG4gICAgY29uc3QgY3VycmVudENoaWxkTWFwcGluZyA9IGdldENoaWxkTWFwcGluZyh0b0NoaWxkQXJyYXkodGhpcy5wcm9wcy5jaGlsZHJlbikgfHwgW10pXG5cbiAgICBpZiAoIWN1cnJlbnRDaGlsZE1hcHBpbmcgfHwgIWN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhpcyB3YXMgcmVtb3ZlZCBiZWZvcmUgaXQgaGFkIGZ1bGx5IGVudGVyZWQuIFJlbW92ZSBpdC5cbiAgICAgIHRoaXMucGVyZm9ybUxlYXZlKGtleSlcbiAgICB9XG4gIH1cblxuICBwZXJmb3JtTGVhdmUgKGtleSkge1xuICAgIC8vIElmIHdlIHNob3VsZCBpbW1lZGlhdGVseSBhYm9ydCB0aGlzIGxlYXZlIGZ1bmN0aW9uLFxuICAgIC8vIGRvbid0IHJ1biB0aGUgbGVhdmUgdHJhbnNpdGlvbiBhdCBhbGwuXG4gICAgY29uc3QgaWR4ID0gdGhpcy5rZXlzVG9BYm9ydExlYXZlLmluZGV4T2Yoa2V5KVxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0gPSB0cnVlXG5cbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XVxuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbExlYXZlKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50V2lsbExlYXZlKHRoaXMuX2hhbmRsZURvbmVMZWF2aW5nLmJpbmQodGhpcywga2V5KSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgc29tZXdoYXQgZGFuZ2Vyb3VzIGIvYyBpdCBjYWxscyBzZXRTdGF0ZSgpXG4gICAgICAvLyBhZ2FpbiwgZWZmZWN0aXZlbHkgbXV0YXRpbmcgdGhlIGNvbXBvbmVudCBiZWZvcmUgYWxsIHRoZSB3b3JrXG4gICAgICAvLyBpcyBkb25lLlxuICAgICAgdGhpcy5faGFuZGxlRG9uZUxlYXZpbmcoa2V5KVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVEb25lTGVhdmluZyAoa2V5KSB7XG4gICAgLy8gSWYgd2Ugc2hvdWxkIGltbWVkaWF0ZWx5IGFib3J0IHRoZSBsZWF2ZSxcbiAgICAvLyB0aGVuIHNraXAgdGhpcyBhbHRvZ2V0aGVyXG4gICAgY29uc3QgaWR4ID0gdGhpcy5rZXlzVG9BYm9ydExlYXZlLmluZGV4T2Yoa2V5KVxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XVxuXG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRMZWF2ZSkge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudERpZExlYXZlKClcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldXG5cbiAgICBjb25zdCBjdXJyZW50Q2hpbGRNYXBwaW5nID0gZ2V0Q2hpbGRNYXBwaW5nKHRvQ2hpbGRBcnJheSh0aGlzLnByb3BzLmNoaWxkcmVuKSB8fCBbXSlcblxuICAgIGlmIChjdXJyZW50Q2hpbGRNYXBwaW5nICYmIGN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhpcyBlbnRlcmVkIGFnYWluIGJlZm9yZSBpdCBmdWxseSBsZWZ0LiBBZGQgaXQgYWdhaW4uXG4gICAgICB0aGlzLnBlcmZvcm1FbnRlcihrZXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gYXNzaWduKHt9LCB0aGlzLnN0YXRlLmNoaWxkcmVuKVxuICAgICAgZGVsZXRlIGNoaWxkcmVuW2tleV1cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBjaGlsZHJlbiB9KVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoeyBjaGlsZEZhY3RvcnksIHRyYW5zaXRpb25MZWF2ZSwgdHJhbnNpdGlvbk5hbWUsIHRyYW5zaXRpb25BcHBlYXIsIHRyYW5zaXRpb25FbnRlciwgdHJhbnNpdGlvbkxlYXZlVGltZW91dCwgdHJhbnNpdGlvbkVudGVyVGltZW91dCwgdHJhbnNpdGlvbkFwcGVhclRpbWVvdXQsIGNvbXBvbmVudCwgLi4ucHJvcHMgfSwgeyBjaGlsZHJlbiB9KSB7XG4gICAgLy8gVE9ETzogd2UgY291bGQgZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3IgdGhlIHdyYXBwZXIgbm9kZVxuICAgIC8vIGJ5IGNsb25pbmcgYSBzaW5nbGUgY2hpbGRcbiAgICBjb25zdCBjaGlsZHJlblRvUmVuZGVyID0gW11cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltrZXldXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNvbnN0IHJlZiA9IGxpbmtSZWYodGhpcywga2V5KSxcbiAgICAgICAgICAgIGVsID0gY2xvbmVFbGVtZW50KGNoaWxkRmFjdG9yeShjaGlsZCksIHsgcmVmLCBrZXkgfSlcbiAgICAgICAgICBjaGlsZHJlblRvUmVuZGVyLnB1c2goZWwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaChjb21wb25lbnQsIHByb3BzLCBjaGlsZHJlblRvUmVuZGVyKVxuICB9XG59XG5cblRyYW5zaXRpb25Hcm91cC5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbXBvbmVudDogJ3NwYW4nLFxuICBjaGlsZEZhY3Rvcnk6IGlkZW50aXR5LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zaXRpb25Hcm91cFxuIiwiLyogZXNsaW50LWRpc2FibGUganN4LWExMXkvbm8tbm9uaW50ZXJhY3RpdmUtZWxlbWVudC1pbnRlcmFjdGlvbnMgICovXG4vKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9jbGljay1ldmVudHMtaGF2ZS1rZXktZXZlbnRzICovXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCB7IFVJUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IEZhZGVJbiA9IHJlcXVpcmUoJy4vRmFkZUluJylcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvbkdyb3VwJylcblxuLyoqXG4gKiBJbmZvcm1lclxuICogU2hvd3MgcmFkIG1lc3NhZ2UgYnViYmxlc1xuICogdXNlZCBsaWtlIHRoaXM6IGB1cHB5LmluZm8oJ2hlbGxvIHdvcmxkJywgJ2luZm8nLCA1MDAwKWBcbiAqIG9yIGZvciBlcnJvcnM6IGB1cHB5LmluZm8oJ0Vycm9yIHVwbG9hZGluZyBpbWcuanBnJywgJ2Vycm9yJywgNTAwMClgXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEluZm9ybWVyIGV4dGVuZHMgVUlQbHVnaW4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMudHlwZSA9ICdwcm9ncmVzc2luZGljYXRvcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdJbmZvcm1lcidcbiAgICB0aGlzLnRpdGxlID0gJ0luZm9ybWVyJ1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge31cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuICB9XG5cbiAgcmVuZGVyID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweSB1cHB5LUluZm9ybWVyXCI+XG4gICAgICAgIDxUcmFuc2l0aW9uR3JvdXA+XG4gICAgICAgICAge3N0YXRlLmluZm8ubWFwKChpbmZvKSA9PiAoXG4gICAgICAgICAgICA8RmFkZUluIGtleT17aW5mby5tZXNzYWdlfT5cbiAgICAgICAgICAgICAgPHAgcm9sZT1cImFsZXJ0XCI+XG4gICAgICAgICAgICAgICAge2luZm8ubWVzc2FnZX1cbiAgICAgICAgICAgICAgICB7JyAnfVxuICAgICAgICAgICAgICAgIHtpbmZvLmRldGFpbHMgJiYgKFxuICAgICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17aW5mby5kZXRhaWxzfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wLWxlZnRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLW1pY3JvdGlwLXNpemU9XCJtZWRpdW1cIlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hbGVydFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBhbGVydChgJHtpbmZvLm1lc3NhZ2V9IFxcblxcbiAke2luZm8uZGV0YWlsc31gKX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgP1xuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDwvRmFkZUluPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L1RyYW5zaXRpb25Hcm91cD5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLm9wdHNcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IHsgVUlQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3QgbG9jYWxlID0gcmVxdWlyZSgnLi9sb2NhbGUuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEluc3RhZ3JhbSBleHRlbmRzIFVJUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0luc3RhZ3JhbSdcbiAgICBQcm92aWRlci5pbml0UGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiNFMTMwNkNcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE2IDguNjIyYzIuNDAzIDAgMi42ODguMDA5IDMuNjM3LjA1Mi44NzcuMDQgMS4zNTQuMTg3IDEuNjcuMzEuMzkyLjE0NC43NDUuMzc0IDEuMDM2LjY3My4yOTkuMjkuNTI5LjY0NC42NzMgMS4wMzUuMTIzLjMxNy4yNy43OTQuMzEgMS42NzEuMDQzLjk1LjA1MiAxLjIzNC4wNTIgMy42MzdzLS4wMDkgMi42ODgtLjA1MiAzLjYzN2MtLjA0Ljg3Ny0uMTg3IDEuMzU0LS4zMSAxLjY3MWEyLjk4IDIuOTggMCAwIDEtMS43MDggMS43MDhjLS4zMTcuMTIzLS43OTQuMjctMS42NzEuMzEtLjk1LjA0My0xLjIzNC4wNTMtMy42MzcuMDUzcy0yLjY4OC0uMDEtMy42MzctLjA1M2MtLjg3Ny0uMDQtMS4zNTQtLjE4Ny0xLjY3MS0uMzFhMi43ODggMi43ODggMCAwIDEtMS4wMzUtLjY3MyAyLjc4OCAyLjc4OCAwIDAgMS0uNjczLTEuMDM1Yy0uMTIzLS4zMTctLjI3LS43OTQtLjMxLTEuNjcxLS4wNDMtLjk0OS0uMDUyLTEuMjM0LS4wNTItMy42MzdzLjAwOS0yLjY4OC4wNTItMy42MzdjLjA0LS44NzcuMTg3LTEuMzU0LjMxLTEuNjcuMTQ0LS4zOTIuMzc0LS43NDUuNjczLTEuMDM2LjI5LS4yOTkuNjQ0LS41MjkgMS4wMzUtLjY3My4zMTctLjEyMy43OTQtLjI3IDEuNjcxLS4zMS45NS0uMDQzIDEuMjM0LS4wNTIgMy42MzctLjA1MnpNMTYgN2MtMi40NDQgMC0yLjc1LjAxLTMuNzEuMDU0LS45NTkuMDQ0LTEuNjEzLjE5Ni0yLjE4NS40MTktLjYuMjI1LTEuMTQ1LjU4LTEuNTk0IDEuMDM4LS40NTguNDUtLjgxMy45OTMtMS4wMzkgMS41OTQtLjIyMi41NzItLjM3NCAxLjIyNi0uNDE4IDIuMTg0QzcuMDEgMTMuMjUgNyAxMy41NTYgNyAxNnMuMDEgMi43NS4wNTQgMy43MWMuMDQ0Ljk1OS4xOTYgMS42MTMuNDE5IDIuMTg1LjIyNi42LjU4IDEuMTQ1IDEuMDM4IDEuNTk0LjQ1LjQ1OC45OTMuODEzIDEuNTk0IDEuMDM4LjU3Mi4yMjMgMS4yMjcuMzc1IDIuMTg0LjQxOS45Ni4wNDQgMS4yNjcuMDU0IDMuNzExLjA1NHMyLjc1LS4wMSAzLjcxLS4wNTRjLjk1OS0uMDQ0IDEuNjEzLS4xOTYgMi4xODUtLjQxOWE0LjYwMiA0LjYwMiAwIDAgMCAyLjYzMi0yLjYzMmMuMjIzLS41NzIuMzc1LTEuMjI2LjQxOS0yLjE4NC4wNDQtLjk2LjA1NC0xLjI2Ny4wNTQtMy43MTFzLS4wMS0yLjc1LS4wNTQtMy43MWMtLjA0NC0uOTU5LS4xOTYtMS42MTMtLjQxOS0yLjE4NUE0LjQxMiA0LjQxMiAwIDAgMCAyMy40OSA4LjUxYTQuNDEyIDQuNDEyIDAgMCAwLTEuNTk0LTEuMDM5Yy0uNTcyLS4yMjItMS4yMjYtLjM3NC0yLjE4NC0uNDE4QzE4Ljc1IDcuMDEgMTguNDQ0IDcgMTYgN3ptMCA0LjVhNC41IDQuNSAwIDEgMCAwIDkgNC41IDQuNSAwIDAgMCAwLTl6bTAgNy40MjFhMi45MjEgMi45MjEgMCAxIDEgMC01Ljg0MiAyLjkyMSAyLjkyMSAwIDAgMSAwIDUuODQyem00Ljg3NS02LjY3MWExLjEyNSAxLjEyNSAwIDEgMSAwLTIuMjUgMS4xMjUgMS4xMjUgMCAwIDEgMCAyLjI1elwiIGZpbGw9XCIjRkZGXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gbG9jYWxlXG5cbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5pMThuKCdwbHVnaW5OYW1lSW5zdGFncmFtJylcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ2luc3RhZ3JhbScsXG4gICAgICBwbHVnaW5JZDogdGhpcy5pZCxcbiAgICB9KVxuXG4gICAgdGhpcy5vbkZpcnN0UmVuZGVyID0gdGhpcy5vbkZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldyA9IG5ldyBQcm92aWRlclZpZXdzKHRoaXMsIHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgdmlld1R5cGU6ICdncmlkJyxcbiAgICAgIHNob3dUaXRsZXM6IGZhbHNlLFxuICAgICAgc2hvd0ZpbHRlcjogZmFsc2UsXG4gICAgICBzaG93QnJlYWRjcnVtYnM6IGZhbHNlLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcudGVhckRvd24oKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvbkZpcnN0UmVuZGVyICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wcm92aWRlci5mZXRjaFByZUF1dGhUb2tlbigpLFxuICAgICAgdGhpcy52aWV3LmdldEZvbGRlcigncmVjZW50JyksXG4gICAgXSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnJlbmRlcihzdGF0ZSlcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZ3M6IHtcbiAgICBwbHVnaW5OYW1lSW5zdGFncmFtOiAnSW5zdGFncmFtJyxcbiAgfSxcbn1cbiIsImNvbnN0IHsgVUlQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3QgbG9jYWxlID0gcmVxdWlyZSgnLi9sb2NhbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE9uZURyaXZlIGV4dGVuZHMgVUlQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnT25lRHJpdmUnXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ09uZURyaXZlJ1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiBmaWxsPVwiIzAyNjJDMFwiIC8+XG4gICAgICAgICAgPGcgZmlsbD1cIiNGRkZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjQuMTU3IDIyczEuNDkyLS4yMDUgMS43OS0xLjY1NWEyLjYyNCAyLjYyNCAwIDAgMCAuMDMtLjg3OGMtLjIyLTEuNjQtMS45ODgtMi4wMS0xLjk4OC0yLjAxcy4zMDctMS43NjUtMS4zMTItMi42OWMtMS42Mi0uOTI1LTMuMSAwLTMuMSAwUzE4LjcxMSAxMyAxNi4zNjYgMTNjLTMuMDE2IDAtMy41MTkgMy40NDgtMy41MTkgMy40NDhTMTAgMTYuNjE4IDEwIDE5LjE0YzAgMi41MjMgMi41OTcgMi44NiAyLjU5NyAyLjg2aDExLjU2elwiIC8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTkuNDIxIDE5LjI0NmMwLTIuMTk3IDEuNjA2LTMuMTU5IDIuODcxLTMuNDcyLjQ0LTEuNDc3IDEuNjU0LTMuNDM5IDQuMTM1LTMuNDM5SDE2LjQ0NWMxLjcyMSAwIDIuNzkuODIzIDMuMzY4IDEuNDc2YTMuOTkgMy45OSAwIDAgMSAxLjE0Ny0uMTcxaC4wMWwuMDMuMDAyQzIxLjAxNyAxMy41IDIwLjY5MSAxMCAxNi43NTcgMTBjLTIuNjkgMC0zLjYzOSAyLjM0NS0zLjYzOSAyLjM0NXMtMS45NS0xLjQ4Mi0zLjk1NS41NjdjLTEuMDI4IDEuMDUyLS43OSAyLjY2OS0uNzkgMi42NjlTNiAxNS44MjQgNiAxOC40MTJDNiAyMC43NTcgOC40NTIgMjEgOC40NTIgMjFoMS4zNzJhMy43NyAzLjc3IDAgMCAxLS40MDMtMS43NTR6XCIgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgICAgcHJvdmlkZXI6ICdvbmVkcml2ZScsXG4gICAgICBwbHVnaW5JZDogdGhpcy5pZCxcbiAgICB9KVxuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gbG9jYWxlXG5cbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5pMThuKCdwbHVnaW5OYW1lT25lRHJpdmUnKVxuXG4gICAgdGhpcy5vbkZpcnN0UmVuZGVyID0gdGhpcy5vbkZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldyA9IG5ldyBQcm92aWRlclZpZXdzKHRoaXMsIHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcudGVhckRvd24oKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvbkZpcnN0UmVuZGVyICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wcm92aWRlci5mZXRjaFByZUF1dGhUb2tlbigpLFxuICAgICAgdGhpcy52aWV3LmdldEZvbGRlcigpLFxuICAgIF0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdzOiB7XG4gICAgcGx1Z2luTmFtZU9uZURyaXZlOiAnT25lRHJpdmUnLFxuICB9LFxufVxuIiwiY29uc3QgeyBoLCBGcmFnbWVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3QgQnJlYWRjcnVtYiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGdldEZvbGRlciwgdGl0bGUsIGlzTGFzdCB9ID0gcHJvcHNcblxuICByZXR1cm4gKFxuICAgIDxGcmFnbWVudD5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldFwiXG4gICAgICAgIG9uQ2xpY2s9e2dldEZvbGRlcn1cbiAgICAgID5cbiAgICAgICAge3RpdGxlfVxuICAgICAgPC9idXR0b24+XG4gICAgICB7IWlzTGFzdCA/ICcgLyAnIDogJyd9XG4gICAgPC9GcmFnbWVudD5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGdldEZvbGRlciwgdGl0bGUsIGJyZWFkY3J1bWJzSWNvbiwgZGlyZWN0b3JpZXMgfSA9IHByb3BzXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYnJlYWRjcnVtYnNcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1icmVhZGNydW1ic0ljb25cIj57YnJlYWRjcnVtYnNJY29ufTwvZGl2PlxuICAgICAge1xuICAgICAgICBkaXJlY3Rvcmllcy5tYXAoKGRpcmVjdG9yeSwgaSkgPT4gKFxuICAgICAgICAgIDxCcmVhZGNydW1iXG4gICAgICAgICAgICBrZXk9e2RpcmVjdG9yeS5pZH1cbiAgICAgICAgICAgIGdldEZvbGRlcj17KCkgPT4gZ2V0Rm9sZGVyKGRpcmVjdG9yeS5pZCl9XG4gICAgICAgICAgICB0aXRsZT17aSA9PT0gMCA/IHRpdGxlIDogZGlyZWN0b3J5LnRpdGxlfVxuICAgICAgICAgICAgaXNMYXN0PXtpICsgMSA9PT0gZGlyZWN0b3JpZXMubGVuZ3RofVxuICAgICAgICAgIC8+XG4gICAgICAgICkpXG4gICAgICB9XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcblxuY29uc3QgcmVtb3RlRmlsZU9ialRvTG9jYWwgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcmVtb3RlRmlsZU9ialRvTG9jYWwnKVxuXG5jb25zdCBGaWx0ZXIgPSByZXF1aXJlKCcuL0ZpbHRlcicpXG5jb25zdCBGb290ZXJBY3Rpb25zID0gcmVxdWlyZSgnLi9Gb290ZXJBY3Rpb25zJylcbmNvbnN0IEl0ZW0gPSByZXF1aXJlKCcuL0l0ZW0vaW5kZXgnKVxuXG5jb25zdCBWSVJUVUFMX1NIQVJFRF9ESVIgPSAnc2hhcmVkLXdpdGgtbWUnXG5cbmZ1bmN0aW9uIEJyb3dzZXIgKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50U2VsZWN0aW9uLFxuICAgIGZvbGRlcnMsXG4gICAgZmlsZXMsXG4gICAgdXBweUZpbGVzLFxuICAgIHZpZXdUeXBlLFxuICAgIGhlYWRlckNvbXBvbmVudCxcbiAgICBzaG93QnJlYWRjcnVtYnMsXG4gICAgaXNDaGVja2VkLFxuICAgIHRvZ2dsZUNoZWNrYm94LFxuICAgIGhhbmRsZVNjcm9sbCxcbiAgICBzaG93VGl0bGVzLFxuICAgIGkxOG4sXG4gICAgdmFsaWRhdGVSZXN0cmljdGlvbnMsXG4gICAgc2hvd0ZpbHRlcixcbiAgICBmaWx0ZXJRdWVyeSxcbiAgICBmaWx0ZXJJbnB1dCxcbiAgICBnZXROZXh0Rm9sZGVyLFxuICAgIGNhbmNlbCxcbiAgICBkb25lLFxuICAgIGNvbHVtbnMsXG4gIH0gPSBwcm9wc1xuXG4gIGNvbnN0IHNlbGVjdGVkID0gY3VycmVudFNlbGVjdGlvbi5sZW5ndGhcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgJ3VwcHktUHJvdmlkZXJCcm93c2VyJyxcbiAgICAgICAgYHVwcHktUHJvdmlkZXJCcm93c2VyLXZpZXdUeXBlLS0ke3ZpZXdUeXBlfWAsXG4gICAgICApfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItaGVhZGVyXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAndXBweS1Qcm92aWRlckJyb3dzZXItaGVhZGVyQmFyJyxcbiAgICAgICAgICAgICFzaG93QnJlYWRjcnVtYnMgJiYgJ3VwcHktUHJvdmlkZXJCcm93c2VyLWhlYWRlckJhci0tc2ltcGxlJyxcbiAgICAgICAgICApfVxuICAgICAgICA+XG4gICAgICAgICAge2hlYWRlckNvbXBvbmVudH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAge3Nob3dGaWx0ZXIgJiYgKFxuICAgICAgICA8RmlsdGVyXG4gICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICBmaWx0ZXJRdWVyeT17ZmlsdGVyUXVlcnl9XG4gICAgICAgICAgZmlsdGVySW5wdXQ9e2ZpbHRlcklucHV0fVxuICAgICAgICAvPlxuICAgICAgKX1cblxuICAgICAgeygoKSA9PiB7XG4gICAgICAgIGlmICghZm9sZGVycy5sZW5ndGggJiYgIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItZW1wdHlcIj5cbiAgICAgICAgICAgICAge3Byb3BzLmkxOG4oJ25vRmlsZXNGb3VuZCcpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJCcm93c2VyLWJvZHlcIj5cbiAgICAgICAgICAgIDx1bFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1saXN0XCJcbiAgICAgICAgICAgICAgb25TY3JvbGw9e2hhbmRsZVNjcm9sbH1cbiAgICAgICAgICAgICAgcm9sZT1cImxpc3Rib3hcIlxuICAgICAgICAgICAgICAvLyBtYWtpbmcgPHVsPiBub3QgZm9jdXNhYmxlIGZvciBmaXJlZm94XG4gICAgICAgICAgICAgIHRhYkluZGV4PVwiLTFcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7Zm9sZGVycy5tYXAoKGZvbGRlcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBJdGVtKHtcbiAgICAgICAgICAgICAgICAgIGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICBzaG93VGl0bGVzLFxuICAgICAgICAgICAgICAgICAgdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICBpMThuLFxuICAgICAgICAgICAgICAgICAgaWQ6IGZvbGRlci5pZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBmb2xkZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgIGdldEl0ZW1JY29uOiAoKSA9PiBmb2xkZXIuaWNvbixcbiAgICAgICAgICAgICAgICAgIGlzQ2hlY2tlZDogaXNDaGVja2VkKGZvbGRlciksXG4gICAgICAgICAgICAgICAgICB0b2dnbGVDaGVja2JveDogKGV2ZW50KSA9PiB0b2dnbGVDaGVja2JveChldmVudCwgZm9sZGVyKSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb2xkZXInLFxuICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogaXNDaGVja2VkKGZvbGRlcik/LmxvYWRpbmcsXG4gICAgICAgICAgICAgICAgICBpc0NoZWNrYm94RGlzYWJsZWQ6IGZvbGRlci5pZCA9PT0gVklSVFVBTF9TSEFSRURfRElSLFxuICAgICAgICAgICAgICAgICAgaGFuZGxlRm9sZGVyQ2xpY2s6ICgpID0+IGdldE5leHRGb2xkZXIoZm9sZGVyKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KX1cblxuICAgICAgICAgICAgICB7ZmlsZXMubWFwKChmaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVkID0gdmFsaWRhdGVSZXN0cmljdGlvbnMoXG4gICAgICAgICAgICAgICAgICByZW1vdGVGaWxlT2JqVG9Mb2NhbChmaWxlKSxcbiAgICAgICAgICAgICAgICAgIFsuLi51cHB5RmlsZXMsIC4uLmN1cnJlbnRTZWxlY3Rpb25dLFxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIHJldHVybiBJdGVtKHtcbiAgICAgICAgICAgICAgICAgIGlkOiBmaWxlLmlkLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICAgIGF1dGhvcjogZmlsZS5hdXRob3IsXG4gICAgICAgICAgICAgICAgICBnZXRJdGVtSWNvbjogKCkgPT4gZmlsZS5pY29uLFxuICAgICAgICAgICAgICAgICAgaXNDaGVja2VkOiBpc0NoZWNrZWQoZmlsZSksXG4gICAgICAgICAgICAgICAgICB0b2dnbGVDaGVja2JveDogKGV2ZW50KSA9PiB0b2dnbGVDaGVja2JveChldmVudCwgZmlsZSksXG4gICAgICAgICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgc2hvd1RpdGxlcyxcbiAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgaTE4bixcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6ICF2YWxpZGF0ZWQucmVzdWx0ICYmICFpc0NoZWNrZWQoZmlsZSksXG4gICAgICAgICAgICAgICAgICByZXN0cmljdGlvblJlYXNvbjogdmFsaWRhdGVkLnJlYXNvbixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICAgIH0pKCl9XG5cbiAgICAgIHtzZWxlY3RlZCA+IDAgJiYgKFxuICAgICAgICA8Rm9vdGVyQWN0aW9uc1xuICAgICAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cbiAgICAgICAgICBkb25lPXtkb25lfVxuICAgICAgICAgIGNhbmNlbD17Y2FuY2VsfVxuICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclxuIiwiY29uc3QgeyBDb21wb25lbnQsIHRvQ2hpbGRBcnJheSB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDbG9zZVdyYXBwZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgY29uc3QgeyBvblVubW91bnQgfSA9IHRoaXMucHJvcHNcbiAgICBvblVubW91bnQoKVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG4gICAgcmV0dXJuIHRvQ2hpbGRBcnJheShjaGlsZHJlbilbMF1cbiAgfVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5wcmV2ZW50RW50ZXJQcmVzcyA9IHRoaXMucHJldmVudEVudGVyUHJlc3MuYmluZCh0aGlzKVxuICB9XG5cbiAgcHJldmVudEVudGVyUHJlc3MgKGV2KSB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItc2VhcmNoXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlci1zZWFyY2hJbnB1dFwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPXt0aGlzLnByb3BzLmkxOG4oJ2ZpbHRlcicpfVxuICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bignZmlsdGVyJyl9XG4gICAgICAgICAgb25LZXlVcD17dGhpcy5wcmV2ZW50RW50ZXJQcmVzc31cbiAgICAgICAgICBvbktleURvd249e3RoaXMucHJldmVudEVudGVyUHJlc3N9XG4gICAgICAgICAgb25LZXlQcmVzcz17dGhpcy5wcmV2ZW50RW50ZXJQcmVzc31cbiAgICAgICAgICBvbklucHV0PXsoZSkgPT4gdGhpcy5wcm9wcy5maWx0ZXJRdWVyeShlKX1cbiAgICAgICAgICB2YWx1ZT17dGhpcy5wcm9wcy5maWx0ZXJJbnB1dH1cbiAgICAgICAgLz5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uIHVwcHktUHJvdmlkZXJCcm93c2VyLXNlYXJjaEljb25cIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMTJcIiB2aWV3Qm94PVwiMCAwIDEyIDEyXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk04LjYzOCA3Ljk5bDMuMTcyIDMuMTcyYS40OTIuNDkyIDAgMSAxLS42OTcuNjk3TDcuOTEgOC42NTZhNC45NzcgNC45NzcgMCAwIDEtMi45ODMuOTgzQzIuMjA2IDkuNjM5IDAgNy40ODEgMCA0LjgxOSAwIDIuMTU4IDIuMjA2IDAgNC45MjcgMGMyLjcyMSAwIDQuOTI3IDIuMTU4IDQuOTI3IDQuODJhNC43NCA0Ljc0IDAgMCAxLTEuMjE2IDMuMTd6bS0zLjcxLjY4NWMyLjE3NiAwIDMuOTQtMS43MjYgMy45NC0zLjg1NiAwLTIuMTI5LTEuNzY0LTMuODU1LTMuOTQtMy44NTVDMi43NS45NjQuOTg0IDIuNjkuOTg0IDQuODE5YzAgMi4xMyAxLjc2NSAzLjg1NiAzLjk0MiAzLjg1NnpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAge3RoaXMucHJvcHMuZmlsdGVySW5wdXQgJiYgKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlci1zZWFyY2hDbG9zZVwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bigncmVzZXRGaWx0ZXInKX1cbiAgICAgICAgICAgIHRpdGxlPXt0aGlzLnByb3BzLmkxOG4oJ3Jlc2V0RmlsdGVyJyl9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLmZpbHRlclF1ZXJ5fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHZpZXdCb3g9XCIwIDAgMTkgMTlcIj5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0xNy4zMTggMTcuMjMyTDkuOTQgOS44NTQgOS41ODYgOS41bC0uMzU0LjM1NC03LjM3OCA3LjM3OGguNzA3bC0uNjItLjYydi43MDZMOS4zMTggOS45NGwuMzU0LS4zNTQtLjM1NC0uMzU0TDEuOTQgMS44NTR2LjcwN2wuNjItLjYyaC0uNzA2bDcuMzc4IDcuMzc4LjM1NC4zNTQuMzU0LS4zNTQgNy4zNzgtNy4zNzhoLS43MDdsLjYyMi42MnYtLjcwNkw5Ljg1NCA5LjIzMmwtLjM1NC4zNTQuMzU0LjM1NCA3LjM3OCA3LjM3OC43MDgtLjcwNy03LjM4LTcuMzc4di43MDhsNy4zOC03LjM4LjM1My0uMzUzLS4zNTMtLjM1My0uNjIyLS42MjItLjM1My0uMzUzLS4zNTQuMzUyLTcuMzc4IDcuMzhoLjcwOEwyLjU2IDEuMjMgMi4yMDguODhsLS4zNTMuMzUzLS42MjIuNjItLjM1My4zNTUuMzUyLjM1MyA3LjM4IDcuMzh2LS43MDhsLTcuMzggNy4zOC0uMzUzLjM1My4zNTIuMzUzLjYyMi42MjIuMzUzLjM1My4zNTQtLjM1MyA3LjM4LTcuMzhoLS43MDhsNy4zOCA3LjM4elwiIC8+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItZm9vdGVyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeVwiIG9uQ2xpY2s9e3Byb3BzLmRvbmV9IHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAge3Byb3BzLmkxOG4oJ3NlbGVjdFgnLCB7XG4gICAgICAgICAgc21hcnRfY291bnQ6IHByb3BzLnNlbGVjdGVkLFxuICAgICAgICB9KX1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLWxpbmtcIiBvbkNsaWNrPXtwcm9wcy5jYW5jZWx9IHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAge3Byb3BzLmkxOG4oJ2NhbmNlbCcpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gR3JpZExpc3RJdGVtIChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2xhc3NOYW1lLFxuICAgIGlzRGlzYWJsZWQsXG4gICAgcmVzdHJpY3Rpb25SZWFzb24sXG4gICAgaXNDaGVja2VkLFxuICAgIHRpdGxlLFxuICAgIGl0ZW1JY29uRWwsXG4gICAgc2hvd1RpdGxlcyxcbiAgICB0b2dnbGVDaGVja2JveCxcbiAgICBpZCxcbiAgICBjaGlsZHJlbixcbiAgfSA9IHByb3BzXG5cbiAgcmV0dXJuIChcbiAgICA8bGlcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgdGl0bGU9e2lzRGlzYWJsZWQgPyByZXN0cmljdGlvblJlYXNvbiA6IG51bGx9XG4gICAgPlxuICAgICAgPGlucHV0XG4gICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIGNsYXNzTmFtZT17YHVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tY2hlY2tib3ggJHtcbiAgICAgICAgICBpc0NoZWNrZWQgPyAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWNoZWNrYm94LS1pcy1jaGVja2VkJyA6ICcnXG4gICAgICAgIH0gdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWNoZWNrYm94LS1ncmlkYH1cbiAgICAgICAgb25DaGFuZ2U9e3RvZ2dsZUNoZWNrYm94fVxuICAgICAgICBuYW1lPVwibGlzdGl0ZW1cIlxuICAgICAgICBpZD17aWR9XG4gICAgICAgIGNoZWNrZWQ9e2lzQ2hlY2tlZH1cbiAgICAgICAgZGlzYWJsZWQ9e2lzRGlzYWJsZWR9XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgIC8+XG4gICAgICA8bGFiZWxcbiAgICAgICAgaHRtbEZvcj17aWR9XG4gICAgICAgIGFyaWEtbGFiZWw9e3RpdGxlfVxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWlubmVyXCJcbiAgICAgID5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWlubmVyLXJlbGF0aXZlXCI+XG4gICAgICAgICAge2l0ZW1JY29uRWx9XG5cbiAgICAgICAgICB7c2hvd1RpdGxlcyAmJiB0aXRsZX1cblxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9sYWJlbD5cbiAgICA8L2xpPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZExpc3RJdGVtXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmZ1bmN0aW9uIEZpbGVJY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD17MTF9IGhlaWdodD17MTQuNX0gdmlld0JveD1cIjAgMCA0NCA1OFwiPlxuICAgICAgPHBhdGggZD1cIk0yNy40MzcuNTE3YTEgMSAwIDAgMC0uMDk0LjAzSDQuMjVDMi4wMzcuNTQ4LjIxNyAyLjM2OC4yMTcgNC41OHY0OC40MDVjMCAyLjIxMiAxLjgyIDQuMDMgNC4wMyA0LjAzSDM5LjAzYzIuMjEgMCA0LjAzLTEuODE4IDQuMDMtNC4wM1YxNS42MWExIDEgMCAwIDAtLjAzLS4yOCAxIDEgMCAwIDAgMC0uMDkzIDEgMSAwIDAgMC0uMDMtLjAzMiAxIDEgMCAwIDAgMC0uMDMgMSAxIDAgMCAwLS4wMzItLjA2MyAxIDEgMCAwIDAtLjAzLS4wNjMgMSAxIDAgMCAwLS4wMzIgMCAxIDEgMCAwIDAtLjAzLS4wNjMgMSAxIDAgMCAwLS4wMzItLjAzIDEgMSAwIDAgMC0uMDMtLjA2MyAxIDEgMCAwIDAtLjA2My0uMDYybC0xNC41OTMtMTRhMSAxIDAgMCAwLS4wNjItLjA2MkExIDEgMCAwIDAgMjggLjcwOGExIDEgMCAwIDAtLjM3NC0uMTU3IDEgMSAwIDAgMC0uMTU2IDAgMSAxIDAgMCAwLS4wMy0uMDNsLS4wMDMtLjAwM3pNNC4yNSAyLjU0N2gyMi4yMTh2OS45N2MwIDIuMjEgMS44MiA0LjAzIDQuMDMgNC4wM2gxMC41NjR2MzYuNDM4YTIuMDIgMi4wMiAwIDAgMS0yLjAzMiAyLjAzMkg0LjI1Yy0xLjEzIDAtMi4wMzItLjktMi4wMzItMi4wMzJWNC41OGMwLTEuMTMuOTAyLTIuMDMyIDIuMDMtMi4wMzJ6bTI0LjIxOCAxLjM0NWwxMC4zNzUgOS45MzcuNzUuNzE4SDMwLjVjLTEuMTMgMC0yLjAzMi0uOS0yLjAzMi0yLjAzVjMuODl6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBGb2xkZXJJY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiBzdHlsZT17eyBtaW5XaWR0aDogMTYsIG1hcmdpblJpZ2h0OiAzIH19IHZpZXdCb3g9XCIwIDAgMjc2LjE1NyAyNzYuMTU3XCI+XG4gICAgICA8cGF0aCBkPVwiTTI3My4wOCAxMDEuMzc4Yy0zLjMtNC42NS04Ljg2LTcuMzItMTUuMjU0LTcuMzJoLTI0LjM0VjY3LjU5YzAtMTAuMi04LjMtMTguNS0xOC41LTE4LjVoLTg1LjMyMmMtMy42MyAwLTkuMjk1LTIuODc1LTExLjQzNi01LjgwNWwtNi4zODYtOC43MzVjLTQuOTgyLTYuODE0LTE1LjEwNC0xMS45NTQtMjMuNTQ2LTExLjk1NEg1OC43M2MtOS4yOTIgMC0xOC42MzggNi42MDgtMjEuNzM3IDE1LjM3MmwtMi4wMzMgNS43NTJjLS45NTggMi43MS00LjcyIDUuMzctNy41OTYgNS4zN0gxOC41QzguMyA0OS4wOSAwIDU3LjM5IDAgNjcuNTl2MTY3LjA3YzAgLjg4Ni4xNiAxLjczLjQ0MyAyLjUyLjE1MiAzLjMwNiAxLjE4IDYuNDI0IDMuMDUzIDkuMDY0IDMuMyA0LjY1MiA4Ljg2IDcuMzIgMTUuMjU1IDcuMzJoMTg4LjQ4N2MxMS4zOTUgMCAyMy4yNy04LjQyNSAyNy4wMzUtMTkuMThsNDAuNjc3LTExNi4xODhjMi4xMS02LjAzNSAxLjQzLTEyLjE2NC0xLjg3LTE2LjgxNnpNMTguNSA2NC4wODhoOC44NjRjOS4yOTUgMCAxOC42NC02LjYwNyAyMS43MzgtMTUuMzdsMi4wMzItNS43NWMuOTYtMi43MTIgNC43MjItNS4zNzMgNy41OTctNS4zNzNoMjkuNTY1YzMuNjMgMCA5LjI5NSAyLjg3NiAxMS40MzcgNS44MDZsNi4zODYgOC43MzVjNC45ODIgNi44MTUgMTUuMTA0IDExLjk1NCAyMy41NDYgMTEuOTU0aDg1LjMyMmMxLjg5OCAwIDMuNSAxLjYwMiAzLjUgMy41djI2LjQ3SDY5LjM0Yy0xMS4zOTUgMC0yMy4yNyA4LjQyMy0yNy4wMzUgMTkuMTc4TDE1IDE5MS4yM1Y2Ny41OWMwLTEuODk4IDEuNjAzLTMuNSAzLjUtMy41em0yNDIuMjkgNDkuMTVsLTQwLjY3NiAxMTYuMTg4Yy0xLjY3NCA0Ljc4LTcuODEyIDkuMTM1LTEyLjg3NyA5LjEzNUgxOC43NWMtMS40NDcgMC0yLjU3Ni0uMzcyLTMuMDItLjk5Ny0uNDQyLS42MjUtLjQyMi0xLjgxNC4wNTctMy4xOGw0MC42NzctMTE2LjE5YzEuNjc0LTQuNzggNy44MTItOS4xMzQgMTIuODc3LTkuMTM0aDE4OC40ODdjMS40NDggMCAyLjU3Ny4zNzIgMy4wMi45OTcuNDQzLjYyNS40MjMgMS44MTQtLjA1NiAzLjE4elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gVmlkZW9JY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgc3R5bGU9e3sgd2lkdGg6IDE2LCBtYXJnaW5SaWdodDogNCB9fSB2aWV3Qm94PVwiMCAwIDU4IDU4XCI+XG4gICAgICA8cGF0aCBkPVwiTTM2LjUzNyAyOC4xNTZsLTExLTdhMS4wMDUgMS4wMDUgMCAwIDAtMS4wMi0uMDMzQzI0LjIgMjEuMyAyNCAyMS42MzUgMjQgMjJ2MTRhMSAxIDAgMCAwIDEuNTM3Ljg0NGwxMS03YTEuMDAyIDEuMDAyIDAgMCAwIDAtMS42ODh6TTI2IDM0LjE4VjIzLjgyTDM0LjEzNyAyOSAyNiAzNC4xOHpcIiAvPlxuICAgICAgPHBhdGggZD1cIk01NyA2SDFhMSAxIDAgMCAwLTEgMXY0NGExIDEgMCAwIDAgMSAxaDU2YTEgMSAwIDAgMCAxLTFWN2ExIDEgMCAwIDAtMS0xek0xMCAyOEgydi05aDh2OXptLTggMmg4djlIMnYtOXptMTAgMTBWOGgzNHY0MkgxMlY0MHptNDQtMTJoLTh2LTloOHY5em0tOCAyaDh2OWgtOHYtOXptOC0yMnY5aC04VjhoOHpNMiA4aDh2OUgyVjh6bTAgNDJ2LTloOHY5SDJ6bTU0IDBoLTh2LTloOHY5elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzLml0ZW1JY29uU3RyaW5nID09PSBudWxsKSByZXR1cm5cblxuICBzd2l0Y2ggKHByb3BzLml0ZW1JY29uU3RyaW5nKSB7XG4gICAgY2FzZSAnZmlsZSc6XG4gICAgICByZXR1cm4gPEZpbGVJY29uIC8+XG4gICAgY2FzZSAnZm9sZGVyJzpcbiAgICAgIHJldHVybiA8Rm9sZGVySWNvbiAvPlxuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgIHJldHVybiA8VmlkZW9JY29uIC8+XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiA8aW1nIHNyYz17cHJvcHMuaXRlbUljb25TdHJpbmd9IGFsdD17cHJvcHMuYWx0fSAvPlxuICB9XG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbi8vIGlmIGZvbGRlcjpcbi8vICAgKyBjaGVja2JveCAoc2VsZWN0cyBhbGwgZmlsZXMgZnJvbSBmb2xkZXIpXG4vLyAgICsgZm9sZGVyIG5hbWUgKG9wZW5zIGZvbGRlcilcbi8vIGlmIGZpbGU6XG4vLyAgICsgY2hlY2tib3ggKHNlbGVjdHMgZmlsZSlcbi8vICAgKyBmaWxlIG5hbWUgKHNlbGVjdHMgZmlsZSlcblxuZnVuY3Rpb24gTGlzdEl0ZW0gKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc05hbWUsXG4gICAgaXNEaXNhYmxlZCxcbiAgICByZXN0cmljdGlvblJlYXNvbixcbiAgICBpc0NoZWNrYm94RGlzYWJsZWQsXG4gICAgaXNDaGVja2VkLFxuICAgIHRvZ2dsZUNoZWNrYm94LFxuICAgIHR5cGUsXG4gICAgaWQsXG4gICAgaXRlbUljb25FbCxcbiAgICB0aXRsZSxcbiAgICBoYW5kbGVGb2xkZXJDbGljayxcbiAgICBzaG93VGl0bGVzLFxuICAgIGkxOG4sXG4gIH0gPSBwcm9wc1xuXG4gIHJldHVybiAoXG4gICAgPGxpXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgIHRpdGxlPXtpc0Rpc2FibGVkID8gcmVzdHJpY3Rpb25SZWFzb24gOiBudWxsfVxuICAgID5cbiAgICAgIHshaXNDaGVja2JveERpc2FibGVkID8gKFxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgIGNsYXNzTmFtZT17YHVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tY2hlY2tib3ggJHtpc0NoZWNrZWQgPyAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWNoZWNrYm94LS1pcy1jaGVja2VkJyA6ICcnfWB9XG4gICAgICAgICAgb25DaGFuZ2U9e3RvZ2dsZUNoZWNrYm94fVxuICAgICAgICAgIC8vIGZvciB0aGUgPGxhYmVsLz5cbiAgICAgICAgICBuYW1lPVwibGlzdGl0ZW1cIlxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBjaGVja2VkPXtpc0NoZWNrZWR9XG4gICAgICAgICAgYXJpYS1sYWJlbD17dHlwZSA9PT0gJ2ZpbGUnID8gbnVsbCA6IGkxOG4oJ2FsbEZpbGVzRnJvbUZvbGRlck5hbWVkJywgeyBuYW1lOiB0aXRsZSB9KX1cbiAgICAgICAgICBkaXNhYmxlZD17aXNEaXNhYmxlZH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgIC8+XG4gICAgICApIDogbnVsbH1cblxuICAgICAge3R5cGUgPT09ICdmaWxlJyA/IChcbiAgICAgICAgLy8gbGFiZWwgZm9yIGEgY2hlY2tib3hcbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgaHRtbEZvcj17aWR9XG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pbm5lclwiXG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pY29uV3JhcFwiPlxuICAgICAgICAgICAge2l0ZW1JY29uRWx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3Nob3dUaXRsZXMgJiYgdGl0bGV9XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICApIDogKFxuICAgICAgICAvLyBidXR0b24gdG8gb3BlbiBhIGZvbGRlclxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pbm5lclwiXG4gICAgICAgICAgb25DbGljaz17aGFuZGxlRm9sZGVyQ2xpY2t9XG4gICAgICAgICAgYXJpYS1sYWJlbD17aTE4bignb3BlbkZvbGRlck5hbWVkJywgeyBuYW1lOiB0aXRsZSB9KX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWljb25XcmFwXCI+XG4gICAgICAgICAgICB7aXRlbUljb25FbH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7c2hvd1RpdGxlcyAmJiA8c3Bhbj57dGl0bGV9PC9zcGFuPn1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApfVxuICAgIDwvbGk+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0SXRlbVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3QgSXRlbUljb24gPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvSXRlbUljb24nKVxuY29uc3QgR3JpZExpc3RJdGVtID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0dyaWRMaScpXG5jb25zdCBMaXN0SXRlbSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9MaXN0TGknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGF1dGhvciB9ID0gcHJvcHNcbiAgY29uc3QgaXRlbUljb25TdHJpbmcgPSBwcm9wcy5nZXRJdGVtSWNvbigpXG5cbiAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NOYW1lcyhcbiAgICAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtJyxcbiAgICB7ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tLXNlbGVjdGVkJzogcHJvcHMuaXNDaGVja2VkIH0sXG4gICAgeyAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLS1kaXNhYmxlZCc6IHByb3BzLmlzRGlzYWJsZWQgfSxcbiAgICB7ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tLW5vUHJldmlldyc6IGl0ZW1JY29uU3RyaW5nID09PSAndmlkZW8nIH0sXG4gIClcblxuICBjb25zdCBpdGVtSWNvbkVsID0gPEl0ZW1JY29uIGl0ZW1JY29uU3RyaW5nPXtpdGVtSWNvblN0cmluZ30gLz5cblxuICBzd2l0Y2ggKHByb3BzLnZpZXdUeXBlKSB7XG4gICAgY2FzZSAnZ3JpZCc6XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8R3JpZExpc3RJdGVtXG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgIGl0ZW1JY29uRWw9e2l0ZW1JY29uRWx9XG4gICAgICAgIC8+XG4gICAgICApXG4gICAgY2FzZSAnbGlzdCc6XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8TGlzdEl0ZW0gey4uLnByb3BzfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gaXRlbUljb25FbD17aXRlbUljb25FbH0gLz5cbiAgICAgIClcbiAgICBjYXNlICd1bnNwbGFzaCc6XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8R3JpZExpc3RJdGVtIHsuLi5wcm9wc30gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGl0ZW1JY29uRWw9e2l0ZW1JY29uRWx9PlxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBocmVmPXtgJHthdXRob3IudXJsfT91dG1fc291cmNlPUNvbXBhbmlvbiZ1dG1fbWVkaXVtPXJlZmVycmFsYH1cbiAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1hdXRob3JcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHthdXRob3IubmFtZX1cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvR3JpZExpc3RJdGVtPlxuICAgICAgKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIG5vIHN1Y2ggdHlwZSAke3Byb3BzLnZpZXdUeXBlfWApXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItbG9hZGluZ1wiPlxuICAgICAgPHNwYW4+e3Byb3BzLmkxOG4oJ2xvYWRpbmcnKX08L3NwYW4+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gR29vZ2xlSWNvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgd2lkdGg9XCIyNlwiXG4gICAgICBoZWlnaHQ9XCIyNlwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDI2IDI2XCJcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgID5cbiAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjRkZGXCIgY3g9XCIxM1wiIGN5PVwiMTNcIiByPVwiMTNcIiAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9XCJNMjEuNjQgMTMuMjA1YzAtLjYzOS0uMDU3LTEuMjUyLS4xNjQtMS44NDFIMTN2My40ODFoNC44NDRhNC4xNCA0LjE0IDAgMDEtMS43OTYgMi43MTZ2Mi4yNTloMi45MDhjMS43MDItMS41NjcgMi42ODQtMy44NzUgMi42ODQtNi42MTV6XCJcbiAgICAgICAgICBmaWxsPVwiIzQyODVGNFwiXG4gICAgICAgICAgZmlsbC1ydWxlPVwibm9uemVyb1wiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIk0xMyAyMmMyLjQzIDAgNC40NjctLjgwNiA1Ljk1Ni0yLjE4bC0yLjkwOC0yLjI1OWMtLjgwNi41NC0xLjgzNy44Ni0zLjA0OC44Ni0yLjM0NCAwLTQuMzI4LTEuNTg0LTUuMDM2LTMuNzExSDQuOTU3djIuMzMyQTguOTk3IDguOTk3IDAgMDAxMyAyMnpcIlxuICAgICAgICAgIGZpbGw9XCIjMzRBODUzXCJcbiAgICAgICAgICBmaWxsLXJ1bGU9XCJub256ZXJvXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTcuOTY0IDE0LjcxQTUuNDEgNS40MSAwIDAxNy42ODIgMTNjMC0uNTkzLjEwMi0xLjE3LjI4Mi0xLjcxVjguOTU4SDQuOTU3QTguOTk2IDguOTk2IDAgMDA0IDEzYzAgMS40NTIuMzQ4IDIuODI3Ljk1NyA0LjA0MmwzLjAwNy0yLjMzMnpcIlxuICAgICAgICAgIGZpbGw9XCIjRkJCQzA1XCJcbiAgICAgICAgICBmaWxsLXJ1bGU9XCJub256ZXJvXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTEzIDcuNThjMS4zMjEgMCAyLjUwOC40NTQgMy40NCAxLjM0NWwyLjU4Mi0yLjU4QzE3LjQ2MyA0Ljg5MSAxNS40MjYgNCAxMyA0YTguOTk3IDguOTk3IDAgMDAtOC4wNDMgNC45NThsMy4wMDcgMi4zMzJDOC42NzIgOS4xNjMgMTAuNjU2IDcuNTggMTMgNy41OHpcIlxuICAgICAgICAgIGZpbGw9XCIjRUE0MzM1XCJcbiAgICAgICAgICBmaWxsLXJ1bGU9XCJub256ZXJvXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGggZD1cIk00IDRoMTh2MThINHpcIiAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIEF1dGhWaWV3IChwcm9wcykge1xuICBjb25zdCB7IHBsdWdpbk5hbWUsIHBsdWdpbkljb24sIGkxOG5BcnJheSwgaGFuZGxlQXV0aCB9ID0gcHJvcHNcbiAgLy8gSW4gb3JkZXIgdG8gY29tcGx5IHdpdGggR29vZ2xlJ3MgYnJhbmQgd2UgbmVlZCB0byBjcmVhdGUgYSBkaWZmZXJlbnQgYnV0dG9uXG4gIC8vIGZvciB0aGUgR29vZ2xlIERyaXZlIHBsdWdpblxuICBjb25zdCBpc0dvb2dsZURyaXZlID0gcGx1Z2luTmFtZSA9PT0gJ0dvb2dsZSBEcml2ZSdcblxuICBjb25zdCBwbHVnaW5OYW1lQ29tcG9uZW50ID0gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYXV0aFRpdGxlTmFtZVwiPlxuICAgICAge3BsdWdpbk5hbWV9XG4gICAgICA8YnIgLz5cbiAgICA8L3NwYW4+XG4gIClcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYXV0aFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWF1dGhJY29uXCI+e3BsdWdpbkljb24oKX08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1hdXRoVGl0bGVcIj5cbiAgICAgICAge2kxOG5BcnJheSgnYXV0aGVudGljYXRlV2l0aFRpdGxlJywge1xuICAgICAgICAgIHBsdWdpbk5hbWU6IHBsdWdpbk5hbWVDb21wb25lbnQsXG4gICAgICAgIH0pfVxuICAgICAgPC9kaXY+XG4gICAgICB7aXNHb29nbGVEcml2ZSA/IChcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeSB1cHB5LVByb3ZpZGVyLWF1dGhCdG4gdXBweS1Qcm92aWRlci1idG4tZ29vZ2xlXCJcbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVBdXRofVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgPlxuICAgICAgICAgIDxHb29nbGVJY29uIC8+XG4gICAgICAgICAge2kxOG5BcnJheSgnc2lnbkluV2l0aEdvb2dsZScpfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICkgOiAoXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLXByaW1hcnkgdXBweS1Qcm92aWRlci1hdXRoQnRuXCJcbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVBdXRofVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgPlxuICAgICAgICAgIHtpMThuQXJyYXkoJ2F1dGhlbnRpY2F0ZVdpdGgnLCB7IHBsdWdpbk5hbWUgfSl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhWaWV3XG4iLCJjb25zdCBVc2VyID0gcmVxdWlyZSgnLi9Vc2VyJylcbmNvbnN0IEJyZWFkY3J1bWJzID0gcmVxdWlyZSgnLi4vQnJlYWRjcnVtYnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBjb21wb25lbnRzID0gW11cbiAgaWYgKHByb3BzLnNob3dCcmVhZGNydW1icykge1xuICAgIGNvbXBvbmVudHMucHVzaChCcmVhZGNydW1icyh7XG4gICAgICBnZXRGb2xkZXI6IHByb3BzLmdldEZvbGRlcixcbiAgICAgIGRpcmVjdG9yaWVzOiBwcm9wcy5kaXJlY3RvcmllcyxcbiAgICAgIGJyZWFkY3J1bWJzSWNvbjogcHJvcHMucGx1Z2luSWNvbiAmJiBwcm9wcy5wbHVnaW5JY29uKCksXG4gICAgICB0aXRsZTogcHJvcHMudGl0bGUsXG4gICAgfSkpXG4gIH1cblxuICBjb21wb25lbnRzLnB1c2goVXNlcih7XG4gICAgbG9nb3V0OiBwcm9wcy5sb2dvdXQsXG4gICAgdXNlcm5hbWU6IHByb3BzLnVzZXJuYW1lLFxuICAgIGkxOG46IHByb3BzLmkxOG4sXG4gIH0pKVxuXG4gIHJldHVybiBjb21wb25lbnRzXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBBdXRoVmlldyA9IHJlcXVpcmUoJy4vQXV0aFZpZXcnKVxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9IZWFkZXInKVxuY29uc3QgQnJvd3NlciA9IHJlcXVpcmUoJy4uL0Jyb3dzZXInKVxuY29uc3QgTG9hZGVyVmlldyA9IHJlcXVpcmUoJy4uL0xvYWRlcicpXG5jb25zdCBDbG9zZVdyYXBwZXIgPSByZXF1aXJlKCcuLi9DbG9zZVdyYXBwZXInKVxuY29uc3QgVmlldyA9IHJlcXVpcmUoJy4uL1ZpZXcnKVxuXG5mdW5jdGlvbiBnZXRPcmlnaW4gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gIHJldHVybiBsb2NhdGlvbi5vcmlnaW5cbn1cblxuLyoqXG4gKiBDbGFzcyB0byBlYXNpbHkgZ2VuZXJhdGUgZ2VuZXJpYyB2aWV3cyBmb3IgUHJvdmlkZXIgcGx1Z2luc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFByb3ZpZGVyVmlldyBleHRlbmRzIFZpZXcge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbiBpbnN0YW5jZSBvZiB0aGUgcGx1Z2luXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocGx1Z2luLCBvcHRzKSB7XG4gICAgc3VwZXIocGx1Z2luLCBvcHRzKVxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHZpZXdUeXBlOiAnbGlzdCcsXG4gICAgICBzaG93VGl0bGVzOiB0cnVlLFxuICAgICAgc2hvd0ZpbHRlcjogdHJ1ZSxcbiAgICAgIHNob3dCcmVhZGNydW1iczogdHJ1ZSxcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgLy8gTG9naWNcbiAgICB0aGlzLmZpbHRlclF1ZXJ5ID0gdGhpcy5maWx0ZXJRdWVyeS5iaW5kKHRoaXMpXG4gICAgdGhpcy5nZXRGb2xkZXIgPSB0aGlzLmdldEZvbGRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5nZXROZXh0Rm9sZGVyID0gdGhpcy5nZXROZXh0Rm9sZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLmxvZ291dCA9IHRoaXMubG9nb3V0LmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUF1dGggPSB0aGlzLmhhbmRsZUF1dGguYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gdGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKVxuICAgIHRoaXMubGlzdEFsbEZpbGVzID0gdGhpcy5saXN0QWxsRmlsZXMuYmluZCh0aGlzKVxuICAgIHRoaXMuZG9uZVBpY2tpbmcgPSB0aGlzLmRvbmVQaWNraW5nLmJpbmQodGhpcylcblxuICAgIC8vIFZpc3VhbFxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLy8gU2V0IGRlZmF1bHQgc3RhdGUgZm9yIHRoZSBwbHVnaW5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgIGZpbGVzOiBbXSxcbiAgICAgIGZvbGRlcnM6IFtdLFxuICAgICAgZGlyZWN0b3JpZXM6IFtdLFxuICAgICAgZmlsdGVySW5wdXQ6ICcnLFxuICAgICAgaXNTZWFyY2hWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGN1cnJlbnRTZWxlY3Rpb246IFtdLFxuICAgIH0pXG4gIH1cblxuICB0ZWFyRG93biAoKSB7XG4gICAgLy8gTm90aGluZy5cbiAgfVxuXG4gICN1cGRhdGVGaWxlc0FuZEZvbGRlcnMgKHJlcywgZmlsZXMsIGZvbGRlcnMpIHtcbiAgICB0aGlzLm5leHRQYWdlUGF0aCA9IHJlcy5uZXh0UGFnZVBhdGhcbiAgICByZXMuaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uaXNGb2xkZXIpIHtcbiAgICAgICAgZm9sZGVycy5wdXNoKGl0ZW0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlcy5wdXNoKGl0ZW0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgZm9sZGVycywgZmlsZXMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiBmb2xkZXIgSUQsIGZldGNoIGEgbmV3IGZvbGRlciBhbmQgdXBkYXRlIGl0IHRvIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgRm9sZGVyIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSAgIEZvbGRlcnMvZmlsZXMgaW4gZm9sZGVyXG4gICAqL1xuICBnZXRGb2xkZXIgKGlkLCBuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhcmVkSGFuZGxlci5sb2FkZXJXcmFwcGVyKFxuICAgICAgdGhpcy5wcm92aWRlci5saXN0KGlkKSxcbiAgICAgIChyZXMpID0+IHtcbiAgICAgICAgY29uc3QgZm9sZGVycyA9IFtdXG4gICAgICAgIGNvbnN0IGZpbGVzID0gW11cbiAgICAgICAgbGV0IHVwZGF0ZWREaXJlY3Rvcmllc1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmRpcmVjdG9yaWVzLmZpbmRJbmRleCgoZGlyKSA9PiBpZCA9PT0gZGlyLmlkKVxuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB1cGRhdGVkRGlyZWN0b3JpZXMgPSBzdGF0ZS5kaXJlY3Rvcmllcy5zbGljZSgwLCBpbmRleCArIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlZERpcmVjdG9yaWVzID0gc3RhdGUuZGlyZWN0b3JpZXMuY29uY2F0KFt7IGlkLCB0aXRsZTogbmFtZSB9XSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSByZXMudXNlcm5hbWUgfHwgdGhpcy51c2VybmFtZVxuICAgICAgICB0aGlzLiN1cGRhdGVGaWxlc0FuZEZvbGRlcnMocmVzLCBmaWxlcywgZm9sZGVycylcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBkaXJlY3RvcmllczogdXBkYXRlZERpcmVjdG9yaWVzIH0pXG4gICAgICB9LFxuICAgICAgdGhpcy5oYW5kbGVFcnJvcixcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBuZXcgZm9sZGVyXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZm9sZGVyXG4gICAqL1xuICBnZXROZXh0Rm9sZGVyIChmb2xkZXIpIHtcbiAgICB0aGlzLmdldEZvbGRlcihmb2xkZXIucmVxdWVzdFBhdGgsIGZvbGRlci5uYW1lKVxuICAgIHRoaXMubGFzdENoZWNrYm94ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzZXNzaW9uIHRva2VuIG9uIGNsaWVudCBzaWRlLlxuICAgKi9cbiAgbG9nb3V0ICgpIHtcbiAgICB0aGlzLnByb3ZpZGVyLmxvZ291dCgpXG4gICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICBpZiAoIXJlcy5yZXZva2VkKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5wbHVnaW4udXBweS5pMThuKCdjb21wYW5pb25VbmF1dGhvcml6ZUhpbnQnLCB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgICAgICAgICAgdXJsOiByZXMubWFudWFsX3Jldm9rZV91cmwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5wbHVnaW4udXBweS5pbmZvKG1lc3NhZ2UsICdpbmZvJywgNzAwMClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZmlsZXM6IFtdLFxuICAgICAgICAgICAgZm9sZGVyczogW10sXG4gICAgICAgICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKG5ld1N0YXRlKVxuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKVxuICB9XG5cbiAgZmlsdGVyUXVlcnkgKGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IC4uLnN0YXRlLCBmaWx0ZXJJbnB1dDogZSA/IGUudGFyZ2V0LnZhbHVlIDogJycgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFsbCBmaWxlcyBmb3VuZCBpbnNpZGUgb2Ygc3BlY2lmaWVkIGZvbGRlci5cbiAgICpcbiAgICogVXNlcyBzZXBhcmF0ZWQgc3RhdGUgd2hpbGUgZm9sZGVyIGNvbnRlbnRzIGFyZSBiZWluZyBmZXRjaGVkIGFuZFxuICAgKiBtYW50YWlucyBsaXN0IG9mIHNlbGVjdGVkIGZvbGRlcnMsIHdoaWNoIGFyZSBzZXBhcmF0ZWQgZnJvbSBmaWxlcy5cbiAgICovXG4gIGFkZEZvbGRlciAoZm9sZGVyKSB7XG4gICAgY29uc3QgZm9sZGVySWQgPSB0aGlzLnByb3ZpZGVyRmlsZVRvSWQoZm9sZGVyKVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGZvbGRlcnMgPSB7IC4uLnN0YXRlLnNlbGVjdGVkRm9sZGVycyB9XG5cbiAgICBpZiAoZm9sZGVySWQgaW4gZm9sZGVycyAmJiBmb2xkZXJzW2ZvbGRlcklkXS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmb2xkZXJzW2ZvbGRlcklkXSA9IHsgbG9hZGluZzogdHJ1ZSwgZmlsZXM6IFtdIH1cblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgc2VsZWN0ZWRGb2xkZXJzOiB7IC4uLmZvbGRlcnMgfSB9KVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMubGlzdEFsbEZpbGVzKGZvbGRlci5yZXF1ZXN0UGF0aCkudGhlbigoZmlsZXMpID0+IHtcbiAgICAgIGxldCBjb3VudCA9IDBcblxuICAgICAgLy8gSWYgdGhlIHNhbWUgZm9sZGVyIGlzIGFkZGVkIGFnYWluLCB3ZSBkb24ndCB3YW50IHRvIHNlbmRcbiAgICAgIC8vIFggYW1vdW50IG9mIGR1cGxpY2F0ZSBmaWxlIG5vdGlmaWNhdGlvbnMsIHdlIHdhbnQgdG8gc2F5XG4gICAgICAvLyB0aGUgZm9sZGVyIHdhcyBhbHJlYWR5IGFkZGVkLiBUaGlzIGNoZWNrcyBpZiBhbGwgZmlsZXMgYXJlIGR1cGxpY2F0ZSxcbiAgICAgIC8vIGlmIHRoYXQncyB0aGUgY2FzZSwgd2UgZG9uJ3QgYWRkIHRoZSBmaWxlcy5cbiAgICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5wcm92aWRlckZpbGVUb0lkKGZpbGUpXG4gICAgICAgIGlmICghdGhpcy5wbHVnaW4udXBweS5jaGVja0lmRmlsZUFscmVhZHlFeGlzdHMoaWQpKSB7XG4gICAgICAgICAgY291bnQrK1xuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHRoaXMuYWRkRmlsZShmaWxlKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgaWRzID0gZmlsZXMubWFwKHRoaXMucHJvdmlkZXJGaWxlVG9JZClcblxuICAgICAgZm9sZGVyc1tmb2xkZXJJZF0gPSB7XG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBmaWxlczogaWRzLFxuICAgICAgfVxuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBzZWxlY3RlZEZvbGRlcnM6IGZvbGRlcnMgfSlcblxuICAgICAgbGV0IG1lc3NhZ2VcblxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLnBsdWdpbi51cHB5LmkxOG4oJ2ZvbGRlckFscmVhZHlBZGRlZCcsIHtcbiAgICAgICAgICBmb2xkZXI6IGZvbGRlci5uYW1lLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMucGx1Z2luLnVwcHkuaTE4bignZm9sZGVyQWRkZWQnLCB7XG4gICAgICAgICAgc21hcnRfY291bnQ6IGNvdW50LCBmb2xkZXI6IGZvbGRlci5uYW1lLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMucGx1Z2luLnVwcHkuaTE4bignZW1wdHlGb2xkZXJBZGRlZCcpXG4gICAgICB9XG5cbiAgICAgIHRoaXMucGx1Z2luLnVwcHkuaW5mbyhtZXNzYWdlKVxuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICAgIGNvbnN0IHNlbGVjdGVkRm9sZGVycyA9IHsgLi4uc3RhdGUuc2VsZWN0ZWRGb2xkZXJzIH1cbiAgICAgIGRlbGV0ZSBzZWxlY3RlZEZvbGRlcnNbZm9sZGVySWRdXG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IHNlbGVjdGVkRm9sZGVycyB9KVxuICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVBdXRoICgpIHtcbiAgICBjb25zdCBhdXRoU3RhdGUgPSBidG9hKEpTT04uc3RyaW5naWZ5KHsgb3JpZ2luOiBnZXRPcmlnaW4oKSB9KSlcbiAgICBjb25zdCBjbGllbnRWZXJzaW9uID0gYEB1cHB5L3Byb3ZpZGVyLXZpZXdzPSR7UHJvdmlkZXJWaWV3LlZFUlNJT059YFxuICAgIGNvbnN0IGxpbmsgPSB0aGlzLnByb3ZpZGVyLmF1dGhVcmwoeyBzdGF0ZTogYXV0aFN0YXRlLCB1cHB5VmVyc2lvbnM6IGNsaWVudFZlcnNpb24gfSlcblxuICAgIGNvbnN0IGF1dGhXaW5kb3cgPSB3aW5kb3cub3BlbihsaW5rLCAnX2JsYW5rJylcbiAgICBjb25zdCBoYW5kbGVUb2tlbiA9IChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuI2lzT3JpZ2luQWxsb3dlZChlLm9yaWdpbiwgdGhpcy5wbHVnaW4ub3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMpIHx8IGUuc291cmNlICE9PSBhdXRoV2luZG93KSB7XG4gICAgICAgIHRoaXMucGx1Z2luLnVwcHkubG9nKGByZWplY3RpbmcgZXZlbnQgZnJvbSAke2Uub3JpZ2lufSB2cyBhbGxvd2VkIHBhdHRlcm4gJHt0aGlzLnBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0c31gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHN0cmluZyBiZWZvcmUgZG9pbmcgdGhlIEpTT04ucGFyc2UgdG8gbWFpbnRhaW4gc3VwcG9ydFxuICAgICAgLy8gZm9yIG9sZGVyIENvbXBhbmlvbiB2ZXJzaW9ucyB0aGF0IHVzZWQgb2JqZWN0IHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgZS5kYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoZS5kYXRhKSA6IGUuZGF0YVxuXG4gICAgICBpZiAoZGF0YS5lcnJvcikge1xuICAgICAgICB0aGlzLnBsdWdpbi51cHB5LmxvZygnYXV0aCBhYm9ydGVkJylcbiAgICAgICAgY29uc3QgeyB1cHB5IH0gPSB0aGlzLnBsdWdpblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gdXBweS5pMThuKCdhdXRoQWJvcnRlZCcpXG4gICAgICAgIHVwcHkuaW5mbyh7IG1lc3NhZ2UgfSwgJ3dhcm5pbmcnLCA1MDAwKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLnRva2VuKSB7XG4gICAgICAgIHRoaXMucGx1Z2luLnVwcHkubG9nKCdkaWQgbm90IHJlY2VpdmUgdG9rZW4gZnJvbSBhdXRoIHdpbmRvdycpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBhdXRoV2luZG93LmNsb3NlKClcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlVG9rZW4pXG4gICAgICB0aGlzLnByb3ZpZGVyLnNldEF1dGhUb2tlbihkYXRhLnRva2VuKVxuICAgICAgdGhpcy5wcmVGaXJzdFJlbmRlcigpXG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlVG9rZW4pXG4gIH1cblxuICAjaXNPcmlnaW5BbGxvd2VkIChvcmlnaW4sIGFsbG93ZWRPcmlnaW4pIHtcbiAgICBjb25zdCBnZXRSZWdleCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3ZhbHVlfSRgKVxuICAgICAgfSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGF0dGVybnMgPSBBcnJheS5pc0FycmF5KGFsbG93ZWRPcmlnaW4pID8gYWxsb3dlZE9yaWdpbi5tYXAoZ2V0UmVnZXgpIDogW2dldFJlZ2V4KGFsbG93ZWRPcmlnaW4pXVxuICAgIHJldHVybiBwYXR0ZXJuc1xuICAgICAgLmZpbHRlcigocGF0dGVybikgPT4gcGF0dGVybiAhPSBudWxsKSAvLyBsb29zZSBjb21wYXJpc29uIHRvIGNhdGNoIHVuZGVmaW5lZFxuICAgICAgLnNvbWUoKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdChvcmlnaW4pIHx8IHBhdHRlcm4udGVzdChgJHtvcmlnaW59L2ApKSAvLyBhbGxvd2luZyBmb3IgdHJhaWxpbmcgJy8nXG4gIH1cblxuICBhc3luYyBoYW5kbGVTY3JvbGwgKGV2ZW50KSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMubmV4dFBhZ2VQYXRoIHx8IG51bGxcblxuICAgIGlmICh0aGlzLnNob3VsZEhhbmRsZVNjcm9sbChldmVudCkgJiYgcGF0aCkge1xuICAgICAgdGhpcy5pc0hhbmRsaW5nU2Nyb2xsID0gdHJ1ZVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIubGlzdChwYXRoKVxuICAgICAgICBjb25zdCB7IGZpbGVzLCBmb2xkZXJzIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICAgICAgdGhpcy4jdXBkYXRlRmlsZXNBbmRGb2xkZXJzKHJlc3BvbnNlLCBmaWxlcywgZm9sZGVycylcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzSGFuZGxpbmdTY3JvbGwgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxpc3RBbGxGaWxlcyAocGF0aCwgZmlsZXMgPSBudWxsKSB7XG4gICAgZmlsZXMgPSBmaWxlcyB8fCBbXVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnByb3ZpZGVyLmxpc3QocGF0aCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIHJlcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFpdGVtLmlzRm9sZGVyKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKGl0ZW0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRm9sZGVyKGl0ZW0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBtb3JlRmlsZXMgPSByZXMubmV4dFBhZ2VQYXRoIHx8IG51bGxcbiAgICAgICAgaWYgKG1vcmVGaWxlcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RBbGxGaWxlcyhtb3JlRmlsZXMsIGZpbGVzKVxuICAgICAgICAgICAgLnRoZW4oKGZpbGVzKSA9PiByZXNvbHZlKGZpbGVzKSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHJlamVjdChlKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlcylcbiAgICAgIH0pLmNhdGNoKGUgPT4gcmVqZWN0KGUpKVxuICAgIH0pXG4gIH1cblxuICBkb25lUGlja2luZyAoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50U2VsZWN0aW9uIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgcHJvbWlzZXMgPSBjdXJyZW50U2VsZWN0aW9uLm1hcCgoZmlsZSkgPT4ge1xuICAgICAgaWYgKGZpbGUuaXNGb2xkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkRm9sZGVyKGZpbGUpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpXG4gICAgfSlcblxuICAgIHRoaXMuc2hhcmVkSGFuZGxlci5sb2FkZXJXcmFwcGVyKFByb21pc2UuYWxsKHByb21pc2VzKSwgKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG4gICAgfSwgKCkgPT4ge30pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlLCB2aWV3T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhdXRoZW50aWNhdGVkLCBkaWRGaXJzdFJlbmRlciB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgaWYgKCFkaWRGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5wcmVGaXJzdFJlbmRlcigpXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Vmlld09wdGlvbnMgPSB7IC4uLnRoaXMub3B0cywgLi4udmlld09wdGlvbnMgfVxuICAgIGNvbnN0IHsgZmlsZXMsIGZvbGRlcnMsIGZpbHRlcklucHV0LCBsb2FkaW5nLCBjdXJyZW50U2VsZWN0aW9uIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgeyBpc0NoZWNrZWQsIHRvZ2dsZUNoZWNrYm94LCBmaWx0ZXJJdGVtcyB9ID0gdGhpcy5zaGFyZWRIYW5kbGVyXG4gICAgY29uc3QgaGFzSW5wdXQgPSBmaWx0ZXJJbnB1dCAhPT0gJydcbiAgICBjb25zdCBoZWFkZXJQcm9wcyA9IHtcbiAgICAgIHNob3dCcmVhZGNydW1iczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd0JyZWFkY3J1bWJzLFxuICAgICAgZ2V0Rm9sZGVyOiB0aGlzLmdldEZvbGRlcixcbiAgICAgIGRpcmVjdG9yaWVzOiB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLmRpcmVjdG9yaWVzLFxuICAgICAgcGx1Z2luSWNvbjogdGhpcy5wbHVnaW4uaWNvbixcbiAgICAgIHRpdGxlOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgIGxvZ291dDogdGhpcy5sb2dvdXQsXG4gICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgIGkxOG46IHRoaXMucGx1Z2luLnVwcHkuaTE4bixcbiAgICB9XG5cbiAgICBjb25zdCBicm93c2VyUHJvcHMgPSB7XG4gICAgICBpc0NoZWNrZWQsXG4gICAgICB0b2dnbGVDaGVja2JveCxcbiAgICAgIGN1cnJlbnRTZWxlY3Rpb24sXG4gICAgICBmaWxlczogaGFzSW5wdXQgPyBmaWx0ZXJJdGVtcyhmaWxlcykgOiBmaWxlcyxcbiAgICAgIGZvbGRlcnM6IGhhc0lucHV0ID8gZmlsdGVySXRlbXMoZm9sZGVycykgOiBmb2xkZXJzLFxuICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICBnZXROZXh0Rm9sZGVyOiB0aGlzLmdldE5leHRGb2xkZXIsXG4gICAgICBnZXRGb2xkZXI6IHRoaXMuZ2V0Rm9sZGVyLFxuICAgICAgZmlsdGVySXRlbXM6IHRoaXMuc2hhcmVkSGFuZGxlci5maWx0ZXJJdGVtcyxcbiAgICAgIGZpbHRlclF1ZXJ5OiB0aGlzLmZpbHRlclF1ZXJ5LFxuICAgICAgbG9nb3V0OiB0aGlzLmxvZ291dCxcbiAgICAgIGhhbmRsZVNjcm9sbDogdGhpcy5oYW5kbGVTY3JvbGwsXG4gICAgICBsaXN0QWxsRmlsZXM6IHRoaXMubGlzdEFsbEZpbGVzLFxuICAgICAgZG9uZTogdGhpcy5kb25lUGlja2luZyxcbiAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWxQaWNraW5nLFxuICAgICAgaGVhZGVyQ29tcG9uZW50OiBIZWFkZXIoaGVhZGVyUHJvcHMpLFxuICAgICAgdGl0bGU6IHRoaXMucGx1Z2luLnRpdGxlLFxuICAgICAgdmlld1R5cGU6IHRhcmdldFZpZXdPcHRpb25zLnZpZXdUeXBlLFxuICAgICAgc2hvd1RpdGxlczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd1RpdGxlcyxcbiAgICAgIHNob3dGaWx0ZXI6IHRhcmdldFZpZXdPcHRpb25zLnNob3dGaWx0ZXIsXG4gICAgICBzaG93QnJlYWRjcnVtYnM6IHRhcmdldFZpZXdPcHRpb25zLnNob3dCcmVhZGNydW1icyxcbiAgICAgIHBsdWdpbkljb246IHRoaXMucGx1Z2luLmljb24sXG4gICAgICBpMThuOiB0aGlzLnBsdWdpbi51cHB5LmkxOG4sXG4gICAgICB1cHB5RmlsZXM6IHRoaXMucGx1Z2luLnVwcHkuZ2V0RmlsZXMoKSxcbiAgICAgIHZhbGlkYXRlUmVzdHJpY3Rpb25zOiAoLi4uYXJncykgPT4gdGhpcy5wbHVnaW4udXBweS52YWxpZGF0ZVJlc3RyaWN0aW9ucyguLi5hcmdzKSxcbiAgICB9XG5cbiAgICBpZiAobG9hZGluZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPENsb3NlV3JhcHBlciBvblVubW91bnQ9e3RoaXMuY2xlYXJTZWxlY3Rpb259PlxuICAgICAgICAgIDxMb2FkZXJWaWV3IGkxOG49e3RoaXMucGx1Z2luLnVwcHkuaTE4bn0gLz5cbiAgICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKCFhdXRoZW50aWNhdGVkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgPEF1dGhWaWV3XG4gICAgICAgICAgICBwbHVnaW5OYW1lPXt0aGlzLnBsdWdpbi50aXRsZX1cbiAgICAgICAgICAgIHBsdWdpbkljb249e3RoaXMucGx1Z2luLmljb259XG4gICAgICAgICAgICBoYW5kbGVBdXRoPXt0aGlzLmhhbmRsZUF1dGh9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnBsdWdpbi51cHB5LmkxOG59XG4gICAgICAgICAgICBpMThuQXJyYXk9e3RoaXMucGx1Z2luLnVwcHkuaTE4bkFycmF5fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvQ2xvc2VXcmFwcGVyPlxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgIDxCcm93c2VyIHsuLi5icm93c2VyUHJvcHN9IC8+XG4gICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICApXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChbXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItdXNlclwiIGtleT1cInVzZXJuYW1lXCI+e3Byb3BzLnVzZXJuYW1lfTwvc3Bhbj4sXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17cHJvcHMubG9nb3V0fSBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXItdXNlckxvZ291dFwiIGtleT1cImxvZ291dFwiPlxuICAgICAge3Byb3BzLmkxOG4oJ2xvZ091dCcpfVxuICAgIDwvYnV0dG9uPixcbiAgXSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Qcm92aWRlclZpZXcnKVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3Byb3BzLnRyaWdnZXJTZWFyY2hJbnB1dH0gY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VyLXVzZXJMb2dvdXRcIj5cbiAgICAgIHtwcm9wcy5pMThuKCdiYWNrVG9TZWFyY2gnKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBsZXQgaW5wdXRcbiAgY29uc3QgaGFuZGxlS2V5UHJlc3MgPSAoZXYpID0+IHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHZhbGlkYXRlQW5kU2VhcmNoKClcbiAgICB9XG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZUFuZFNlYXJjaCA9ICgpID0+IHtcbiAgICBpZiAoaW5wdXQudmFsdWUpIHtcbiAgICAgIHByb3BzLnNlYXJjaChpbnB1dC52YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TZWFyY2hQcm92aWRlclwiPlxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtdGV4dElucHV0IHVwcHktU2VhcmNoUHJvdmlkZXItaW5wdXRcIlxuICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2VudGVyVGV4dFRvU2VhcmNoJyl9XG4gICAgICAgIHBsYWNlaG9sZGVyPXtwcm9wcy5pMThuKCdlbnRlclRleHRUb1NlYXJjaCcpfVxuICAgICAgICBvbktleVVwPXtoYW5kbGVLZXlQcmVzc31cbiAgICAgICAgcmVmPXsoaW5wdXRfKSA9PiB7IGlucHV0ID0gaW5wdXRfIH19XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgIC8+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeSB1cHB5LVNlYXJjaFByb3ZpZGVyLXNlYXJjaEJ1dHRvblwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBvbkNsaWNrPXt2YWxpZGF0ZUFuZFNlYXJjaH1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmkxOG4oJ3NlYXJjaEltYWdlcycpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IFNlYXJjaElucHV0ID0gcmVxdWlyZSgnLi9JbnB1dFZpZXcnKVxuY29uc3QgQnJvd3NlciA9IHJlcXVpcmUoJy4uL0Jyb3dzZXInKVxuY29uc3QgTG9hZGVyVmlldyA9IHJlcXVpcmUoJy4uL0xvYWRlcicpXG5jb25zdCBIZWFkZXIgPSByZXF1aXJlKCcuL0hlYWRlcicpXG5jb25zdCBDbG9zZVdyYXBwZXIgPSByZXF1aXJlKCcuLi9DbG9zZVdyYXBwZXInKVxuY29uc3QgVmlldyA9IHJlcXVpcmUoJy4uL1ZpZXcnKVxuXG4vKipcbiAqIENsYXNzIHRvIGVhc2lseSBnZW5lcmF0ZSBnZW5lcmljIHZpZXdzIGZvciBQcm92aWRlciBwbHVnaW5zXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2VhcmNoUHJvdmlkZXJWaWV3IGV4dGVuZHMgVmlldyB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gICNzZWFyY2hUZXJtXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwbHVnaW4gaW5zdGFuY2Ugb2YgdGhlIHBsdWdpblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHBsdWdpbiwgb3B0cykge1xuICAgIHN1cGVyKHBsdWdpbiwgb3B0cylcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHZpZXdUeXBlOiAnZ3JpZCcsXG4gICAgICBzaG93VGl0bGVzOiBmYWxzZSxcbiAgICAgIHNob3dGaWx0ZXI6IGZhbHNlLFxuICAgICAgc2hvd0JyZWFkY3J1bWJzOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgLy8gTG9naWNcbiAgICB0aGlzLnNlYXJjaCA9IHRoaXMuc2VhcmNoLmJpbmQodGhpcylcbiAgICB0aGlzLnRyaWdnZXJTZWFyY2hJbnB1dCA9IHRoaXMudHJpZ2dlclNlYXJjaElucHV0LmJpbmQodGhpcylcbiAgICB0aGlzLmFkZEZpbGUgPSB0aGlzLmFkZEZpbGUuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gdGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuZG9uZVBpY2tpbmcgPSB0aGlzLmRvbmVQaWNraW5nLmJpbmQodGhpcylcblxuICAgIC8vIFZpc3VhbFxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLy8gU2V0IGRlZmF1bHQgc3RhdGUgZm9yIHRoZSBwbHVnaW5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBpc0lucHV0TW9kZTogdHJ1ZSxcbiAgICAgIGZpbGVzOiBbXSxcbiAgICAgIGZvbGRlcnM6IFtdLFxuICAgICAgZGlyZWN0b3JpZXM6IFtdLFxuICAgICAgZmlsdGVySW5wdXQ6ICcnLFxuICAgICAgaXNTZWFyY2hWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGN1cnJlbnRTZWxlY3Rpb246IFtdLFxuICAgIH0pXG4gIH1cblxuICB0ZWFyRG93biAoKSB7XG4gICAgLy8gTm90aGluZy5cbiAgfVxuXG4gICN1cGRhdGVGaWxlc0FuZElucHV0TW9kZSAocmVzLCBmaWxlcykge1xuICAgIHRoaXMubmV4dFBhZ2VRdWVyeSA9IHJlcy5uZXh0UGFnZVF1ZXJ5XG4gICAgdGhpcy4jc2VhcmNoVGVybSA9IHJlcy5zZWFyY2hlZEZvclxuICAgIHJlcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7IGZpbGVzLnB1c2goaXRlbSkgfSlcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGlzSW5wdXRNb2RlOiBmYWxzZSwgZmlsZXMgfSlcbiAgfVxuXG4gIHNlYXJjaCAocXVlcnkpIHtcbiAgICBpZiAocXVlcnkgJiYgcXVlcnkgPT09IHRoaXMuI3NlYXJjaFRlcm0pIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gc2VhcmNoIGFnYWluIGFzIHRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHNlYXJjaFxuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBpc0lucHV0TW9kZTogZmFsc2UgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNoYXJlZEhhbmRsZXIubG9hZGVyV3JhcHBlcihcbiAgICAgIHRoaXMucHJvdmlkZXIuc2VhcmNoKHF1ZXJ5KSxcbiAgICAgIChyZXMpID0+IHtcbiAgICAgICAgdGhpcy4jdXBkYXRlRmlsZXNBbmRJbnB1dE1vZGUocmVzLCBbXSlcbiAgICAgIH0sXG4gICAgICB0aGlzLmhhbmRsZUVycm9yLFxuICAgIClcbiAgfVxuXG4gIHRyaWdnZXJTZWFyY2hJbnB1dCAoKSB7XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBpc0lucHV0TW9kZTogdHJ1ZSB9KVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlU2Nyb2xsIChldmVudCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5uZXh0UGFnZVF1ZXJ5IHx8IG51bGxcblxuICAgIGlmICh0aGlzLnNob3VsZEhhbmRsZVNjcm9sbChldmVudCkgJiYgcXVlcnkpIHtcbiAgICAgIHRoaXMuaXNIYW5kbGluZ1Njcm9sbCA9IHRydWVcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlYXJjaCh0aGlzLiNzZWFyY2hUZXJtLCBxdWVyeSlcbiAgICAgICAgY29uc3QgeyBmaWxlcyB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgICAgIHRoaXMuI3VwZGF0ZUZpbGVzQW5kSW5wdXRNb2RlKHJlc3BvbnNlLCBmaWxlcylcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzSGFuZGxpbmdTY3JvbGwgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRvbmVQaWNraW5nICgpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRTZWxlY3Rpb24gfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBwcm9taXNlcyA9IGN1cnJlbnRTZWxlY3Rpb24ubWFwKChmaWxlKSA9PiB0aGlzLmFkZEZpbGUoZmlsZSkpXG5cbiAgICB0aGlzLnNoYXJlZEhhbmRsZXIubG9hZGVyV3JhcHBlcihQcm9taXNlLmFsbChwcm9taXNlcyksICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKVxuICAgIH0sICgpID0+IHt9KVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSwgdmlld09wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlkRmlyc3RSZW5kZXIsIGlzSW5wdXRNb2RlIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICBpZiAoIWRpZEZpcnN0UmVuZGVyKSB7XG4gICAgICB0aGlzLnByZUZpcnN0UmVuZGVyKClcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRWaWV3T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRzLCAuLi52aWV3T3B0aW9ucyB9XG4gICAgY29uc3QgeyBmaWxlcywgZm9sZGVycywgZmlsdGVySW5wdXQsIGxvYWRpbmcsIGN1cnJlbnRTZWxlY3Rpb24gfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCB7IGlzQ2hlY2tlZCwgdG9nZ2xlQ2hlY2tib3gsIGZpbHRlckl0ZW1zIH0gPSB0aGlzLnNoYXJlZEhhbmRsZXJcbiAgICBjb25zdCBoYXNJbnB1dCA9IGZpbHRlcklucHV0ICE9PSAnJ1xuXG4gICAgY29uc3QgYnJvd3NlclByb3BzID0ge1xuICAgICAgaXNDaGVja2VkLFxuICAgICAgdG9nZ2xlQ2hlY2tib3gsXG4gICAgICBjdXJyZW50U2VsZWN0aW9uLFxuICAgICAgZmlsZXM6IGhhc0lucHV0ID8gZmlsdGVySXRlbXMoZmlsZXMpIDogZmlsZXMsXG4gICAgICBmb2xkZXJzOiBoYXNJbnB1dCA/IGZpbHRlckl0ZW1zKGZvbGRlcnMpIDogZm9sZGVycyxcbiAgICAgIGhhbmRsZVNjcm9sbDogdGhpcy5oYW5kbGVTY3JvbGwsXG4gICAgICBkb25lOiB0aGlzLmRvbmVQaWNraW5nLFxuICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbFBpY2tpbmcsXG4gICAgICBoZWFkZXJDb21wb25lbnQ6IEhlYWRlcih7XG4gICAgICAgIHRyaWdnZXJTZWFyY2hJbnB1dDogdGhpcy50cmlnZ2VyU2VhcmNoSW5wdXQsXG4gICAgICAgIGkxOG46IHRoaXMucGx1Z2luLnVwcHkuaTE4bixcbiAgICAgIH0pLFxuICAgICAgdGl0bGU6IHRoaXMucGx1Z2luLnRpdGxlLFxuICAgICAgdmlld1R5cGU6IHRhcmdldFZpZXdPcHRpb25zLnZpZXdUeXBlLFxuICAgICAgc2hvd1RpdGxlczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd1RpdGxlcyxcbiAgICAgIHNob3dGaWx0ZXI6IHRhcmdldFZpZXdPcHRpb25zLnNob3dGaWx0ZXIsXG4gICAgICBzaG93QnJlYWRjcnVtYnM6IHRhcmdldFZpZXdPcHRpb25zLnNob3dCcmVhZGNydW1icyxcbiAgICAgIHBsdWdpbkljb246IHRoaXMucGx1Z2luLmljb24sXG4gICAgICBpMThuOiB0aGlzLnBsdWdpbi51cHB5LmkxOG4sXG4gICAgICB1cHB5RmlsZXM6IHRoaXMucGx1Z2luLnVwcHkuZ2V0RmlsZXMoKSxcbiAgICAgIHZhbGlkYXRlUmVzdHJpY3Rpb25zOiAoLi4uYXJncykgPT4gdGhpcy5wbHVnaW4udXBweS52YWxpZGF0ZVJlc3RyaWN0aW9ucyguLi5hcmdzKSxcbiAgICB9XG5cbiAgICBpZiAobG9hZGluZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPENsb3NlV3JhcHBlciBvblVubW91bnQ9e3RoaXMuY2xlYXJTZWxlY3Rpb259PlxuICAgICAgICAgIDxMb2FkZXJWaWV3IGkxOG49e3RoaXMucGx1Z2luLnVwcHkuaTE4bn0gLz5cbiAgICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGlzSW5wdXRNb2RlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgPFNlYXJjaElucHV0XG4gICAgICAgICAgICBzZWFyY2g9e3RoaXMuc2VhcmNofVxuICAgICAgICAgICAgaTE4bj17dGhpcy5wbHVnaW4udXBweS5pMThufVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvQ2xvc2VXcmFwcGVyPlxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgIDxCcm93c2VyIHsuLi5icm93c2VyUHJvcHN9IC8+XG4gICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICApXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9TZWFyY2hQcm92aWRlclZpZXcnKVxuIiwiY29uc3QgcmVtb3RlRmlsZU9ialRvTG9jYWwgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcmVtb3RlRmlsZU9ialRvTG9jYWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNoYXJlZEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAocGx1Z2luKSB7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB0aGlzLmZpbHRlckl0ZW1zID0gdGhpcy5maWx0ZXJJdGVtcy5iaW5kKHRoaXMpXG4gICAgdGhpcy50b2dnbGVDaGVja2JveCA9IHRoaXMudG9nZ2xlQ2hlY2tib3guYmluZCh0aGlzKVxuICAgIHRoaXMuaXNDaGVja2VkID0gdGhpcy5pc0NoZWNrZWQuYmluZCh0aGlzKVxuICAgIHRoaXMubG9hZGVyV3JhcHBlciA9IHRoaXMubG9hZGVyV3JhcHBlci5iaW5kKHRoaXMpXG4gIH1cblxuICBmaWx0ZXJJdGVtcyAoaXRlbXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBpZiAoIXN0YXRlLmZpbHRlcklucHV0IHx8IHN0YXRlLmZpbHRlcklucHV0ID09PSAnJykge1xuICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfVxuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGZvbGRlcikgPT4ge1xuICAgICAgcmV0dXJuIGZvbGRlci5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdGF0ZS5maWx0ZXJJbnB1dC50b0xvd2VyQ2FzZSgpKSAhPT0gLTFcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgZmlsZS9mb2xkZXIgY2hlY2tib3ggdG8gb24vb2ZmIHN0YXRlIHdoaWxlIHVwZGF0aW5nIGZpbGVzIGxpc3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzb21lIGV4dHJhIGNvbXBsZXhpdHkgY29tZXMgZnJvbSBzdXBwb3J0aW5nIHNoaWZ0K2NsaWNrIHRvXG4gICAqIHRvZ2dsZSBtdWx0aXBsZSBjaGVja2JveGVzIGF0IG9uY2UsIHdoaWNoIGlzIGRvbmUgYnkgZ2V0dGluZyBhbGwgZmlsZXNcbiAgICogaW4gYmV0d2VlbiBsYXN0IGNoZWNrZWQgZmlsZSBhbmQgY3VycmVudCBvbmUuXG4gICAqL1xuICB0b2dnbGVDaGVja2JveCAoZSwgZmlsZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLmN1cnJlbnRUYXJnZXQuZm9jdXMoKVxuICAgIGNvbnN0IHsgZm9sZGVycywgZmlsZXMgfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZmlsdGVySXRlbXMoZm9sZGVycy5jb25jYXQoZmlsZXMpKVxuXG4gICAgLy8gU2hpZnQtY2xpY2tpbmcgc2VsZWN0cyBhIHNpbmdsZSBjb25zZWN1dGl2ZSBsaXN0IG9mIGl0ZW1zXG4gICAgLy8gc3RhcnRpbmcgYXQgdGhlIHByZXZpb3VzIGNsaWNrIGFuZCBkZXNlbGVjdHMgZXZlcnl0aGluZyBlbHNlLlxuICAgIGlmICh0aGlzLmxhc3RDaGVja2JveCAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICBjb25zdCBwcmV2SW5kZXggPSBpdGVtcy5pbmRleE9mKHRoaXMubGFzdENoZWNrYm94KVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaXRlbXMuaW5kZXhPZihmaWxlKVxuICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IChwcmV2SW5kZXggPCBjdXJyZW50SW5kZXgpXG4gICAgICAgID8gaXRlbXMuc2xpY2UocHJldkluZGV4LCBjdXJyZW50SW5kZXggKyAxKVxuICAgICAgICA6IGl0ZW1zLnNsaWNlKGN1cnJlbnRJbmRleCwgcHJldkluZGV4ICsgMSlcbiAgICAgIGNvbnN0IHJlZHVjZWRDdXJyZW50U2VsZWN0aW9uID0gW11cblxuICAgICAgLy8gQ2hlY2sgcmVzdHJpY3Rpb25zIG9uIGVhY2ggZmlsZSBpbiBjdXJyZW50U2VsZWN0aW9uLFxuICAgICAgLy8gcmVkdWNlIGl0IHRvIG9ubHkgY29udGFpbiBmaWxlcyB0aGF0IHBhc3MgcmVzdHJpY3Rpb25zXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY3VycmVudFNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCB7IHVwcHkgfSA9IHRoaXMucGx1Z2luXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3RyaWN0aW9ucyA9IHVwcHkudmFsaWRhdGVSZXN0cmljdGlvbnMoXG4gICAgICAgICAgcmVtb3RlRmlsZU9ialRvTG9jYWwoaXRlbSksXG4gICAgICAgICAgWy4uLnVwcHkuZ2V0RmlsZXMoKSwgLi4ucmVkdWNlZEN1cnJlbnRTZWxlY3Rpb25dLFxuICAgICAgICApXG4gICAgICAgIGlmICh2YWxpZGF0ZWRSZXN0cmljdGlvbnMucmVzdWx0KSB7XG4gICAgICAgICAgcmVkdWNlZEN1cnJlbnRTZWxlY3Rpb24ucHVzaChpdGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcHkuaW5mbyh7IG1lc3NhZ2U6IHZhbGlkYXRlZFJlc3RyaWN0aW9ucy5yZWFzb24gfSwgJ2Vycm9yJywgdXBweS5vcHRzLmluZm9UaW1lb3V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGN1cnJlbnRTZWxlY3Rpb246IHJlZHVjZWRDdXJyZW50U2VsZWN0aW9uIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmxhc3RDaGVja2JveCA9IGZpbGVcbiAgICBjb25zdCB7IGN1cnJlbnRTZWxlY3Rpb24gfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBpZiAodGhpcy5pc0NoZWNrZWQoZmlsZSkpIHtcbiAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgY3VycmVudFNlbGVjdGlvbjogY3VycmVudFNlbGVjdGlvbi5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uaWQgIT09IGZpbGUuaWQpLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBjdXJyZW50U2VsZWN0aW9uOiBjdXJyZW50U2VsZWN0aW9uLmNvbmNhdChbZmlsZV0pLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpc0NoZWNrZWQgKGZpbGUpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRTZWxlY3Rpb24gfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICAvLyBjb21wYXJpbmcgaWQgaW5zdGVhZCBvZiB0aGUgZmlsZSBvYmplY3QsIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0XG4gICAgLy8gY2hhbmdlcyB3aGVuIHdlIHN3aXRjaCBmb2xkZXJzLCBhbmQgdGhlIGZpbGUgbGlzdCBpcyB1cGRhdGVkXG4gICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb24uc29tZSgoaXRlbSkgPT4gaXRlbS5pZCA9PT0gZmlsZS5pZClcbiAgfVxuXG4gIGxvYWRlcldyYXBwZXIgKHByb21pc2UsIHRoZW4sIGNhdGNoXykge1xuICAgIHByb21pc2VcbiAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBsb2FkaW5nOiBmYWxzZSB9KVxuICAgICAgICB0aGVuKHJlc3VsdClcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBsb2FkaW5nOiBmYWxzZSB9KVxuICAgICAgICBjYXRjaF8oZXJyKVxuICAgICAgfSlcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGxvYWRpbmc6IHRydWUgfSlcbiAgfVxufVxuIiwiY29uc3QgZ2V0RmlsZVR5cGUgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RmlsZVR5cGUnKVxuY29uc3QgaXNQcmV2aWV3U3VwcG9ydGVkID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzUHJldmlld1N1cHBvcnRlZCcpXG5jb25zdCBnZW5lcmF0ZUZpbGVJRCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZW5lcmF0ZUZpbGVJRCcpXG5cbi8vIFRPRE86IG5vdyB0aGF0IHdlIGhhdmUgYSBzaGFyZWQgYFZpZXdgIGNsYXNzLFxuLy8gYFNoYXJlZEhhbmRsZXJgIGNvdWxkIGJlIGNsZWFuZWQgdXAgYW5kIG1vdmVkIGludG8gaGVyZVxuY29uc3QgU2hhcmVkSGFuZGxlciA9IHJlcXVpcmUoJy4vU2hhcmVkSGFuZGxlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yIChwbHVnaW4sIG9wdHMpIHtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpblxuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyXG4gICAgdGhpcy5zaGFyZWRIYW5kbGVyID0gbmV3IFNoYXJlZEhhbmRsZXIocGx1Z2luKVxuXG4gICAgdGhpcy5pc0hhbmRsaW5nU2Nyb2xsID0gZmFsc2VcblxuICAgIHRoaXMucHJlRmlyc3RSZW5kZXIgPSB0aGlzLnByZUZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUVycm9yID0gdGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpXG4gICAgdGhpcy5hZGRGaWxlID0gdGhpcy5hZGRGaWxlLmJpbmQodGhpcylcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uID0gdGhpcy5jbGVhclNlbGVjdGlvbi5iaW5kKHRoaXMpXG4gICAgdGhpcy5jYW5jZWxQaWNraW5nID0gdGhpcy5jYW5jZWxQaWNraW5nLmJpbmQodGhpcylcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIHByb3ZpZGVyRmlsZVRvSWQgKGZpbGUpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVGaWxlSUQoe1xuICAgICAgZGF0YTogZmlsZSxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSB8fCBmaWxlLmlkLFxuICAgICAgdHlwZTogZmlsZS5taW1ldHlwZSxcbiAgICB9KVxuICB9XG5cbiAgcHJlRmlyc3RSZW5kZXIgKCkge1xuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgZGlkRmlyc3RSZW5kZXI6IHRydWUgfSlcbiAgICB0aGlzLnBsdWdpbi5vbkZpcnN0UmVuZGVyKClcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIHNob3VsZEhhbmRsZVNjcm9sbCAoZXZlbnQpIHtcbiAgICBjb25zdCB7IHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wLCBvZmZzZXRIZWlnaHQgfSA9IGV2ZW50LnRhcmdldFxuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gc2Nyb2xsSGVpZ2h0IC0gKHNjcm9sbFRvcCArIG9mZnNldEhlaWdodClcblxuICAgIHJldHVybiBzY3JvbGxQb3NpdGlvbiA8IDUwICYmICF0aGlzLmlzSGFuZGxpbmdTY3JvbGxcbiAgfVxuXG4gIGNsZWFyU2VsZWN0aW9uICgpIHtcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGN1cnJlbnRTZWxlY3Rpb246IFtdIH0pXG4gIH1cblxuICBjYW5jZWxQaWNraW5nICgpIHtcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcblxuICAgIGNvbnN0IGRhc2hib2FyZCA9IHRoaXMucGx1Z2luLnVwcHkuZ2V0UGx1Z2luKCdEYXNoYm9hcmQnKVxuXG4gICAgaWYgKGRhc2hib2FyZCkge1xuICAgICAgZGFzaGJvYXJkLmhpZGVBbGxQYW5lbHMoKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUVycm9yIChlcnJvcikge1xuICAgIGNvbnN0IHsgdXBweSB9ID0gdGhpcy5wbHVnaW5cbiAgICBjb25zdCBtZXNzYWdlID0gdXBweS5pMThuKCdjb21wYW5pb25FcnJvcicpXG5cbiAgICB1cHB5LmxvZyhlcnJvci50b1N0cmluZygpKVxuXG4gICAgaWYgKGVycm9yLmlzQXV0aEVycm9yKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB1cHB5LmluZm8oeyBtZXNzYWdlLCBkZXRhaWxzOiBlcnJvci50b1N0cmluZygpIH0sICdlcnJvcicsIDUwMDApXG4gIH1cblxuICBhZGRGaWxlIChmaWxlKSB7XG4gICAgY29uc3QgdGFnRmlsZSA9IHtcbiAgICAgIGlkOiB0aGlzLnByb3ZpZGVyRmlsZVRvSWQoZmlsZSksXG4gICAgICBzb3VyY2U6IHRoaXMucGx1Z2luLmlkLFxuICAgICAgZGF0YTogZmlsZSxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSB8fCBmaWxlLmlkLFxuICAgICAgdHlwZTogZmlsZS5taW1lVHlwZSxcbiAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgbWV0YToge30sXG4gICAgICBib2R5OiB7XG4gICAgICAgIGZpbGVJZDogZmlsZS5pZCxcbiAgICAgIH0sXG4gICAgICByZW1vdGU6IHtcbiAgICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLnBsdWdpbi5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgICAgdXJsOiBgJHt0aGlzLnByb3ZpZGVyLmZpbGVVcmwoZmlsZS5yZXF1ZXN0UGF0aCl9YCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIGZpbGVJZDogZmlsZS5pZCxcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiB0aGlzLnByb3ZpZGVyLm9wdHMsXG4gICAgICAgIHByb3ZpZGVyTmFtZTogdGhpcy5wcm92aWRlci5uYW1lLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlVHlwZSA9IGdldEZpbGVUeXBlKHRhZ0ZpbGUpXG5cbiAgICAvLyBUT0RPIFNob3VsZCB3ZSBqdXN0IGFsd2F5cyB1c2UgdGhlIHRodW1ibmFpbCBVUkwgaWYgaXQgZXhpc3RzP1xuICAgIGlmIChmaWxlVHlwZSAmJiBpc1ByZXZpZXdTdXBwb3J0ZWQoZmlsZVR5cGUpKSB7XG4gICAgICB0YWdGaWxlLnByZXZpZXcgPSBmaWxlLnRodW1ibmFpbFxuICAgIH1cblxuICAgIGlmIChmaWxlLmF1dGhvcikge1xuICAgICAgdGFnRmlsZS5tZXRhLmF1dGhvciA9IGZpbGUuYXV0aG9yXG4gICAgfVxuXG4gICAgdGhpcy5wbHVnaW4udXBweS5sb2coJ0FkZGluZyByZW1vdGUgZmlsZScpXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5wbHVnaW4udXBweS5hZGRGaWxlKHRhZ0ZpbGUpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICB0aGlzLnBsdWdpbi51cHB5LmxvZyhlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IFByb3ZpZGVyVmlld3MgPSByZXF1aXJlKCcuL1Byb3ZpZGVyVmlldycpXG5jb25zdCBTZWFyY2hQcm92aWRlclZpZXdzID0gcmVxdWlyZSgnLi9TZWFyY2hQcm92aWRlclZpZXcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJvdmlkZXJWaWV3cyxcbiAgU2VhcmNoUHJvdmlkZXJWaWV3cyxcbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgUmVjb3JkQnV0dG9uID0gcmVxdWlyZSgnLi9SZWNvcmRCdXR0b24nKVxuY29uc3QgU3VibWl0QnV0dG9uID0gcmVxdWlyZSgnLi9TdWJtaXRCdXR0b24nKVxuY29uc3QgU3RvcFdhdGNoID0gcmVxdWlyZSgnLi9TdG9wV2F0Y2gnKVxuY29uc3QgU3RyZWFtU3RhdHVzID0gcmVxdWlyZSgnLi9TdHJlYW1TdGF0dXMnKVxuXG5jbGFzcyBSZWNvcmRlclNjcmVlbiBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICB0aGlzLnByb3BzLm9uU3RvcCgpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgcmVjb3JkaW5nLCBzdHJlYW06IHZpZGVvU3RyZWFtLCByZWNvcmRlZFZpZGVvIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB2aWRlb1Byb3BzID0ge1xuICAgICAgcGxheXNpbmxpbmU6IHRydWUsXG4gICAgfVxuXG4gICAgLy8gc2hvdyBzdHJlYW1cbiAgICBpZiAocmVjb3JkaW5nIHx8ICghcmVjb3JkZWRWaWRlbyAmJiAhcmVjb3JkaW5nKSkge1xuICAgICAgdmlkZW9Qcm9wcy5tdXRlZCA9IHRydWVcbiAgICAgIHZpZGVvUHJvcHMuYXV0b3BsYXkgPSB0cnVlXG4gICAgICB2aWRlb1Byb3BzLnNyY09iamVjdCA9IHZpZGVvU3RyZWFtXG4gICAgfVxuXG4gICAgLy8gc2hvdyBwcmV2aWV3XG4gICAgaWYgKHJlY29yZGVkVmlkZW8gJiYgIXJlY29yZGluZykge1xuICAgICAgdmlkZW9Qcm9wcy5tdXRlZCA9IGZhbHNlXG4gICAgICB2aWRlb1Byb3BzLmNvbnRyb2xzID0gdHJ1ZVxuICAgICAgdmlkZW9Qcm9wcy5zcmMgPSByZWNvcmRlZFZpZGVvXG5cbiAgICAgIC8vIHJlc2V0IHNyY09iamVjdCBpbiBkb20uIElmIG5vdCByZXNldHRlZCwgc3RyZWFtIHN0aWNrcyBpbiBlbGVtZW50XG4gICAgICBpZiAodGhpcy52aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweSB1cHB5LVNjcmVlbkNhcHR1cmUtY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TY3JlZW5DYXB0dXJlLXZpZGVvQ29udGFpbmVyXCI+XG4gICAgICAgICAgPFN0cmVhbVN0YXR1cyB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgICB7LyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L21lZGlhLWhhcy1jYXB0aW9uICovfVxuICAgICAgICAgIDx2aWRlbyByZWY9e3ZpZGVvRWxlbWVudCA9PiB7IHRoaXMudmlkZW9FbGVtZW50ID0gdmlkZW9FbGVtZW50IH19IGNsYXNzTmFtZT1cInVwcHktU2NyZWVuQ2FwdHVyZS12aWRlb1wiIHsuLi52aWRlb1Byb3BzfSAvPlxuICAgICAgICAgIDxTdG9wV2F0Y2ggey4uLnRoaXMucHJvcHN9IC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TY3JlZW5DYXB0dXJlLWJ1dHRvbkNvbnRhaW5lclwiPlxuICAgICAgICAgIDxSZWNvcmRCdXR0b24gey4uLnRoaXMucHJvcHN9IC8+XG4gICAgICAgICAgPFN1Ym1pdEJ1dHRvbiB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWNvcmRlclNjcmVlblxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG4vKipcbiAqIENvbnRyb2wgc2NyZWVuIGNhcHR1cmUgcmVjb3JkaW5nLiBXaWxsIHNob3cgcmVjb3JkIG9yIHN0b3AgYnV0dG9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFJlY29yZEJ1dHRvbiAoeyByZWNvcmRpbmcsIG9uU3RhcnRSZWNvcmRpbmcsIG9uU3RvcFJlY29yZGluZywgaTE4biB9KSB7XG4gIGlmIChyZWNvcmRpbmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVNjcmVlbkNhcHR1cmUtYnV0dG9uIHVwcHktU2NyZWVuQ2FwdHVyZS1idXR0b24tLXZpZGVvIHVwcHktU2NyZWVuQ2FwdHVyZS1idXR0b24tLXN0b3AtcmVjXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIHRpdGxlPXtpMThuKCdzdG9wQ2FwdHVyaW5nJyl9XG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N0b3BDYXB0dXJpbmcnKX1cbiAgICAgICAgb25DbGljaz17b25TdG9wUmVjb3JkaW5nfVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG4gICAgICAgICAgPHJlY3QgeD1cIjE1XCIgeT1cIjE1XCIgd2lkdGg9XCI3MFwiIGhlaWdodD1cIjcwXCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktU2NyZWVuQ2FwdHVyZS1idXR0b24gdXBweS1TY3JlZW5DYXB0dXJlLWJ1dHRvbi0tdmlkZW9cIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICB0aXRsZT17aTE4bignc3RhcnRDYXB0dXJpbmcnKX1cbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N0YXJ0Q2FwdHVyaW5nJyl9XG4gICAgICBvbkNsaWNrPXtvblN0YXJ0UmVjb3JkaW5nfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG4gICAgICAgIDxjaXJjbGUgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiNDBcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgIDxyZWN0IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJJY29uQmdcIiBmaWxsPVwiIzJDM0U1MFwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTI0LjE4MiA5SDcuODE4QzYuODEgOSA2IDkuNzQyIDYgMTAuNjY3djEwYzAgLjkxNi44MSAxLjY2NiAxLjgxOCAxLjY2Nmg0LjU0NlYyNGg3LjI3MnYtMS42NjdoNC41NDZjMSAwIDEuODA5LS43NSAxLjgwOS0xLjY2NmwuMDA5LTEwQzI2IDkuNzQyIDI1LjE4MiA5IDI0LjE4MiA5ek0yNCAyMUg4VjExaDE2djEwelwiIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgPGNpcmNsZSBmaWxsPVwiI0ZGRlwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjJcIiAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApXG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY2xhc3MgU3RvcHdhdGNoIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5zdGF0ZSA9IHsgZWxhcHNlZFRpbWU6IDAgfVxuXG4gICAgdGhpcy53cmFwcGVyU3R5bGUgPSB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgfVxuXG4gICAgdGhpcy5vdmVybGF5U3R5bGUgPSB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJhY2tncm91bmQ6ICdibGFjaycsXG4gICAgICBvcGFjaXR5OiAwLjcsXG4gICAgfVxuXG4gICAgdGhpcy5pbmZvQ29udGFpbmVyU3R5bGUgPSB7XG4gICAgICBtYXJnaW5MZWZ0OiAnYXV0bycsXG4gICAgICBtYXJnaW5SaWdodDogJ2F1dG8nLFxuICAgICAgbWFyZ2luVG9wOiAnYXV0bycsXG4gICAgICBtYXJnaW5Cb3R0b206ICdhdXRvJyxcbiAgICAgIHpJbmRleDogMSxcbiAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgIH1cblxuICAgIHRoaXMuaW5mb3RleHRTdHlsZSA9IHtcbiAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnYXV0bycsXG4gICAgICBtYXJnaW5Cb3R0b206ICcxcmVtJyxcbiAgICAgIGZvbnRTaXplOiAnMS41cmVtJyxcbiAgICB9XG5cbiAgICB0aGlzLnRpbWVTdHlsZSA9IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICBtYXJnaW5MZWZ0OiAnYXV0bycsXG4gICAgICBtYXJnaW5SaWdodDogJ2F1dG8nLFxuICAgICAgZm9udFNpemU6ICczcmVtJyxcbiAgICAgIGZvbnRGYW1pbHk6ICdDb3VyaWVyIE5ldycsXG4gICAgfVxuICB9XG5cbiAgc3RhcnRUaW1lciAoKSB7XG4gICAgdGhpcy50aW1lclRpY2soKVxuICAgIHRoaXMudGltZXJSdW5uaW5nID0gdHJ1ZVxuICB9XG5cbiAgcmVzZXRUaW1lciAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGVsYXBzZWRUaW1lOiAwIH0pXG4gICAgdGhpcy50aW1lclJ1bm5pbmcgPSBmYWxzZVxuICB9XG5cbiAgdGltZXJUaWNrICgpIHtcbiAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHN0YXRlID0+ICh7IGVsYXBzZWRUaW1lOiBzdGF0ZS5lbGFwc2VkVGltZSArIDEgfSkpXG4gICAgICB0aGlzLnRpbWVyVGljaygpXG4gICAgfSwgMTAwMClcbiAgfVxuXG4gIGZtdE1TUyAocykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gICAgcmV0dXJuIChzIC0gKHMgJT0gNjApKSAvIDYwICsgKHMgPiA5ID8gJzonIDogJzowJykgKyBzXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgcmVjb3JkaW5nLCBpMThuIH0gPSB7IC4uLnRoaXMucHJvcHMgfVxuXG4gICAgLy8gc2Vjb25kIHRvIG1pbnV0ZXMgYW5kIHNlY29uZHNcbiAgICBjb25zdCBtaW5BbmRTZWMgPSB0aGlzLmZtdE1TUyh0aGlzLnN0YXRlLmVsYXBzZWRUaW1lKVxuXG4gICAgaWYgKHJlY29yZGluZyAmJiAhdGhpcy50aW1lclJ1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lcigpXG4gICAgfVxuXG4gICAgaWYgKCFyZWNvcmRpbmcgJiYgdGhpcy50aW1lclJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucmVzZXRUaW1lcigpXG4gICAgfVxuXG4gICAgaWYgKHJlY29yZGluZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBzdHlsZT17dGhpcy53cmFwcGVyU3R5bGV9PlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3RoaXMub3ZlcmxheVN0eWxlfSAvPlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3RoaXMuaW5mb0NvbnRhaW5lclN0eWxlfT5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3RoaXMuaW5mb3RleHRTdHlsZX0+XG4gICAgICAgICAgICAgIHtpMThuKCdyZWNvcmRpbmcnKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17dGhpcy50aW1lU3R5bGV9PlxuICAgICAgICAgICAgICB7bWluQW5kU2VjfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9wd2F0Y2hcbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAoeyBzdHJlYW1BY3RpdmUsIGkxOG4gfSkgPT4ge1xuICBpZiAoc3RyZWFtQWN0aXZlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgdGl0bGU9e2kxOG4oJ3N0cmVhbUFjdGl2ZScpfSBhcmlhLWxhYmVsPXtpMThuKCdzdHJlYW1BY3RpdmUnKX0gY2xhc3NOYW1lPVwidXBweS1TY3JlZW5DYXB0dXJlLWljb24tLXN0cmVhbSB1cHB5LVNjcmVlbkNhcHR1cmUtaWNvbi0tc3RyZWFtQWN0aXZlXCI+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBvcGFjaXR5PVwiLjFcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xIDE4djNoM2MwLTEuNjYtMS4zNC0zLTMtM3ptMC00djJjMi43NiAwIDUgMi4yNCA1IDVoMmMwLTMuODctMy4xMy03LTctN3ptMTgtN0g1djEuNjNjMy45NiAxLjI4IDcuMDkgNC40MSA4LjM3IDguMzdIMTlWN3pNMSAxMHYyYzQuOTcgMCA5IDQuMDMgOSA5aDJjMC02LjA4LTQuOTMtMTEtMTEtMTF6bTIwLTdIM2MtMS4xIDAtMiAuOS0yIDJ2M2gyVjVoMTh2MTRoLTd2Mmg3YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHRpdGxlPXtpMThuKCdzdHJlYW1QYXNzaXZlJyl9IGFyaWEtbGFiZWw9e2kxOG4oJ3N0cmVhbVBhc3NpdmUnKX0gY2xhc3NOYW1lPVwidXBweS1TY3JlZW5DYXB0dXJlLWljb24tLXN0cmVhbVwiPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBvcGFjaXR5PVwiLjFcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2M2gyVjVoMTh2MTRoLTd2Mmg3YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6TTEgMTh2M2gzYzAtMS42Ni0xLjM0LTMtMy0zem0wLTR2MmMyLjc2IDAgNSAyLjI0IDUgNWgyYzAtMy44Ny0zLjEzLTctNy03em0wLTR2MmM0Ljk3IDAgOSA0LjAzIDkgOWgyYzAtNi4wOC00LjkzLTExLTExLTExelwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG4vKipcbiAqIFN1Ym1pdCByZWNvcmRlZCB2aWRlbyB0byB1cHB5LiBFbmFibGVkIHdoZW4gZmlsZSBpcyBhdmFpbGFibGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTdWJtaXRCdXR0b24gKHsgcmVjb3JkaW5nLCByZWNvcmRlZFZpZGVvLCBvblN1Ym1pdCwgaTE4biB9KSB7XG4gIGlmIChyZWNvcmRlZFZpZGVvICYmICFyZWNvcmRpbmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVNjcmVlbkNhcHR1cmUtYnV0dG9uIHVwcHktU2NyZWVuQ2FwdHVyZS1idXR0b24tLXN1Ym1pdFwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICB0aXRsZT17aTE4bignc3VibWl0UmVjb3JkZWRGaWxlJyl9XG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N1Ym1pdFJlY29yZGVkRmlsZScpfVxuICAgICAgICBvbkNsaWNrPXtvblN1Ym1pdH1cbiAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgPlxuICAgICAgICA8c3ZnXG4gICAgICAgICAgd2lkdGg9XCIxMlwiXG4gICAgICAgICAgaGVpZ2h0PVwiOVwiXG4gICAgICAgICAgdmlld0JveD1cIjAgMCAxMiA5XCJcbiAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiXG4gICAgICAgID5cbiAgICAgICAgICA8cGF0aCBmaWxsPVwiI2ZmZlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIGQ9XCJNMTAuNjYgMEwxMiAxLjMxIDQuMTM2IDkgMCA0Ljk1NmwxLjM0LTEuMzFMNC4xMzYgNi4zOHpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgeyBVSVBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBnZXRGaWxlVHlwZUV4dGVuc2lvbiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRGaWxlVHlwZUV4dGVuc2lvbicpXG5jb25zdCBTY3JlZW5SZWNJY29uID0gcmVxdWlyZSgnLi9TY3JlZW5SZWNJY29uJylcbmNvbnN0IENhcHR1cmVTY3JlZW4gPSByZXF1aXJlKCcuL0NhcHR1cmVTY3JlZW4nKVxuXG5jb25zdCBsb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZScpXG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXRVc2VyTWVkaWFcbmZ1bmN0aW9uIGdldE1lZGlhRGV2aWNlcyAoKSB7XG4gIC8vIGNoZWNrIGlmIHNjcmVlbiBjYXB0dXJpbmcgaXMgc3VwcG9ydGVkXG4gIHJldHVybiB3aW5kb3cuTWVkaWFSZWNvcmRlciAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxufVxuXG4vKipcbiAqIFNjcmVlbiBjYXB0dXJlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2NyZWVuQ2FwdHVyZSBleHRlbmRzIFVJUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMubWVkaWFEZXZpY2VzID0gZ2V0TWVkaWFEZXZpY2VzKClcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgdGhpcy5wcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICdodHRwcycgOiAnaHR0cCdcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdTY3JlZW5DYXB0dXJlJ1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ1NjcmVlbmNhc3QnXG4gICAgdGhpcy50eXBlID0gJ2FjcXVpcmVyJ1xuICAgIHRoaXMuaWNvbiA9IFNjcmVlblJlY0ljb25cblxuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGxvY2FsZVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVN0cmVhbUNvbnN0cmFpbnRzXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzI1Byb3BlcnRpZXNfb2Zfc2hhcmVkX3NjcmVlbl90cmFja3NcbiAgICAgIGRpc3BsYXlNZWRpYUNvbnN0cmFpbnRzOiB7XG4gICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgd2lkdGg6IDEyODAsXG4gICAgICAgICAgaGVpZ2h0OiA3MjAsXG4gICAgICAgICAgZnJhbWVSYXRlOiB7XG4gICAgICAgICAgICBpZGVhbDogMyxcbiAgICAgICAgICAgIG1heDogNSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1cnNvcjogJ21vdGlvbicsXG4gICAgICAgICAgZGlzcGxheVN1cmZhY2U6ICdtb25pdG9yJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFTdHJlYW1Db25zdHJhaW50cy9hdWRpb1xuICAgICAgdXNlck1lZGlhQ29uc3RyYWludHM6IHtcbiAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICB9LFxuICAgICAgcHJlZmVycmVkVmlkZW9NaW1lVHlwZTogJ3ZpZGVvL3dlYm0nLFxuICAgIH1cblxuICAgIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICAvLyBpMThuXG4gICAgdGhpcy5pMThuSW5pdCgpXG5cbiAgICAvLyB1cHB5IHBsdWdpbiBjbGFzcyByZWxhdGVkXG4gICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlID0gdGhpcy5zZXRQbHVnaW5TdGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICAvLyBzY3JlZW4gY2FwdHVyZXIgcmVsYXRlZFxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLnN0b3AgPSB0aGlzLnN0b3AuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcgPSB0aGlzLnN0YXJ0UmVjb3JkaW5nLmJpbmQodGhpcylcbiAgICB0aGlzLnN0b3BSZWNvcmRpbmcgPSB0aGlzLnN0b3BSZWNvcmRpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuc3VibWl0ID0gdGhpcy5zdWJtaXQuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RyZWFtSW50ZXJydXB0ZWQgPSB0aGlzLnN0cmVhbUluYWN0aXZhdGVkLmJpbmQodGhpcylcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB0aGlzLmNhcHR1cmVBY3RpdmUgPSBmYWxzZVxuICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBudWxsXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICAvLyBSZXR1cm4gaWYgYnJvd3NlciBkb2VzbuKAmXQgc3VwcG9ydCBnZXREaXNwbGF5TWVkaWEgYW5kXG4gICAgaWYgKCF0aGlzLm1lZGlhRGV2aWNlcykge1xuICAgICAgdGhpcy51cHB5LmxvZygnU2NyZWVuIHJlY29yZGVyIGFjY2VzcyBpcyBub3Qgc3VwcG9ydGVkJywgJ2Vycm9yJylcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBzdHJlYW1BY3RpdmU6IGZhbHNlLFxuICAgICAgYXVkaW9TdHJlYW1BY3RpdmU6IGZhbHNlLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICBpZiAodGhpcy52aWRlb1N0cmVhbSkge1xuICAgICAgdGhpcy5zdG9wKClcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgc3RhcnQgKCkge1xuICAgIGlmICghdGhpcy5tZWRpYURldmljZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1NjcmVlbiByZWNvcmRlciBhY2Nlc3Mgbm90IHN1cHBvcnRlZCcpKVxuICAgIH1cblxuICAgIHRoaXMuY2FwdHVyZUFjdGl2ZSA9IHRydWVcblxuICAgIHRoaXMuc2VsZWN0QXVkaW9TdHJlYW1Tb3VyY2UoKVxuXG4gICAgdGhpcy5zZWxlY3RWaWRlb1N0cmVhbVNvdXJjZSgpXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAvLyBzb21ldGhpbmcgaGFwcGVuZWQgaW4gc3RhcnQgLT4gcmV0dXJuXG4gICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gQ2xvc2UgdGhlIERhc2hib2FyZCBwYW5lbCBpZiBwbHVnaW4gaXMgaW5zdGFsbGVkXG4gICAgICAgICAgLy8gaW50byBEYXNoYm9hcmQgKGNvdWxkIGJlIG90aGVyIHBhcmVudCBVSSBwbHVnaW4pXG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmhpZGVBbGxQYW5lbHMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmhpZGVBbGxQYW5lbHMoKVxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQWN0aXZlID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBzZWxlY3RWaWRlb1N0cmVhbVNvdXJjZSAoKSB7XG4gICAgLy8gaWYgYWN0aXZlIHN0cmVhbSBhdmFpbGFibGUsIHJldHVybiBpdFxuICAgIGlmICh0aGlzLnZpZGVvU3RyZWFtKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXNvbHZlKHRoaXMudmlkZW9TdHJlYW0pKVxuICAgIH1cblxuICAgIC8vIGFzayB1c2VyIHRvIHNlbGVjdCBzb3VyY2UgdG8gcmVjb3JkIGFuZCBnZXQgbWVkaWFzdHJlYW0gZnJvbSB0aGF0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICByZXR1cm4gdGhpcy5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHRoaXMub3B0cy5kaXNwbGF5TWVkaWFDb25zdHJhaW50cylcbiAgICAgIC50aGVuKCh2aWRlb1N0cmVhbSkgPT4ge1xuICAgICAgICB0aGlzLnZpZGVvU3RyZWFtID0gdmlkZW9TdHJlYW1cblxuICAgICAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXIgdG8gc3RvcCByZWNvcmRpbmcgaWYgc3RyZWFtIGlzIGludGVycnVwdGVkXG4gICAgICAgIHRoaXMudmlkZW9TdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignaW5hY3RpdmUnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdHJlYW1JbmFjdGl2YXRlZCgpXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgc3RyZWFtQWN0aXZlOiB0cnVlLFxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB2aWRlb1N0cmVhbVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAgIHNjcmVlblJlY0Vycm9yOiBlcnIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy51c2VyRGVuaWVkID0gdHJ1ZVxuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMudXNlckRlbmllZCA9IGZhbHNlXG4gICAgICAgIH0sIDEwMDApXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9KVxuICB9XG5cbiAgc2VsZWN0QXVkaW9TdHJlYW1Tb3VyY2UgKCkge1xuICAgIC8vIGlmIGFjdGl2ZSBzdHJlYW0gYXZhaWxhYmxlLCByZXR1cm4gaXRcbiAgICBpZiAodGhpcy5hdWRpb1N0cmVhbSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gcmVzb2x2ZSh0aGlzLmF1ZGlvU3RyZWFtKSlcbiAgICB9XG5cbiAgICAvLyBhc2sgdXNlciB0byBzZWxlY3Qgc291cmNlIHRvIHJlY29yZCBhbmQgZ2V0IG1lZGlhc3RyZWFtIGZyb20gdGhhdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgcmV0dXJuIHRoaXMubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh0aGlzLm9wdHMudXNlck1lZGlhQ29uc3RyYWludHMpXG4gICAgICAudGhlbigoYXVkaW9TdHJlYW0pID0+IHtcbiAgICAgICAgdGhpcy5hdWRpb1N0cmVhbSA9IGF1ZGlvU3RyZWFtXG5cbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgYXVkaW9TdHJlYW1BY3RpdmU6IHRydWUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIGF1ZGlvU3RyZWFtXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVyci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICAgIHRoaXMudXBweS5pbmZvKHRoaXMuaTE4bignbWljRGlzYWJsZWQnKSwgJ2Vycm9yJywgNTAwMClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSlcbiAgfVxuXG4gIHN0YXJ0UmVjb3JkaW5nICgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge31cbiAgICB0aGlzLmNhcHR1cmVkTWVkaWFGaWxlID0gbnVsbFxuICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gW11cbiAgICBjb25zdCB7IHByZWZlcnJlZFZpZGVvTWltZVR5cGUgfSA9IHRoaXMub3B0c1xuXG4gICAgdGhpcy5zZWxlY3RWaWRlb1N0cmVhbVNvdXJjZSgpXG4gICAgICAudGhlbigodmlkZW9TdHJlYW0pID0+IHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byB1c2UgdGhlIHBhc3NlZCBwcmVmZXJyZWRWaWRlb01pbWVUeXBlIChpZiBhbnkpIGR1cmluZyByZWNvcmRpbmcuXG4gICAgICAgIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpdCwgd2UnbGwgZmFsbCBiYWNrIHRvIHRoZSBicm93c2VyIGRlZmF1bHQgaW5zdGVhZFxuICAgICAgICBpZiAocHJlZmVycmVkVmlkZW9NaW1lVHlwZVxuICAgICAgICAgICAgJiYgTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQocHJlZmVycmVkVmlkZW9NaW1lVHlwZSlcbiAgICAgICAgICAgICYmIGdldEZpbGVUeXBlRXh0ZW5zaW9uKHByZWZlcnJlZFZpZGVvTWltZVR5cGUpKSB7XG4gICAgICAgICAgb3B0aW9ucy5taW1lVHlwZSA9IHByZWZlcnJlZFZpZGVvTWltZVR5cGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXBhcmUgdHJhY2tzXG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IFt2aWRlb1N0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdXVxuXG4gICAgICAgIC8vIG1lcmdlIGF1ZGlvIGlmIGV4aXRzXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvU3RyZWFtKSB7XG4gICAgICAgICAgdHJhY2tzLnB1c2godGhpcy5hdWRpb1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBzdHJlYW0gZnJvbSB2aWRlbyBhbmQgYXVkaW9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0odHJhY2tzKVxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgbWVkaWFyZWNvcmRlclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgICAgICB0aGlzLnJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIodGhpcy5vdXRwdXRTdHJlYW0sIG9wdGlvbnMpXG5cbiAgICAgICAgLy8gcHVzaCBkYXRhIHRvIGJ1ZmZlciB3aGVuIGRhdGEgYXZhaWxhYmxlXG4gICAgICAgIHRoaXMucmVjb3JkZXIuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIChldmVudCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzLnB1c2goZXZlbnQuZGF0YSlcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBzdGFydCByZWNvcmRpbmdcbiAgICAgICAgdGhpcy5yZWNvcmRlci5zdGFydCgpXG5cbiAgICAgICAgLy8gc2V0IHBsdWdpbiBzdGF0ZSB0byByZWNvcmRpbmdcbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgcmVjb3JkaW5nOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyLCAnZXJyb3InKVxuICAgICAgfSlcbiAgfVxuXG4gIHN0cmVhbUluYWN0aXZhdGVkICgpIHtcbiAgICAvLyBnZXQgc2NyZWVuIHJlY29yZGVyIHN0YXRlXG4gICAgY29uc3QgeyByZWNvcmRlZFZpZGVvLCByZWNvcmRpbmcgfSA9IHsgLi4udGhpcy5nZXRQbHVnaW5TdGF0ZSgpIH1cblxuICAgIGlmICghcmVjb3JkZWRWaWRlbyAmJiAhcmVjb3JkaW5nKSB7XG4gICAgICAvLyBDbG9zZSB0aGUgRGFzaGJvYXJkIHBhbmVsIGlmIHBsdWdpbiBpcyBpbnN0YWxsZWRcbiAgICAgIC8vIGludG8gRGFzaGJvYXJkIChjb3VsZCBiZSBvdGhlciBwYXJlbnQgVUkgcGx1Z2luKVxuICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmhpZGVBbGxQYW5lbHMpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaGlkZUFsbFBhbmVscygpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNvcmRpbmcpIHtcbiAgICAgIC8vIHN0b3AgcmVjb3JkZXIgaWYgaXQgaXMgYWN0aXZlXG4gICAgICB0aGlzLnVwcHkubG9nKCdDYXB0dXJlIHN0cmVhbSBpbmFjdGl2ZSDigJQgc3RvcCByZWNvcmRpbmcnKVxuICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nKClcbiAgICB9XG5cbiAgICB0aGlzLnZpZGVvU3RyZWFtID0gbnVsbFxuICAgIHRoaXMuYXVkaW9TdHJlYW0gPSBudWxsXG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIHN0cmVhbUFjdGl2ZTogZmFsc2UsIGF1ZGlvU3RyZWFtQWN0aXZlOiBmYWxzZSxcbiAgICB9KVxuICB9XG5cbiAgc3RvcFJlY29yZGluZyAoKSB7XG4gICAgY29uc3Qgc3RvcHBlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5yZWNvcmRlci5zdG9wKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHN0b3BwZWQudGhlbigoKSA9PiB7XG4gICAgICAvLyByZWNvcmRpbmcgc3RvcHBlZFxuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIHJlY29yZGluZzogZmFsc2UsXG4gICAgICB9KVxuICAgICAgLy8gZ2V0IHZpZGVvIGZpbGUgYWZ0ZXIgcmVjb3JkZXIgc3RvcHBlZFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlkZW8oKVxuICAgIH0pLnRoZW4oKGZpbGUpID0+IHtcbiAgICAgIC8vIHN0b3JlIG1lZGlhIGZpbGVcbiAgICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBmaWxlXG5cbiAgICAgIC8vIGNyZWF0ZSBvYmplY3QgdXJsIGZvciBjYXB0dXJlIHJlc3VsdCBwcmV2aWV3XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgcmVjb3JkZWRWaWRlbzogVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlLmRhdGEpLFxuICAgICAgfSlcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIHN1Ym1pdCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGFkZCByZWNvcmRlZCBmaWxlIHRvIHVwcHlcbiAgICAgIGlmICh0aGlzLmNhcHR1cmVkTWVkaWFGaWxlKSB7XG4gICAgICAgIHRoaXMudXBweS5hZGRGaWxlKHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBMb2dnaW5nIHRoZSBlcnJvciwgZXhlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIsICdlcnJvcicpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgLy8gZmx1c2ggdmlkZW8gc3RyZWFtXG4gICAgaWYgKHRoaXMudmlkZW9TdHJlYW0pIHtcbiAgICAgIHRoaXMudmlkZW9TdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgICB0aGlzLnZpZGVvU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgdHJhY2suc3RvcCgpXG4gICAgICB9KVxuICAgICAgdGhpcy52aWRlb1N0cmVhbSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBmbHVzaCBhdWRpbyBzdHJlYW1cbiAgICBpZiAodGhpcy5hdWRpb1N0cmVhbSkge1xuICAgICAgdGhpcy5hdWRpb1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLnN0b3AoKVxuICAgICAgfSlcbiAgICAgIHRoaXMuYXVkaW9TdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgICB0aGlzLmF1ZGlvU3RyZWFtID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGZsdXNoIG91dHB1dCBzdHJlYW1cbiAgICBpZiAodGhpcy5vdXRwdXRTdHJlYW0pIHtcbiAgICAgIHRoaXMub3V0cHV0U3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgdHJhY2suc3RvcCgpXG4gICAgICB9KVxuICAgICAgdGhpcy5vdXRwdXRTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgICB0aGlzLm91dHB1dFN0cmVhbSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgcHJldmlldyB2aWRlb1xuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgcmVjb3JkZWRWaWRlbzogbnVsbCxcbiAgICB9KVxuXG4gICAgdGhpcy5jYXB0dXJlQWN0aXZlID0gZmFsc2VcbiAgfVxuXG4gIGdldFZpZGVvICgpIHtcbiAgICBjb25zdCBtaW1lVHlwZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzWzBdLnR5cGVcbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZ2V0RmlsZVR5cGVFeHRlbnNpb24obWltZVR5cGUpXG5cbiAgICBpZiAoIWZpbGVFeHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSByZWNvcmRpbmc6IFVuc3VwcG9ydGVkIG1lZGlhIHR5cGUgXCIke21pbWVUeXBlfVwiYCkpXG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGBzY3JlZW5jYXAtJHtEYXRlLm5vdygpfS4ke2ZpbGVFeHRlbnNpb259YFxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYih0aGlzLnJlY29yZGluZ0NodW5rcywgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgIGNvbnN0IGZpbGUgPSB7XG4gICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICBuYW1lLFxuICAgICAgZGF0YTogbmV3IEJsb2IoW2Jsb2JdLCB7IHR5cGU6IG1pbWVUeXBlIH0pLFxuICAgICAgdHlwZTogbWltZVR5cGUsXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmaWxlKVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICAvLyBnZXQgc2NyZWVuIHJlY29yZGVyIHN0YXRlXG4gICAgY29uc3QgcmVjb3JkZXJTdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgaWYgKCFyZWNvcmRlclN0YXRlLnN0cmVhbUFjdGl2ZSAmJiAhdGhpcy5jYXB0dXJlQWN0aXZlICYmICF0aGlzLnVzZXJEZW5pZWQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q2FwdHVyZVNjcmVlblxuICAgICAgICB7Li4ucmVjb3JkZXJTdGF0ZX1cbiAgICAgICAgb25TdGFydFJlY29yZGluZz17dGhpcy5zdGFydFJlY29yZGluZ31cbiAgICAgICAgb25TdG9wUmVjb3JkaW5nPXt0aGlzLnN0b3BSZWNvcmRpbmd9XG4gICAgICAgIG9uU3RvcD17dGhpcy5zdG9wfVxuICAgICAgICBvblN1Ym1pdD17dGhpcy5zdWJtaXR9XG4gICAgICAgIGkxOG49e3RoaXMuaTE4bn1cbiAgICAgICAgc3RyZWFtPXt0aGlzLnZpZGVvU3RyZWFtfVxuICAgICAgLz5cbiAgICApXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdzOiB7XG4gICAgc3RhcnRDYXB0dXJpbmc6ICdCZWdpbiBzY3JlZW4gY2FwdHVyaW5nJyxcbiAgICBzdG9wQ2FwdHVyaW5nOiAnU3RvcCBzY3JlZW4gY2FwdHVyaW5nJyxcbiAgICBzdWJtaXRSZWNvcmRlZEZpbGU6ICdTdWJtaXQgcmVjb3JkZWQgZmlsZScsXG4gICAgc3RyZWFtQWN0aXZlOiAnU3RyZWFtIGFjdGl2ZScsXG4gICAgc3RyZWFtUGFzc2l2ZTogJ1N0cmVhbSBwYXNzaXZlJyxcbiAgICBtaWNEaXNhYmxlZDogJ01pY3JvcGhvbmUgYWNjZXNzIGRlbmllZCBieSB1c2VyJyxcbiAgICByZWNvcmRpbmc6ICdSZWNvcmRpbmcnLFxuICB9LFxufVxuIiwiY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCdsb2Rhc2gudGhyb3R0bGUnKVxuY29uc3QgcHJldHRpZXJCeXRlcyA9IHJlcXVpcmUoJ0B0cmFuc2xvYWRpdC9wcmV0dGllci1ieXRlcycpXG5jb25zdCBwcmV0dHlFVEEgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcHJldHR5RVRBJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3Qgc3RhdHVzQmFyU3RhdGVzID0gcmVxdWlyZSgnLi9TdGF0dXNCYXJTdGF0ZXMnKVxuXG5jb25zdCBET1QgPSBgXFx1MDBCN2BcbmNvbnN0IHJlbmRlckRvdCA9ICgpID0+IGAgJHtET1R9IGBcblxuZnVuY3Rpb24gVXBsb2FkQnRuIChwcm9wcykge1xuICBjb25zdCB7XG4gICAgbmV3RmlsZXMsXG4gICAgaXNVcGxvYWRTdGFydGVkLFxuICAgIHJlY292ZXJlZFN0YXRlLFxuICAgIGkxOG4sXG4gICAgdXBsb2FkU3RhdGUsXG4gICAgaXNTb21lR2hvc3QsXG4gICAgc3RhcnRVcGxvYWQsXG4gIH0gPSBwcm9wc1xuXG4gIGNvbnN0IHVwbG9hZEJ0bkNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKFxuICAgICd1cHB5LXUtcmVzZXQnLFxuICAgICd1cHB5LWMtYnRuJyxcbiAgICAndXBweS1TdGF0dXNCYXItYWN0aW9uQnRuJyxcbiAgICAndXBweS1TdGF0dXNCYXItYWN0aW9uQnRuLS11cGxvYWQnLFxuICAgIHtcbiAgICAgICd1cHB5LWMtYnRuLXByaW1hcnknOiB1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkcsXG4gICAgfSxcbiAgICB7ICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLWRpc2FibGVkJzogaXNTb21lR2hvc3QgfSxcbiAgKVxuXG4gIGNvbnN0IHVwbG9hZEJ0blRleHQgPSBuZXdGaWxlcyAmJiBpc1VwbG9hZFN0YXJ0ZWQgJiYgIXJlY292ZXJlZFN0YXRlXG4gICAgPyBpMThuKCd1cGxvYWRYTmV3RmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBuZXdGaWxlcyB9KVxuICAgIDogaTE4bigndXBsb2FkWEZpbGVzJywgeyBzbWFydF9jb3VudDogbmV3RmlsZXMgfSlcblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgY2xhc3NOYW1lPXt1cGxvYWRCdG5DbGFzc05hbWVzfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bigndXBsb2FkWEZpbGVzJywgeyBzbWFydF9jb3VudDogbmV3RmlsZXMgfSl9XG4gICAgICBvbkNsaWNrPXtzdGFydFVwbG9hZH1cbiAgICAgIGRpc2FibGVkPXtpc1NvbWVHaG9zdH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICB7dXBsb2FkQnRuVGV4dH1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5mdW5jdGlvbiBSZXRyeUJ0biAocHJvcHMpIHtcbiAgY29uc3QgeyBpMThuLCB1cHB5IH0gPSBwcm9wc1xuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4gdXBweS1TdGF0dXNCYXItYWN0aW9uQnRuLS1yZXRyeVwiXG4gICAgICBhcmlhLWxhYmVsPXtpMThuKCdyZXRyeVVwbG9hZCcpfVxuICAgICAgb25DbGljaz17KCkgPT4gdXBweS5yZXRyeUFsbCgpfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIDxzdmdcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiXG4gICAgICAgIHdpZHRoPVwiOFwiXG4gICAgICAgIGhlaWdodD1cIjEwXCJcbiAgICAgICAgdmlld0JveD1cIjAgMCA4IDEwXCJcbiAgICAgID5cbiAgICAgICAgPHBhdGggZD1cIk00IDIuNDA4YTIuNzUgMi43NSAwIDEgMCAyLjc1IDIuNzUuNjI2LjYyNiAwIDAgMSAxLjI1LjAxOHYuMDIzYTQgNCAwIDEgMS00LTQuMDQxVi4yNWEuMjUuMjUgMCAwIDEgLjM4OS0uMjA4bDIuMjk5IDEuNTMzYS4yNS4yNSAwIDAgMSAwIC40MTZsLTIuMyAxLjUzM0EuMjUuMjUgMCAwIDEgNCAzLjMxNnYtLjkwOHpcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgICB7aTE4bigncmV0cnknKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5mdW5jdGlvbiBDYW5jZWxCdG4gKHByb3BzKSB7XG4gIGNvbnN0IHsgaTE4biwgdXBweSB9ID0gcHJvcHNcblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktU3RhdHVzQmFyLWFjdGlvbkNpcmNsZUJ0blwiXG4gICAgICB0aXRsZT17aTE4bignY2FuY2VsJyl9XG4gICAgICBhcmlhLWxhYmVsPXtpMThuKCdjYW5jZWwnKX1cbiAgICAgIG9uQ2xpY2s9eygpID0+IHVwcHkuY2FuY2VsQWxsKCl9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2Z1xuICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCJcbiAgICAgICAgd2lkdGg9XCIxNlwiXG4gICAgICAgIGhlaWdodD1cIjE2XCJcbiAgICAgICAgdmlld0JveD1cIjAgMCAxNiAxNlwiXG4gICAgICA+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPGNpcmNsZSBmaWxsPVwiIzg4OFwiIGN4PVwiOFwiIGN5PVwiOFwiIHI9XCI4XCIgLz5cbiAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgZmlsbD1cIiNGRkZcIlxuICAgICAgICAgICAgZD1cIk05LjI4MyA4bDIuNTY3IDIuNTY3LTEuMjgzIDEuMjgzTDggOS4yODMgNS40MzMgMTEuODUgNC4xNSAxMC41NjcgNi43MTcgOCA0LjE1IDUuNDMzIDUuNDMzIDQuMTUgOCA2LjcxN2wyLjU2Ny0yLjU2NyAxLjI4MyAxLjI4M3pcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbmZ1bmN0aW9uIFBhdXNlUmVzdW1lQnV0dG9uIChwcm9wcykge1xuICBjb25zdCB7IGlzQWxsUGF1c2VkLCBpMThuLCBpc0FsbENvbXBsZXRlLCByZXN1bWFibGVVcGxvYWRzLCB1cHB5IH0gPSBwcm9wc1xuICBjb25zdCB0aXRsZSA9IGlzQWxsUGF1c2VkID8gaTE4bigncmVzdW1lJykgOiBpMThuKCdwYXVzZScpXG5cbiAgZnVuY3Rpb24gdG9nZ2xlUGF1c2VSZXN1bWUgKCkge1xuICAgIGlmIChpc0FsbENvbXBsZXRlKSByZXR1cm4gbnVsbFxuXG4gICAgaWYgKCFyZXN1bWFibGVVcGxvYWRzKSB7XG4gICAgICByZXR1cm4gdXBweS5jYW5jZWxBbGwoKVxuICAgIH1cblxuICAgIGlmIChpc0FsbFBhdXNlZCkge1xuICAgICAgcmV0dXJuIHVwcHkucmVzdW1lQWxsKClcbiAgICB9XG5cbiAgICByZXR1cm4gdXBweS5wYXVzZUFsbCgpXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHRpdGxlPXt0aXRsZX1cbiAgICAgIGFyaWEtbGFiZWw9e3RpdGxlfVxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktU3RhdHVzQmFyLWFjdGlvbkNpcmNsZUJ0blwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIG9uQ2xpY2s9e3RvZ2dsZVBhdXNlUmVzdW1lfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIDxzdmdcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiXG4gICAgICAgIHdpZHRoPVwiMTZcIlxuICAgICAgICBoZWlnaHQ9XCIxNlwiXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgMTYgMTZcIlxuICAgICAgPlxuICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxjaXJjbGUgZmlsbD1cIiM4ODhcIiBjeD1cIjhcIiBjeT1cIjhcIiByPVwiOFwiIC8+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGZpbGw9XCIjRkZGXCJcbiAgICAgICAgICAgIGQ9e1xuICAgICAgICAgICAgICBpc0FsbFBhdXNlZFxuICAgICAgICAgICAgICAgID8gJ002IDQuMjVMMTEuNSA4IDYgMTEuNzV6J1xuICAgICAgICAgICAgICAgIDogJ001IDQuNWgydjdINXYtN3ptNCAwaDJ2N0g5di03eidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5mdW5jdGlvbiBEb25lQnRuIChwcm9wcykge1xuICBjb25zdCB7IGkxOG4sIGRvbmVCdXR0b25IYW5kbGVyIH0gPSBwcm9wc1xuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4gdXBweS1TdGF0dXNCYXItYWN0aW9uQnRuLS1kb25lXCJcbiAgICAgIG9uQ2xpY2s9e2RvbmVCdXR0b25IYW5kbGVyfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIHtpMThuKCdkb25lJyl9XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuZnVuY3Rpb24gTG9hZGluZ1NwaW5uZXIgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXNwaW5uZXJcIlxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgIHdpZHRoPVwiMTRcIlxuICAgICAgaGVpZ2h0PVwiMTRcIlxuICAgID5cbiAgICAgIDxwYXRoXG4gICAgICAgIGQ9XCJNMTMuOTgzIDYuNTQ3Yy0uMTItMi41MDktMS42NC00Ljg5My0zLjkzOS01LjkzNi0yLjQ4LTEuMTI3LTUuNDg4LS42NTYtNy41NTYgMS4wOTRDLjUyNCAzLjM2Ny0uMzk4IDYuMDQ4LjE2MiA4LjU2MmMuNTU2IDIuNDk1IDIuNDYgNC41MiA0Ljk0IDUuMTgzIDIuOTMyLjc4NCA1LjYxLS42MDIgNy4yNTYtMy4wMTUtMS40OTMgMS45OTMtMy43NDUgMy4zMDktNi4yOTggMi44NjgtMi41MTQtLjQzNC00LjU3OC0yLjM0OS01LjE1My00Ljg0YTYuMjI2IDYuMjI2IDAgMCAxIDIuOTgtNi43NzhDNi4zNC41ODYgOS43NCAxLjEgMTEuMzczIDMuNDkzYy40MDcuNTk2LjY5MyAxLjI4Mi44NDIgMS45ODguMTI3LjU5OC4wNzMgMS4xOTcuMTYxIDEuNzk0LjA3OC41MjUuNTQzIDEuMjU3IDEuMTUuODY0LjUyNS0uMzQxLjQ5LTEuMDUuNDU2LTEuNTkyLS4wMDctLjE1LjAyLjMgMCAwXCJcbiAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gUHJvZ3Jlc3NCYXJQcm9jZXNzaW5nIChwcm9wcykge1xuICBjb25zdCB7IHByb2dyZXNzIH0gPSBwcm9wc1xuICBjb25zdCB7IHZhbHVlLCBtb2RlLCBtZXNzYWdlIH0gPSBwcm9ncmVzc1xuICBjb25zdCByb3VuZGVkVmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKVxuICBjb25zdCBkb3QgPSBgXFx1MDBCN2BcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItY29udGVudFwiPlxuICAgICAgPExvYWRpbmdTcGlubmVyIC8+XG4gICAgICB7bW9kZSA9PT0gJ2RldGVybWluYXRlJyA/IGAke3JvdW5kZWRWYWx1ZX0lICR7ZG90fSBgIDogJyd9XG4gICAgICB7bWVzc2FnZX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5mdW5jdGlvbiBQcm9ncmVzc0RldGFpbHMgKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBudW1VcGxvYWRzLFxuICAgIGNvbXBsZXRlLFxuICAgIHRvdGFsVXBsb2FkZWRTaXplLFxuICAgIHRvdGFsU2l6ZSxcbiAgICB0b3RhbEVUQSxcbiAgICBpMThuLFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBpZlNob3dGaWxlc1VwbG9hZGVkT2ZUb3RhbCA9IG51bVVwbG9hZHMgPiAxXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1NlY29uZGFyeVwiPlxuICAgICAge2lmU2hvd0ZpbGVzVXBsb2FkZWRPZlRvdGFsXG4gICAgICAgICYmIGkxOG4oJ2ZpbGVzVXBsb2FkZWRPZlRvdGFsJywge1xuICAgICAgICAgIGNvbXBsZXRlLFxuICAgICAgICAgIHNtYXJ0X2NvdW50OiBudW1VcGxvYWRzLFxuICAgICAgICB9KX1cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWFkZGl0aW9uYWxJbmZvXCI+XG4gICAgICAgIHsvKiBXaGVuIHNob3VsZCB3ZSByZW5kZXIgdGhpcyBkb3Q/XG4gICAgICAgICAgMS4gLi1hZGRpdGlvbmFsSW5mbyBpcyBzaG93biAoaGFwcGVucyBvbmx5IG9uIGRlc2t0b3BzKVxuICAgICAgICAgIDIuIEFORCAnZmlsZXNVcGxvYWRlZE9mVG90YWwnIHdhcyBzaG93blxuICAgICAgICAqL31cbiAgICAgICAge2lmU2hvd0ZpbGVzVXBsb2FkZWRPZlRvdGFsICYmIHJlbmRlckRvdCgpfVxuXG4gICAgICAgIHtpMThuKCdkYXRhVXBsb2FkZWRPZlRvdGFsJywge1xuICAgICAgICAgIGNvbXBsZXRlOiBwcmV0dGllckJ5dGVzKHRvdGFsVXBsb2FkZWRTaXplKSxcbiAgICAgICAgICB0b3RhbDogcHJldHRpZXJCeXRlcyh0b3RhbFNpemUpLFxuICAgICAgICB9KX1cblxuICAgICAgICB7cmVuZGVyRG90KCl9XG5cbiAgICAgICAge2kxOG4oJ3hUaW1lTGVmdCcsIHtcbiAgICAgICAgICB0aW1lOiBwcmV0dHlFVEEodG90YWxFVEEpLFxuICAgICAgICB9KX1cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5mdW5jdGlvbiBGaWxlVXBsb2FkQ291bnQgKHByb3BzKSB7XG4gIGNvbnN0IHsgaTE4biwgY29tcGxldGUsIG51bVVwbG9hZHMgfSA9IHByb3BzXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1NlY29uZGFyeVwiPlxuICAgICAge2kxOG4oJ2ZpbGVzVXBsb2FkZWRPZlRvdGFsJywgeyBjb21wbGV0ZSwgc21hcnRfY291bnQ6IG51bVVwbG9hZHMgfSl9XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZnVuY3Rpb24gVXBsb2FkTmV3bHlBZGRlZEZpbGVzIChwcm9wcykge1xuICBjb25zdCB7IGkxOG4sIG5ld0ZpbGVzLCBzdGFydFVwbG9hZCB9ID0gcHJvcHNcbiAgY29uc3QgdXBsb2FkQnRuQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktdS1yZXNldCcsXG4gICAgJ3VwcHktYy1idG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLXVwbG9hZE5ld2x5QWRkZWQnLFxuICApXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1NlY29uZGFyeVwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNTZWNvbmRhcnlIaW50XCI+XG4gICAgICAgIHtpMThuKCd4TW9yZUZpbGVzQWRkZWQnLCB7IHNtYXJ0X2NvdW50OiBuZXdGaWxlcyB9KX1cbiAgICAgIDwvZGl2PlxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPXt1cGxvYWRCdG5DbGFzc05hbWVzfVxuICAgICAgICBhcmlhLWxhYmVsPXtpMThuKCd1cGxvYWRYRmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBuZXdGaWxlcyB9KX1cbiAgICAgICAgb25DbGljaz17c3RhcnRVcGxvYWR9XG4gICAgICA+XG4gICAgICAgIHtpMThuKCd1cGxvYWQnKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IFRocm90dGxlZFByb2dyZXNzRGV0YWlscyA9IHRocm90dGxlKFByb2dyZXNzRGV0YWlscywgNTAwLCB7XG4gIGxlYWRpbmc6IHRydWUsXG4gIHRyYWlsaW5nOiB0cnVlLFxufSlcblxuZnVuY3Rpb24gUHJvZ3Jlc3NCYXJVcGxvYWRpbmcgKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBpMThuLFxuICAgIHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MsXG4gICAgdG90YWxQcm9ncmVzcyxcbiAgICBzaG93UHJvZ3Jlc3NEZXRhaWxzLFxuICAgIGlzVXBsb2FkU3RhcnRlZCxcbiAgICBpc0FsbENvbXBsZXRlLFxuICAgIGlzQWxsUGF1c2VkLFxuICAgIG5ld0ZpbGVzLFxuICAgIG51bVVwbG9hZHMsXG4gICAgY29tcGxldGUsXG4gICAgdG90YWxVcGxvYWRlZFNpemUsXG4gICAgdG90YWxTaXplLFxuICAgIHRvdGFsRVRBLFxuICAgIHN0YXJ0VXBsb2FkLFxuICB9ID0gcHJvcHNcbiAgY29uc3Qgc2hvd1VwbG9hZE5ld2x5QWRkZWRGaWxlcyA9IG5ld0ZpbGVzICYmIGlzVXBsb2FkU3RhcnRlZFxuXG4gIGlmICghaXNVcGxvYWRTdGFydGVkIHx8IGlzQWxsQ29tcGxldGUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdGl0bGUgPSBpc0FsbFBhdXNlZCA/IGkxOG4oJ3BhdXNlZCcpIDogaTE4bigndXBsb2FkaW5nJylcblxuICBmdW5jdGlvbiByZW5kZXJQcm9ncmVzc0RldGFpbHMgKCkge1xuICAgIGlmICghaXNBbGxQYXVzZWQgJiYgIXNob3dVcGxvYWROZXdseUFkZGVkRmlsZXMgJiYgc2hvd1Byb2dyZXNzRGV0YWlscykge1xuICAgICAgaWYgKHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8VGhyb3R0bGVkUHJvZ3Jlc3NEZXRhaWxzXG4gICAgICAgICAgICBudW1VcGxvYWRzPXtudW1VcGxvYWRzfVxuICAgICAgICAgICAgY29tcGxldGU9e2NvbXBsZXRlfVxuICAgICAgICAgICAgdG90YWxVcGxvYWRlZFNpemU9e3RvdGFsVXBsb2FkZWRTaXplfVxuICAgICAgICAgICAgdG90YWxTaXplPXt0b3RhbFNpemV9XG4gICAgICAgICAgICB0b3RhbEVUQT17dG90YWxFVEF9XG4gICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgIC8+XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxGaWxlVXBsb2FkQ291bnRcbiAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgIGNvbXBsZXRlPXtjb21wbGV0ZX1cbiAgICAgICAgICBudW1VcGxvYWRzPXtudW1VcGxvYWRzfVxuICAgICAgICAvPlxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWNvbnRlbnRcIiBhcmlhLWxhYmVsPXt0aXRsZX0gdGl0bGU9e3RpdGxlfT5cbiAgICAgIHshaXNBbGxQYXVzZWQgPyA8TG9hZGluZ1NwaW5uZXIgLz4gOiBudWxsfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNQcmltYXJ5XCI+XG4gICAgICAgICAge3N1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MgPyBgJHt0aXRsZX06ICR7dG90YWxQcm9ncmVzc30lYCA6IHRpdGxlfVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICB7cmVuZGVyUHJvZ3Jlc3NEZXRhaWxzKCl9XG5cbiAgICAgICAge3Nob3dVcGxvYWROZXdseUFkZGVkRmlsZXMgPyAoXG4gICAgICAgICAgPFVwbG9hZE5ld2x5QWRkZWRGaWxlc1xuICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgIG5ld0ZpbGVzPXtuZXdGaWxlc31cbiAgICAgICAgICAgIHN0YXJ0VXBsb2FkPXtzdGFydFVwbG9hZH1cbiAgICAgICAgICAvPlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmZ1bmN0aW9uIFByb2dyZXNzQmFyQ29tcGxldGUgKHByb3BzKSB7XG4gIGNvbnN0IHsgaTE4biB9ID0gcHJvcHNcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWNvbnRlbnRcIlxuICAgICAgcm9sZT1cInN0YXR1c1wiXG4gICAgICB0aXRsZT17aTE4bignY29tcGxldGUnKX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1ByaW1hcnlcIj5cbiAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzSW5kaWNhdG9yIHVwcHktYy1pY29uXCJcbiAgICAgICAgICAgIHdpZHRoPVwiMTVcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMTFcIlxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCAxNSAxMVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0uNDE0IDUuODQzTDEuNjI3IDQuNjNsMy40NzIgMy40NzJMMTMuMjAyIDBsMS4yMTIgMS4yMTNMNS4xIDEwLjUyOHpcIiAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIHtpMThuKCdjb21wbGV0ZScpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmZ1bmN0aW9uIFByb2dyZXNzQmFyRXJyb3IgKHByb3BzKSB7XG4gIGNvbnN0IHsgZXJyb3IsIGkxOG4sIGNvbXBsZXRlLCBudW1VcGxvYWRzIH0gPSBwcm9wc1xuXG4gIGZ1bmN0aW9uIGRpc3BsYXlFcnJvckFsZXJ0ICgpIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgJHtpMThuKCd1cGxvYWRGYWlsZWQnKX0gXFxuXFxuICR7ZXJyb3J9YFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hbGVydFxuICAgIGFsZXJ0KGVycm9yTWVzc2FnZSkgLy8gVE9ETzogbW92ZSB0byBjdXN0b20gYWxlcnQgaW1wbGVtZW50YXRpb25cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1jb250ZW50XCIgdGl0bGU9e2kxOG4oJ3VwbG9hZEZhaWxlZCcpfT5cbiAgICAgIDxzdmdcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNJbmRpY2F0b3IgdXBweS1jLWljb25cIlxuICAgICAgICB3aWR0aD1cIjExXCJcbiAgICAgICAgaGVpZ2h0PVwiMTFcIlxuICAgICAgICB2aWV3Qm94PVwiMCAwIDExIDExXCJcbiAgICAgID5cbiAgICAgICAgPHBhdGggZD1cIk00LjI3OCA1LjVMMCAxLjIyMiAxLjIyMiAwIDUuNSA0LjI3OCA5Ljc3OCAwIDExIDEuMjIyIDYuNzIyIDUuNSAxMSA5Ljc3OCA5Ljc3OCAxMSA1LjUgNi43MjIgMS4yMjIgMTEgMCA5Ljc3OHpcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1ByaW1hcnlcIj5cbiAgICAgICAgICB7aTE4bigndXBsb2FkRmFpbGVkJyl9XG5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1TdGF0dXNCYXItZGV0YWlsc1wiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPXtpMThuKCdzaG93RXJyb3JEZXRhaWxzJyl9XG4gICAgICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wLXJpZ2h0XCJcbiAgICAgICAgICAgIGRhdGEtbWljcm90aXAtc2l6ZT1cIm1lZGl1bVwiXG4gICAgICAgICAgICBvbkNsaWNrPXtkaXNwbGF5RXJyb3JBbGVydH1cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgID9cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPEZpbGVVcGxvYWRDb3VudCBpMThuPXtpMThufSBjb21wbGV0ZT17Y29tcGxldGV9IG51bVVwbG9hZHM9e251bVVwbG9hZHN9IC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVXBsb2FkQnRuLFxuICBSZXRyeUJ0bixcbiAgQ2FuY2VsQnRuLFxuICBQYXVzZVJlc3VtZUJ1dHRvbixcbiAgRG9uZUJ0bixcbiAgTG9hZGluZ1NwaW5uZXIsXG4gIFByb2dyZXNzRGV0YWlscyxcbiAgUHJvZ3Jlc3NCYXJQcm9jZXNzaW5nLFxuICBQcm9ncmVzc0JhckVycm9yLFxuICBQcm9ncmVzc0JhclVwbG9hZGluZyxcbiAgUHJvZ3Jlc3NCYXJDb21wbGV0ZSxcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IHN0YXR1c0JhclN0YXRlcyA9IHJlcXVpcmUoJy4vU3RhdHVzQmFyU3RhdGVzJylcbmNvbnN0IGNhbGN1bGF0ZVByb2Nlc3NpbmdQcm9ncmVzcyA9IHJlcXVpcmUoJy4vY2FsY3VsYXRlUHJvY2Vzc2luZ1Byb2dyZXNzJylcblxuY29uc3Qge1xuICBVcGxvYWRCdG4sXG4gIFJldHJ5QnRuLFxuICBDYW5jZWxCdG4sXG4gIFBhdXNlUmVzdW1lQnV0dG9uLFxuICBEb25lQnRuLFxuICBQcm9ncmVzc0JhclByb2Nlc3NpbmcsXG4gIFByb2dyZXNzQmFyRXJyb3IsXG4gIFByb2dyZXNzQmFyVXBsb2FkaW5nLFxuICBQcm9ncmVzc0JhckNvbXBsZXRlLFxufSA9IHJlcXVpcmUoJy4vQ29tcG9uZW50cycpXG5cbmNvbnN0IHtcbiAgU1RBVEVfRVJST1IsXG4gIFNUQVRFX1dBSVRJTkcsXG4gIFNUQVRFX1BSRVBST0NFU1NJTkcsXG4gIFNUQVRFX1VQTE9BRElORyxcbiAgU1RBVEVfUE9TVFBST0NFU1NJTkcsXG4gIFNUQVRFX0NPTVBMRVRFLFxufSA9IHN0YXR1c0JhclN0YXRlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXR1c0JhclxuXG5mdW5jdGlvbiBTdGF0dXNCYXIgKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBuZXdGaWxlcyxcbiAgICBhbGxvd05ld1VwbG9hZCxcbiAgICBpc1VwbG9hZEluUHJvZ3Jlc3MsXG4gICAgaXNBbGxQYXVzZWQsXG4gICAgcmVzdW1hYmxlVXBsb2FkcyxcbiAgICBlcnJvcixcbiAgICBoaWRlVXBsb2FkQnV0dG9uLFxuICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbixcbiAgICBoaWRlQ2FuY2VsQnV0dG9uLFxuICAgIGhpZGVSZXRyeUJ1dHRvbixcbiAgICByZWNvdmVyZWRTdGF0ZSxcbiAgICB1cGxvYWRTdGF0ZSxcbiAgICB0b3RhbFByb2dyZXNzLFxuICAgIGZpbGVzLFxuICAgIHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MsXG4gICAgaGlkZUFmdGVyRmluaXNoLFxuICAgIGlzU29tZUdob3N0LFxuICAgIGlzVGFyZ2V0RE9NRWwsXG4gICAgZG9uZUJ1dHRvbkhhbmRsZXIsXG4gICAgaXNVcGxvYWRTdGFydGVkLFxuICAgIGkxOG4sXG4gICAgc3RhcnRVcGxvYWQsXG4gICAgdXBweSxcbiAgICBpc0FsbENvbXBsZXRlLFxuICAgIHNob3dQcm9ncmVzc0RldGFpbHMsXG4gICAgbnVtVXBsb2FkcyxcbiAgICBjb21wbGV0ZSxcbiAgICB0b3RhbFNpemUsXG4gICAgdG90YWxFVEEsXG4gICAgdG90YWxVcGxvYWRlZFNpemUsXG4gIH0gPSBwcm9wc1xuXG4gIGZ1bmN0aW9uIGdldFByb2dyZXNzVmFsdWUgKCkge1xuICAgIHN3aXRjaCAodXBsb2FkU3RhdGUpIHtcbiAgICAgIGNhc2UgU1RBVEVfUE9TVFBST0NFU1NJTkc6XG4gICAgICBjYXNlIFNUQVRFX1BSRVBST0NFU1NJTkc6IHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBjYWxjdWxhdGVQcm9jZXNzaW5nUHJvZ3Jlc3MoZmlsZXMpXG5cbiAgICAgICAgaWYgKHByb2dyZXNzLm1vZGUgPT09ICdkZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3MudmFsdWUgKiAxMDBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxQcm9ncmVzc1xuICAgICAgfVxuICAgICAgY2FzZSBTVEFURV9FUlJPUjoge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY2FzZSBTVEFURV9VUExPQURJTkc6IHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c1VwbG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxQcm9ncmVzc1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRvdGFsUHJvZ3Jlc3NcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0luZGV0ZXJtaW5hdGUgKCkge1xuICAgIHN3aXRjaCAodXBsb2FkU3RhdGUpIHtcbiAgICAgIGNhc2UgU1RBVEVfUE9TVFBST0NFU1NJTkc6XG4gICAgICBjYXNlIFNUQVRFX1BSRVBST0NFU1NJTkc6IHtcbiAgICAgICAgY29uc3QgeyBtb2RlIH0gPSBjYWxjdWxhdGVQcm9jZXNzaW5nUHJvZ3Jlc3MoZmlsZXMpXG4gICAgICAgIHJldHVybiBtb2RlID09PSAnaW5kZXRlcm1pbmF0ZSdcbiAgICAgIH1cbiAgICAgIGNhc2UgU1RBVEVfVVBMT0FESU5HOiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNVcGxvYWRQcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0hpZGRlbiAoKSB7XG4gICAgaWYgKHJlY292ZXJlZFN0YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHVwbG9hZFN0YXRlKSB7XG4gICAgICBjYXNlIFNUQVRFX1dBSVRJTkc6XG4gICAgICAgIHJldHVybiBoaWRlVXBsb2FkQnV0dG9uIHx8IG5ld0ZpbGVzID09PSAwXG4gICAgICBjYXNlIFNUQVRFX0NPTVBMRVRFOlxuICAgICAgICByZXR1cm4gaGlkZUFmdGVyRmluaXNoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm9ncmVzc1ZhbHVlID0gZ2V0UHJvZ3Jlc3NWYWx1ZSgpXG5cbiAgY29uc3QgaXNIaWRkZW4gPSBnZXRJc0hpZGRlbigpXG5cbiAgY29uc3Qgd2lkdGggPSBwcm9ncmVzc1ZhbHVlID8/IDEwMFxuXG4gIGNvbnN0IHNob3dVcGxvYWRCdG4gPSAhZXJyb3JcbiAgICAmJiBuZXdGaWxlc1xuICAgICYmICFpc1VwbG9hZEluUHJvZ3Jlc3NcbiAgICAmJiAhaXNBbGxQYXVzZWRcbiAgICAmJiBhbGxvd05ld1VwbG9hZFxuICAgICYmICFoaWRlVXBsb2FkQnV0dG9uXG5cbiAgY29uc3Qgc2hvd0NhbmNlbEJ0biA9ICFoaWRlQ2FuY2VsQnV0dG9uXG4gICAgJiYgdXBsb2FkU3RhdGUgIT09IFNUQVRFX1dBSVRJTkdcbiAgICAmJiB1cGxvYWRTdGF0ZSAhPT0gU1RBVEVfQ09NUExFVEVcblxuICBjb25zdCBzaG93UGF1c2VSZXN1bWVCdG4gPSByZXN1bWFibGVVcGxvYWRzXG4gICAgJiYgIWhpZGVQYXVzZVJlc3VtZUJ1dHRvblxuICAgICYmIHVwbG9hZFN0YXRlID09PSBTVEFURV9VUExPQURJTkdcblxuICBjb25zdCBzaG93UmV0cnlCdG4gPSBlcnJvciAmJiAhaXNBbGxDb21wbGV0ZSAmJiAhaGlkZVJldHJ5QnV0dG9uXG5cbiAgY29uc3Qgc2hvd0RvbmVCdG4gPSBkb25lQnV0dG9uSGFuZGxlciAmJiB1cGxvYWRTdGF0ZSA9PT0gU1RBVEVfQ09NUExFVEVcblxuICBjb25zdCBwcm9ncmVzc0NsYXNzTmFtZXMgPSBjbGFzc05hbWVzKCd1cHB5LVN0YXR1c0Jhci1wcm9ncmVzcycsIHtcbiAgICAnaXMtaW5kZXRlcm1pbmF0ZSc6IGdldElzSW5kZXRlcm1pbmF0ZSgpLFxuICB9KVxuXG4gIGNvbnN0IHN0YXR1c0JhckNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKFxuICAgIHsgJ3VwcHktUm9vdCc6IGlzVGFyZ2V0RE9NRWwgfSxcbiAgICAndXBweS1TdGF0dXNCYXInLFxuICAgIGBpcy0ke3VwbG9hZFN0YXRlfWAsXG4gICAgeyAnaGFzLWdob3N0cyc6IGlzU29tZUdob3N0IH0sXG4gIClcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdGF0dXNCYXJDbGFzc05hbWVzfSBhcmlhLWhpZGRlbj17aXNIaWRkZW59PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e3Byb2dyZXNzQ2xhc3NOYW1lc31cbiAgICAgICAgc3R5bGU9e3sgd2lkdGg6IGAke3dpZHRofSVgIH19XG4gICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXG4gICAgICAgIGFyaWEtbGFiZWw9e2Ake3dpZHRofSVgfVxuICAgICAgICBhcmlhLXZhbHVldGV4dD17YCR7d2lkdGh9JWB9XG4gICAgICAgIGFyaWEtdmFsdWVtaW49XCIwXCJcbiAgICAgICAgYXJpYS12YWx1ZW1heD1cIjEwMFwiXG4gICAgICAgIGFyaWEtdmFsdWVub3c9e3Byb2dyZXNzVmFsdWV9XG4gICAgICAvPlxuXG4gICAgICB7KCgpID0+IHtcbiAgICAgICAgc3dpdGNoICh1cGxvYWRTdGF0ZSkge1xuICAgICAgICAgIGNhc2UgU1RBVEVfUFJFUFJPQ0VTU0lORzpcbiAgICAgICAgICBjYXNlIFNUQVRFX1BPU1RQUk9DRVNTSU5HOlxuICAgICAgICAgICAgcmV0dXJuIDxQcm9ncmVzc0JhclByb2Nlc3NpbmcgcHJvZ3Jlc3M9e2NhbGN1bGF0ZVByb2Nlc3NpbmdQcm9ncmVzcyhmaWxlcyl9IC8+XG4gICAgICAgICAgY2FzZSBTVEFURV9DT01QTEVURTpcbiAgICAgICAgICAgIHJldHVybiA8UHJvZ3Jlc3NCYXJDb21wbGV0ZSBpMThuPXtpMThufSAvPlxuICAgICAgICAgIGNhc2UgU1RBVEVfRVJST1I6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8UHJvZ3Jlc3NCYXJFcnJvclxuICAgICAgICAgICAgICAgIGVycm9yPXtlcnJvcn1cbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIG51bVVwbG9hZHM9e251bVVwbG9hZHN9XG4gICAgICAgICAgICAgICAgY29tcGxldGU9e2NvbXBsZXRlfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKVxuICAgICAgICAgIGNhc2UgU1RBVEVfVVBMT0FESU5HOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPFByb2dyZXNzQmFyVXBsb2FkaW5nXG4gICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICBzdXBwb3J0c1VwbG9hZFByb2dyZXNzPXtzdXBwb3J0c1VwbG9hZFByb2dyZXNzfVxuICAgICAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3M9e3RvdGFsUHJvZ3Jlc3N9XG4gICAgICAgICAgICAgICAgc2hvd1Byb2dyZXNzRGV0YWlscz17c2hvd1Byb2dyZXNzRGV0YWlsc31cbiAgICAgICAgICAgICAgICBpc1VwbG9hZFN0YXJ0ZWQ9e2lzVXBsb2FkU3RhcnRlZH1cbiAgICAgICAgICAgICAgICBpc0FsbENvbXBsZXRlPXtpc0FsbENvbXBsZXRlfVxuICAgICAgICAgICAgICAgIGlzQWxsUGF1c2VkPXtpc0FsbFBhdXNlZH1cbiAgICAgICAgICAgICAgICBuZXdGaWxlcz17bmV3RmlsZXN9XG4gICAgICAgICAgICAgICAgbnVtVXBsb2Fkcz17bnVtVXBsb2Fkc31cbiAgICAgICAgICAgICAgICBjb21wbGV0ZT17Y29tcGxldGV9XG4gICAgICAgICAgICAgICAgdG90YWxVcGxvYWRlZFNpemU9e3RvdGFsVXBsb2FkZWRTaXplfVxuICAgICAgICAgICAgICAgIHRvdGFsU2l6ZT17dG90YWxTaXplfVxuICAgICAgICAgICAgICAgIHRvdGFsRVRBPXt0b3RhbEVUQX1cbiAgICAgICAgICAgICAgICBzdGFydFVwbG9hZD17c3RhcnRVcGxvYWR9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0pKCl9XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItYWN0aW9uc1wiPlxuICAgICAgICB7cmVjb3ZlcmVkU3RhdGUgfHwgc2hvd1VwbG9hZEJ0biA/IChcbiAgICAgICAgICA8VXBsb2FkQnRuXG4gICAgICAgICAgICBuZXdGaWxlcz17bmV3RmlsZXN9XG4gICAgICAgICAgICBpc1VwbG9hZFN0YXJ0ZWQ9e2lzVXBsb2FkU3RhcnRlZH1cbiAgICAgICAgICAgIHJlY292ZXJlZFN0YXRlPXtyZWNvdmVyZWRTdGF0ZX1cbiAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICBpc1NvbWVHaG9zdD17aXNTb21lR2hvc3R9XG4gICAgICAgICAgICBzdGFydFVwbG9hZD17c3RhcnRVcGxvYWR9XG4gICAgICAgICAgICB1cGxvYWRTdGF0ZT17dXBsb2FkU3RhdGV9XG4gICAgICAgICAgLz5cbiAgICAgICAgKSA6IG51bGx9XG5cbiAgICAgICAge3Nob3dSZXRyeUJ0biA/IDxSZXRyeUJ0biBpMThuPXtpMThufSB1cHB5PXt1cHB5fSAvPiA6IG51bGx9XG5cbiAgICAgICAge3Nob3dQYXVzZVJlc3VtZUJ0biA/IChcbiAgICAgICAgICA8UGF1c2VSZXN1bWVCdXR0b25cbiAgICAgICAgICAgIGlzQWxsUGF1c2VkPXtpc0FsbFBhdXNlZH1cbiAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICBpc0FsbENvbXBsZXRlPXtpc0FsbENvbXBsZXRlfVxuICAgICAgICAgICAgcmVzdW1hYmxlVXBsb2Fkcz17cmVzdW1hYmxlVXBsb2Fkc31cbiAgICAgICAgICAgIHVwcHk9e3VwcHl9XG4gICAgICAgICAgLz5cbiAgICAgICAgKSA6IG51bGx9XG5cbiAgICAgICAge3Nob3dDYW5jZWxCdG4gPyA8Q2FuY2VsQnRuIGkxOG49e2kxOG59IHVwcHk9e3VwcHl9IC8+IDogbnVsbH1cblxuICAgICAgICB7c2hvd0RvbmVCdG4gPyAoXG4gICAgICAgICAgPERvbmVCdG4gaTE4bj17aTE4bn0gZG9uZUJ1dHRvbkhhbmRsZXI9e2RvbmVCdXR0b25IYW5kbGVyfSAvPlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgU1RBVEVfRVJST1I6ICdlcnJvcicsXG4gIFNUQVRFX1dBSVRJTkc6ICd3YWl0aW5nJyxcbiAgU1RBVEVfUFJFUFJPQ0VTU0lORzogJ3ByZXByb2Nlc3NpbmcnLFxuICBTVEFURV9VUExPQURJTkc6ICd1cGxvYWRpbmcnLFxuICBTVEFURV9QT1NUUFJPQ0VTU0lORzogJ3Bvc3Rwcm9jZXNzaW5nJyxcbiAgU1RBVEVfQ09NUExFVEU6ICdjb21wbGV0ZScsXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVByb2Nlc3NpbmdQcm9ncmVzcyAoZmlsZXMpIHtcbiAgY29uc3QgdmFsdWVzID0gW11cbiAgbGV0IG1vZGVcbiAgbGV0IG1lc3NhZ2VcblxuICBmb3IgKGNvbnN0IHsgcHJvZ3Jlc3MgfSBvZiBPYmplY3QudmFsdWVzKGZpbGVzKSkge1xuICAgIGNvbnN0IHsgcHJlcHJvY2VzcywgcG9zdHByb2Nlc3MgfSA9IHByb2dyZXNzXG4gICAgLy8gSW4gdGhlIGZ1dHVyZSB3ZSBzaG91bGQgcHJvYmFibHkgZG8gdGhpcyBkaWZmZXJlbnRseS4gRm9yIG5vdyB3ZSdsbCB0YWtlIHRoZVxuICAgIC8vIG1vZGUgYW5kIG1lc3NhZ2UgZnJvbSB0aGUgZmlyc3QgZmlsZeKAplxuICAgIGlmIChtZXNzYWdlID09IG51bGwgJiYgKHByZXByb2Nlc3MgfHwgcG9zdHByb2Nlc3MpKSB7XG4gICAgICAoeyBtb2RlLCBtZXNzYWdlIH0gPSBwcmVwcm9jZXNzIHx8IHBvc3Rwcm9jZXNzKVxuICAgIH1cbiAgICBpZiAocHJlcHJvY2Vzcz8ubW9kZSA9PT0gJ2RldGVybWluYXRlJykgdmFsdWVzLnB1c2gocHJlcHJvY2Vzcy52YWx1ZSlcbiAgICBpZiAocG9zdHByb2Nlc3M/Lm1vZGUgPT09ICdkZXRlcm1pbmF0ZScpIHZhbHVlcy5wdXNoKHBvc3Rwcm9jZXNzLnZhbHVlKVxuICB9XG5cbiAgY29uc3QgdmFsdWUgPSB2YWx1ZXMucmVkdWNlKCh0b3RhbCwgcHJvZ3Jlc3NWYWx1ZSkgPT4ge1xuICAgIHJldHVybiB0b3RhbCArIHByb2dyZXNzVmFsdWUgLyB2YWx1ZXMubGVuZ3RoXG4gIH0sIDApXG5cbiAgcmV0dXJuIHtcbiAgICBtb2RlLFxuICAgIG1lc3NhZ2UsXG4gICAgdmFsdWUsXG4gIH1cbn1cbiIsImNvbnN0IHsgVUlQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgZ2V0U3BlZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0U3BlZWQnKVxuY29uc3QgZ2V0Qnl0ZXNSZW1haW5pbmcgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0Qnl0ZXNSZW1haW5pbmcnKVxuY29uc3QgZ2V0VGV4dERpcmVjdGlvbiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRUZXh0RGlyZWN0aW9uJylcbmNvbnN0IHN0YXR1c0JhclN0YXRlcyA9IHJlcXVpcmUoJy4vU3RhdHVzQmFyU3RhdGVzJylcbmNvbnN0IFN0YXR1c0JhclVJID0gcmVxdWlyZSgnLi9TdGF0dXNCYXInKVxuXG5jb25zdCBsb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZS5qcycpXG5cbi8qKlxuICogU3RhdHVzQmFyOiByZW5kZXJzIGEgc3RhdHVzIGJhciB3aXRoIHVwbG9hZC9wYXVzZS9yZXN1bWUvY2FuY2VsL3JldHJ5IGJ1dHRvbnMsXG4gKiBwcm9ncmVzcyBwZXJjZW50YWdlIGFuZCB0aW1lIHJlbWFpbmluZy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTdGF0dXNCYXIgZXh0ZW5kcyBVSVBsdWdpbiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1N0YXR1c0JhcidcbiAgICB0aGlzLnRpdGxlID0gJ1N0YXR1c0JhcidcbiAgICB0aGlzLnR5cGUgPSAncHJvZ3Jlc3NpbmRpY2F0b3InXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBsb2NhbGVcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRhcmdldDogJ2JvZHknLFxuICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlUmV0cnlCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVDYW5jZWxCdXR0b246IGZhbHNlLFxuICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogZmFsc2UsXG4gICAgICBoaWRlQWZ0ZXJGaW5pc2g6IHRydWUsXG4gICAgICBkb25lQnV0dG9uSGFuZGxlcjogbnVsbCxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcylcbiAgfVxuXG4gIHN0YXJ0VXBsb2FkID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVjb3ZlcmVkU3RhdGUgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG5cbiAgICBpZiAocmVjb3ZlcmVkU3RhdGUpIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCdyZXN0b3JlLWNvbmZpcm1lZCcpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudXBweS51cGxvYWQoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAvLyBFcnJvciBsb2dnZWQgaW4gQ29yZVxuICAgIH0pXG4gIH07XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhcGFiaWxpdGllcyxcbiAgICAgIGZpbGVzLFxuICAgICAgYWxsb3dOZXdVcGxvYWQsXG4gICAgICB0b3RhbFByb2dyZXNzLFxuICAgICAgZXJyb3IsXG4gICAgICByZWNvdmVyZWRTdGF0ZSxcbiAgICB9ID0gc3RhdGVcblxuICAgIGNvbnN0IHtcbiAgICAgIG5ld0ZpbGVzLFxuICAgICAgc3RhcnRlZEZpbGVzLFxuICAgICAgY29tcGxldGVGaWxlcyxcbiAgICAgIGluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcyxcblxuICAgICAgaXNVcGxvYWRTdGFydGVkLFxuICAgICAgaXNBbGxDb21wbGV0ZSxcbiAgICAgIGlzQWxsRXJyb3JlZCxcbiAgICAgIGlzQWxsUGF1c2VkLFxuICAgICAgaXNVcGxvYWRJblByb2dyZXNzLFxuICAgICAgaXNTb21lR2hvc3QsXG4gICAgfSA9IHRoaXMudXBweS5nZXRPYmplY3RPZkZpbGVzUGVyU3RhdGUoKVxuXG4gICAgLy8gSWYgc29tZSBzdGF0ZSB3YXMgcmVjb3ZlcmVkLCB3ZSB3YW50IHRvIHNob3cgVXBsb2FkIGJ1dHRvbi9jb3VudGVyXG4gICAgLy8gZm9yIGFsbCB0aGUgZmlsZXMsIGJlY2F1c2UgaW4gdGhpcyBjYXNlIGl04oCZcyBub3QgYW4gVXBsb2FkIGJ1dHRvbixcbiAgICAvLyBidXQg4oCcQ29uZmlybSBSZXN0b3JlIEJ1dHRvbuKAnVxuICAgIGNvbnN0IG5ld0ZpbGVzT3JSZWNvdmVyZWQgPSByZWNvdmVyZWRTdGF0ZVxuICAgICAgPyBPYmplY3QudmFsdWVzKGZpbGVzKVxuICAgICAgOiBuZXdGaWxlc1xuICAgIGNvbnN0IHRvdGFsRVRBID0gZ2V0VG90YWxFVEEoaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzKVxuICAgIGNvbnN0IHJlc3VtYWJsZVVwbG9hZHMgPSAhIWNhcGFiaWxpdGllcy5yZXN1bWFibGVVcGxvYWRzXG4gICAgY29uc3Qgc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA9IGNhcGFiaWxpdGllcy51cGxvYWRQcm9ncmVzcyAhPT0gZmFsc2VcblxuICAgIGxldCB0b3RhbFNpemUgPSAwXG4gICAgbGV0IHRvdGFsVXBsb2FkZWRTaXplID0gMFxuXG4gICAgc3RhcnRlZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHRvdGFsU2l6ZSArPSBmaWxlLnByb2dyZXNzLmJ5dGVzVG90YWwgfHwgMFxuICAgICAgdG90YWxVcGxvYWRlZFNpemUgKz0gZmlsZS5wcm9ncmVzcy5ieXRlc1VwbG9hZGVkIHx8IDBcbiAgICB9KVxuXG4gICAgcmV0dXJuIFN0YXR1c0JhclVJKHtcbiAgICAgIGVycm9yLFxuICAgICAgdXBsb2FkU3RhdGU6IGdldFVwbG9hZGluZ1N0YXRlKFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaXNBbGxDb21wbGV0ZSxcbiAgICAgICAgcmVjb3ZlcmVkU3RhdGUsXG4gICAgICAgIHN0YXRlLmZpbGVzIHx8IHt9LFxuICAgICAgKSxcbiAgICAgIGFsbG93TmV3VXBsb2FkLFxuICAgICAgdG90YWxQcm9ncmVzcyxcbiAgICAgIHRvdGFsU2l6ZSxcbiAgICAgIHRvdGFsVXBsb2FkZWRTaXplLFxuICAgICAgaXNBbGxDb21wbGV0ZTogZmFsc2UsXG4gICAgICBpc0FsbFBhdXNlZCxcbiAgICAgIGlzQWxsRXJyb3JlZCxcbiAgICAgIGlzVXBsb2FkU3RhcnRlZCxcbiAgICAgIGlzVXBsb2FkSW5Qcm9ncmVzcyxcbiAgICAgIGlzU29tZUdob3N0LFxuICAgICAgcmVjb3ZlcmVkU3RhdGUsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVGaWxlcy5sZW5ndGgsXG4gICAgICBuZXdGaWxlczogbmV3RmlsZXNPclJlY292ZXJlZC5sZW5ndGgsXG4gICAgICBudW1VcGxvYWRzOiBzdGFydGVkRmlsZXMubGVuZ3RoLFxuICAgICAgdG90YWxFVEEsXG4gICAgICBmaWxlcyxcbiAgICAgIGkxOG46IHRoaXMuaTE4bixcbiAgICAgIHVwcHk6IHRoaXMudXBweSxcbiAgICAgIHN0YXJ0VXBsb2FkOiB0aGlzLnN0YXJ0VXBsb2FkLFxuICAgICAgZG9uZUJ1dHRvbkhhbmRsZXI6IHRoaXMub3B0cy5kb25lQnV0dG9uSGFuZGxlcixcbiAgICAgIHJlc3VtYWJsZVVwbG9hZHMsXG4gICAgICBzdXBwb3J0c1VwbG9hZFByb2dyZXNzLFxuICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogdGhpcy5vcHRzLnNob3dQcm9ncmVzc0RldGFpbHMsXG4gICAgICBoaWRlVXBsb2FkQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVVwbG9hZEJ1dHRvbixcbiAgICAgIGhpZGVSZXRyeUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbixcbiAgICAgIGhpZGVDYW5jZWxCdXR0b246IHRoaXMub3B0cy5oaWRlQ2FuY2VsQnV0dG9uLFxuICAgICAgaGlkZUFmdGVyRmluaXNoOiB0aGlzLm9wdHMuaGlkZUFmdGVyRmluaXNoLFxuICAgICAgaXNUYXJnZXRET01FbDogdGhpcy5pc1RhcmdldERPTUVsLFxuICAgIH0pXG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICAvLyBTZXQgdGhlIHRleHQgZGlyZWN0aW9uIGlmIHRoZSBwYWdlIGhhcyBub3QgZGVmaW5lZCBvbmUuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBnZXRUZXh0RGlyZWN0aW9uKGVsZW1lbnQpXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIGVsZW1lbnQuZGlyID0gJ2x0cidcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRvdGFsU3BlZWQgKGZpbGVzKSB7XG4gIGxldCB0b3RhbFNwZWVkID0gMFxuICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgdG90YWxTcGVlZCArPSBnZXRTcGVlZChmaWxlLnByb2dyZXNzKVxuICB9KVxuICByZXR1cm4gdG90YWxTcGVlZFxufVxuXG5mdW5jdGlvbiBnZXRUb3RhbEVUQSAoZmlsZXMpIHtcbiAgY29uc3QgdG90YWxTcGVlZCA9IGdldFRvdGFsU3BlZWQoZmlsZXMpXG4gIGlmICh0b3RhbFNwZWVkID09PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGNvbnN0IHRvdGFsQnl0ZXNSZW1haW5pbmcgPSBmaWxlcy5yZWR1Y2UoKHRvdGFsLCBmaWxlKSA9PiB7XG4gICAgcmV0dXJuIHRvdGFsICsgZ2V0Qnl0ZXNSZW1haW5pbmcoZmlsZS5wcm9ncmVzcylcbiAgfSwgMClcblxuICByZXR1cm4gTWF0aC5yb3VuZCgodG90YWxCeXRlc1JlbWFpbmluZyAvIHRvdGFsU3BlZWQpICogMTApIC8gMTBcbn1cblxuZnVuY3Rpb24gZ2V0VXBsb2FkaW5nU3RhdGUgKGVycm9yLCBpc0FsbENvbXBsZXRlLCByZWNvdmVyZWRTdGF0ZSwgZmlsZXMpIHtcbiAgaWYgKGVycm9yICYmICFpc0FsbENvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHN0YXR1c0JhclN0YXRlcy5TVEFURV9FUlJPUlxuICB9XG5cbiAgaWYgKGlzQWxsQ29tcGxldGUpIHtcbiAgICByZXR1cm4gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0NPTVBMRVRFXG4gIH1cblxuICBpZiAocmVjb3ZlcmVkU3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkdcbiAgfVxuXG4gIGxldCBzdGF0ZSA9IHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HXG4gIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyhmaWxlcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyBwcm9ncmVzcyB9ID0gZmlsZXNbZmlsZUlEc1tpXV1cbiAgICAvLyBJZiBBTlkgZmlsZXMgYXJlIGJlaW5nIHVwbG9hZGVkIHJpZ2h0IG5vdywgc2hvdyB0aGUgdXBsb2FkaW5nIHN0YXRlLlxuICAgIGlmIChwcm9ncmVzcy51cGxvYWRTdGFydGVkICYmICFwcm9ncmVzcy51cGxvYWRDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHN0YXR1c0JhclN0YXRlcy5TVEFURV9VUExPQURJTkdcbiAgICB9XG4gICAgLy8gSWYgZmlsZXMgYXJlIGJlaW5nIHByZXByb2Nlc3NlZCBBTkQgcG9zdHByb2Nlc3NlZCBhdCB0aGlzIHRpbWUsIHdlIHNob3cgdGhlXG4gICAgLy8gcHJlcHJvY2VzcyBzdGF0ZS4gSWYgYW55IGZpbGVzIGFyZSBiZWluZyB1cGxvYWRlZCB3ZSBzaG93IHVwbG9hZGluZy5cbiAgICBpZiAocHJvZ3Jlc3MucHJlcHJvY2VzcyAmJiBzdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1VQTE9BRElORykge1xuICAgICAgc3RhdGUgPSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfUFJFUFJPQ0VTU0lOR1xuICAgIH1cbiAgICAvLyBJZiBOTyBmaWxlcyBhcmUgYmVpbmcgcHJlcHJvY2Vzc2VkIG9yIHVwbG9hZGVkIHJpZ2h0IG5vdywgYnV0IHNvbWUgZmlsZXMgYXJlXG4gICAgLy8gYmVpbmcgcG9zdHByb2Nlc3NlZCwgc2hvdyB0aGUgcG9zdHByb2Nlc3Mgc3RhdGUuXG4gICAgaWYgKFxuICAgICAgcHJvZ3Jlc3MucG9zdHByb2Nlc3NcbiAgICAgICYmIHN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HXG4gICAgICAmJiBzdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkdcbiAgICApIHtcbiAgICAgIHN0YXRlID0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BPU1RQUk9DRVNTSU5HXG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZ3M6IHtcbiAgICAvLyBTaG93biBpbiB0aGUgc3RhdHVzIGJhciB3aGlsZSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQuXG4gICAgdXBsb2FkaW5nOiAnVXBsb2FkaW5nJyxcbiAgICAvLyBTaG93biBpbiB0aGUgc3RhdHVzIGJhciBvbmNlIGFsbCBmaWxlcyBoYXZlIGJlZW4gdXBsb2FkZWQuXG4gICAgY29tcGxldGU6ICdDb21wbGV0ZScsXG4gICAgLy8gU2hvd24gaW4gdGhlIHN0YXR1cyBiYXIgaWYgYW4gdXBsb2FkIGZhaWxlZC5cbiAgICB1cGxvYWRGYWlsZWQ6ICdVcGxvYWQgZmFpbGVkJyxcbiAgICAvLyBTaG93biBpbiB0aGUgc3RhdHVzIGJhciB3aGlsZSB0aGUgdXBsb2FkIGlzIHBhdXNlZC5cbiAgICBwYXVzZWQ6ICdQYXVzZWQnLFxuICAgIC8vIFVzZWQgYXMgdGhlIGxhYmVsIGZvciB0aGUgYnV0dG9uIHRoYXQgcmV0cmllcyBhbiB1cGxvYWQuXG4gICAgcmV0cnk6ICdSZXRyeScsXG4gICAgLy8gVXNlZCBhcyB0aGUgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBjYW5jZWxzIGFuIHVwbG9hZC5cbiAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgIC8vIFVzZWQgYXMgdGhlIGxhYmVsIGZvciB0aGUgYnV0dG9uIHRoYXQgcGF1c2VzIGFuIHVwbG9hZC5cbiAgICBwYXVzZTogJ1BhdXNlJyxcbiAgICAvLyBVc2VkIGFzIHRoZSBsYWJlbCBmb3IgdGhlIGJ1dHRvbiB0aGF0IHJlc3VtZXMgYW4gdXBsb2FkLlxuICAgIHJlc3VtZTogJ1Jlc3VtZScsXG4gICAgLy8gVXNlZCBhcyB0aGUgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCByZXNldHMgdGhlIHVwbG9hZCBzdGF0ZSBhZnRlciBhbiB1cGxvYWRcbiAgICBkb25lOiAnRG9uZScsXG4gICAgLy8gV2hlbiBgc2hvd1Byb2dyZXNzRGV0YWlsc2AgaXMgc2V0LCBzaG93cyB0aGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIGZ1bGx5IHVwbG9hZGVkIHNvIGZhci5cbiAgICBmaWxlc1VwbG9hZGVkT2ZUb3RhbDoge1xuICAgICAgMDogJyV7Y29tcGxldGV9IG9mICV7c21hcnRfY291bnR9IGZpbGUgdXBsb2FkZWQnLFxuICAgICAgMTogJyV7Y29tcGxldGV9IG9mICV7c21hcnRfY291bnR9IGZpbGVzIHVwbG9hZGVkJyxcbiAgICB9LFxuICAgIC8vIFdoZW4gYHNob3dQcm9ncmVzc0RldGFpbHNgIGlzIHNldCwgc2hvd3MgdGhlIGFtb3VudCBvZiBieXRlcyB0aGF0IGhhdmUgYmVlbiB1cGxvYWRlZCBzbyBmYXIuXG4gICAgZGF0YVVwbG9hZGVkT2ZUb3RhbDogJyV7Y29tcGxldGV9IG9mICV7dG90YWx9JyxcbiAgICAvLyBXaGVuIGBzaG93UHJvZ3Jlc3NEZXRhaWxzYCBpcyBzZXQsIHNob3dzIGFuIGVzdGltYXRpb24gb2YgaG93IGxvbmcgdGhlIHVwbG9hZCB3aWxsIHRha2UgdG8gY29tcGxldGUuXG4gICAgeFRpbWVMZWZ0OiAnJXt0aW1lfSBsZWZ0JyxcbiAgICAvLyBVc2VkIGFzIHRoZSBsYWJlbCBmb3IgdGhlIGJ1dHRvbiB0aGF0IHN0YXJ0cyBhbiB1cGxvYWQuXG4gICAgdXBsb2FkWEZpbGVzOiB7XG4gICAgICAwOiAnVXBsb2FkICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgMTogJ1VwbG9hZCAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgfSxcbiAgICAvLyBVc2VkIGFzIHRoZSBsYWJlbCBmb3IgdGhlIGJ1dHRvbiB0aGF0IHN0YXJ0cyBhbiB1cGxvYWQsIGlmIGFub3RoZXIgdXBsb2FkIGhhcyBiZWVuIHN0YXJ0ZWQgaW4gdGhlIHBhc3RcbiAgICAvLyBhbmQgbmV3IGZpbGVzIHdlcmUgYWRkZWQgbGF0ZXIuXG4gICAgdXBsb2FkWE5ld0ZpbGVzOiB7XG4gICAgICAwOiAnVXBsb2FkICsle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgIDE6ICdVcGxvYWQgKyV7c21hcnRfY291bnR9IGZpbGVzJyxcbiAgICB9LFxuICAgIHVwbG9hZDogJ1VwbG9hZCcsXG4gICAgcmV0cnlVcGxvYWQ6ICdSZXRyeSB1cGxvYWQnLFxuICAgIHhNb3JlRmlsZXNBZGRlZDoge1xuICAgICAgMDogJyV7c21hcnRfY291bnR9IG1vcmUgZmlsZSBhZGRlZCcsXG4gICAgICAxOiAnJXtzbWFydF9jb3VudH0gbW9yZSBmaWxlcyBhZGRlZCcsXG4gICAgfSxcbiAgICBzaG93RXJyb3JEZXRhaWxzOiAnU2hvdyBlcnJvciBkZXRhaWxzJyxcbiAgfSxcbn1cbiIsIi8qKlxuICogRGVmYXVsdCBzdG9yZSB0aGF0IGtlZXBzIHN0YXRlIGluIGEgc2ltcGxlIG9iamVjdC5cbiAqL1xuY2xhc3MgRGVmYXVsdFN0b3JlIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7fVxuICAgIHRoaXMuY2FsbGJhY2tzID0gW11cbiAgfVxuXG4gIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVxuICB9XG5cbiAgc2V0U3RhdGUgKHBhdGNoKSB7XG4gICAgY29uc3QgcHJldlN0YXRlID0geyAuLi50aGlzLnN0YXRlIH1cbiAgICBjb25zdCBuZXh0U3RhdGUgPSB7IC4uLnRoaXMuc3RhdGUsIC4uLnBhdGNoIH1cblxuICAgIHRoaXMuc3RhdGUgPSBuZXh0U3RhdGVcbiAgICB0aGlzLiNwdWJsaXNoKHByZXZTdGF0ZSwgbmV4dFN0YXRlLCBwYXRjaClcbiAgfVxuXG4gIHN1YnNjcmliZSAobGlzdGVuZXIpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGxpc3RlbmVyKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgICAgdGhpcy5jYWxsYmFja3Muc3BsaWNlKFxuICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbmRleE9mKGxpc3RlbmVyKSxcbiAgICAgICAgMSxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAjcHVibGlzaCAoLi4uYXJncykge1xuICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBsaXN0ZW5lciguLi5hcmdzKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZhdWx0U3RvcmUgKCkge1xuICByZXR1cm4gbmV3IERlZmF1bHRTdG9yZSgpXG59XG4iLCJjb25zdCB7IFVJUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IGRhdGFVUkl0b0Jsb2IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZGF0YVVSSXRvQmxvYicpXG5jb25zdCBpc09iamVjdFVSTCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9pc09iamVjdFVSTCcpXG5jb25zdCBpc1ByZXZpZXdTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNQcmV2aWV3U3VwcG9ydGVkJylcbmNvbnN0IGV4aWZyID0gcmVxdWlyZSgnZXhpZnIvZGlzdC9taW5pLmxlZ2FjeS51bWQuanMnKVxuXG5jb25zdCBsb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZScpXG5cbi8qKlxuICogVGhlIFRodW1ibmFpbCBHZW5lcmF0b3IgcGx1Z2luXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUaHVtYm5haWxHZW5lcmF0b3IgZXh0ZW5kcyBVSVBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnR5cGUgPSAnbW9kaWZpZXInXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnVGh1bWJuYWlsR2VuZXJhdG9yJ1xuICAgIHRoaXMudGl0bGUgPSAnVGh1bWJuYWlsIEdlbmVyYXRvcidcbiAgICB0aGlzLnF1ZXVlID0gW11cbiAgICB0aGlzLnF1ZXVlUHJvY2Vzc2luZyA9IGZhbHNlXG4gICAgdGhpcy5kZWZhdWx0VGh1bWJuYWlsRGltZW5zaW9uID0gMjAwXG4gICAgdGhpcy50aHVtYm5haWxUeXBlID0gdGhpcy5vcHRzLnRodW1ibmFpbFR5cGUgfHwgJ2ltYWdlL2pwZWcnXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBsb2NhbGVcblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdGh1bWJuYWlsV2lkdGg6IG51bGwsXG4gICAgICB0aHVtYm5haWxIZWlnaHQ6IG51bGwsXG4gICAgICB3YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZDogZmFsc2UsXG4gICAgICBsYXp5OiBmYWxzZSxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIGlmICh0aGlzLm9wdHMubGF6eSAmJiB0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGh1bWJuYWlsR2VuZXJhdG9yOiBUaGUgYGxhenlgIGFuZCBgd2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWRgIG9wdGlvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4gUGxlYXNlIGVuc3VyZSBhdCBtb3N0IG9uZSBvZiB0aGVtIGlzIHNldCB0byBgdHJ1ZWAuJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGh1bWJuYWlsIGZvciB0aGUgZ2l2ZW4gVXBweSBmaWxlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHt7ZGF0YTogQmxvYn19IGZpbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRIZWlnaHRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjcmVhdGVUaHVtYm5haWwgKGZpbGUsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpIHtcbiAgICBjb25zdCBvcmlnaW5hbFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZS5kYXRhKVxuXG4gICAgY29uc3Qgb25sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKVxuICAgICAgaW1hZ2Uuc3JjID0gb3JpZ2luYWxVcmxcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob3JpZ2luYWxVcmwpXG4gICAgICAgIHJlc29sdmUoaW1hZ2UpXG4gICAgICB9KVxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvcmlnaW5hbFVybClcbiAgICAgICAgcmVqZWN0KGV2ZW50LmVycm9yIHx8IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSB0aHVtYm5haWwnKSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IG9yaWVudGF0aW9uUHJvbWlzZSA9IGV4aWZyLnJvdGF0aW9uKGZpbGUuZGF0YSkuY2F0Y2goKCkgPT4gMSlcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChbb25sb2FkLCBvcmllbnRhdGlvblByb21pc2VdKVxuICAgICAgLnRoZW4oKFtpbWFnZSwgb3JpZW50YXRpb25dKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmdldFByb3BvcnRpb25hbERpbWVuc2lvbnMoaW1hZ2UsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIG9yaWVudGF0aW9uLmRlZylcbiAgICAgICAgY29uc3Qgcm90YXRlZEltYWdlID0gdGhpcy5yb3RhdGVJbWFnZShpbWFnZSwgb3JpZW50YXRpb24pXG4gICAgICAgIGNvbnN0IHJlc2l6ZWRJbWFnZSA9IHRoaXMucmVzaXplSW1hZ2Uocm90YXRlZEltYWdlLCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodClcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzVG9CbG9iKHJlc2l6ZWRJbWFnZSwgdGhpcy50aHVtYm5haWxUeXBlLCA4MClcbiAgICAgIH0pXG4gICAgICAudGhlbihibG9iID0+IHtcbiAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuZXcgY2FsY3VsYXRlZCBkaW1lbnNpb25zIGZvciB0aGUgZ2l2ZW4gaW1hZ2UgYW5kIGEgdGFyZ2V0IHdpZHRoXG4gICAqIG9yIGhlaWdodC4gSWYgYm90aCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBnaXZlbiwgb25seSB3aWR0aCBpcyB0YWtlbiBpbnRvXG4gICAqIGFjY291bnQuIElmIG5laXRoZXIgd2lkdGggbm9yIGhlaWdodCBhcmUgZ2l2ZW4sIHRoZSBkZWZhdWx0IGRpbWVuc2lvblxuICAgKiBpcyB1c2VkLlxuICAgKi9cbiAgZ2V0UHJvcG9ydGlvbmFsRGltZW5zaW9ucyAoaW1nLCB3aWR0aCwgaGVpZ2h0LCByb3RhdGlvbikge1xuICAgIGxldCBhc3BlY3QgPSBpbWcud2lkdGggLyBpbWcuaGVpZ2h0XG4gICAgaWYgKHJvdGF0aW9uID09PSA5MCB8fCByb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICBhc3BlY3QgPSBpbWcuaGVpZ2h0IC8gaW1nLndpZHRoXG4gICAgfVxuXG4gICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQod2lkdGggLyBhc3BlY3QpLFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQoaGVpZ2h0ICogYXNwZWN0KSxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5kZWZhdWx0VGh1bWJuYWlsRGltZW5zaW9uLFxuICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuZGVmYXVsdFRodW1ibmFpbERpbWVuc2lvbiAvIGFzcGVjdCksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSB0aGUgaW1hZ2UgZG9lc27igJl0IGV4Y2VlZCBicm93c2VyL2RldmljZSBjYW52YXMgbGltaXRzLlxuICAgKiBGb3IgaW9zIHdpdGggMjU2IFJBTSBhbmQgaWVcbiAgICovXG4gIHByb3RlY3QgKGltYWdlKSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjA4MTQ4My9tYXhpbXVtLXNpemUtb2YtYS1jYW52YXMtZWxlbWVudFxuXG4gICAgY29uc3QgcmF0aW8gPSBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodFxuXG4gICAgY29uc3QgbWF4U3F1YXJlID0gNTAwMDAwMCAvLyBpb3MgbWF4IGNhbnZhcyBzcXVhcmVcbiAgICBjb25zdCBtYXhTaXplID0gNDA5NiAvLyBpZSBtYXggY2FudmFzIGRpbWVuc2lvbnNcblxuICAgIGxldCBtYXhXID0gTWF0aC5mbG9vcihNYXRoLnNxcnQobWF4U3F1YXJlICogcmF0aW8pKVxuICAgIGxldCBtYXhIID0gTWF0aC5mbG9vcihtYXhTcXVhcmUgLyBNYXRoLnNxcnQobWF4U3F1YXJlICogcmF0aW8pKVxuICAgIGlmIChtYXhXID4gbWF4U2l6ZSkge1xuICAgICAgbWF4VyA9IG1heFNpemVcbiAgICAgIG1heEggPSBNYXRoLnJvdW5kKG1heFcgLyByYXRpbylcbiAgICB9XG4gICAgaWYgKG1heEggPiBtYXhTaXplKSB7XG4gICAgICBtYXhIID0gbWF4U2l6ZVxuICAgICAgbWF4VyA9IE1hdGgucm91bmQocmF0aW8gKiBtYXhIKVxuICAgIH1cbiAgICBpZiAoaW1hZ2Uud2lkdGggPiBtYXhXKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgY2FudmFzLndpZHRoID0gbWF4V1xuICAgICAgY2FudmFzLmhlaWdodCA9IG1heEhcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgbWF4VywgbWF4SClcbiAgICAgIGltYWdlID0gY2FudmFzXG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlXG4gIH1cblxuICAvKipcbiAgICogUmVzaXplIGFuIGltYWdlIHRvIHRoZSB0YXJnZXQgYHdpZHRoYCBhbmQgYGhlaWdodGAuXG4gICAqXG4gICAqIFJldHVybnMgYSBDYW52YXMgd2l0aCB0aGUgcmVzaXplZCBpbWFnZSBvbiBpdC5cbiAgICovXG4gIHJlc2l6ZUltYWdlIChpbWFnZSwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCkge1xuICAgIC8vIFJlc2l6aW5nIGluIHN0ZXBzIHJlZmFjdG9yZWQgdG8gdXNlIGEgc29sdXRpb24gZnJvbVxuICAgIC8vIGh0dHBzOi8vYmxvZy51cGxvYWRjYXJlLmNvbS9pbWFnZS1yZXNpemUtaW4tYnJvd3NlcnMtaXMtYnJva2VuLWUzOGVlZDA4ZGYwMVxuXG4gICAgaW1hZ2UgPSB0aGlzLnByb3RlY3QoaW1hZ2UpXG5cbiAgICBsZXQgc3RlcHMgPSBNYXRoLmNlaWwoTWF0aC5sb2cyKGltYWdlLndpZHRoIC8gdGFyZ2V0V2lkdGgpKVxuICAgIGlmIChzdGVwcyA8IDEpIHtcbiAgICAgIHN0ZXBzID0gMVxuICAgIH1cbiAgICBsZXQgc1cgPSB0YXJnZXRXaWR0aCAqIDIgKiogKHN0ZXBzIC0gMSlcbiAgICBsZXQgc0ggPSB0YXJnZXRIZWlnaHQgKiAyICoqIChzdGVwcyAtIDEpXG4gICAgY29uc3QgeCA9IDJcblxuICAgIHdoaWxlIChzdGVwcy0tKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgY2FudmFzLndpZHRoID0gc1dcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBzSFxuICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBzVywgc0gpXG4gICAgICBpbWFnZSA9IGNhbnZhc1xuXG4gICAgICBzVyA9IE1hdGgucm91bmQoc1cgLyB4KVxuICAgICAgc0ggPSBNYXRoLnJvdW5kKHNIIC8geClcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VcbiAgfVxuXG4gIHJvdGF0ZUltYWdlIChpbWFnZSwgdHJhbnNsYXRlKSB7XG4gICAgbGV0IHcgPSBpbWFnZS53aWR0aFxuICAgIGxldCBoID0gaW1hZ2UuaGVpZ2h0XG5cbiAgICBpZiAodHJhbnNsYXRlLmRlZyA9PT0gOTAgfHwgdHJhbnNsYXRlLmRlZyA9PT0gMjcwKSB7XG4gICAgICB3ID0gaW1hZ2UuaGVpZ2h0XG4gICAgICBoID0gaW1hZ2Uud2lkdGhcbiAgICB9XG5cbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IHdcbiAgICBjYW52YXMuaGVpZ2h0ID0gaFxuXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29udGV4dC50cmFuc2xhdGUodyAvIDIsIGggLyAyKVxuICAgIGlmICh0cmFuc2xhdGUuY2FudmFzKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSh0cmFuc2xhdGUucmFkKVxuICAgICAgY29udGV4dC5zY2FsZSh0cmFuc2xhdGUuc2NhbGVYLCB0cmFuc2xhdGUuc2NhbGVZKVxuICAgIH1cbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgLWltYWdlLndpZHRoIC8gMiwgLWltYWdlLmhlaWdodCAvIDIsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG5cbiAgICByZXR1cm4gY2FudmFzXG4gIH1cblxuICAvKipcbiAgICogU2F2ZSBhIDxjYW52YXM+IGVsZW1lbnQncyBjb250ZW50IHRvIGEgQmxvYiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGNhbnZhc1RvQmxvYiAoY2FudmFzLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAxOCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjYW5ub3QgcmVhZCBpbWFnZSwgcHJvYmFibHkgYW4gc3ZnIHdpdGggZXh0ZXJuYWwgcmVzb3VyY2VzJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhcy50b0Jsb2IpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY2FudmFzLnRvQmxvYihyZXNvbHZlLCB0eXBlLCBxdWFsaXR5KVxuICAgICAgfSkudGhlbigoYmxvYikgPT4ge1xuICAgICAgICBpZiAoYmxvYiA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlYWQgaW1hZ2UsIHByb2JhYmx5IGFuIHN2ZyB3aXRoIGV4dGVybmFsIHJlc291cmNlcycpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2JcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBkYXRhVVJJdG9CbG9iKGNhbnZhcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSksIHt9KVxuICAgIH0pLnRoZW4oKGJsb2IpID0+IHtcbiAgICAgIGlmIChibG9iID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGV4dHJhY3QgYmxvYiwgcHJvYmFibHkgYW4gb2xkIGJyb3dzZXInKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJsb2JcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJldmlldyBVUkwgZm9yIGEgZmlsZS5cbiAgICovXG4gIHNldFByZXZpZXdVUkwgKGZpbGVJRCwgcHJldmlldykge1xuICAgIHRoaXMudXBweS5zZXRGaWxlU3RhdGUoZmlsZUlELCB7IHByZXZpZXcgfSlcbiAgfVxuXG4gIGFkZFRvUXVldWUgKGl0ZW0pIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goaXRlbSlcbiAgICBpZiAodGhpcy5xdWV1ZVByb2Nlc3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnByb2Nlc3NRdWV1ZSgpXG4gICAgfVxuICB9XG5cbiAgcHJvY2Vzc1F1ZXVlICgpIHtcbiAgICB0aGlzLnF1ZXVlUHJvY2Vzc2luZyA9IHRydWVcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy51cHB5LmdldEZpbGUodGhpcy5xdWV1ZS5zaGlmdCgpKVxuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coJ1tUaHVtYm5haWxHZW5lcmF0b3JdIGZpbGUgd2FzIHJlbW92ZWQgYmVmb3JlIGEgdGh1bWJuYWlsIGNvdWxkIGJlIGdlbmVyYXRlZCwgYnV0IG5vdCByZW1vdmVkIGZyb20gdGhlIHF1ZXVlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnJywgJ2Vycm9yJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0VGh1bWJuYWlsKGN1cnJlbnQpXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7fSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBub2RlL2hhbmRsZS1jYWxsYmFjay1lcnJcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5wcm9jZXNzUXVldWUoKSlcbiAgICB9XG4gICAgdGhpcy5xdWV1ZVByb2Nlc3NpbmcgPSBmYWxzZVxuICAgIHRoaXMudXBweS5sb2coJ1tUaHVtYm5haWxHZW5lcmF0b3JdIEVtcHRpZWQgdGh1bWJuYWlsIHF1ZXVlJylcbiAgICB0aGlzLnVwcHkuZW1pdCgndGh1bWJuYWlsOmFsbC1nZW5lcmF0ZWQnKVxuICB9XG5cbiAgcmVxdWVzdFRodW1ibmFpbCAoZmlsZSkge1xuICAgIGlmIChpc1ByZXZpZXdTdXBwb3J0ZWQoZmlsZS50eXBlKSAmJiAhZmlsZS5pc1JlbW90ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGh1bWJuYWlsKGZpbGUsIHRoaXMub3B0cy50aHVtYm5haWxXaWR0aCwgdGhpcy5vcHRzLnRodW1ibmFpbEhlaWdodClcbiAgICAgICAgLnRoZW4ocHJldmlldyA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRQcmV2aWV3VVJMKGZpbGUuaWQsIHByZXZpZXcpXG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhgW1RodW1ibmFpbEdlbmVyYXRvcl0gR2VuZXJhdGVkIHRodW1ibmFpbCBmb3IgJHtmaWxlLmlkfWApXG4gICAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3RodW1ibmFpbDpnZW5lcmF0ZWQnLCB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlLmlkKSwgcHJldmlldylcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhgW1RodW1ibmFpbEdlbmVyYXRvcl0gRmFpbGVkIHRodW1ibmFpbCBmb3IgJHtmaWxlLmlkfTpgLCAnd2FybmluZycpXG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIsICd3YXJuaW5nJylcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndGh1bWJuYWlsOmVycm9yJywgdGhpcy51cHB5LmdldEZpbGUoZmlsZS5pZCksIGVycilcbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICBvbkZpbGVBZGRlZCA9IChmaWxlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgIWZpbGUucHJldmlld1xuICAgICAgJiYgZmlsZS5kYXRhXG4gICAgICAmJiBpc1ByZXZpZXdTdXBwb3J0ZWQoZmlsZS50eXBlKVxuICAgICAgJiYgIWZpbGUuaXNSZW1vdGVcbiAgICApIHtcbiAgICAgIHRoaXMuYWRkVG9RdWV1ZShmaWxlLmlkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYSBsYXp5IHJlcXVlc3QgZm9yIGEgdGh1bWJuYWlsIGlmIHRoZSB0aHVtYm5haWwgaGFzIG5vdCB5ZXQgYmVlbiBnZW5lcmF0ZWQuXG4gICAqL1xuICBvbkNhbmNlbFJlcXVlc3QgPSAoZmlsZSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5xdWV1ZS5pbmRleE9mKGZpbGUuaWQpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5xdWV1ZS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aHVtYm5haWwgZm9yIGEgZmlsZS4gQ2FuY2VsIGxhenkgcmVxdWVzdHMgYW5kIGZyZWUgdGhlIHRodW1ibmFpbCBVUkwuXG4gICAqL1xuICBvbkZpbGVSZW1vdmVkID0gKGZpbGUpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuaW5kZXhPZihmaWxlLmlkKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMucXVldWUuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIG9iamVjdCBVUkxzLlxuICAgIGlmIChmaWxlLnByZXZpZXcgJiYgaXNPYmplY3RVUkwoZmlsZS5wcmV2aWV3KSkge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChmaWxlLnByZXZpZXcpXG4gICAgfVxuICB9XG5cbiAgb25SZXN0b3JlZCA9ICgpID0+IHtcbiAgICBjb25zdCByZXN0b3JlZEZpbGVzID0gdGhpcy51cHB5LmdldEZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gZmlsZS5pc1Jlc3RvcmVkKVxuICAgIHJlc3RvcmVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgLy8gT25seSBhZGQgYmxvYiBVUkxzOyB0aGV5IGFyZSBsaWtlbHkgaW52YWxpZCBhZnRlciBiZWluZyByZXN0b3JlZC5cbiAgICAgIGlmICghZmlsZS5wcmV2aWV3IHx8IGlzT2JqZWN0VVJMKGZpbGUucHJldmlldykpIHtcbiAgICAgICAgdGhpcy5hZGRUb1F1ZXVlKGZpbGUuaWQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHdhaXRVbnRpbEFsbFByb2Nlc3NlZCA9IChmaWxlSURzKSA9PiB7XG4gICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgICB0aGlzLnVwcHkuZW1pdCgncHJlcHJvY2Vzcy1wcm9ncmVzcycsIGZpbGUsIHtcbiAgICAgICAgbW9kZTogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLmkxOG4oJ2dlbmVyYXRpbmdUaHVtYm5haWxzJyksXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCBlbWl0UHJlcHJvY2Vzc0NvbXBsZXRlRm9yQWxsID0gKCkgPT4ge1xuICAgICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3ByZXByb2Nlc3MtY29tcGxldGUnLCBmaWxlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICh0aGlzLnF1ZXVlUHJvY2Vzc2luZykge1xuICAgICAgICB0aGlzLnVwcHkub25jZSgndGh1bWJuYWlsOmFsbC1nZW5lcmF0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgZW1pdFByZXByb2Nlc3NDb21wbGV0ZUZvckFsbCgpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0UHJlcHJvY2Vzc0NvbXBsZXRlRm9yQWxsKClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5vbignZmlsZS1yZW1vdmVkJywgdGhpcy5vbkZpbGVSZW1vdmVkKVxuICAgIGlmICh0aGlzLm9wdHMubGF6eSkge1xuICAgICAgdGhpcy51cHB5Lm9uKCd0aHVtYm5haWw6cmVxdWVzdCcsIHRoaXMub25GaWxlQWRkZWQpXG4gICAgICB0aGlzLnVwcHkub24oJ3RodW1ibmFpbDpjYW5jZWwnLCB0aGlzLm9uQ2FuY2VsUmVxdWVzdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cHB5Lm9uKCdmaWxlLWFkZGVkJywgdGhpcy5vbkZpbGVBZGRlZClcbiAgICAgIHRoaXMudXBweS5vbigncmVzdG9yZWQnLCB0aGlzLm9uUmVzdG9yZWQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCkge1xuICAgICAgdGhpcy51cHB5LmFkZFByZVByb2Nlc3Nvcih0aGlzLndhaXRVbnRpbEFsbFByb2Nlc3NlZClcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5vZmYoJ2ZpbGUtcmVtb3ZlZCcsIHRoaXMub25GaWxlUmVtb3ZlZClcbiAgICBpZiAodGhpcy5vcHRzLmxhenkpIHtcbiAgICAgIHRoaXMudXBweS5vZmYoJ3RodW1ibmFpbDpyZXF1ZXN0JywgdGhpcy5vbkZpbGVBZGRlZClcbiAgICAgIHRoaXMudXBweS5vZmYoJ3RodW1ibmFpbDpjYW5jZWwnLCB0aGlzLm9uQ2FuY2VsUmVxdWVzdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cHB5Lm9mZignZmlsZS1hZGRlZCcsIHRoaXMub25GaWxlQWRkZWQpXG4gICAgICB0aGlzLnVwcHkub2ZmKCdyZXN0b3JlZCcsIHRoaXMub25SZXN0b3JlZClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLndhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkKSB7XG4gICAgICB0aGlzLnVwcHkucmVtb3ZlUHJlUHJvY2Vzc29yKHRoaXMud2FpdFVudGlsQWxsUHJvY2Vzc2VkKVxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZ3M6IHtcbiAgICBnZW5lcmF0aW5nVGh1bWJuYWlsczogJ0dlbmVyYXRpbmcgdGh1bWJuYWlscy4uLicsXG4gIH0sXG59XG4iLCJjb25zdCB0dXMgPSByZXF1aXJlKCd0dXMtanMtY2xpZW50JylcblxuZnVuY3Rpb24gaXNDb3Jkb3ZhICgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICB0eXBlb2Ygd2luZG93LlBob25lR2FwICE9PSAndW5kZWZpbmVkJ1xuICAgIHx8IHR5cGVvZiB3aW5kb3cuQ29yZG92YSAhPT0gJ3VuZGVmaW5lZCdcbiAgICB8fCB0eXBlb2Ygd2luZG93LmNvcmRvdmEgIT09ICd1bmRlZmluZWQnXG4gIClcbn1cblxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSAoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ3N0cmluZydcbiAgICAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnXG59XG5cbi8vIFdlIG92ZXJyaWRlIHR1cyBmaW5nZXJwcmludCB0byB1cHB54oCZcyBgZmlsZS5pZGAsIHNpbmNlIHRoZSBgZmlsZS5pZGBcbi8vIG5vdyBhbHNvIGluY2x1ZGVzIGByZWxhdGl2ZVBhdGhgIGZvciBmaWxlcyBhZGRlZCBmcm9tIGZvbGRlcnMuXG4vLyBUaGlzIG1lYW5zIHlvdSBjYW4gYWRkIDIgaWRlbnRpY2FsIGZpbGVzLCBpZiBvbmUgaXMgaW4gZm9sZGVyIGEsXG4vLyB0aGUgb3RoZXIgaW4gZm9sZGVyIGIg4oCUIGBhL2ZpbGUuanBnYCBhbmQgYGIvZmlsZS5qcGdgLCB3aGVuIGFkZGVkXG4vLyB0b2dldGhlciB3aXRoIGEgZm9sZGVyLCB3aWxsIGJlIHRyZWF0ZWQgYXMgMiBzZXBhcmF0ZSBmaWxlcy5cbi8vXG4vLyBGb3IgUmVhY3QgTmF0aXZlIGFuZCBDb3Jkb3ZhLCB3ZSBsZXQgdHVzLWpzLWNsaWVudOKAmXMgZGVmYXVsdFxuLy8gZmluZ2VycHJpbnQgaGFuZGxpbmcgdGFrZSBjaGFyZ2UuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbmdlcnByaW50ICh1cHB5RmlsZU9iaikge1xuICByZXR1cm4gKGZpbGUsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoaXNDb3Jkb3ZhKCkgfHwgaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gdHVzLmRlZmF1bHRPcHRpb25zLmZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgY29uc3QgdXBweUZpbmdlcnByaW50ID0gW1xuICAgICAgJ3R1cycsXG4gICAgICB1cHB5RmlsZU9iai5pZCxcbiAgICAgIG9wdGlvbnMuZW5kcG9pbnQsXG4gICAgXS5qb2luKCctJylcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodXBweUZpbmdlcnByaW50KVxuICB9XG59XG4iLCJjb25zdCBCYXNlUGx1Z2luID0gcmVxdWlyZSgnQHVwcHkvY29yZS9saWIvQmFzZVBsdWdpbicpXG5jb25zdCB0dXMgPSByZXF1aXJlKCd0dXMtanMtY2xpZW50JylcbmNvbnN0IHsgUHJvdmlkZXIsIFJlcXVlc3RDbGllbnQsIFNvY2tldCB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCBlbWl0U29ja2V0UHJvZ3Jlc3MgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZW1pdFNvY2tldFByb2dyZXNzJylcbmNvbnN0IGdldFNvY2tldEhvc3QgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0U29ja2V0SG9zdCcpXG5jb25zdCBzZXR0bGUgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvc2V0dGxlJylcbmNvbnN0IEV2ZW50VHJhY2tlciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9FdmVudFRyYWNrZXInKVxuY29uc3QgTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL05ldHdvcmtFcnJvcicpXG5jb25zdCBpc05ldHdvcmtFcnJvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9pc05ldHdvcmtFcnJvcicpXG5jb25zdCB7IFJhdGVMaW1pdGVkUXVldWUgfSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9SYXRlTGltaXRlZFF1ZXVlJylcbmNvbnN0IGhhc1Byb3BlcnR5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2hhc1Byb3BlcnR5JylcbmNvbnN0IGdldEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9nZXRGaW5nZXJwcmludCcpXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlR1c09wdGlvbnN9IFR1c09wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCd0dXMtanMtY2xpZW50JykuVXBsb2FkT3B0aW9uc30gUmF3VHVzT3B0aW9ucyAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ0B1cHB5L2NvcmUnKS5VcHB5fSBVcHB5ICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnQHVwcHkvY29yZScpLlVwcHlGaWxlfSBVcHB5RmlsZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ0B1cHB5L2NvcmUnKS5GYWlsZWRVcHB5RmlsZTx7fT59IEZhaWxlZFVwcHlGaWxlICovXG5cbi8qKlxuICogRXh0cmFjdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3R1cy90dXMtanMtY2xpZW50L2Jsb2IvbWFzdGVyL2xpYi91cGxvYWQuanMjTDEzXG4gKiBleGNlcHRlZCB3ZSByZW1vdmVkICdmaW5nZXJwcmludCcga2V5IHRvIGF2b2lkIGFkZGluZyBtb3JlIGRlcGVuZGVuY2llc1xuICpcbiAqIEB0eXBlIHtSYXdUdXNPcHRpb25zfVxuICovXG5jb25zdCB0dXNEZWZhdWx0T3B0aW9ucyA9IHtcbiAgZW5kcG9pbnQ6ICcnLFxuXG4gIHVwbG9hZFVybDogbnVsbCxcbiAgbWV0YWRhdGE6IHt9LFxuICB1cGxvYWRTaXplOiBudWxsLFxuXG4gIG9uUHJvZ3Jlc3M6IG51bGwsXG4gIG9uQ2h1bmtDb21wbGV0ZTogbnVsbCxcbiAgb25TdWNjZXNzOiBudWxsLFxuICBvbkVycm9yOiBudWxsLFxuXG4gIG92ZXJyaWRlUGF0Y2hNZXRob2Q6IGZhbHNlLFxuICBoZWFkZXJzOiB7fSxcbiAgYWRkUmVxdWVzdElkOiBmYWxzZSxcblxuICBjaHVua1NpemU6IEluZmluaXR5LFxuICByZXRyeURlbGF5czogWzAsIDEwMDAsIDMwMDAsIDUwMDBdLFxuICBwYXJhbGxlbFVwbG9hZHM6IDEsXG4gIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IGZhbHNlLFxuICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IGZhbHNlLFxufVxuXG4vKipcbiAqIFR1cyByZXN1bWFibGUgZmlsZSB1cGxvYWRlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFR1cyBleHRlbmRzIEJhc2VQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAvKipcbiAgICogQHBhcmFtIHtVcHB5fSB1cHB5XG4gICAqIEBwYXJhbSB7VHVzT3B0aW9uc30gb3B0c1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMudHlwZSA9ICd1cGxvYWRlcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdUdXMnXG4gICAgdGhpcy50aXRsZSA9ICdUdXMnXG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB1c2VGYXN0UmVtb3RlUmV0cnk6IHRydWUsXG4gICAgICBsaW1pdDogNSxcbiAgICAgIHJldHJ5RGVsYXlzOiBbMCwgMTAwMCwgMzAwMCwgNTAwMF0sXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIH1cblxuICAgIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLlwiKS5UdXNPcHRpb25zfSAqL1xuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgaWYgKCdhdXRvUmV0cnknIGluIG9wdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBhdXRvUmV0cnlgIG9wdGlvbiB3YXMgZGVwcmVjYXRlZCBhbmQgaGFzIGJlZW4gcmVtb3ZlZC4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXVsdGFuZW91cyB1cGxvYWQgbGltaXRpbmcgaXMgc2hhcmVkIGFjcm9zcyBhbGwgdXBsb2FkcyB3aXRoIHRoaXMgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHR5cGUge1JhdGVMaW1pdGVkUXVldWV9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0cyA9IG5ldyBSYXRlTGltaXRlZFF1ZXVlKHRoaXMub3B0cy5saW1pdClcblxuICAgIHRoaXMudXBsb2FkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHRoaXMudXBsb2FkZXJFdmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgdGhpcy51cGxvYWRlclNvY2tldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICB0aGlzLmhhbmRsZVJlc2V0UHJvZ3Jlc3MgPSB0aGlzLmhhbmRsZVJlc2V0UHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlVXBsb2FkID0gdGhpcy5oYW5kbGVVcGxvYWQuYmluZCh0aGlzKVxuICB9XG5cbiAgaGFuZGxlUmVzZXRQcm9ncmVzcyAoKSB7XG4gICAgY29uc3QgZmlsZXMgPSB7IC4uLnRoaXMudXBweS5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAvLyBPbmx5IGNsb25lIHRoZSBmaWxlIG9iamVjdCBpZiBpdCBoYXMgYSBUdXMgYHVwbG9hZFVybGAgYXR0YWNoZWQuXG4gICAgICBpZiAoZmlsZXNbZmlsZUlEXS50dXMgJiYgZmlsZXNbZmlsZUlEXS50dXMudXBsb2FkVXJsKSB7XG4gICAgICAgIGNvbnN0IHR1c1N0YXRlID0geyAuLi5maWxlc1tmaWxlSURdLnR1cyB9XG4gICAgICAgIGRlbGV0ZSB0dXNTdGF0ZS51cGxvYWRVcmxcbiAgICAgICAgZmlsZXNbZmlsZUlEXSA9IHsgLi4uZmlsZXNbZmlsZUlEXSwgdHVzOiB0dXNTdGF0ZSB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7IGZpbGVzIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgYWxsIHJlZmVyZW5jZXMgZm9yIGEgZmlsZSdzIHVwbG9hZDogdGhlIHR1cy5VcGxvYWQgaW5zdGFuY2UsXG4gICAqIGFueSBldmVudHMgcmVsYXRlZCB0byB0aGUgZmlsZSwgYW5kIHRoZSBDb21wYW5pb24gV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICovXG4gIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzIChmaWxlSUQsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0aGlzLnVwbG9hZGVyc1tmaWxlSURdKSB7XG4gICAgICBjb25zdCB1cGxvYWRlciA9IHRoaXMudXBsb2FkZXJzW2ZpbGVJRF1cblxuICAgICAgdXBsb2FkZXIuYWJvcnQoKVxuXG4gICAgICBpZiAob3B0cy5hYm9ydCkge1xuICAgICAgICB1cGxvYWRlci5hYm9ydCh0cnVlKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwbG9hZGVyc1tmaWxlSURdID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdKSB7XG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ucmVtb3ZlKClcbiAgICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXSA9IG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGVJRF0pIHtcbiAgICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGVJRF0uY2xvc2UoKVxuICAgICAgdGhpcy51cGxvYWRlclNvY2tldHNbZmlsZUlEXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFR1cyB1cGxvYWQuXG4gICAqXG4gICAqIEEgbG90IGNhbiBoYXBwZW4gZHVyaW5nIGFuIHVwbG9hZCwgc28gdGhpcyBpcyBxdWl0ZSBoYXJkIHRvIGZvbGxvdyFcbiAgICogLSBGaXJzdCwgdGhlIHVwbG9hZCBpcyBzdGFydGVkLiBJZiB0aGUgZmlsZSB3YXMgYWxyZWFkeSBwYXVzZWQgYnkgdGhlIHRpbWUgdGhlIHVwbG9hZCBzdGFydHMsIG5vdGhpbmcgc2hvdWxkIGhhcHBlbi5cbiAgICogICBJZiB0aGUgYGxpbWl0YCBvcHRpb24gaXMgdXNlZCwgdGhlIHVwbG9hZCBtdXN0IGJlIHF1ZXVlZCBvbnRvIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUuXG4gICAqICAgV2hlbiBhbiB1cGxvYWQgc3RhcnRzLCB3ZSBzdG9yZSB0aGUgdHVzLlVwbG9hZCBpbnN0YW5jZSwgYW5kIGFuIEV2ZW50VHJhY2tlciBpbnN0YW5jZSB0aGF0IG1hbmFnZXMgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgKiAgIGZvciBwYXVzaW5nLCBjYW5jZWxsYXRpb24sIHJlbW92YWwsIGV0Yy5cbiAgICogLSBXaGlsZSB0aGUgdXBsb2FkIGlzIGluIHByb2dyZXNzLCBpdCBtYXkgYmUgcGF1c2VkIG9yIGNhbmNlbGxlZC5cbiAgICogICBQYXVzaW5nIGFib3J0cyB0aGUgdW5kZXJseWluZyB0dXMuVXBsb2FkLCBhbmQgcmVtb3ZlcyB0aGUgdXBsb2FkIGZyb20gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS4gQWxsIG90aGVyIHN0YXRlIGlzXG4gICAqICAgbWFpbnRhaW5lZC5cbiAgICogICBDYW5jZWxsaW5nIHJlbW92ZXMgdGhlIHVwbG9hZCBmcm9tIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUsIGFuZCBjb21wbGV0ZWx5IGFib3J0cyB0aGUgdXBsb2FkLS0gdGhlIGB0dXMuVXBsb2FkYFxuICAgKiAgIGluc3RhbmNlIGlzIGFib3J0ZWQgYW5kIGRpc2NhcmRlZCwgdGhlIEV2ZW50VHJhY2tlciBpbnN0YW5jZSBpcyBkZXN0cm95ZWQgKHJlbW92aW5nIGFsbCBsaXN0ZW5lcnMpLlxuICAgKiAgIFJlc3VtaW5nIHRoZSB1cGxvYWQgdXNlcyB0aGUgYHRoaXMucmVxdWVzdHNgIHF1ZXVlIGFzIHdlbGwsIHRvIHByZXZlbnQgc2VsZWN0aXZlbHkgcGF1c2luZyBhbmQgcmVzdW1pbmcgdXBsb2FkcyBmcm9tXG4gICAqICAgYnlwYXNzaW5nIHRoZSBsaW1pdC5cbiAgICogLSBBZnRlciBjb21wbGV0aW5nIGFuIHVwbG9hZCwgdGhlIHR1cy5VcGxvYWQgYW5kIEV2ZW50VHJhY2tlciBpbnN0YW5jZXMgYXJlIGNsZWFuZWQgdXAsIGFuZCB0aGUgdXBsb2FkIGlzIG1hcmtlZCBhcyBkb25lXG4gICAqICAgaW4gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS5cbiAgICogLSBXaGVuIGFuIHVwbG9hZCBjb21wbGV0ZWQgd2l0aCBhbiBlcnJvciwgdGhlIHNhbWUgaGFwcGVucyBhcyBvbiBzdWNjZXNzZnVsIGNvbXBsZXRpb24sIGJ1dCB0aGUgYHVwbG9hZCgpYCBwcm9taXNlIGlzXG4gICAqICAgcmVqZWN0ZWQuXG4gICAqXG4gICAqIFdoZW4gd29ya2luZyBvbiB0aGlzIGZ1bmN0aW9uLCBrZWVwIGluIG1pbmQ6XG4gICAqICAtIFdoZW4gYW4gdXBsb2FkIGlzIGNvbXBsZXRlZCBvciBjYW5jZWxsZWQgZm9yIGFueSByZWFzb24sIHRoZSB0dXMuVXBsb2FkIGFuZCBFdmVudFRyYWNrZXIgaW5zdGFuY2VzIG5lZWQgdG8gYmUgY2xlYW5lZFxuICAgKiAgICB1cCB1c2luZyB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkuXG4gICAqICAtIFdoZW4gYW4gdXBsb2FkIGlzIGNhbmNlbGxlZCBvciBwYXVzZWQsIGZvciBhbnkgcmVhc29uLCBpdCBuZWVkcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZSB1c2luZ1xuICAgKiAgICBgcXVldWVkUmVxdWVzdC5hYm9ydCgpYC5cbiAgICogIC0gV2hlbiBhbiB1cGxvYWQgaXMgY29tcGxldGVkIGZvciBhbnkgcmVhc29uLCBpbmNsdWRpbmcgZXJyb3JzLCBpdCBuZWVkcyB0byBiZSBtYXJrZWQgYXMgc3VjaCB1c2luZ1xuICAgKiAgICBgcXVldWVkUmVxdWVzdC5kb25lKClgLlxuICAgKiAgLSBXaGVuIGFuIHVwbG9hZCBpcyBzdGFydGVkIG9yIHJlc3VtZWQsIGl0IG5lZWRzIHRvIGdvIHRocm91Z2ggdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS4gVGhlIGBxdWV1ZWRSZXF1ZXN0YCB2YXJpYWJsZVxuICAgKiAgICBtdXN0IGJlIHVwZGF0ZWQgc28gdGhlIG90aGVyIHVzZXMgb2YgaXQgYXJlIHZhbGlkLlxuICAgKiAgLSBCZWZvcmUgcmVwbGFjaW5nIHRoZSBgcXVldWVkUmVxdWVzdGAgdmFyaWFibGUsIHRoZSBwcmV2aW91cyBgcXVldWVkUmVxdWVzdGAgbXVzdCBiZSBhYm9ydGVkLCBlbHNlIGl0IHdpbGwga2VlcCB0YWtpbmdcbiAgICogICAgdXAgYSBzcG90IGluIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZSBmb3IgdXNlIHdpdGggdXBsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50IGZpbGUgaW4gYSBxdWV1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWwgbnVtYmVyIG9mIGZpbGVzIGluIGEgcXVldWVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICB1cGxvYWQgKGZpbGUpIHtcbiAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgdHVzIHVwbG9hZFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN0YXJ0ZWQnLCBmaWxlKVxuXG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgIC4uLihmaWxlLnR1cyB8fCB7fSksXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5oZWFkZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyhmaWxlKVxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge1Jhd1R1c09wdGlvbnN9ICovXG4gICAgICBjb25zdCB1cGxvYWRPcHRpb25zID0ge1xuICAgICAgICAuLi50dXNEZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugb3ZlcnJpZGUgdHVzIGZpbmdlcnByaW50IHRvIHVwcHnigJlzIGBmaWxlLmlkYCwgc2luY2UgdGhlIGBmaWxlLmlkYFxuICAgICAgLy8gbm93IGFsc28gaW5jbHVkZXMgYHJlbGF0aXZlUGF0aGAgZm9yIGZpbGVzIGFkZGVkIGZyb20gZm9sZGVycy5cbiAgICAgIC8vIFRoaXMgbWVhbnMgeW91IGNhbiBhZGQgMiBpZGVudGljYWwgZmlsZXMsIGlmIG9uZSBpcyBpbiBmb2xkZXIgYSxcbiAgICAgIC8vIHRoZSBvdGhlciBpbiBmb2xkZXIgYi5cbiAgICAgIHVwbG9hZE9wdGlvbnMuZmluZ2VycHJpbnQgPSBnZXRGaW5nZXJwcmludChmaWxlKVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm9uQmVmb3JlUmVxdWVzdCA9IChyZXEpID0+IHtcbiAgICAgICAgY29uc3QgeGhyID0gcmVxLmdldFVuZGVybHlpbmdPYmplY3QoKVxuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsc1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbkJlZm9yZVJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvcHRzLm9uQmVmb3JlUmVxdWVzdChyZXEpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBsb2FkT3B0aW9ucy5vbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVycilcblxuICAgICAgICBjb25zdCB4aHIgPSBlcnIub3JpZ2luYWxSZXF1ZXN0ID8gZXJyLm9yaWdpbmFsUmVxdWVzdC5nZXRVbmRlcmx5aW5nT2JqZWN0KCkgOiBudWxsXG4gICAgICAgIGlmIChpc05ldHdvcmtFcnJvcih4aHIpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IE5ldHdvcmtFcnJvcihlcnIsIHhocilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcXVldWVkUmVxdWVzdC5kb25lKClcblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyKVxuXG4gICAgICAgIHJlamVjdChlcnIpXG4gICAgICB9XG5cbiAgICAgIHVwbG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IChieXRlc1VwbG9hZGVkLCBieXRlc1RvdGFsKSA9PiB7XG4gICAgICAgIHRoaXMub25SZWNlaXZlVXBsb2FkVXJsKGZpbGUsIHVwbG9hZC51cmwpXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtcHJvZ3Jlc3MnLCBmaWxlLCB7XG4gICAgICAgICAgdXBsb2FkZXI6IHRoaXMsXG4gICAgICAgICAgYnl0ZXNVcGxvYWRlZCxcbiAgICAgICAgICBieXRlc1RvdGFsLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm9uU3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdXBsb2FkUmVzcCA9IHtcbiAgICAgICAgICB1cGxvYWRVUkw6IHVwbG9hZC51cmwsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG5cbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdWNjZXNzJywgZmlsZSwgdXBsb2FkUmVzcClcblxuICAgICAgICBpZiAodXBsb2FkLnVybCkge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coYERvd25sb2FkICR7dXBsb2FkLmZpbGUubmFtZX0gZnJvbSAke3VwbG9hZC51cmx9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUodXBsb2FkKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb3B5UHJvcCA9IChvYmosIHNyY1Byb3AsIGRlc3RQcm9wKSA9PiB7XG4gICAgICAgIGlmIChoYXNQcm9wZXJ0eShvYmosIHNyY1Byb3ApICYmICFoYXNQcm9wZXJ0eShvYmosIGRlc3RQcm9wKSkge1xuICAgICAgICAgIG9ialtkZXN0UHJvcF0gPSBvYmpbc3JjUHJvcF1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgICBjb25zdCBtZXRhID0ge31cbiAgICAgIGNvbnN0IG1ldGFGaWVsZHMgPSBBcnJheS5pc0FycmF5KG9wdHMubWV0YUZpZWxkcylcbiAgICAgICAgPyBvcHRzLm1ldGFGaWVsZHNcbiAgICAgICAgLy8gU2VuZCBhbG9uZyBhbGwgZmllbGRzIGJ5IGRlZmF1bHQuXG4gICAgICAgIDogT2JqZWN0LmtleXMoZmlsZS5tZXRhKVxuICAgICAgbWV0YUZpZWxkcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIG1ldGFbaXRlbV0gPSBmaWxlLm1ldGFbaXRlbV1cbiAgICAgIH0pXG5cbiAgICAgIC8vIHR1c2QgdXNlcyBtZXRhZGF0YSBmaWVsZHMgJ2ZpbGV0eXBlJyBhbmQgJ2ZpbGVuYW1lJ1xuICAgICAgY29weVByb3AobWV0YSwgJ3R5cGUnLCAnZmlsZXR5cGUnKVxuICAgICAgY29weVByb3AobWV0YSwgJ25hbWUnLCAnZmlsZW5hbWUnKVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm1ldGFkYXRhID0gbWV0YVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLmRhdGEsIHVwbG9hZE9wdGlvbnMpXG4gICAgICB0aGlzLnVwbG9hZGVyc1tmaWxlLmlkXSA9IHVwbG9hZFxuICAgICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlLmlkXSA9IG5ldyBFdmVudFRyYWNrZXIodGhpcy51cHB5KVxuXG4gICAgICB1cGxvYWQuZmluZFByZXZpb3VzVXBsb2FkcygpLnRoZW4oKHByZXZpb3VzVXBsb2FkcykgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91c1VwbG9hZCA9IHByZXZpb3VzVXBsb2Fkc1swXVxuICAgICAgICBpZiAocHJldmlvdXNVcGxvYWQpIHtcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKGBbVHVzXSBSZXN1bWluZyB1cGxvYWQgb2YgJHtmaWxlLmlkfSBzdGFydGVkIGF0ICR7cHJldmlvdXNVcGxvYWQuY3JlYXRpb25UaW1lfWApXG4gICAgICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZChwcmV2aW91c1VwbG9hZClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgbGV0IHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLnJ1bigoKSA9PiB7XG4gICAgICAgIGlmICghZmlsZS5pc1BhdXNlZCkge1xuICAgICAgICAgIHVwbG9hZC5zdGFydCgpXG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZSwgdGhlIGNhbGxlciB3aWxsIHRha2UgY2FyZSBvZiBjYW5jZWxsaW5nIHRoZSB1cGxvYWQgaXRzZWxmXG4gICAgICAgIC8vIHVzaW5nIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkuIFRoaXMgaXMgYmVjYXVzZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGhhcyB0byBiZVxuICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGlzIHJlcXVlc3QgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlLCBhbmQgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LCB0b28uIEF0XG4gICAgICAgIC8vIHRoYXQgcG9pbnQgdGhpcyBjYW5jZWxsYXRpb24gZnVuY3Rpb24gaXMgbm90IGdvaW5nIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgLy8gQWxzbywgd2UgbmVlZCB0byByZW1vdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgcXVldWUgX3dpdGhvdXRfIGRlc3Ryb3lpbmcgZXZlcnl0aGluZ1xuICAgICAgICAvLyByZWxhdGVkIHRvIHRoaXMgdXBsb2FkIHRvIGhhbmRsZSBwYXVzZXMuXG4gICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vbkZpbGVSZW1vdmUoZmlsZS5pZCwgKHRhcmdldEZpbGVJRCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkLCB7IGFib3J0OiAhIXVwbG9hZC51cmwgfSlcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7dGFyZ2V0RmlsZUlEfSB3YXMgcmVtb3ZlZGApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2UoZmlsZS5pZCwgKGlzUGF1c2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1BhdXNlZCkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGZpbGUgZnJvbSB0aGUgcXVldWUgc28gYW5vdGhlciBmaWxlIGNhbiBzdGFydCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgdXBsb2FkLmFib3J0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXN1bWluZyBhbiB1cGxvYWQgc2hvdWxkIGJlIHF1ZXVlZCwgZWxzZSB5b3UgY291bGQgcGF1c2UgYW5kIHRoZW5cbiAgICAgICAgICAvLyByZXN1bWUgYSBxdWV1ZWQgdXBsb2FkIHRvIG1ha2UgaXQgc2tpcCB0aGUgcXVldWUuXG4gICAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgcXVldWVkUmVxdWVzdCA9IHRoaXMucmVxdWVzdHMucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHVwbG9hZC5zdGFydCgpXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2VBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgdXBsb2FkLmFib3J0KClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25DYW5jZWxBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkLCB7IGFib3J0OiAhIXVwbG9hZC51cmwgfSlcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7ZmlsZS5pZH0gd2FzIGNhbmNlbGVkYClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXN1bWVBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgaWYgKGZpbGUuZXJyb3IpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoKVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdXBsb2FkLnN0YXJ0KClcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZSBmb3IgdXNlIHdpdGggdXBsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50IGZpbGUgaW4gYSBxdWV1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWwgbnVtYmVyIG9mIGZpbGVzIGluIGEgcXVldWVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICB1cGxvYWRSZW1vdGUgKGZpbGUpIHtcbiAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG5cbiAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLm9wdHMgfVxuICAgIGlmIChmaWxlLnR1cykge1xuICAgICAgLy8gSW5zdGFsbCBmaWxlLXNwZWNpZmljIHVwbG9hZCBvdmVycmlkZXMuXG4gICAgICBPYmplY3QuYXNzaWduKG9wdHMsIGZpbGUudHVzKVxuICAgIH1cblxuICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtc3RhcnRlZCcsIGZpbGUpXG4gICAgdGhpcy51cHB5LmxvZyhmaWxlLnJlbW90ZS51cmwpXG5cbiAgICBpZiAoZmlsZS5zZXJ2ZXJUb2tlbikge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFRvU2VydmVyU29ja2V0KGZpbGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IENsaWVudCA9IGZpbGUucmVtb3RlLnByb3ZpZGVyT3B0aW9ucy5wcm92aWRlciA/IFByb3ZpZGVyIDogUmVxdWVzdENsaWVudFxuICAgICAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCh0aGlzLnVwcHksIGZpbGUucmVtb3RlLnByb3ZpZGVyT3B0aW9ucylcblxuICAgICAgLy8gISEgY2FuY2VsbGF0aW9uIGlzIE5PVCBzdXBwb3J0ZWQgYXQgdGhpcyBzdGFnZSB5ZXRcbiAgICAgIGNsaWVudC5wb3N0KGZpbGUucmVtb3RlLnVybCwge1xuICAgICAgICAuLi5maWxlLnJlbW90ZS5ib2R5LFxuICAgICAgICBlbmRwb2ludDogb3B0cy5lbmRwb2ludCxcbiAgICAgICAgdXBsb2FkVXJsOiBvcHRzLnVwbG9hZFVybCxcbiAgICAgICAgcHJvdG9jb2w6ICd0dXMnLFxuICAgICAgICBzaXplOiBmaWxlLmRhdGEuc2l6ZSxcbiAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzLFxuICAgICAgICBtZXRhZGF0YTogZmlsZS5tZXRhLFxuICAgICAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5zZXRGaWxlU3RhdGUoZmlsZS5pZCwgeyBzZXJ2ZXJUb2tlbjogcmVzLnRva2VuIH0pXG4gICAgICAgIGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlLmlkKVxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0VG9TZXJ2ZXJTb2NrZXQoZmlsZSlcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycilcbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgdGhlIGNvbW1lbnQgb24gdGhlIHVwbG9hZCgpIG1ldGhvZC5cbiAgICpcbiAgICogQWRkaXRpb25hbGx5LCB3aGVuIGFuIHVwbG9hZCBpcyByZW1vdmVkLCBjb21wbGV0ZWQsIG9yIGNhbmNlbGxlZCwgd2UgbmVlZCB0byBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoaXMgaXNcbiAgICogaGFuZGxlZCBieSB0aGUgcmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoKSBmdW5jdGlvbiwgc28gdGhlIHNhbWUgZ3VpZGVsaW5lcyBhcHBseSBhcyBpbiB1cGxvYWQoKS5cbiAgICpcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZVxuICAgKi9cbiAgY29ubmVjdFRvU2VydmVyU29ja2V0IChmaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRva2VuID0gZmlsZS5zZXJ2ZXJUb2tlblxuICAgICAgY29uc3QgaG9zdCA9IGdldFNvY2tldEhvc3QoZmlsZS5yZW1vdGUuY29tcGFuaW9uVXJsKVxuICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IFNvY2tldCh7IHRhcmdldDogYCR7aG9zdH0vYXBpLyR7dG9rZW59YCwgYXV0b09wZW46IGZhbHNlIH0pXG4gICAgICB0aGlzLnVwbG9hZGVyU29ja2V0c1tmaWxlLmlkXSA9IHNvY2tldFxuICAgICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlLmlkXSA9IG5ldyBFdmVudFRyYWNrZXIodGhpcy51cHB5KVxuXG4gICAgICB0aGlzLm9uRmlsZVJlbW92ZShmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICBzb2NrZXQuc2VuZCgnY2FuY2VsJywge30pXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7ZmlsZS5pZH0gd2FzIHJlbW92ZWRgKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblBhdXNlKGZpbGUuaWQsIChpc1BhdXNlZCkgPT4ge1xuICAgICAgICBpZiAoaXNQYXVzZWQpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBmaWxlIGZyb20gdGhlIHF1ZXVlIHNvIGFub3RoZXIgZmlsZSBjYW4gc3RhcnQgaW4gaXRzIHBsYWNlLlxuICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlc3VtaW5nIGFuIHVwbG9hZCBzaG91bGQgYmUgcXVldWVkLCBlbHNlIHlvdSBjb3VsZCBwYXVzZSBhbmQgdGhlblxuICAgICAgICAgIC8vIHJlc3VtZSBhIHF1ZXVlZCB1cGxvYWQgdG8gbWFrZSBpdCBza2lwIHRoZSBxdWV1ZS5cbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoJ3Jlc3VtZScsIHt9KVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblBhdXNlQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vbkNhbmNlbEFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICBzb2NrZXQuc2VuZCgnY2FuY2VsJywge30pXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7ZmlsZS5pZH0gd2FzIGNhbmNlbGVkYClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXN1bWVBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgaWYgKGZpbGUuZXJyb3IpIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdyZXN1bWUnLCB7fSlcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXRyeShmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIC8vIE9ubHkgZG8gdGhlIHJldHJ5IGlmIHRoZSB1cGxvYWQgaXMgYWN0dWFsbHkgaW4gcHJvZ3Jlc3M7XG4gICAgICAgIC8vIGVsc2Ugd2UgY291bGQgdHJ5IHRvIHNlbmQgdGhlc2UgbWVzc2FnZXMgd2hlbiB0aGUgdXBsb2FkIGlzIHN0aWxsIHF1ZXVlZC5cbiAgICAgICAgLy8gV2UgbWF5IG5lZWQgYSBiZXR0ZXIgY2hlY2sgZm9yIHRoaXMgc2luY2UgdGhlIHNvY2tldCBtYXkgYWxzbyBiZSBjbG9zZWRcbiAgICAgICAgLy8gZm9yIG90aGVyIHJlYXNvbnMsIGxpa2UgbmV0d29yayBmYWlsdXJlcy5cbiAgICAgICAgaWYgKHNvY2tldC5pc09wZW4pIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXRyeUFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgb25SZXRyeSgpIGNhbGxcbiAgICAgICAgaWYgKHNvY2tldC5pc09wZW4pIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbigncHJvZ3Jlc3MnLCAocHJvZ3Jlc3NEYXRhKSA9PiBlbWl0U29ja2V0UHJvZ3Jlc3ModGhpcywgcHJvZ3Jlc3NEYXRhLCBmaWxlKSlcblxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlcnJEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyRGF0YS5lcnJvclxuICAgICAgICBjb25zdCBlcnJvciA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKG1lc3NhZ2UpLCB7IGNhdXNlOiBlcnJEYXRhLmVycm9yIH0pXG5cbiAgICAgICAgLy8gSWYgdGhlIHJlbW90ZSByZXRyeSBvcHRpbWlzYXRpb24gc2hvdWxkIG5vdCBiZSB1c2VkLFxuICAgICAgICAvLyBjbG9zZSB0aGUgc29ja2V04oCUdGhpcyB3aWxsIHRlbGwgY29tcGFuaW9uIHRvIGNsZWFyIHN0YXRlIGFuZCBkZWxldGUgdGhlIGZpbGUuXG4gICAgICAgIGlmICghdGhpcy5vcHRzLnVzZUZhc3RSZW1vdGVSZXRyeSkge1xuICAgICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcnZlclRva2VuIHNvIHRoYXQgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIHJldHJ5LlxuICAgICAgICAgIHRoaXMudXBweS5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICAgICAgc2VydmVyVG9rZW46IG51bGwsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb2NrZXQuY2xvc2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycm9yKVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ3N1Y2Nlc3MnLCAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCB1cGxvYWRSZXNwID0ge1xuICAgICAgICAgIHVwbG9hZFVSTDogZGF0YS51cmwsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN1Y2Nlc3MnLCBmaWxlLCB1cGxvYWRSZXNwKVxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG5cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuXG4gICAgICBsZXQgcXVldWVkUmVxdWVzdCA9IHRoaXMucmVxdWVzdHMucnVuKCgpID0+IHtcbiAgICAgICAgc29ja2V0Lm9wZW4oKVxuICAgICAgICBpZiAoZmlsZS5pc1BhdXNlZCkge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZSwgdGhlIGNhbGxlciB3aWxsIHRha2UgY2FyZSBvZiBjYW5jZWxsaW5nIHRoZSB1cGxvYWQgaXRzZWxmXG4gICAgICAgIC8vIHVzaW5nIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkuIFRoaXMgaXMgYmVjYXVzZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGhhcyB0byBiZVxuICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGlzIHJlcXVlc3QgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlLCBhbmQgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LCB0b28uIEF0XG4gICAgICAgIC8vIHRoYXQgcG9pbnQgdGhpcyBjYW5jZWxsYXRpb24gZnVuY3Rpb24gaXMgbm90IGdvaW5nIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgLy8gQWxzbywgd2UgbmVlZCB0byByZW1vdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgcXVldWUgX3dpdGhvdXRfIGRlc3Ryb3lpbmcgZXZlcnl0aGluZ1xuICAgICAgICAvLyByZWxhdGVkIHRvIHRoaXMgdXBsb2FkIHRvIGhhbmRsZSBwYXVzZXMuXG4gICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSB1cGxvYWRVcmwgb24gdGhlIGZpbGUgb3B0aW9ucywgc28gdGhhdCB3aGVuIEdvbGRlbiBSZXRyaWV2ZXJcbiAgICogcmVzdG9yZXMgc3RhdGUsIHdlIHdpbGwgY29udGludWUgdXBsb2FkaW5nIHRvIHRoZSBjb3JyZWN0IFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXBsb2FkVVJMXG4gICAqL1xuICBvblJlY2VpdmVVcGxvYWRVcmwgKGZpbGUsIHVwbG9hZFVSTCkge1xuICAgIGNvbnN0IGN1cnJlbnRGaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZS5pZClcbiAgICBpZiAoIWN1cnJlbnRGaWxlKSByZXR1cm5cbiAgICAvLyBPbmx5IGRvIHRoZSB1cGRhdGUgaWYgd2UgZGlkbid0IGhhdmUgYW4gdXBsb2FkIFVSTCB5ZXQuXG4gICAgaWYgKCFjdXJyZW50RmlsZS50dXMgfHwgY3VycmVudEZpbGUudHVzLnVwbG9hZFVybCAhPT0gdXBsb2FkVVJMKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbVHVzXSBTdG9yaW5nIHVwbG9hZCB1cmwnKVxuICAgICAgdGhpcy51cHB5LnNldEZpbGVTdGF0ZShjdXJyZW50RmlsZS5pZCwge1xuICAgICAgICB0dXM6IHsgLi4uY3VycmVudEZpbGUudHVzLCB1cGxvYWRVcmw6IHVwbG9hZFVSTCB9LFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGNiXG4gICAqL1xuICBvbkZpbGVSZW1vdmUgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ2ZpbGUtcmVtb3ZlZCcsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoZmlsZUlEID09PSBmaWxlLmlkKSBjYihmaWxlLmlkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGJvb2xlYW4pOiB2b2lkfSBjYlxuICAgKi9cbiAgb25QYXVzZSAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbigndXBsb2FkLXBhdXNlJywgKHRhcmdldEZpbGVJRCwgaXNQYXVzZWQpID0+IHtcbiAgICAgIGlmIChmaWxlSUQgPT09IHRhcmdldEZpbGVJRCkge1xuICAgICAgICAvLyBjb25zdCBpc1BhdXNlZCA9IHRoaXMudXBweS5wYXVzZVJlc3VtZShmaWxlSUQpXG4gICAgICAgIGNiKGlzUGF1c2VkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblJldHJ5IChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCd1cGxvYWQtcmV0cnknLCAodGFyZ2V0RmlsZUlEKSA9PiB7XG4gICAgICBpZiAoZmlsZUlEID09PSB0YXJnZXRGaWxlSUQpIHtcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblJldHJ5QWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdyZXRyeS1hbGwnLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpIHJldHVyblxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblBhdXNlQWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdwYXVzZS1hbGwnLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpIHJldHVyblxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvbkNhbmNlbEFsbCAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbignY2FuY2VsLWFsbCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKSkgcmV0dXJuXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gY2JcbiAgICovXG4gIG9uUmVzdW1lQWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdyZXN1bWUtYWxsJywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpKSByZXR1cm5cbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KFVwcHlGaWxlIHwgRmFpbGVkVXBweUZpbGUpW119IGZpbGVzXG4gICAqL1xuICB1cGxvYWRGaWxlcyAoZmlsZXMpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IGZpbGVzLm1hcCgoZmlsZSwgaSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGkgKyAxXG4gICAgICBjb25zdCB0b3RhbCA9IGZpbGVzLmxlbmd0aFxuXG4gICAgICBpZiAoJ2Vycm9yJyBpbiBmaWxlICYmIGZpbGUuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihmaWxlLmVycm9yKSlcbiAgICAgIH0gaWYgKGZpbGUuaXNSZW1vdGUpIHtcbiAgICAgICAgLy8gV2UgZW1pdCB1cGxvYWQtc3RhcnRlZCBoZXJlLCBzbyB0aGF0IGl0J3MgYWxzbyBlbWl0dGVkIGZvciBmaWxlc1xuICAgICAgICAvLyB0aGF0IGhhdmUgdG8gd2FpdCBkdWUgdG8gdGhlIGBsaW1pdGAgb3B0aW9uLlxuICAgICAgICAvLyBEb24ndCBkb3VibGUtZW1pdCB1cGxvYWQtc3RhcnRlZCBmb3IgR29sZGVuIFJldHJpZXZlci1yZXN0b3JlZCBmaWxlcyB0aGF0IHdlcmUgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgIGlmICghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8ICFmaWxlLmlzUmVzdG9yZWQpIHtcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN0YXJ0ZWQnLCBmaWxlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZFJlbW90ZShmaWxlLCBjdXJyZW50LCB0b3RhbClcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IGRvdWJsZS1lbWl0IHVwbG9hZC1zdGFydGVkIGZvciBHb2xkZW4gUmV0cmlldmVyLXJlc3RvcmVkIGZpbGVzIHRoYXQgd2VyZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIGlmICghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8ICFmaWxlLmlzUmVzdG9yZWQpIHtcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdGFydGVkJywgZmlsZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnVwbG9hZChmaWxlLCBjdXJyZW50LCB0b3RhbClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHNldHRsZShwcm9taXNlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWxlSURzXG4gICAqL1xuICBoYW5kbGVVcGxvYWQgKGZpbGVJRHMpIHtcbiAgICBpZiAoZmlsZUlEcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tUdXNdIE5vIGZpbGVzIHRvIHVwbG9hZCcpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmxpbWl0ID09PSAwKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKFxuICAgICAgICAnW1R1c10gV2hlbiB1cGxvYWRpbmcgbXVsdGlwbGUgZmlsZXMgYXQgb25jZSwgY29uc2lkZXIgc2V0dGluZyB0aGUgYGxpbWl0YCBvcHRpb24gKHRvIGAxMGAgZm9yIGV4YW1wbGUpLCB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgdXBsb2Fkcywgd2hpY2ggaGVscHMgcHJldmVudCBtZW1vcnkgYW5kIG5ldHdvcmsgaXNzdWVzOiBodHRwczovL3VwcHkuaW8vZG9jcy90dXMvI2xpbWl0LTAnLFxuICAgICAgICAnd2FybmluZycsXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy51cHB5LmxvZygnW1R1c10gVXBsb2FkaW5nLi4uJylcbiAgICBjb25zdCBmaWxlc1RvVXBsb2FkID0gZmlsZUlEcy5tYXAoKGZpbGVJRCkgPT4gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKSlcblxuICAgIHJldHVybiB0aGlzLnVwbG9hZEZpbGVzKGZpbGVzVG9VcGxvYWQpXG4gICAgICAudGhlbigoKSA9PiBudWxsKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGNhcGFiaWxpdGllczogeyAuLi50aGlzLnVwcHkuZ2V0U3RhdGUoKS5jYXBhYmlsaXRpZXMsIHJlc3VtYWJsZVVwbG9hZHM6IHRydWUgfSxcbiAgICB9KVxuICAgIHRoaXMudXBweS5hZGRVcGxvYWRlcih0aGlzLmhhbmRsZVVwbG9hZClcblxuICAgIHRoaXMudXBweS5vbigncmVzZXQtcHJvZ3Jlc3MnLCB0aGlzLmhhbmRsZVJlc2V0UHJvZ3Jlc3MpXG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7XG4gICAgICBjYXBhYmlsaXRpZXM6IHsgLi4udGhpcy51cHB5LmdldFN0YXRlKCkuY2FwYWJpbGl0aWVzLCByZXN1bWFibGVVcGxvYWRzOiBmYWxzZSB9LFxuICAgIH0pXG4gICAgdGhpcy51cHB5LnJlbW92ZVVwbG9hZGVyKHRoaXMuaGFuZGxlVXBsb2FkKVxuICB9XG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY2xhc3MgVXJsVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLmhhbmRsZUtleVByZXNzID0gdGhpcy5oYW5kbGVLZXlQcmVzcy5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVDbGljayA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHRoaXMuaW5wdXQudmFsdWUgPSAnJ1xuICB9XG5cbiAgaGFuZGxlS2V5UHJlc3MgKGV2KSB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLnByb3BzLmFkZEZpbGUodGhpcy5pbnB1dC52YWx1ZSlcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDbGljayAoKSB7XG4gICAgdGhpcy5wcm9wcy5hZGRGaWxlKHRoaXMuaW5wdXQudmFsdWUpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktVXJsXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtdGV4dElucHV0IHVwcHktVXJsLWlucHV0XCJcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5pMThuKCdlbnRlclVybFRvSW1wb3J0Jyl9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3RoaXMucHJvcHMuaTE4bignZW50ZXJVcmxUb0ltcG9ydCcpfVxuICAgICAgICAgIG9uS2V5VXA9e3RoaXMuaGFuZGxlS2V5UHJlc3N9XG4gICAgICAgICAgcmVmPXsoaW5wdXQpID0+IHsgdGhpcy5pbnB1dCA9IGlucHV0IH19XG4gICAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgICAvPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1jLWJ0bi1wcmltYXJ5IHVwcHktVXJsLWltcG9ydEJ1dHRvblwiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgPlxuICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG4oJ2ltcG9ydCcpfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVybFVJXG4iLCJjb25zdCB7IFVJUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IHsgUmVxdWVzdENsaWVudCB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCBVcmxVSSA9IHJlcXVpcmUoJy4vVXJsVUkuanMnKVxuY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcbmNvbnN0IGZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2ZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwnKVxuXG5jb25zdCBsb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZScpXG5cbmZ1bmN0aW9uIFVybEljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiNGRjc1M0VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yMi43ODggMTUuMzg5bC0yLjE5OSAyLjE5YTMuMTg0IDMuMTg0IDAgMCAxLS41MTMuNDM3Yy0uODA2LjU4NC0xLjY4Ni44NzYtMi42MzguODc2YTQuMzc4IDQuMzc4IDAgMCAxLTMuNTE5LTEuNzUyYy0uMjItLjI5Mi0uMTQ2LS44MDIuMTQ3LTEuMDIxLjI5My0uMjIuODA2LS4xNDYgMS4wMjYuMTQ2Ljk1MyAxLjMxMyAyLjc4NSAxLjUzMiA0LjEwNS41ODNhLjU3MS41NzEgMCAwIDAgLjI5My0uMjkybDIuMTk5LTIuMTg5YzEuMS0xLjE2NyAxLjEtMi45OTItLjA3My00LjA4NmEyLjk3NiAyLjk3NiAwIDAgMC00LjEwNSAwbC0xLjI0NiAxLjI0YS43MS43MSAwIDAgMS0xLjAyNiAwIC43MDMuNzAzIDAgMCAxIDAtMS4wMjJsMS4yNDYtMS4yNGE0LjMwNSA0LjMwNSAwIDAgMSA2LjA4MyAwYzEuODMzIDEuNjA1IDEuOTA2IDQuNDUxLjIyIDYuMTN6bS03LjE4MyA1LjAzNWwtMS4yNDYgMS4yNGEyLjk3NiAyLjk3NiAwIDAgMS00LjEwNSAwYy0xLjE3Mi0xLjA5NC0xLjE3Mi0yLjk5MS0uMDczLTQuMDg2bDIuMi0yLjE5LjI5Mi0uMjkxYy42Ni0uNDM4IDEuMzkzLS42NTcgMi4yLS41ODQuODA1LjE0NiAxLjQ2NS41MSAxLjkwNSAxLjE2OC4yMi4yOTIuNzMzLjM2NSAxLjAyNi4xNDYuMjkzLS4yMi4zNjctLjczLjE0Ny0xLjAyMi0uNzMzLS45NDktMS43Ni0xLjUzMi0yLjg1OS0xLjY3OC0xLjEtLjIyLTIuMjcyLjA3My0zLjIyNS44MDJsLS40NC40MzgtMi4xOTkgMi4xOWMtMS42ODYgMS43NS0xLjYxMiA0LjUyNC4wNzQgNi4yMDIuODguODAzIDEuOTc5IDEuMjQxIDMuMDc4IDEuMjQxIDEuMSAwIDIuMTk5LS40MzggMy4wNzktMS4yNGwxLjI0Ni0xLjI0MWEuNzAzLjcwMyAwIDAgMCAwLTEuMDIyYy0uMjk0LS4yOTItLjgwNy0uMzY1LTEuMS0uMDczelwiIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG4vKipcbiAqIFVybFxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVcmwgZXh0ZW5kcyBVSVBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdVcmwnXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnTGluaydcbiAgICB0aGlzLnR5cGUgPSAnYWNxdWlyZXInXG4gICAgdGhpcy5pY29uID0gKCkgPT4gPFVybEljb24gLz5cblxuICAgIC8vIFNldCBkZWZhdWx0IG9wdGlvbnMgYW5kIGxvY2FsZVxuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGxvY2FsZVxuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fVxuXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG5cbiAgICBpZiAoIXRoaXMuaG9zdG5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcGFuaW9uIGhvc3RuYW1lIGlzIHJlcXVpcmVkLCBwbGVhc2UgY29uc3VsdCBodHRwczovL3VwcHkuaW8vZG9jcy9jb21wYW5pb24nKVxuICAgIH1cblxuICAgIC8vIEJpbmQgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciByZWZlcmVuY2FiaWxpdHlcbiAgICB0aGlzLmdldE1ldGEgPSB0aGlzLmdldE1ldGEuYmluZCh0aGlzKVxuICAgIHRoaXMuYWRkRmlsZSA9IHRoaXMuYWRkRmlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVSb290RHJvcCA9IHRoaXMuaGFuZGxlUm9vdERyb3AuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlUm9vdFBhc3RlID0gdGhpcy5oYW5kbGVSb290UGFzdGUuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5jbGllbnQgPSBuZXcgUmVxdWVzdENsaWVudCh1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgfSlcbiAgfVxuXG4gIGdldEZpbGVOYW1lRnJvbVVybCAodXJsKSB7XG4gICAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKVxuICB9XG5cbiAgY2hlY2tJZkNvcnJlY3RVUkwgKHVybCkge1xuICAgIGlmICghdXJsKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IHByb3RvY29sID0gdXJsLm1hdGNoKC9eKFthLXowLTldKyk6XFwvXFwvLylbMV1cbiAgICBpZiAocHJvdG9jb2wgIT09ICdodHRwJyAmJiBwcm90b2NvbCAhPT0gJ2h0dHBzJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGFkZFByb3RvY29sVG9VUkwgKHVybCkge1xuICAgIGNvbnN0IHByb3RvY29sUmVnZXggPSAvXlthLXowLTldKzpcXC9cXC8vXG4gICAgY29uc3QgZGVmYXVsdFByb3RvY29sID0gJ2h0dHA6Ly8nXG4gICAgaWYgKHByb3RvY29sUmVnZXgudGVzdCh1cmwpKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRQcm90b2NvbCArIHVybFxuICB9XG5cbiAgZ2V0TWV0YSAodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnBvc3QoJ3VybC9tZXRhJywgeyB1cmwgfSlcbiAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coJ1tVUkxdIEVycm9yOicpXG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhyZXMuZXJyb3IpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggdGhlIGZpbGUnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH0pXG4gIH1cblxuICBhZGRGaWxlICh1cmwpIHtcbiAgICB1cmwgPSB0aGlzLmFkZFByb3RvY29sVG9VUkwodXJsKVxuICAgIGlmICghdGhpcy5jaGVja0lmQ29ycmVjdFVSTCh1cmwpKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKGBbVVJMXSBJbmNvcnJlY3QgVVJMIGVudGVyZWQ6ICR7dXJsfWApXG4gICAgICB0aGlzLnVwcHkuaW5mbyh0aGlzLmkxOG4oJ2VudGVyQ29ycmVjdFVybCcpLCAnZXJyb3InLCA0MDAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TWV0YSh1cmwpXG4gICAgICAudGhlbigobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCB0YWdGaWxlID0ge1xuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICBuYW1lOiB0aGlzLmdldEZpbGVOYW1lRnJvbVVybCh1cmwpLFxuICAgICAgICAgIHR5cGU6IG1ldGEudHlwZSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBzaXplOiBtZXRhLnNpemUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGNvbXBhbmlvblVybDogdGhpcy5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgICAgICAgIHVybDogYCR7dGhpcy5ob3N0bmFtZX0vdXJsL2dldGAsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgIGZpbGVJZDogdXJsLFxuICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiB0aGlzLmNsaWVudC5vcHRzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ0ZpbGVcbiAgICAgIH0pXG4gICAgICAudGhlbigodGFnRmlsZSkgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKCdbVXJsXSBBZGRpbmcgcmVtb3RlIGZpbGUnKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVwcHkuYWRkRmlsZSh0YWdGaWxlKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgICAgIHRoaXMudXBweS5pbmZvKHtcbiAgICAgICAgICBtZXNzYWdlOiB0aGlzLmkxOG4oJ2ZhaWxlZFRvRmV0Y2gnKSxcbiAgICAgICAgICBkZXRhaWxzOiBlcnIsXG4gICAgICAgIH0sICdlcnJvcicsIDQwMDApXG4gICAgICAgIHJldHVybiBlcnJcbiAgICAgIH0pXG4gIH1cblxuICBjYW5IYW5kbGVSb290RHJvcCAoZSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdG9BcnJheShlLmRhdGFUcmFuc2Zlci5pdGVtcylcbiAgICBjb25zdCB1cmxzID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmtpbmQgPT09ICdzdHJpbmcnXG4gICAgICAmJiBpdGVtLnR5cGUgPT09ICd0ZXh0L3VyaS1saXN0JylcbiAgICByZXR1cm4gdXJscy5sZW5ndGggPiAwXG4gIH1cblxuICBoYW5kbGVSb290RHJvcCAoZSkge1xuICAgIGZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwoZS5kYXRhVHJhbnNmZXIsICdkcm9wJywgKHVybCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW1VSTF0gQWRkaW5nIGZpbGUgZnJvbSBkcm9wcGVkIHVybDogJHt1cmx9YClcbiAgICAgIHRoaXMuYWRkRmlsZSh1cmwpXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZVJvb3RQYXN0ZSAoZSkge1xuICAgIGZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwoZS5jbGlwYm9hcmREYXRhLCAncGFzdGUnLCAodXJsKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGBbVVJMXSBBZGRpbmcgZmlsZSBmcm9tIHBhc3RlZCB1cmw6ICR7dXJsfWApXG4gICAgICB0aGlzLmFkZEZpbGUodXJsKVxuICAgIH0pXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIHJldHVybiA8VXJsVUkgaTE4bj17dGhpcy5pMThufSBhZGRGaWxlPXt0aGlzLmFkZEZpbGV9IC8+XG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nczoge1xuICAgIC8vIExhYmVsIGZvciB0aGUgXCJJbXBvcnRcIiBidXR0b24uXG4gICAgaW1wb3J0OiAnSW1wb3J0JyxcbiAgICAvLyBQbGFjZWhvbGRlciB0ZXh0IGZvciB0aGUgVVJMIGlucHV0LlxuICAgIGVudGVyVXJsVG9JbXBvcnQ6ICdFbnRlciBVUkwgdG8gaW1wb3J0IGEgZmlsZScsXG4gICAgLy8gRXJyb3IgbWVzc2FnZSBzaG93biBpZiBDb21wYW5pb24gY291bGQgbm90IGxvYWQgYSBVUkwuXG4gICAgZmFpbGVkVG9GZXRjaDogJ0NvbXBhbmlvbiBmYWlsZWQgdG8gZmV0Y2ggdGhpcyBVUkwsIHBsZWFzZSBtYWtlIHN1cmUgaXTigJlzIGNvcnJlY3QnLFxuICAgIC8vIEVycm9yIG1lc3NhZ2Ugc2hvd24gaWYgdGhlIGlucHV0IGRvZXMgbm90IGxvb2sgbGlrZSBhIFVSTC5cbiAgICBlbnRlckNvcnJlY3RVcmw6ICdJbmNvcnJlY3QgVVJMOiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgZW50ZXJpbmcgYSBkaXJlY3QgbGluayB0byBhIGZpbGUnLFxuICB9LFxufVxuIiwiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcblxuLypcbiAgU0lUVUFUSU9OXG5cbiAgICAxLiBDcm9zcy1icm93c2VyIGRhdGFUcmFuc2Zlci5pdGVtc1xuXG4gICAgICBwYXN0ZSBpbiBjaHJvbWUgW0NvcHkgSW1hZ2VdOlxuICAgICAgMDoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG4gICAgICBwYXN0ZSBpbiBzYWZhcmkgW0NvcHkgSW1hZ2VdOlxuICAgICAgMDoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG4gICAgICAyOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICAzOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICBwYXN0ZSBpbiBmaXJlZm94IFtDb3B5IEltYWdlXTpcbiAgICAgIDA6IHtraW5kOiBcImZpbGVcIiwgdHlwZTogXCJpbWFnZS9wbmdcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvaHRtbFwifVxuXG4gICAgICBwYXN0ZSBpbiBjaHJvbWUgW0NvcHkgSW1hZ2UgQWRkcmVzc106XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICBwYXN0ZSBpbiBzYWZhcmkgW0NvcHkgSW1hZ2UgQWRkcmVzc106XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICBwYXN0ZSBpbiBmaXJlZm94IFtDb3B5IEltYWdlIEFkZHJlc3NdOlxuICAgICAgMDoge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9wbGFpblwifVxuXG4gICAgICBkcm9wIGluIGNocm9tZSBbZnJvbSBicm93c2VyXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvaHRtbFwifVxuICAgICAgZHJvcCBpbiBzYWZhcmkgW2Zyb20gYnJvd3Nlcl06XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L2h0bWxcIn1cbiAgICAgIDI6IHtraW5kOiBcImZpbGVcIiwgdHlwZTogXCJpbWFnZS9wbmdcIn1cbiAgICAgIGRyb3AgaW4gZmlyZWZveCBbZnJvbSBicm93c2VyXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQveC1tb3otdXJsXCJ9XG4gICAgICAyOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG5cbiAgICAyLiBXZSBjYW4gZGV0ZXJtaW5lIGlmIGl0J3MgYSAnY29weXBhc3RlJyBvciBhICdkcm9wJywgYnV0IHdlIGNhbid0IGRpc2Nlcm4gYmV0d2VlbiBbQ29weSBJbWFnZV0gYW5kIFtDb3B5IEltYWdlIEFkZHJlc3NdXG5cbiAgQ09OQ0xVU0lPTlxuXG4gICAgMS4gJ3Bhc3RlJyAoW0NvcHkgSW1hZ2VdIG9yIFtDb3B5IEltYWdlIEFkZHJlc3NdLCB3ZSBjYW4ndCBkaXNjZXJuIGJldHdlZW4gdGhlc2UgdHdvKVxuICAgICAgRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlcmUgaXMgJ2ZpbGUnIGl0ZW0uIC5oYW5kbGVQYXN0ZSBpbiB0aGUgRGFzaGJvYXJkUGx1Z2luIHdpbGwgZGVhbCB3aXRoIGFsbCAnZmlsZScgaXRlbXMuXG4gICAgICBJZiB0aGVyZSBhcmUgbm8gJ2ZpbGUnIGl0ZW1zIC0gaGFuZGxlICd0ZXh0L3BsYWluJyBpdGVtcy5cblxuICAgIDIuICdkcm9wJ1xuICAgICAgVGFrZSAndGV4dC91cmktbGlzdCcgaXRlbXMuIFNhZmFyaSBoYXMgYW4gYWRkaXRpb25hbCBpdGVtIG9mIC5raW5kID09PSAnZmlsZScsIGFuZCB5b3UgbWF5IHdvcnJ5IGFib3V0IHRoZSBpdGVtIGJlaW5nXG4gICAgICBkdXBsaWNhdGVkIChmaXJzdCBieSBEYXNoYm9hcmRQbHVnaW4sIGFuZCB0aGVuIGJ5IFVybFBsdWdpbiwgbm93KSwgYnV0IGRvbid0LiBEaXJlY3RvcnkgaGFuZGxpbmcgY29kZSB3b24ndCBwYXlcbiAgICAgIGF0dGVudGlvbiB0byB0aGlzIHBhcnRpY3VsYXIgaXRlbSBvZiBraW5kICdmaWxlJy5cbiovXG5cbi8qKlxuICogRmluZHMgYWxsIGxpbmtzIGRyb3BwZWQvcGFzdGVkIGZyb20gb25lIGJyb3dzZXIgd2luZG93IHRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFUcmFuc2ZlciAtIERhdGFUcmFuc2ZlciBpbnN0YW5jZSwgZS5nLiBlLmNsaXBib2FyZERhdGEsIG9yIGUuZGF0YVRyYW5zZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNEcm9wT3JQYXN0ZSAtIGVpdGhlciAnZHJvcCcgb3IgJ3Bhc3RlJ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSAodXJsU3RyaW5nKSA9PiB7fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwgKGRhdGFUcmFuc2ZlciwgaXNEcm9wT3JQYXN0ZSwgY2FsbGJhY2spIHtcbiAgY29uc3QgaXRlbXMgPSB0b0FycmF5KGRhdGFUcmFuc2Zlci5pdGVtcylcblxuICBsZXQgdXJsSXRlbXNcblxuICBzd2l0Y2ggKGlzRHJvcE9yUGFzdGUpIHtcbiAgICBjYXNlICdwYXN0ZSc6IHtcbiAgICAgIGNvbnN0IGF0TGVhc3RPbmVGaWxlSXNEcmFnZ2VkID0gaXRlbXMuc29tZSgoaXRlbSkgPT4gaXRlbS5raW5kID09PSAnZmlsZScpXG4gICAgICBpZiAoYXRMZWFzdE9uZUZpbGVJc0RyYWdnZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cmxJdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5raW5kID09PSAnc3RyaW5nJ1xuICAgICAgICAgICYmIGl0ZW0udHlwZSA9PT0gJ3RleHQvcGxhaW4nKVxuXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdkcm9wJzoge1xuICAgICAgdXJsSXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0ua2luZCA9PT0gJ3N0cmluZydcbiAgICAgICAgJiYgaXRlbS50eXBlID09PSAndGV4dC91cmktbGlzdCcpXG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlzRHJvcE9yUGFzdGUgbXVzdCBiZSBlaXRoZXIgJ2Ryb3AnIG9yICdwYXN0ZScsIGJ1dCBpdCdzICR7aXNEcm9wT3JQYXN0ZX1gKVxuICAgIH1cbiAgfVxuXG4gIHVybEl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpdGVtLmdldEFzU3RyaW5nKCh1cmxTdHJpbmcpID0+IGNhbGxiYWNrKHVybFN0cmluZykpXG4gIH0pXG59XG4iLCIvKipcbiAqIENyZWF0ZSBhIHdyYXBwZXIgYXJvdW5kIGFuIGV2ZW50IGVtaXR0ZXIgd2l0aCBhIGByZW1vdmVgIG1ldGhvZCB0byByZW1vdmVcbiAqIGFsbCBldmVudHMgdGhhdCB3ZXJlIGFkZGVkIHVzaW5nIHRoZSB3cmFwcGVkIGVtaXR0ZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRXZlbnRUcmFja2VyIHtcbiAgI2VtaXR0ZXJcblxuICAjZXZlbnRzID0gW11cblxuICBjb25zdHJ1Y3RvciAoZW1pdHRlcikge1xuICAgIHRoaXMuI2VtaXR0ZXIgPSBlbWl0dGVyXG4gIH1cblxuICBvbiAoZXZlbnQsIGZuKSB7XG4gICAgdGhpcy4jZXZlbnRzLnB1c2goW2V2ZW50LCBmbl0pXG4gICAgcmV0dXJuIHRoaXMuI2VtaXR0ZXIub24oZXZlbnQsIGZuKVxuICB9XG5cbiAgcmVtb3ZlICgpIHtcbiAgICBmb3IgKGNvbnN0IFtldmVudCwgZm5dIG9mIHRoaXMuI2V2ZW50cy5zcGxpY2UoMCkpIHtcbiAgICAgIHRoaXMuI2VtaXR0ZXIub2ZmKGV2ZW50LCBmbilcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAnYVtocmVmXTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnYXJlYVtocmVmXTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdpZnJhbWU6bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ29iamVjdDpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnZW1iZWQ6bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG5dXG4iLCJjbGFzcyBOZXR3b3JrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChlcnJvciwgeGhyID0gbnVsbCkge1xuICAgIHN1cGVyKGBUaGlzIGxvb2tzIGxpa2UgYSBuZXR3b3JrIGVycm9yLCB0aGUgZW5kcG9pbnQgbWlnaHQgYmUgYmxvY2tlZCBieSBhbiBpbnRlcm5ldCBwcm92aWRlciBvciBhIGZpcmV3YWxsLmApXG5cbiAgICB0aGlzLmNhdXNlID0gZXJyb3JcbiAgICB0aGlzLmlzTmV0d29ya0Vycm9yID0gdHJ1ZVxuICAgIHRoaXMucmVxdWVzdCA9IHhoclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya0Vycm9yXG4iLCJmdW5jdGlvbiBjcmVhdGVDYW5jZWxFcnJvciAoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0NhbmNlbGxlZCcpXG59XG5cbmNsYXNzIFJhdGVMaW1pdGVkUXVldWUge1xuICAjYWN0aXZlUmVxdWVzdHMgPSAwXG5cbiAgI3F1ZXVlZEhhbmRsZXJzID0gW11cblxuICBjb25zdHJ1Y3RvciAobGltaXQpIHtcbiAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyB8fCBsaW1pdCA9PT0gMCkge1xuICAgICAgdGhpcy5saW1pdCA9IEluZmluaXR5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGltaXQgPSBsaW1pdFxuICAgIH1cbiAgfVxuXG4gICNjYWxsIChmbikge1xuICAgIHRoaXMuI2FjdGl2ZVJlcXVlc3RzICs9IDFcblxuICAgIGxldCBkb25lID0gZmFsc2VcblxuICAgIGxldCBjYW5jZWxBY3RpdmVcbiAgICB0cnkge1xuICAgICAgY2FuY2VsQWN0aXZlID0gZm4oKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy4jYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiAoKSA9PiB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm5cbiAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy4jYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgICBjYW5jZWxBY3RpdmUoKVxuICAgICAgICB0aGlzLiNxdWV1ZU5leHQoKVxuICAgICAgfSxcblxuICAgICAgZG9uZTogKCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMuI2FjdGl2ZVJlcXVlc3RzIC09IDFcbiAgICAgICAgdGhpcy4jcXVldWVOZXh0KClcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgI3F1ZXVlTmV4dCAoKSB7XG4gICAgLy8gRG8gaXQgc29vbiBidXQgbm90IGltbWVkaWF0ZWx5LCB0aGlzIGFsbG93cyBjbGVhcmluZyBvdXQgdGhlIGVudGlyZSBxdWV1ZSBzeW5jaHJvbm91c2x5XG4gICAgLy8gb25lIGJ5IG9uZSB3aXRob3V0IGNvbnRpbnVvdXNseSBfYWR2YW5jaW5nXyBpdCAoYW5kIHN0YXJ0aW5nIG5ldyB0YXNrcyBiZWZvcmUgaW1tZWRpYXRlbHlcbiAgICAvLyBhYm9ydGluZyB0aGVtKVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHRoaXMuI25leHQoKSlcbiAgfVxuXG4gICNuZXh0ICgpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlUmVxdWVzdHMgPj0gdGhpcy5saW1pdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLiNxdWV1ZWRIYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIERpc3BhdGNoIHRoZSBuZXh0IHJlcXVlc3QsIGFuZCB1cGRhdGUgdGhlIGFib3J0L2RvbmUgaGFuZGxlcnNcbiAgICAvLyBzbyB0aGF0IGNhbmNlbGxpbmcgaXQgZG9lcyB0aGUgUmlnaHQgVGhpbmcgKGFuZCBkb2Vzbid0IGp1c3QgdHJ5XG4gICAgLy8gdG8gZGVxdWV1ZSBhbiBhbHJlYWR5LXJ1bm5pbmcgcmVxdWVzdCkuXG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3F1ZXVlZEhhbmRsZXJzLnNoaWZ0KClcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy4jY2FsbChuZXh0LmZuKVxuICAgIG5leHQuYWJvcnQgPSBoYW5kbGVyLmFib3J0XG4gICAgbmV4dC5kb25lID0gaGFuZGxlci5kb25lXG4gIH1cblxuICAjcXVldWUgKGZuLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgZm4sXG4gICAgICBwcmlvcml0eTogb3B0aW9ucy5wcmlvcml0eSB8fCAwLFxuICAgICAgYWJvcnQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4jZGVxdWV1ZShoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRvbmU6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbWFyayBhIHF1ZXVlZCByZXF1ZXN0IGFzIGRvbmU6IHRoaXMgaW5kaWNhdGVzIGEgYnVnJylcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNxdWV1ZWRIYW5kbGVycy5maW5kSW5kZXgoKG90aGVyKSA9PiB7XG4gICAgICByZXR1cm4gaGFuZGxlci5wcmlvcml0eSA+IG90aGVyLnByaW9yaXR5XG4gICAgfSlcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLiNxdWV1ZWRIYW5kbGVycy5wdXNoKGhhbmRsZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3F1ZXVlZEhhbmRsZXJzLnNwbGljZShpbmRleCwgMCwgaGFuZGxlcilcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXJcbiAgfVxuXG4gICNkZXF1ZXVlIChoYW5kbGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNxdWV1ZWRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy4jcXVldWVkSGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxuXG4gIHJ1biAoZm4sIHF1ZXVlT3B0aW9ucykge1xuICAgIGlmICh0aGlzLiNhY3RpdmVSZXF1ZXN0cyA8IHRoaXMubGltaXQpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWxsKGZuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jcXVldWUoZm4sIHF1ZXVlT3B0aW9ucylcbiAgfVxuXG4gIHdyYXBQcm9taXNlRnVuY3Rpb24gKGZuLCBxdWV1ZU9wdGlvbnMpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxldCBxdWV1ZWRSZXF1ZXN0XG4gICAgICBjb25zdCBvdXRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgbGV0IGNhbmNlbEVycm9yXG4gICAgICAgICAgbGV0IGlubmVyUHJvbWlzZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbm5lclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZm4oLi4uYXJncykpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpbm5lclByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5uZXJQcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbEVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChjYW5jZWxFcnJvcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxFcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoY2FuY2VsRXJyb3IpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuICAgICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsRXJyb3IgPSBjcmVhdGVDYW5jZWxFcnJvcigpXG4gICAgICAgICAgfVxuICAgICAgICB9LCBxdWV1ZU9wdGlvbnMpXG4gICAgICB9KVxuXG4gICAgICBvdXRlclByb21pc2UuYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0ZXJQcm9taXNlXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBSYXRlTGltaXRlZFF1ZXVlLFxuICBpbnRlcm5hbFJhdGVMaW1pdGVkUXVldWU6IFN5bWJvbCgnX19xdWV1ZScpLFxufVxuIiwiY29uc3QgaGFzID0gcmVxdWlyZSgnLi9oYXNQcm9wZXJ0eScpXG5cbmZ1bmN0aW9uIGluc2VydFJlcGxhY2VtZW50IChzb3VyY2UsIHJ4LCByZXBsYWNlbWVudCkge1xuICBjb25zdCBuZXdQYXJ0cyA9IFtdXG4gIHNvdXJjZS5mb3JFYWNoKChjaHVuaykgPT4ge1xuICAgIC8vIFdoZW4gdGhlIHNvdXJjZSBjb250YWlucyBtdWx0aXBsZSBwbGFjZWhvbGRlcnMgZm9yIGludGVycG9sYXRpb24sXG4gICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSBjaHVua3MgdGhhdCBhcmUgbm90IHN0cmluZ3MsIGJlY2F1c2UgdGhvc2VcbiAgICAvLyBjYW4gYmUgSlNYIG9iamVjdHMgYW5kIHdpbGwgYmUgb3RoZXJ3aXNlIGluY29ycmVjdGx5IHR1cm5lZCBpbnRvIHN0cmluZ3MuXG4gICAgLy8gV2l0aG91dCB0aGlzIGNvbmRpdGlvbiB3ZeKAmWQgZ2V0IHRoaXM6IFtvYmplY3QgT2JqZWN0XSBoZWxsbyBbb2JqZWN0IE9iamVjdF0gbXkgPGJ1dHRvbj5cbiAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG5ld1BhcnRzLnB1c2goY2h1bmspXG4gICAgfVxuXG4gICAgcmV0dXJuIHJ4W1N5bWJvbC5zcGxpdF0oY2h1bmspLmZvckVhY2goKHJhdywgaSwgbGlzdCkgPT4ge1xuICAgICAgaWYgKHJhdyAhPT0gJycpIHtcbiAgICAgICAgbmV3UGFydHMucHVzaChyYXcpXG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybGFjZSB3aXRoIHRoZSBgcmVwbGFjZW1lbnRgIHZhbHVlXG4gICAgICBpZiAoaSA8IGxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICBuZXdQYXJ0cy5wdXNoKHJlcGxhY2VtZW50KVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG4gIHJldHVybiBuZXdQYXJ0c1xufVxuXG4vKipcbiAqIFRha2VzIGEgc3RyaW5nIHdpdGggcGxhY2Vob2xkZXIgdmFyaWFibGVzIGxpa2UgYCV7c21hcnRfY291bnR9IGZpbGUgc2VsZWN0ZWRgXG4gKiBhbmQgcmVwbGFjZXMgaXQgd2l0aCB2YWx1ZXMgZnJvbSBvcHRpb25zIGB7c21hcnRfY291bnQ6IDV9YFxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9haXJibmIvcG9seWdsb3QuanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWlyYm5iL3BvbHlnbG90LmpzL2Jsb2IvbWFzdGVyL2xpYi9wb2x5Z2xvdC5qcyNMMjk5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBocmFzZSB0aGF0IG5lZWRzIGludGVycG9sYXRpb24sIHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB3aXRoIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byByZXBsYWNlIHBsYWNlaG9sZGVyc1xuICogQHJldHVybnMge2FueVtdfSBpbnRlcnBvbGF0ZWRcbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUgKHBocmFzZSwgb3B0aW9ucykge1xuICBjb25zdCBkb2xsYXJSZWdleCA9IC9cXCQvZ1xuICBjb25zdCBkb2xsYXJCaWxsc1lhbGwgPSAnJCQkJCdcbiAgbGV0IGludGVycG9sYXRlZCA9IFtwaHJhc2VdXG5cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkgcmV0dXJuIGludGVycG9sYXRlZFxuXG4gIGZvciAoY29uc3QgYXJnIG9mIE9iamVjdC5rZXlzKG9wdGlvbnMpKSB7XG4gICAgaWYgKGFyZyAhPT0gJ18nKSB7XG4gICAgICAvLyBFbnN1cmUgcmVwbGFjZW1lbnQgdmFsdWUgaXMgZXNjYXBlZCB0byBwcmV2ZW50IHNwZWNpYWwgJC1wcmVmaXhlZFxuICAgICAgLy8gcmVnZXggcmVwbGFjZSB0b2tlbnMuIHRoZSBcIiQkJCRcIiBpcyBuZWVkZWQgYmVjYXVzZSBlYWNoIFwiJFwiIG5lZWRzIHRvXG4gICAgICAvLyBiZSBlc2NhcGVkIHdpdGggXCIkXCIgaXRzZWxmLCBhbmQgd2UgbmVlZCB0d28gaW4gdGhlIHJlc3VsdGluZyBvdXRwdXQuXG4gICAgICBsZXQgcmVwbGFjZW1lbnQgPSBvcHRpb25zW2FyZ11cbiAgICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gZG9sbGFyUmVnZXhbU3ltYm9sLnJlcGxhY2VdKHJlcGxhY2VtZW50LCBkb2xsYXJCaWxsc1lhbGwpXG4gICAgICB9XG4gICAgICAvLyBXZSBjcmVhdGUgYSBuZXcgYFJlZ0V4cGAgZWFjaCB0aW1lIGluc3RlYWQgb2YgdXNpbmcgYSBtb3JlLWVmZmljaWVudFxuICAgICAgLy8gc3RyaW5nIHJlcGxhY2Ugc28gdGhhdCB0aGUgc2FtZSBhcmd1bWVudCBjYW4gYmUgcmVwbGFjZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgIC8vIGluIHRoZSBzYW1lIHBocmFzZS5cbiAgICAgIGludGVycG9sYXRlZCA9IGluc2VydFJlcGxhY2VtZW50KGludGVycG9sYXRlZCwgbmV3IFJlZ0V4cChgJVxcXFx7JHthcmd9XFxcXH1gLCAnZycpLCByZXBsYWNlbWVudClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW50ZXJwb2xhdGVkXG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyBzdHJpbmdzIHdpdGggaW50ZXJwb2xhdGlvbiAmIHBsdXJhbGl6YXRpb24gc3VwcG9ydC5cbiAqIEV4dGVuc2libGUgd2l0aCBjdXN0b20gZGljdGlvbmFyaWVzIGFuZCBwbHVyYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBCb3Jyb3dzIGhlYXZpbHkgZnJvbSBhbmQgaW5zcGlyZWQgYnkgUG9seWdsb3QgaHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9wb2x5Z2xvdC5qcyxcbiAqIGJhc2ljYWxseSBhIHN0cmlwcGVkLWRvd24gdmVyc2lvbiBvZiBpdC4gRGlmZmVyZW5jZXM6IHBsdXJhbGl6YXRpb24gZnVuY3Rpb25zIGFyZSBub3QgaGFyZGNvZGVkXG4gKiBhbmQgY2FuIGJlIGVhc2lseSBhZGRlZCBhbW9uZyB3aXRoIGRpY3Rpb25hcmllcywgbmVzdGVkIG9iamVjdHMgYXJlIHVzZWQgZm9yIHBsdXJhbGl6YXRpb25cbiAqIGFzIG9wcG9zZWQgdG8gYHx8fHxgIGRlbGltZXRlclxuICpcbiAqIFVzYWdlIGV4YW1wbGU6IGB0cmFuc2xhdG9yLnRyYW5zbGF0ZSgnZmlsZXNfY2hvc2VuJywge3NtYXJ0X2NvdW50OiAzfSlgXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVHJhbnNsYXRvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdHxBcnJheTxvYmplY3Q+fSBsb2NhbGVzIC0gbG9jYWxlIG9yIGxpc3Qgb2YgbG9jYWxlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChsb2NhbGVzKSB7XG4gICAgdGhpcy5sb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7fSxcbiAgICAgIHBsdXJhbGl6ZSAobikge1xuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobG9jYWxlcykpIHtcbiAgICAgIGxvY2FsZXMuZm9yRWFjaCh0aGlzLiNhcHBseSwgdGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYXBwbHkobG9jYWxlcylcbiAgICB9XG4gIH1cblxuICAjYXBwbHkgKGxvY2FsZSkge1xuICAgIGlmICghbG9jYWxlPy5zdHJpbmdzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcmV2TG9jYWxlID0gdGhpcy5sb2NhbGVcbiAgICB0aGlzLmxvY2FsZSA9IHsgLi4ucHJldkxvY2FsZSwgc3RyaW5nczogeyAuLi5wcmV2TG9jYWxlLnN0cmluZ3MsIC4uLmxvY2FsZS5zdHJpbmdzIH0gfVxuICAgIHRoaXMubG9jYWxlLnBsdXJhbGl6ZSA9IGxvY2FsZS5wbHVyYWxpemUgfHwgcHJldkxvY2FsZS5wbHVyYWxpemVcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgdHJhbnNsYXRlIG1ldGhvZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGggdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIGxhdGVyIHRvIHJlcGxhY2UgcGxhY2Vob2xkZXJzIGluIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0cmFuc2xhdGVkIChhbmQgaW50ZXJwb2xhdGVkKVxuICAgKi9cbiAgdHJhbnNsYXRlIChrZXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVBcnJheShrZXksIG9wdGlvbnMpLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdHJhbnNsYXRpb24gYW5kIHJldHVybiB0aGUgdHJhbnNsYXRlZCBhbmQgaW50ZXJwb2xhdGVkIHBhcnRzIGFzIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGggdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcGxhY2UgcGxhY2Vob2xkZXJzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHRyYW5zbGF0ZWQgYW5kIGludGVycG9sYXRlZCBwYXJ0cywgaW4gb3JkZXIuXG4gICAqL1xuICB0cmFuc2xhdGVBcnJheSAoa2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKCFoYXModGhpcy5sb2NhbGUuc3RyaW5ncywga2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHN0cmluZzogJHtrZXl9YClcbiAgICB9XG5cbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLmxvY2FsZS5zdHJpbmdzW2tleV1cbiAgICBjb25zdCBoYXNQbHVyYWxGb3JtcyA9IHR5cGVvZiBzdHJpbmcgPT09ICdvYmplY3QnXG5cbiAgICBpZiAoaGFzUGx1cmFsRm9ybXMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnNtYXJ0X2NvdW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBwbHVyYWwgPSB0aGlzLmxvY2FsZS5wbHVyYWxpemUob3B0aW9ucy5zbWFydF9jb3VudClcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKHN0cmluZ1twbHVyYWxdLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gdXNlIGEgc3RyaW5nIHdpdGggcGx1cmFsIGZvcm1zLCBidXQgbm8gdmFsdWUgd2FzIGdpdmVuIGZvciAle3NtYXJ0X2NvdW50fScpXG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVycG9sYXRlKHN0cmluZywgb3B0aW9ucylcbiAgfVxufVxuIiwiLyoqXG4gKiBTYXZlIGEgPGNhbnZhcz4gZWxlbWVudCdzIGNvbnRlbnQgdG8gYSBCbG9iIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbnZhc1RvQmxvYiAoY2FudmFzLCB0eXBlLCBxdWFsaXR5KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNhbnZhcy50b0Jsb2IocmVzb2x2ZSwgdHlwZSwgcXVhbGl0eSlcbiAgfSlcbn1cbiIsImNvbnN0IERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KFteL10rXFwvW14sO10rKD86W14sXSo/KSkoO2Jhc2U2NCk/LChbXFxzXFxTXSopJC9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkYXRhVVJJdG9CbG9iIChkYXRhVVJJLCBvcHRzLCB0b0ZpbGUpIHtcbiAgLy8gZ2V0IHRoZSBiYXNlNjQgZGF0YVxuICBjb25zdCBkYXRhVVJJRGF0YSA9IERBVEFfVVJMX1BBVFRFUk4uZXhlYyhkYXRhVVJJKVxuXG4gIC8vIHVzZXIgbWF5IHByb3ZpZGUgbWltZSB0eXBlLCBpZiBub3QgZ2V0IGl0IGZyb20gZGF0YSBVUklcbiAgY29uc3QgbWltZVR5cGUgPSBvcHRzLm1pbWVUeXBlID8/IGRhdGFVUklEYXRhPy5bMV0gPz8gJ3BsYWluL3RleHQnXG5cbiAgbGV0IGRhdGFcbiAgaWYgKGRhdGFVUklEYXRhWzJdICE9IG51bGwpIHtcbiAgICBjb25zdCBiaW5hcnkgPSBhdG9iKGRlY29kZVVSSUNvbXBvbmVudChkYXRhVVJJRGF0YVszXSkpXG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpXG4gICAgfVxuICAgIGRhdGEgPSBbYnl0ZXNdXG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IFtkZWNvZGVVUklDb21wb25lbnQoZGF0YVVSSURhdGFbM10pXVxuICB9XG5cbiAgLy8gQ29udmVydCB0byBhIEZpbGU/XG4gIGlmICh0b0ZpbGUpIHtcbiAgICByZXR1cm4gbmV3IEZpbGUoZGF0YSwgb3B0cy5uYW1lIHx8ICcnLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IoZGF0YSwgeyB0eXBlOiBtaW1lVHlwZSB9KVxufVxuIiwiY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCdsb2Rhc2gudGhyb3R0bGUnKVxuXG5mdW5jdGlvbiBlbWl0U29ja2V0UHJvZ3Jlc3MgKHVwbG9hZGVyLCBwcm9ncmVzc0RhdGEsIGZpbGUpIHtcbiAgY29uc3QgeyBwcm9ncmVzcywgYnl0ZXNVcGxvYWRlZCwgYnl0ZXNUb3RhbCB9ID0gcHJvZ3Jlc3NEYXRhXG4gIGlmIChwcm9ncmVzcykge1xuICAgIHVwbG9hZGVyLnVwcHkubG9nKGBVcGxvYWQgcHJvZ3Jlc3M6ICR7cHJvZ3Jlc3N9YClcbiAgICB1cGxvYWRlci51cHB5LmVtaXQoJ3VwbG9hZC1wcm9ncmVzcycsIGZpbGUsIHtcbiAgICAgIHVwbG9hZGVyLFxuICAgICAgYnl0ZXNVcGxvYWRlZCxcbiAgICAgIGJ5dGVzVG90YWwsXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlKGVtaXRTb2NrZXRQcm9ncmVzcywgMzAwLCB7XG4gIGxlYWRpbmc6IHRydWUsXG4gIHRyYWlsaW5nOiB0cnVlLFxufSlcbiIsImNvbnN0IE5ldHdvcmtFcnJvciA9IHJlcXVpcmUoJy4vTmV0d29ya0Vycm9yJylcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB3aW5kb3cuZmV0Y2ggdGhhdCB0aHJvd3MgYSBOZXR3b3JrRXJyb3Igd2hlbiBhcHByb3ByaWF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZldGNoV2l0aE5ldHdvcmtFcnJvciAoLi4ub3B0aW9ucykge1xuICByZXR1cm4gZmV0Y2goLi4ub3B0aW9ucylcbiAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKGVycilcbiAgICAgIH1cbiAgICB9KVxufVxuIiwiY29uc3QgaXNET01FbGVtZW50ID0gcmVxdWlyZSgnLi9pc0RPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEZpbmQgb25lIG9yIG1vcmUgRE9NIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE5vZGV9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtOb2RlW118bnVsbH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaW5kQWxsRE9NRWxlbWVudHMgKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50KVxuICAgIHJldHVybiBlbGVtZW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogQXJyYXkuZnJvbShlbGVtZW50cylcbiAgfVxuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgaXNET01FbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtlbGVtZW50XVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsImNvbnN0IGlzRE9NRWxlbWVudCA9IHJlcXVpcmUoJy4vaXNET01FbGVtZW50JylcblxuLyoqXG4gKiBGaW5kIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfHN0cmluZ30gZWxlbWVudFxuICogQHJldHVybnMge05vZGV8bnVsbH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaW5kRE9NRWxlbWVudCAoZWxlbWVudCwgY29udGV4dCA9IGRvY3VtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpXG4gIH1cblxuICBpZiAoaXNET01FbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCJmdW5jdGlvbiBlbmNvZGVDaGFyYWN0ZXIgKGNoYXJhY3Rlcikge1xuICByZXR1cm4gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMzIpXG59XG5cbmZ1bmN0aW9uIGVuY29kZUZpbGVuYW1lIChuYW1lKSB7XG4gIGxldCBzdWZmaXggPSAnJ1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bXkEtWjAtOV0vaWcsIChjaGFyYWN0ZXIpID0+IHtcbiAgICBzdWZmaXggKz0gYC0ke2VuY29kZUNoYXJhY3RlcihjaGFyYWN0ZXIpfWBcbiAgICByZXR1cm4gJy8nXG4gIH0pICsgc3VmZml4XG59XG5cbi8qKlxuICogVGFrZXMgYSBmaWxlIG9iamVjdCBhbmQgdHVybnMgaXQgaW50byBmaWxlSUQsIGJ5IGNvbnZlcnRpbmcgZmlsZS5uYW1lIHRvIGxvd2VyY2FzZSxcbiAqIHJlbW92aW5nIGV4dHJhIGNoYXJhY3RlcnMgYW5kIGFkZGluZyB0eXBlLCBzaXplIGFuZCBsYXN0TW9kaWZpZWRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZmlsZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGZpbGVJRFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlRmlsZUlEIChmaWxlKSB7XG4gIC8vIEl0J3MgdGVtcHRpbmcgdG8gZG8gYFtpdGVtc10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKWAgaGVyZSwgYnV0IHRoYXRcbiAgLy8gaXMgc2xvd2VyISBzaW1wbGUgc3RyaW5nIGNvbmNhdGVuYXRpb24gaXMgZmFzdFxuXG4gIGxldCBpZCA9ICd1cHB5J1xuICBpZiAodHlwZW9mIGZpbGUubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZCArPSBgLSR7ZW5jb2RlRmlsZW5hbWUoZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkpfWBcbiAgfVxuXG4gIGlmIChmaWxlLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlkICs9IGAtJHtmaWxlLnR5cGV9YFxuICB9XG5cbiAgaWYgKGZpbGUubWV0YSAmJiB0eXBlb2YgZmlsZS5tZXRhLnJlbGF0aXZlUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZCArPSBgLSR7ZW5jb2RlRmlsZW5hbWUoZmlsZS5tZXRhLnJlbGF0aXZlUGF0aC50b0xvd2VyQ2FzZSgpKX1gXG4gIH1cblxuICBpZiAoZmlsZS5kYXRhLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlkICs9IGAtJHtmaWxlLmRhdGEuc2l6ZX1gXG4gIH1cbiAgaWYgKGZpbGUuZGF0YS5sYXN0TW9kaWZpZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlkICs9IGAtJHtmaWxlLmRhdGEubGFzdE1vZGlmaWVkfWBcbiAgfVxuXG4gIHJldHVybiBpZFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCeXRlc1JlbWFpbmluZyAoZmlsZVByb2dyZXNzKSB7XG4gIHJldHVybiBmaWxlUHJvZ3Jlc3MuYnl0ZXNUb3RhbCAtIGZpbGVQcm9ncmVzcy5ieXRlc1VwbG9hZGVkXG59XG4iLCJjb25zdCB3ZWJraXRHZXRBc0VudHJ5QXBpID0gcmVxdWlyZSgnLi91dGlscy93ZWJraXRHZXRBc0VudHJ5QXBpL2luZGV4JylcbmNvbnN0IGZhbGxiYWNrQXBpID0gcmVxdWlyZSgnLi91dGlscy9mYWxsYmFja0FwaScpXG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYXJyYXkgb2YgZHJvcHBlZCBmaWxlcyAoaWYgYSBmb2xkZXIgaXNcbiAqIGRyb3BwZWQsIGFuZCBicm93c2VyIHN1cHBvcnRzIGZvbGRlciBwYXJzaW5nIC0gcHJvbWlzZSByZXNvbHZlcyB0byB0aGUgZmxhdFxuICogYXJyYXkgb2YgYWxsIGZpbGVzIGluIGFsbCBkaXJlY3RvcmllcykuXG4gKiBFYWNoIGZpbGUgaGFzIC5yZWxhdGl2ZVBhdGggcHJvcCBhcHBlbmRlZCB0byBpdCAoZS5nLiBcIi9kb2NzL1ByYWd1ZS90aWNrZXRfZnJvbV9wcmFndWVfdG9fdWZhLnBkZlwiKVxuICogaWYgYnJvd3NlciBzdXBwb3J0cyBpdC4gT3RoZXJ3aXNlIGl0J3MgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7RGF0YVRyYW5zZmVyfSBkYXRhVHJhbnNmZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxvZ0Ryb3BFcnJvciAtIGEgZnVuY3Rpb24gdGhhdCdzIGNhbGxlZCBldmVyeSB0aW1lIHNvbWVcbiAqIGZvbGRlciBvciBzb21lIGZpbGUgZXJyb3Igb3V0IChlLmcuIGJlY2F1c2Ugb2YgdGhlIGZvbGRlciBuYW1lIGJlaW5nIHRvbyBsb25nXG4gKiBvbiBXaW5kb3dzKS4gTm90aWNlIHRoYXQgcmVzdWx0aW5nIHByb21pc2Ugd2lsbCBhbHdheXMgYmUgcmVzb2x2ZWQgYW55d2F5LlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIEFycmF5PEZpbGU+XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RHJvcHBlZEZpbGVzIChkYXRhVHJhbnNmZXIsIHsgbG9nRHJvcEVycm9yID0gKCkgPT4ge30gfSA9IHt9KSB7XG4gIC8vIEdldCBhbGwgZmlsZXMgZnJvbSBhbGwgc3ViZGlycy4gV29ya3MgKGF0IGxlYXN0KSBpbiBDaHJvbWUsIE1vemlsbGEsIGFuZCBTYWZhcmlcbiAgaWYgKGRhdGFUcmFuc2Zlci5pdGVtcz8uWzBdICYmICd3ZWJraXRHZXRBc0VudHJ5JyBpbiBkYXRhVHJhbnNmZXIuaXRlbXNbMF0pIHtcbiAgICByZXR1cm4gd2Via2l0R2V0QXNFbnRyeUFwaShkYXRhVHJhbnNmZXIsIGxvZ0Ryb3BFcnJvcilcbiAgLy8gT3RoZXJ3aXNlIGp1c3QgcmV0dXJuIGFsbCBmaXJzdC1vcmRlciBmaWxlc1xuICB9XG4gIHJldHVybiBmYWxsYmFja0FwaShkYXRhVHJhbnNmZXIpXG59XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnLi4vLi4vdG9BcnJheScpXG5cbi8vIC5maWxlcyBmYWxsYmFjaywgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGFueSBicm93c2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZhbGxiYWNrQXBpIChkYXRhVHJhbnNmZXIpIHtcbiAgY29uc3QgZmlsZXMgPSB0b0FycmF5KGRhdGFUcmFuc2Zlci5maWxlcylcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmaWxlcylcbn1cbiIsIi8qKlxuICogUmVjdXJzaXZlIGZ1bmN0aW9uLCBjYWxscyB0aGUgb3JpZ2luYWwgY2FsbGJhY2soKSB3aGVuIHRoZSBkaXJlY3RvcnkgaXMgZW50aXJlbHkgcGFyc2VkLlxuICpcbiAqIEBwYXJhbSB7RmlsZVN5c3RlbURpcmVjdG9yeVJlYWRlcn0gZGlyZWN0b3J5UmVhZGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvbGRFbnRyaWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsb2dEcm9wRXJyb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGVkIHdpdGggKFsgYWxsIGZpbGVzIGFuZCBkaXJlY3RvcmllcyBpbiB0aGF0IGRpcmVjdG9yeVJlYWRlciBdKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5IChkaXJlY3RvcnlSZWFkZXIsIG9sZEVudHJpZXMsIGxvZ0Ryb3BFcnJvciwgeyBvblN1Y2Nlc3MgfSkge1xuICBkaXJlY3RvcnlSZWFkZXIucmVhZEVudHJpZXMoXG4gICAgKGVudHJpZXMpID0+IHtcbiAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSBbLi4ub2xkRW50cmllcywgLi4uZW50cmllc11cbiAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgRmlsZVN5c3RlbSBBUEkgc3BlYywgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoKVxuICAgICAgLy8gbXVzdCBiZSBjYWxsZWQgdW50aWwgaXQgY2FsbHMgdGhlIG9uU3VjY2VzcyB3aXRoIGFuIGVtcHR5IGFycmF5LlxuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5KGRpcmVjdG9yeVJlYWRlciwgbmV3RW50cmllcywgbG9nRHJvcEVycm9yLCB7IG9uU3VjY2VzcyB9KVxuICAgICAgICB9LCAwKVxuICAgICAgLy8gRG9uZSBpdGVyYXRpbmcgdGhpcyBwYXJ0aWN1bGFyIGRpcmVjdG9yeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25TdWNjZXNzKG5ld0VudHJpZXMpXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBNYWtlIHN1cmUgd2UgcmVzb2x2ZSBvbiBlcnJvciBhbnl3YXksIGl0J3MgZmluZSBpZiBvbmx5IG9uZSBkaXJlY3RvcnkgY291bGRuJ3QgYmUgcGFyc2VkIVxuICAgIChlcnJvcikgPT4ge1xuICAgICAgbG9nRHJvcEVycm9yKGVycm9yKVxuICAgICAgb25TdWNjZXNzKG9sZEVudHJpZXMpXG4gICAgfSxcbiAgKVxufVxuIiwiLyoqXG4gKiBHZXQgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgRmlsZUVudHJ5I2Z1bGxQYXRoLCBiZWNhdXNlIEZpbGUjd2Via2l0UmVsYXRpdmVQYXRoIGlzIGFsd2F5cyAnJywgYXQgbGVhc3Qgb25Ecm9wLlxuICpcbiAqIEBwYXJhbSB7RmlsZUVudHJ5fSBmaWxlRW50cnlcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IC0gaWYgZmlsZSBpcyBub3QgaW4gYSBmb2xkZXIgLSByZXR1cm4gbnVsbCAodGhpcyBpcyB0b1xuICogYmUgY29uc2lzdGVudCB3aXRoIC5yZWxhdGl2ZVBhdGgtcyBvZiBmaWxlcyBzZWxlY3RlZCBmcm9tIE15IERldmljZSkuIElmIGZpbGVcbiAqIGlzIGluIGEgZm9sZGVyIC0gcmV0dXJuIGl0cyBmdWxsUGF0aCwgZS5nLiAnL3NpbXBzb25zL2hpLmpwZWcnLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFJlbGF0aXZlUGF0aCAoZmlsZUVudHJ5KSB7XG4gIC8vIGZpbGVFbnRyeS5mdWxsUGF0aCAtIFwiL3NpbXBzb25zL2hpLmpwZWdcIiBvciB1bmRlZmluZWQgKGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQpXG4gIC8vIGZpbGVFbnRyeS5uYW1lIC0gXCJoaS5qcGVnXCJcbiAgaWYgKCFmaWxlRW50cnkuZnVsbFBhdGggfHwgZmlsZUVudHJ5LmZ1bGxQYXRoID09PSBgLyR7ZmlsZUVudHJ5Lm5hbWV9YCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgcmV0dXJuIGZpbGVFbnRyeS5mdWxsUGF0aFxufVxuIiwiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJy4uLy4uLy4uL3RvQXJyYXknKVxuY29uc3QgZ2V0UmVsYXRpdmVQYXRoID0gcmVxdWlyZSgnLi9nZXRSZWxhdGl2ZVBhdGgnKVxuY29uc3QgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkgPSByZXF1aXJlKCcuL2dldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3ZWJraXRHZXRBc0VudHJ5QXBpIChkYXRhVHJhbnNmZXIsIGxvZ0Ryb3BFcnJvcikge1xuICBjb25zdCBmaWxlcyA9IFtdXG5cbiAgY29uc3Qgcm9vdFByb21pc2VzID0gW11cblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlc29sdmVkIHByb21pc2UsIHdoZW4gOmZpbGVzIGFycmF5IGlzIGVuaGFuY2VkXG4gICAqXG4gICAqIEBwYXJhbSB7KEZpbGVTeXN0ZW1GaWxlRW50cnl8RmlsZVN5c3RlbURpcmVjdG9yeUVudHJ5KX0gZW50cnlcbiAgICogQHJldHVybnMge1Byb21pc2V9IC0gZW1wdHkgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gOmZpbGVzIGlzIGVuaGFuY2VkIHdpdGggYSBmaWxlXG4gICAqL1xuICBjb25zdCBjcmVhdGVQcm9taXNlVG9BZGRGaWxlT3JQYXJzZURpcmVjdG9yeSA9IChlbnRyeSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAvLyBUaGlzIGlzIGEgYmFzZSBjYWxsXG4gICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgLy8gQ3JlYXRlcyBhIG5ldyBGaWxlIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byByZWFkIHRoZSBmaWxlLlxuICAgICAgZW50cnkuZmlsZShcbiAgICAgICAgKGZpbGUpID0+IHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICBmaWxlLnJlbGF0aXZlUGF0aCA9IGdldFJlbGF0aXZlUGF0aChlbnRyeSlcbiAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSByZXNvbHZlIG9uIGVycm9yIGFueXdheSwgaXQncyBmaW5lIGlmIG9ubHkgb25lIGZpbGUgY291bGRuJ3QgYmUgcmVhZCFcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgbG9nRHJvcEVycm9yKGVycm9yKVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9LFxuICAgICAgKVxuICAgICAgLy8gVGhpcyBpcyBhIHJlY3Vyc2l2ZSBjYWxsXG4gICAgfSBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgY29uc3QgZGlyZWN0b3J5UmVhZGVyID0gZW50cnkuY3JlYXRlUmVhZGVyKClcbiAgICAgIGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5KGRpcmVjdG9yeVJlYWRlciwgW10sIGxvZ0Ryb3BFcnJvciwge1xuICAgICAgICBvblN1Y2Nlc3M6IChlbnRyaWVzKSA9PiByZXNvbHZlKFByb21pc2UuYWxsKFxuICAgICAgICAgIGVudHJpZXMubWFwKGNyZWF0ZVByb21pc2VUb0FkZEZpbGVPclBhcnNlRGlyZWN0b3J5KSxcbiAgICAgICAgKSksXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICAvLyBGb3IgZWFjaCBkcm9wcGVkIGl0ZW0sIC0gbWFrZSBzdXJlIGl0J3MgYSBmaWxlL2RpcmVjdG9yeSwgYW5kIHN0YXJ0IGRlZXBlbmluZyBpbiFcbiAgdG9BcnJheShkYXRhVHJhbnNmZXIuaXRlbXMpXG4gICAgLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KClcbiAgICAgIC8vIDplbnRyeSBjYW4gYmUgbnVsbCB3aGVuIHdlIGRyb3AgdGhlIHVybCBlLmcuXG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgcm9vdFByb21pc2VzLnB1c2goY3JlYXRlUHJvbWlzZVRvQWRkRmlsZU9yUGFyc2VEaXJlY3RvcnkoZW50cnkpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKHJvb3RQcm9taXNlcylcbiAgICAudGhlbigoKSA9PiBmaWxlcylcbn1cbiIsIi8qKlxuICogVGFrZXMgYSBmdWxsIGZpbGVuYW1lIHN0cmluZyBhbmQgcmV0dXJucyBhbiBvYmplY3Qge25hbWUsIGV4dGVuc2lvbn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVsbEZpbGVOYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB7bmFtZSwgZXh0ZW5zaW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uIChmdWxsRmlsZU5hbWUpIHtcbiAgY29uc3QgbGFzdERvdCA9IGZ1bGxGaWxlTmFtZS5sYXN0SW5kZXhPZignLicpXG4gIC8vIHRoZXNlIGNvdW50IGFzIG5vIGV4dGVuc2lvbjogXCJuby1kb3RcIiwgXCJ0cmFpbGluZy1kb3QuXCJcbiAgaWYgKGxhc3REb3QgPT09IC0xIHx8IGxhc3REb3QgPT09IGZ1bGxGaWxlTmFtZS5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGZ1bGxGaWxlTmFtZSxcbiAgICAgIGV4dGVuc2lvbjogdW5kZWZpbmVkLFxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IGZ1bGxGaWxlTmFtZS5zbGljZSgwLCBsYXN0RG90KSxcbiAgICBleHRlbnNpb246IGZ1bGxGaWxlTmFtZS5zbGljZShsYXN0RG90ICsgMSksXG4gIH1cbn1cbiIsImNvbnN0IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9nZXRGaWxlTmFtZUFuZEV4dGVuc2lvbicpXG5jb25zdCBtaW1lVHlwZXMgPSByZXF1aXJlKCcuL21pbWVUeXBlcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RmlsZVR5cGUgKGZpbGUpIHtcbiAgaWYgKGZpbGUudHlwZSkgcmV0dXJuIGZpbGUudHlwZVxuXG4gIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBmaWxlLm5hbWUgPyBnZXRGaWxlTmFtZUFuZEV4dGVuc2lvbihmaWxlLm5hbWUpLmV4dGVuc2lvbj8udG9Mb3dlckNhc2UoKSA6IG51bGxcbiAgaWYgKGZpbGVFeHRlbnNpb24gJiYgZmlsZUV4dGVuc2lvbiBpbiBtaW1lVHlwZXMpIHtcbiAgICAvLyBlbHNlLCBzZWUgaWYgd2UgY2FuIG1hcCBleHRlbnNpb24gdG8gYSBtaW1lIHR5cGVcbiAgICByZXR1cm4gbWltZVR5cGVzW2ZpbGVFeHRlbnNpb25dXG4gIH1cbiAgLy8gaWYgYWxsIGZhaWxzLCBmYWxsIGJhY2sgdG8gYSBnZW5lcmljIGJ5dGUgc3RyZWFtIHR5cGVcbiAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG59XG4iLCJjb25zdCBtaW1lVG9FeHRlbnNpb25zID0ge1xuICAnYXVkaW8vbXAzJzogJ21wMycsXG4gICdhdWRpby9tcDQnOiAnbXA0JyxcbiAgJ2F1ZGlvL29nZyc6ICdvZ2cnLFxuICAnYXVkaW8vd2VibSc6ICd3ZWJtJyxcbiAgJ2ltYWdlL2dpZic6ICdnaWYnLFxuICAnaW1hZ2UvaGVpYyc6ICdoZWljJyxcbiAgJ2ltYWdlL2hlaWYnOiAnaGVpZicsXG4gICdpbWFnZS9qcGVnJzogJ2pwZycsXG4gICdpbWFnZS9wbmcnOiAncG5nJyxcbiAgJ2ltYWdlL3N2Zyt4bWwnOiAnc3ZnJyxcbiAgJ3ZpZGVvL21wNCc6ICdtcDQnLFxuICAndmlkZW8vb2dnJzogJ29ndicsXG4gICd2aWRlby9xdWlja3RpbWUnOiAnbW92JyxcbiAgJ3ZpZGVvL3dlYm0nOiAnd2VibScsXG4gICd2aWRlby94LW1hdHJvc2thJzogJ21rdicsXG4gICd2aWRlby94LW1zdmlkZW8nOiAnYXZpJyxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZUV4dGVuc2lvbiAobWltZVR5cGUpIHtcbiAgLy8gUmVtb3ZlIHRoZSA7IGJpdCBpbiAndmlkZW8veC1tYXRyb3NrYTtjb2RlY3M9YXZjMSdcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIFttaW1lVHlwZV0gPSBtaW1lVHlwZS5zcGxpdCgnOycsIDEpXG4gIHJldHVybiBtaW1lVG9FeHRlbnNpb25zW21pbWVUeXBlXSB8fCBudWxsXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNvY2tldEhvc3QgKHVybCkge1xuICAvLyBnZXQgdGhlIGhvc3QgZG9tYWluXG4gIGNvbnN0IHJlZ2V4ID0gL14oPzpodHRwcz86XFwvXFwvfFxcL1xcLyk/KD86W15AXFxuXStAKT8oPzp3d3dcXC4pPyhbXlxcbl0rKS9pXG4gIGNvbnN0IGhvc3QgPSByZWdleC5leGVjKHVybClbMV1cbiAgY29uc3Qgc29ja2V0UHJvdG9jb2wgPSAvXmh0dHA6XFwvXFwvL2kudGVzdCh1cmwpID8gJ3dzJyA6ICd3c3MnXG5cbiAgcmV0dXJuIGAke3NvY2tldFByb3RvY29sfTovLyR7aG9zdH1gXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNwZWVkIChmaWxlUHJvZ3Jlc3MpIHtcbiAgaWYgKCFmaWxlUHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZCkgcmV0dXJuIDBcblxuICBjb25zdCB0aW1lRWxhcHNlZCA9IERhdGUubm93KCkgLSBmaWxlUHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICBjb25zdCB1cGxvYWRTcGVlZCA9IGZpbGVQcm9ncmVzcy5ieXRlc1VwbG9hZGVkIC8gKHRpbWVFbGFwc2VkIC8gMTAwMClcbiAgcmV0dXJuIHVwbG9hZFNwZWVkXG59XG4iLCIvKipcbiAqIEdldCB0aGUgZGVjbGFyZWQgdGV4dCBkaXJlY3Rpb24gZm9yIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbGVtZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRUZXh0RGlyZWN0aW9uIChlbGVtZW50KSB7XG4gIC8vIFRoZXJlIGlzIGFub3RoZXIgd2F5IHRvIGRldGVybWluZSB0ZXh0IGRpcmVjdGlvbiB1c2luZyBnZXRDb21wdXRlZFN0eWxlKCksIGFzIGRvbmUgaGVyZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BlbmNpbC1qcy90ZXh0LWRpcmVjdGlvbi9ibG9iLzJhMjM1Y2U5NTA4OWIzMTg1YWNlYzNiNTEzMTNjYmJhOTIxYjM4MTEvdGV4dC1kaXJlY3Rpb24uanNcbiAgLy9cbiAgLy8gV2UgZG8gbm90IHVzZSB0aGF0IGFwcHJvYWNoIGJlY2F1c2Ugd2UgYXJlIGludGVyZXN0ZWQgc3BlY2lmaWNhbGx5IGluIHRoZSBfZGVjbGFyZWRfIHRleHQgZGlyZWN0aW9uLlxuICAvLyBJZiBubyB0ZXh0IGRpcmVjdGlvbiBpcyBkZWNsYXJlZCwgd2UgaGF2ZSB0byBwcm92aWRlIG91ciBvd24gZXhwbGljaXQgdGV4dCBkaXJlY3Rpb24gc28gb3VyXG4gIC8vIGJpZGlyZWN0aW9uYWwgQ1NTIHN0eWxlIHNoZWV0cyB3b3JrLlxuICB3aGlsZSAoZWxlbWVudCAmJiAhZWxlbWVudC5kaXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlXG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ/LmRpclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHREaXJlY3Rpb25cbiIsIi8qKlxuICogQWRkcyB6ZXJvIHRvIHN0cmluZ3Mgc2hvcnRlciB0aGFuIHR3byBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhZCAobnVtYmVyKSB7XG4gIHJldHVybiBudW1iZXIgPCAxMCA/IGAwJHtudW1iZXJ9YCA6IG51bWJlci50b1N0cmluZygpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiB0aGUgZm9ybWF0IG9mIGBob3VyczptaW51dGVzOnNlY29uZHNgXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0VGltZVN0YW1wICgpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKClcbiAgY29uc3QgaG91cnMgPSBwYWQoZGF0ZS5nZXRIb3VycygpKVxuICBjb25zdCBtaW51dGVzID0gcGFkKGRhdGUuZ2V0TWludXRlcygpKVxuICBjb25zdCBzZWNvbmRzID0gcGFkKGRhdGUuZ2V0U2Vjb25kcygpKVxuICByZXR1cm4gYCR7aG91cnN9OiR7bWludXRlc306JHtzZWNvbmRzfWBcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzIChvYmplY3QsIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KVxufVxuIiwiLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBET00gZWxlbWVudC4gRHVjay10eXBpbmcgYmFzZWQgb24gYG5vZGVUeXBlYC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRE9NRWxlbWVudCAob2JqKSB7XG4gIHJldHVybiBvYmo/Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERVxufVxuIiwiLyoqXG4gKiBDaGVja3MgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgRHJhZyAmIERyb3AgKG5vdCBzdXBwb3J0ZWQgb24gbW9iaWxlIGRldmljZXMsIGZvciBleGFtcGxlKS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RyYWdEcm9wU3VwcG9ydGVkICgpIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuYm9keVxuXG4gIGlmICghKCdkcmFnZ2FibGUnIGluIGRpdikgfHwgISgnb25kcmFnc3RhcnQnIGluIGRpdiAmJiAnb25kcm9wJyBpbiBkaXYpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoISgnRm9ybURhdGEnIGluIHdpbmRvdykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICghKCdGaWxlUmVhZGVyJyBpbiB3aW5kb3cpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IgKHhocikge1xuICBpZiAoIXhocikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiAoeGhyLnJlYWR5U3RhdGUgIT09IDAgJiYgeGhyLnJlYWR5U3RhdGUgIT09IDQpIHx8IHhoci5zdGF0dXMgPT09IDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05ldHdvcmtFcnJvclxuIiwiLyoqXG4gKiBDaGVjayBpZiBhIFVSTCBzdHJpbmcgaXMgYW4gb2JqZWN0IFVSTCBmcm9tIGBVUkwuY3JlYXRlT2JqZWN0VVJMYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc09iamVjdFVSTCAodXJsKSB7XG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aCgnYmxvYjonKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1ByZXZpZXdTdXBwb3J0ZWQgKGZpbGVUeXBlKSB7XG4gIGlmICghZmlsZVR5cGUpIHJldHVybiBmYWxzZVxuICAvLyBsaXN0IG9mIGltYWdlcyB0aGF0IGJyb3dzZXJzIGNhbiBwcmV2aWV3XG4gIHJldHVybiAvXlteL10rXFwvKGpwZT9nfGdpZnxwbmd8c3ZnfHN2Z1xcK3htbHxibXB8d2VicHxhdmlmKSQvLnRlc3QoZmlsZVR5cGUpXG59XG4iLCIvLyBfX19XaHkgbm90IGFkZCB0aGUgbWltZS10eXBlcyBwYWNrYWdlP1xuLy8gICAgSXQncyAxOS43a0IgZ3ppcHBlZCwgYW5kIHdlIG9ubHkgbmVlZCBtaW1lIHR5cGVzIGZvciB3ZWxsLWtub3duIGV4dGVuc2lvbnMgKGZvciBmaWxlIHByZXZpZXdzKS5cbi8vIF9fX1doZXJlIHRvIHRha2UgbmV3IGV4dGVuc2lvbnMgZnJvbT9cbi8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvbWltZS1kYi9ibG9iL21hc3Rlci9kYi5qc29uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtZDogJ3RleHQvbWFya2Rvd24nLFxuICBtYXJrZG93bjogJ3RleHQvbWFya2Rvd24nLFxuICBtcDQ6ICd2aWRlby9tcDQnLFxuICBtcDM6ICdhdWRpby9tcDMnLFxuICBzdmc6ICdpbWFnZS9zdmcreG1sJyxcbiAganBnOiAnaW1hZ2UvanBlZycsXG4gIHBuZzogJ2ltYWdlL3BuZycsXG4gIGdpZjogJ2ltYWdlL2dpZicsXG4gIGhlaWM6ICdpbWFnZS9oZWljJyxcbiAgaGVpZjogJ2ltYWdlL2hlaWYnLFxuICB5YW1sOiAndGV4dC95YW1sJyxcbiAgeW1sOiAndGV4dC95YW1sJyxcbiAgY3N2OiAndGV4dC9jc3YnLFxuICB0c3Y6ICd0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzJyxcbiAgdGFiOiAndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcycsXG4gIGF2aTogJ3ZpZGVvL3gtbXN2aWRlbycsXG4gIG1rczogJ3ZpZGVvL3gtbWF0cm9za2EnLFxuICBta3Y6ICd2aWRlby94LW1hdHJvc2thJyxcbiAgbW92OiAndmlkZW8vcXVpY2t0aW1lJyxcbiAgZG9jOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgZG9jbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLmRvY3VtZW50Lm1hY3JvZW5hYmxlZC4xMicsXG4gIGRvY3g6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gIGRvdDogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gIGRvdG06ICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInLFxuICBkb3R4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGUnLFxuICB4bGE6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bGFtOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsYzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHhsZjogJ2FwcGxpY2F0aW9uL3gteGxpZmYreG1sJyxcbiAgeGxtOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGxzOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGxzYjogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9lbmFibGVkLjEyJyxcbiAgeGxzbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5tYWNyb2VuYWJsZWQuMTInLFxuICB4bHN4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnLFxuICB4bHQ6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bHRtOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsdHg6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50ZW1wbGF0ZScsXG4gIHhsdzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHR4dDogJ3RleHQvcGxhaW4nLFxuICB0ZXh0OiAndGV4dC9wbGFpbicsXG4gIGNvbmY6ICd0ZXh0L3BsYWluJyxcbiAgbG9nOiAndGV4dC9wbGFpbicsXG4gIHBkZjogJ2FwcGxpY2F0aW9uL3BkZicsXG4gIHppcDogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICc3eic6ICdhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWQnLFxuICByYXI6ICdhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkJyxcbiAgdGFyOiAnYXBwbGljYXRpb24veC10YXInLFxuICBnejogJ2FwcGxpY2F0aW9uL2d6aXAnLFxuICBkbWc6ICdhcHBsaWNhdGlvbi94LWFwcGxlLWRpc2tpbWFnZScsXG59XG4iLCJjb25zdCBzZWNvbmRzVG9UaW1lID0gcmVxdWlyZSgnLi9zZWNvbmRzVG9UaW1lJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcmV0dHlFVEEgKHNlY29uZHMpIHtcbiAgY29uc3QgdGltZSA9IHNlY29uZHNUb1RpbWUoc2Vjb25kcylcblxuICAvLyBPbmx5IGRpc3BsYXkgaG91cnMgYW5kIG1pbnV0ZXMgaWYgdGhleSBhcmUgZ3JlYXRlciB0aGFuIDAgYnV0IGFsd2F5c1xuICAvLyBkaXNwbGF5IG1pbnV0ZXMgaWYgaG91cnMgaXMgYmVpbmcgZGlzcGxheWVkXG4gIC8vIERpc3BsYXkgYSBsZWFkaW5nIHplcm8gaWYgdGhlIHRoZXJlIGlzIGEgcHJlY2VkaW5nIHVuaXQ6IDFtIDA1cywgYnV0IDVzXG4gIGNvbnN0IGhvdXJzU3RyID0gdGltZS5ob3VycyA9PT0gMCA/ICcnIDogYCR7dGltZS5ob3Vyc31oYFxuICBjb25zdCBtaW51dGVzU3RyID0gdGltZS5taW51dGVzID09PSAwID8gJycgOiBgJHt0aW1lLmhvdXJzID09PSAwID8gdGltZS5taW51dGVzIDogYCAke3RpbWUubWludXRlcy50b1N0cmluZygxMCkucGFkU3RhcnQoMiwgJzAnKX1gfW1gXG4gIGNvbnN0IHNlY29uZHNTdHIgPSB0aW1lLmhvdXJzICE9PSAwID8gJycgOiBgJHt0aW1lLm1pbnV0ZXMgPT09IDAgPyB0aW1lLnNlY29uZHMgOiBgICR7dGltZS5zZWNvbmRzLnRvU3RyaW5nKDEwKS5wYWRTdGFydCgyLCAnMCcpfWB9c2BcblxuICByZXR1cm4gYCR7aG91cnNTdHJ9JHttaW51dGVzU3RyfSR7c2Vjb25kc1N0cn1gXG59XG4iLCJjb25zdCBnZXRGaWxlTmFtZUFuZEV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbW90ZUZpbGVPYmpUb0xvY2FsIChmaWxlKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZmlsZSxcbiAgICB0eXBlOiBmaWxlLm1pbWVUeXBlLFxuICAgIGV4dGVuc2lvbjogZmlsZS5uYW1lID8gZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24oZmlsZS5uYW1lKS5leHRlbnNpb24gOiBudWxsLFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNlY29uZHNUb1RpbWUgKHJhd1NlY29uZHMpIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHJhd1NlY29uZHMgLyAzNjAwKSAlIDI0XG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHJhd1NlY29uZHMgLyA2MCkgJSA2MFxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihyYXdTZWNvbmRzICUgNjApXG5cbiAgcmV0dXJuIHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUgKHByb21pc2VzKSB7XG4gIGNvbnN0IHJlc29sdXRpb25zID0gW11cbiAgY29uc3QgcmVqZWN0aW9ucyA9IFtdXG4gIGZ1bmN0aW9uIHJlc29sdmVkICh2YWx1ZSkge1xuICAgIHJlc29sdXRpb25zLnB1c2godmFsdWUpXG4gIH1cbiAgZnVuY3Rpb24gcmVqZWN0ZWQgKGVycm9yKSB7XG4gICAgcmVqZWN0aW9ucy5wdXNoKGVycm9yKVxuICB9XG5cbiAgY29uc3Qgd2FpdCA9IFByb21pc2UuYWxsKFxuICAgIHByb21pc2VzLm1hcCgocHJvbWlzZSkgPT4gcHJvbWlzZS50aGVuKHJlc29sdmVkLCByZWplY3RlZCkpLFxuICApXG5cbiAgcmV0dXJuIHdhaXQudGhlbigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3NmdWw6IHJlc29sdXRpb25zLFxuICAgICAgZmFpbGVkOiByZWplY3Rpb25zLFxuICAgIH1cbiAgfSlcbn1cbiIsIi8qKlxuICogQ29udmVydHMgbGlzdCBpbnRvIGFycmF5XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuZnJvbVxuIiwiLyoqXG4gKiBUcnVuY2F0ZXMgYSBzdHJpbmcgdG8gdGhlIGdpdmVuIG51bWJlciBvZiBjaGFycyAobWF4TGVuZ3RoKSBieSBpbnNlcnRpbmcgJy4uLicgaW4gdGhlIG1pZGRsZSBvZiB0aGF0IHN0cmluZy5cbiAqIFBhcnRpYWxseSB0YWtlbiBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NzIzMjc0LzMxOTI0NzAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIHN0cmluZyB0byBiZSB0cnVuY2F0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhMZW5ndGggLSBtYXhpbXVtIHNpemUgb2YgdGhlIHJlc3VsdGluZyBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHNlcGFyYXRvciA9ICcuLi4nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRydW5jYXRlU3RyaW5nIChzdHJpbmcsIG1heExlbmd0aCkge1xuICAvLyBSZXR1cm4gdGhlIGVtcHR5IHN0cmluZyBpZiBtYXhMZW5ndGggaXMgemVyb1xuICBpZiAobWF4TGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgLy8gUmV0dXJuIG9yaWdpbmFsIHN0cmluZyBpZiBpdCdzIGFscmVhZHkgc2hvcnRlciB0aGFuIG1heExlbmd0aFxuICBpZiAoc3RyaW5nLmxlbmd0aCA8PSBtYXhMZW5ndGgpIHJldHVybiBzdHJpbmdcbiAgLy8gUmV0dXJuIHRydW5jYXRlZCBzdWJzdHJpbmcgYXBwZW5kZWQgb2YgdGhlIGVsbGlwc2lzIGNoYXIgaWYgc3RyaW5nIGNhbid0IGJlIG1lYW5pbmdmdWxseSB0cnVuY2F0ZWRcbiAgaWYgKG1heExlbmd0aCA8PSBzZXBhcmF0b3IubGVuZ3RoICsgMSkgcmV0dXJuIGAke3N0cmluZy5zbGljZSgwLCBtYXhMZW5ndGggLSAxKX3igKZgXG5cbiAgY29uc3QgY2hhcnNUb1Nob3cgPSBtYXhMZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoXG4gIGNvbnN0IGZyb250Q2hhcnMgPSBNYXRoLmNlaWwoY2hhcnNUb1Nob3cgLyAyKVxuICBjb25zdCBiYWNrQ2hhcnMgPSBNYXRoLmZsb29yKGNoYXJzVG9TaG93IC8gMilcblxuICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGZyb250Q2hhcnMpICsgc2VwYXJhdG9yICsgc3RyaW5nLnNsaWNlKC1iYWNrQ2hhcnMpXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBmaWxsPVwiIzAwOTdEQ1wiIHdpZHRoPVwiNjZcIiBoZWlnaHQ9XCI1NVwiIHZpZXdCb3g9XCIwIDAgNjYgNTVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNNTcuMyA4LjQzM2M0LjU5IDAgOC4xIDMuNTEgOC4xIDguMXYyOS43YzAgNC41OS0zLjUxIDguMS04LjEgOC4xSDguN2MtNC41OSAwLTguMS0zLjUxLTguMS04LjF2LTI5LjdjMC00LjU5IDMuNTEtOC4xIDguMS04LjFoOS40NWw0LjU5LTcuMDJjLjU0LS41NCAxLjM1LTEuMDggMi4xNi0xLjA4aDE2LjJjLjgxIDAgMS42Mi41NCAyLjE2IDEuMDhsNC41OSA3LjAyaDkuNDV6TTMzIDE0LjY0Yy04LjYyIDAtMTUuMzkzIDYuNzczLTE1LjM5MyAxNS4zOTMgMCA4LjYyIDYuNzczIDE1LjM5MyAxNS4zOTMgMTUuMzkzIDguNjIgMCAxNS4zOTMtNi43NzMgMTUuMzkzLTE1LjM5MyAwLTguNjItNi43NzMtMTUuMzkzLTE1LjM5My0xNS4zOTN6TTMzIDQwYy01LjY0OCAwLTkuOTY2LTQuMzE5LTkuOTY2LTkuOTY3IDAtNS42NDcgNC4zMTgtOS45NjYgOS45NjYtOS45NjZzOS45NjYgNC4zMTkgOS45NjYgOS45NjZDNDIuOTY2IDM1LjY4MSAzOC42NDggNDAgMzMgNDB6XCIgZmlsbFJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUganN4LWExMXkvbWVkaWEtaGFzLWNhcHRpb24gKi9cbmNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgU25hcHNob3RCdXR0b24gPSByZXF1aXJlKCcuL1NuYXBzaG90QnV0dG9uJylcbmNvbnN0IFJlY29yZEJ1dHRvbiA9IHJlcXVpcmUoJy4vUmVjb3JkQnV0dG9uJylcbmNvbnN0IFJlY29yZGluZ0xlbmd0aCA9IHJlcXVpcmUoJy4vUmVjb3JkaW5nTGVuZ3RoJylcbmNvbnN0IFZpZGVvU291cmNlU2VsZWN0ID0gcmVxdWlyZSgnLi9WaWRlb1NvdXJjZVNlbGVjdCcpXG5jb25zdCBTdWJtaXRCdXR0b24gPSByZXF1aXJlKCcuL1N1Ym1pdEJ1dHRvbicpXG5jb25zdCBEaXNjYXJkQnV0dG9uID0gcmVxdWlyZSgnLi9EaXNjYXJkQnV0dG9uJylcblxuZnVuY3Rpb24gaXNNb2RlQXZhaWxhYmxlIChtb2RlcywgbW9kZSkge1xuICByZXR1cm4gbW9kZXMuaW5kZXhPZihtb2RlKSAhPT0gLTFcbn1cblxuY2xhc3MgQ2FtZXJhU2NyZWVuIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIGNvbnN0IHsgb25Gb2N1cyB9ID0gdGhpcy5wcm9wc1xuICAgIG9uRm9jdXMoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIGNvbnN0IHsgb25TdG9wIH0gPSB0aGlzLnByb3BzXG4gICAgb25TdG9wKClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjLFxuICAgICAgcmVjb3JkZWRWaWRlbyxcbiAgICAgIHJlY29yZGluZyxcbiAgICAgIG1vZGVzLFxuICAgICAgc3VwcG9ydHNSZWNvcmRpbmcsXG4gICAgICB2aWRlb1NvdXJjZXMsXG4gICAgICBzaG93VmlkZW9Tb3VyY2VEcm9wZG93bixcbiAgICAgIHNob3dSZWNvcmRpbmdMZW5ndGgsXG4gICAgICBvblN1Ym1pdCxcbiAgICAgIGkxOG4sXG4gICAgICBtaXJyb3IsXG4gICAgICBvblNuYXBzaG90LFxuICAgICAgb25TdGFydFJlY29yZGluZyxcbiAgICAgIG9uU3RvcFJlY29yZGluZyxcbiAgICAgIG9uRGlzY2FyZFJlY29yZGVkVmlkZW8sXG4gICAgICByZWNvcmRpbmdMZW5ndGhTZWNvbmRzLFxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCBoYXNSZWNvcmRlZFZpZGVvID0gISFyZWNvcmRlZFZpZGVvXG4gICAgY29uc3Qgc2hvdWxkU2hvd1JlY29yZEJ1dHRvbiA9ICFoYXNSZWNvcmRlZFZpZGVvICYmIHN1cHBvcnRzUmVjb3JkaW5nICYmIChcbiAgICAgIGlzTW9kZUF2YWlsYWJsZShtb2RlcywgJ3ZpZGVvLW9ubHknKVxuICAgICAgfHwgaXNNb2RlQXZhaWxhYmxlKG1vZGVzLCAnYXVkaW8tb25seScpXG4gICAgICB8fCBpc01vZGVBdmFpbGFibGUobW9kZXMsICd2aWRlby1hdWRpbycpXG4gICAgKVxuICAgIGNvbnN0IHNob3VsZFNob3dTbmFwc2hvdEJ1dHRvbiA9ICFoYXNSZWNvcmRlZFZpZGVvICYmIGlzTW9kZUF2YWlsYWJsZShtb2RlcywgJ3BpY3R1cmUnKVxuICAgIGNvbnN0IHNob3VsZFNob3dSZWNvcmRpbmdMZW5ndGggPSBzdXBwb3J0c1JlY29yZGluZyAmJiBzaG93UmVjb3JkaW5nTGVuZ3RoXG4gICAgY29uc3Qgc2hvdWxkU2hvd1ZpZGVvU291cmNlRHJvcGRvd24gPSBzaG93VmlkZW9Tb3VyY2VEcm9wZG93biAmJiB2aWRlb1NvdXJjZXMgJiYgdmlkZW9Tb3VyY2VzLmxlbmd0aCA+IDFcblxuICAgIGNvbnN0IHZpZGVvUHJvcHMgPSB7XG4gICAgICBwbGF5c2lubGluZTogdHJ1ZSxcbiAgICB9XG5cbiAgICBpZiAocmVjb3JkZWRWaWRlbykge1xuICAgICAgdmlkZW9Qcm9wcy5tdXRlZCA9IGZhbHNlXG4gICAgICB2aWRlb1Byb3BzLmNvbnRyb2xzID0gdHJ1ZVxuICAgICAgdmlkZW9Qcm9wcy5zcmMgPSByZWNvcmRlZFZpZGVvXG5cbiAgICAgIC8vIHJlc2V0IHNyY09iamVjdCBpbiBkb20uIElmIG5vdCByZXNldHRlZCwgc3RyZWFtIHN0aWNrcyBpbiBlbGVtZW50XG4gICAgICBpZiAodGhpcy52aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvUHJvcHMubXV0ZWQgPSB0cnVlXG4gICAgICB2aWRlb1Byb3BzLmF1dG9wbGF5ID0gdHJ1ZVxuICAgICAgdmlkZW9Qcm9wcy5zcmNPYmplY3QgPSBzcmNcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5IHVwcHktV2ViY2FtLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXZpZGVvQ29udGFpbmVyXCI+XG4gICAgICAgICAgPHZpZGVvXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmV0dXJuLWFzc2lnbiAqL1xuICAgICAgICAgICAgcmVmPXsodmlkZW9FbGVtZW50KSA9PiAodGhpcy52aWRlb0VsZW1lbnQgPSB2aWRlb0VsZW1lbnQpfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgdXBweS1XZWJjYW0tdmlkZW8gICR7bWlycm9yID8gJ3VwcHktV2ViY2FtLXZpZGVvLS1taXJyb3JlZCcgOiAnJ31gfVxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1wcm9wcy1uby1zcHJlYWRpbmcgKi9cbiAgICAgICAgICAgIHsuLi52aWRlb1Byb3BzfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLWZvb3RlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tdmlkZW9Tb3VyY2VDb250YWluZXJcIj5cbiAgICAgICAgICAgIHtzaG91bGRTaG93VmlkZW9Tb3VyY2VEcm9wZG93blxuICAgICAgICAgICAgICA/IFZpZGVvU291cmNlU2VsZWN0KHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgIDogbnVsbH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLWJ1dHRvbkNvbnRhaW5lclwiPlxuICAgICAgICAgICAge3Nob3VsZFNob3dTbmFwc2hvdEJ1dHRvbiAmJiA8U25hcHNob3RCdXR0b24gb25TbmFwc2hvdD17b25TbmFwc2hvdH0gaTE4bj17aTE4bn0gLz59XG5cbiAgICAgICAgICAgIHtzaG91bGRTaG93UmVjb3JkQnV0dG9uICYmIChcbiAgICAgICAgICAgICAgPFJlY29yZEJ1dHRvblxuICAgICAgICAgICAgICAgIHJlY29yZGluZz17cmVjb3JkaW5nfVxuICAgICAgICAgICAgICAgIG9uU3RhcnRSZWNvcmRpbmc9e29uU3RhcnRSZWNvcmRpbmd9XG4gICAgICAgICAgICAgICAgb25TdG9wUmVjb3JkaW5nPXtvblN0b3BSZWNvcmRpbmd9XG4gICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgIHtoYXNSZWNvcmRlZFZpZGVvICYmIDxTdWJtaXRCdXR0b24gb25TdWJtaXQ9e29uU3VibWl0fSBpMThuPXtpMThufSAvPn1cblxuICAgICAgICAgICAge2hhc1JlY29yZGVkVmlkZW8gJiYgPERpc2NhcmRCdXR0b24gb25EaXNjYXJkPXtvbkRpc2NhcmRSZWNvcmRlZFZpZGVvfSBpMThuPXtpMThufSAvPn1cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHtzaG91bGRTaG93UmVjb3JkaW5nTGVuZ3RoICYmIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tcmVjb3JkaW5nTGVuZ3RoXCI+XG4gICAgICAgICAgICAgIDxSZWNvcmRpbmdMZW5ndGggcmVjb3JkaW5nTGVuZ3RoU2Vjb25kcz17cmVjb3JkaW5nTGVuZ3RoU2Vjb25kc30gaTE4bj17aTE4bn0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhU2NyZWVuXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmZ1bmN0aW9uIERpc2NhcmRCdXR0b24gKHsgb25EaXNjYXJkLCBpMThuIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVdlYmNhbS1idXR0b24gdXBweS1XZWJjYW0tYnV0dG9uLS1kaXNjYXJkXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgdGl0bGU9e2kxOG4oJ2Rpc2NhcmRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ2Rpc2NhcmRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIG9uQ2xpY2s9e29uRGlzY2FyZH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICA8c3ZnXG4gICAgICAgIHdpZHRoPVwiMTNcIlxuICAgICAgICBoZWlnaHQ9XCIxM1wiXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgMTMgMTNcIlxuICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiXG4gICAgICA+XG4gICAgICAgIDxnIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0uNDk2IDExLjM2N0wxMS4xMDMuNzZsMS40MTQgMS40MTRMMS45MTEgMTIuNzgxelwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMS4xMDQgMTIuNzgyTC40OTcgMi4xNzUgMS45MTEuNzZsMTAuNjA3IDEwLjYwNnpcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc2NhcmRCdXR0b25cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXBlcm1pc3NvbnNcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tcGVybWlzc29uc0ljb25cIj57cHJvcHMuaWNvbigpfTwvZGl2PlxuICAgICAgPGgxIGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXRpdGxlXCI+e3Byb3BzLmhhc0NhbWVyYSA/IHByb3BzLmkxOG4oJ2FsbG93QWNjZXNzVGl0bGUnKSA6IHByb3BzLmkxOG4oJ25vQ2FtZXJhVGl0bGUnKX08L2gxPlxuICAgICAgPHA+e3Byb3BzLmhhc0NhbWVyYSA/IHByb3BzLmkxOG4oJ2FsbG93QWNjZXNzRGVzY3JpcHRpb24nKSA6IHByb3BzLmkxOG4oJ25vQ2FtZXJhRGVzY3JpcHRpb24nKX08L3A+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWNvcmRCdXR0b24gKHsgcmVjb3JkaW5nLCBvblN0YXJ0UmVjb3JkaW5nLCBvblN0b3BSZWNvcmRpbmcsIGkxOG4gfSkge1xuICBpZiAocmVjb3JkaW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIHRpdGxlPXtpMThuKCdzdG9wUmVjb3JkaW5nJyl9XG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N0b3BSZWNvcmRpbmcnKX1cbiAgICAgICAgb25DbGljaz17b25TdG9wUmVjb3JkaW5nfVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG4gICAgICAgICAgPHJlY3QgeD1cIjE1XCIgeT1cIjE1XCIgd2lkdGg9XCI3MFwiIGhlaWdodD1cIjcwXCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktV2ViY2FtLWJ1dHRvblwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCdzdGFydFJlY29yZGluZycpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bignc3RhcnRSZWNvcmRpbmcnKX1cbiAgICAgIG9uQ2xpY2s9e29uU3RhcnRSZWNvcmRpbmd9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0MFwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgZm9ybWF0U2Vjb25kcyA9IHJlcXVpcmUoJy4vZm9ybWF0U2Vjb25kcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVjb3JkaW5nTGVuZ3RoICh7IHJlY29yZGluZ0xlbmd0aFNlY29uZHMsIGkxOG4gfSkge1xuICBjb25zdCBmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzID0gZm9ybWF0U2Vjb25kcyhyZWNvcmRpbmdMZW5ndGhTZWNvbmRzKVxuXG4gIHJldHVybiAoXG4gICAgPHNwYW4gYXJpYS1sYWJlbD17aTE4bigncmVjb3JkaW5nTGVuZ3RoJywgeyByZWNvcmRpbmdfbGVuZ3RoOiBmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzIH0pfT5cbiAgICAgIHtmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzfVxuICAgIDwvc3Bhbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgQ2FtZXJhSWNvbiA9IHJlcXVpcmUoJy4vQ2FtZXJhSWNvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gKHsgb25TbmFwc2hvdCwgaTE4biB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uIHVwcHktV2ViY2FtLWJ1dHRvbi0tcGljdHVyZVwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCd0YWtlUGljdHVyZScpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bigndGFrZVBpY3R1cmUnKX1cbiAgICAgIG9uQ2xpY2s9e29uU25hcHNob3R9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAge0NhbWVyYUljb24oKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBTdWJtaXRCdXR0b24gKHsgb25TdWJtaXQsIGkxOG4gfSkge1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktV2ViY2FtLWJ1dHRvbiB1cHB5LVdlYmNhbS1idXR0b24tLXN1Ym1pdFwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCdzdWJtaXRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N1Ym1pdFJlY29yZGVkRmlsZScpfVxuICAgICAgb25DbGljaz17b25TdWJtaXR9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2Z1xuICAgICAgICB3aWR0aD1cIjEyXCJcbiAgICAgICAgaGVpZ2h0PVwiOVwiXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgMTIgOVwiXG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCJcbiAgICAgID5cbiAgICAgICAgPHBhdGggZmlsbD1cIiNmZmZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiBkPVwiTTEwLjY2IDBMMTIgMS4zMSA0LjEzNiA5IDAgNC45NTZsMS4zNC0xLjMxTDQuMTM2IDYuMzh6XCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3VibWl0QnV0dG9uXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKHsgY3VycmVudERldmljZUlkLCB2aWRlb1NvdXJjZXMsIG9uQ2hhbmdlVmlkZW9Tb3VyY2UgfSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tdmlkZW9Tb3VyY2VcIj5cbiAgICAgIDxzZWxlY3RcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktV2ViY2FtLXZpZGVvU291cmNlLXNlbGVjdFwiXG4gICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHsgb25DaGFuZ2VWaWRlb1NvdXJjZShldmVudC50YXJnZXQudmFsdWUpIH19XG4gICAgICA+XG4gICAgICAgIHt2aWRlb1NvdXJjZXMubWFwKCh2aWRlb1NvdXJjZSkgPT4gKFxuICAgICAgICAgIDxvcHRpb25cbiAgICAgICAgICAgIGtleT17dmlkZW9Tb3VyY2UuZGV2aWNlSWR9XG4gICAgICAgICAgICB2YWx1ZT17dmlkZW9Tb3VyY2UuZGV2aWNlSWR9XG4gICAgICAgICAgICBzZWxlY3RlZD17dmlkZW9Tb3VyY2UuZGV2aWNlSWQgPT09IGN1cnJlbnREZXZpY2VJZH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dmlkZW9Tb3VyY2UubGFiZWx9XG4gICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICkpfVxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsIi8qKlxuICogVGFrZXMgYW4gSW50ZWdlciB2YWx1ZSBvZiBzZWNvbmRzIChlLmcuIDgzKSBhbmQgY29udmVydHMgaXQgaW50byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJzE6MjMnKS5cbiAqXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHNlY29uZHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmb3JtYXR0ZWQgc2Vjb25kcyAoZS5nLiAnMToyMycgZm9yIDEgbWludXRlIGFuZCAyMyBzZWNvbmRzKVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXRTZWNvbmRzIChzZWNvbmRzKSB7XG4gIHJldHVybiBgJHtNYXRoLmZsb29yKFxuICAgIHNlY29uZHMgLyA2MCxcbiAgKX06JHtTdHJpbmcoc2Vjb25kcyAlIDYwKS5wYWRTdGFydCgyLCAwKX1gXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCB7IFVJUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IGdldEZpbGVUeXBlRXh0ZW5zaW9uID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVUeXBlRXh0ZW5zaW9uJylcbmNvbnN0IG1pbWVUeXBlcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9taW1lVHlwZXMnKVxuY29uc3QgY2FudmFzVG9CbG9iID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2NhbnZhc1RvQmxvYicpXG5jb25zdCBzdXBwb3J0c01lZGlhUmVjb3JkZXIgPSByZXF1aXJlKCcuL3N1cHBvcnRzTWVkaWFSZWNvcmRlcicpXG5jb25zdCBDYW1lcmFJY29uID0gcmVxdWlyZSgnLi9DYW1lcmFJY29uJylcbmNvbnN0IENhbWVyYVNjcmVlbiA9IHJlcXVpcmUoJy4vQ2FtZXJhU2NyZWVuJylcbmNvbnN0IFBlcm1pc3Npb25zU2NyZWVuID0gcmVxdWlyZSgnLi9QZXJtaXNzaW9uc1NjcmVlbicpXG5cbmNvbnN0IGxvY2FsZSA9IHJlcXVpcmUoJy4vbG9jYWxlLmpzJylcbi8qKlxuICogTm9ybWFsaXplIGEgTUlNRSB0eXBlIG9yIGZpbGUgZXh0ZW5zaW9uIGludG8gYSBNSU1FIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVUeXBlIC0gTUlNRSB0eXBlIG9yIGEgZmlsZSBleHRlbnNpb24gcHJlZml4ZWQgd2l0aCBgLmAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIE1JTUUgdHlwZSBvciBgdW5kZWZpbmVkYCBpZiB0aGUgZmlsZVR5cGUgaXMgYW4gZXh0ZW5zaW9uIGFuZCBpcyBub3Qga25vd24uXG4gKi9cbmZ1bmN0aW9uIHRvTWltZVR5cGUgKGZpbGVUeXBlKSB7XG4gIGlmIChmaWxlVHlwZVswXSA9PT0gJy4nKSB7XG4gICAgcmV0dXJuIG1pbWVUeXBlc1tmaWxlVHlwZS5zbGljZSgxKV1cbiAgfVxuICByZXR1cm4gZmlsZVR5cGVcbn1cblxuLyoqXG4gKiBJcyB0aGlzIE1JTUUgdHlwZSBhIHZpZGVvP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIE1JTUUgdHlwZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZpZGVvTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIHJldHVybiAvXnZpZGVvXFwvW14qXSskLy50ZXN0KG1pbWVUeXBlKVxufVxuXG4vKipcbiAqIElzIHRoaXMgTUlNRSB0eXBlIGFuIGltYWdlP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIE1JTUUgdHlwZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ltYWdlTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIHJldHVybiAvXmltYWdlXFwvW14qXSskLy50ZXN0KG1pbWVUeXBlKVxufVxuXG5mdW5jdGlvbiBnZXRNZWRpYURldmljZXMgKCkge1xuICAvLyBidWcgaW4gdGhlIGNvbXBhdGliaWxpdHkgZGF0YVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xufVxuLyoqXG4gKiBXZWJjYW1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBXZWJjYW0gZXh0ZW5kcyBVSVBsdWdpbiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAvLyBlbmFibGVNaXJyb3IgaXMgdXNlZCB0byB0b2dnbGUgbWlycm9yaW5nLCBmb3IgaW5zdGFuY2Ugd2hlbiBkaXNjYXJkaW5nIHRoZSB2aWRlbyxcbiAgLy8gd2hpbGUgYG9wdHMubWlycm9yYCBpcyB1c2VkIHRvIHJlbWVtYmVyIHRoZSBpbml0aWFsIHVzZXIgc2V0dGluZ1xuICAjZW5hYmxlTWlycm9yXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMubWVkaWFEZXZpY2VzID0gZ2V0TWVkaWFEZXZpY2VzKClcbiAgICB0aGlzLnN1cHBvcnRzVXNlck1lZGlhID0gISF0aGlzLm1lZGlhRGV2aWNlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICB0aGlzLnByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL2h0dHBzL2kpID8gJ2h0dHBzJyA6ICdodHRwJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1dlYmNhbSdcbiAgICB0aGlzLnR5cGUgPSAnYWNxdWlyZXInXG4gICAgdGhpcy5jYXB0dXJlZE1lZGlhRmlsZSA9IG51bGxcbiAgICB0aGlzLmljb24gPSAoKSA9PiAoXG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxyZWN0IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJJY29uQmdcIiBmaWxsPVwiIzAzQkZFRlwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMjIgMTFjMS4xMzMgMCAyIC44NjcgMiAydjcuMzMzYzAgMS4xMzQtLjg2NyAyLTIgMkgxMGMtMS4xMzMgMC0yLS44NjYtMi0yVjEzYzAtMS4xMzMuODY3LTIgMi0yaDIuMzMzbDEuMTM0LTEuNzMzQzEzLjYgOS4xMzMgMTMuOCA5IDE0IDloNGMuMiAwIC40LjEzMy41MzMuMjY3TDE5LjY2NyAxMUgyMnptLTYgMS41MzNhMy43NjQgMy43NjQgMCAwIDAtMy44IDMuOGMwIDIuMTI5IDEuNjcyIDMuODAxIDMuOCAzLjgwMXMzLjgtMS42NzIgMy44LTMuOGMwLTIuMTMtMS42NzItMy44MDEtMy44LTMuODAxem0wIDYuMjYxYy0xLjM5NSAwLTIuNDYtMS4wNjYtMi40Ni0yLjQ2IDAtMS4zOTUgMS4wNjUtMi40NjEgMi40Ni0yLjQ2MXMyLjQ2IDEuMDY2IDIuNDYgMi40NmMwIDEuMzk1LTEuMDY1IDIuNDYxLTIuNDYgMi40NjF6XCIgZmlsbD1cIiNGRkZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICApXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBsb2NhbGVcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIG9uQmVmb3JlU25hcHNob3Q6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgY291bnRkb3duOiBmYWxzZSxcbiAgICAgIG1vZGVzOiBbXG4gICAgICAgICd2aWRlby1hdWRpbycsXG4gICAgICAgICd2aWRlby1vbmx5JyxcbiAgICAgICAgJ2F1ZGlvLW9ubHknLFxuICAgICAgICAncGljdHVyZScsXG4gICAgICBdLFxuICAgICAgbWlycm9yOiB0cnVlLFxuICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd246IGZhbHNlLFxuICAgICAgZmFjaW5nTW9kZTogJ3VzZXInLFxuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZTogbnVsbCxcbiAgICAgIHByZWZlcnJlZFZpZGVvTWltZVR5cGU6IG51bGwsXG4gICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoOiBmYWxzZSxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5pMThuKCdwbHVnaW5OYW1lQ2FtZXJhJylcblxuICAgIHRoaXMuI2VuYWJsZU1pcnJvciA9IHRoaXMub3B0cy5taXJyb3JcblxuICAgIHRoaXMuaW5zdGFsbCA9IHRoaXMuaW5zdGFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSA9IHRoaXMuc2V0UGx1Z2luU3RhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLy8gQ2FtZXJhIGNvbnRyb2xzXG4gICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RvcCA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpXG4gICAgdGhpcy50YWtlU25hcHNob3QgPSB0aGlzLnRha2VTbmFwc2hvdC5iaW5kKHRoaXMpXG4gICAgdGhpcy5zdGFydFJlY29yZGluZyA9IHRoaXMuc3RhcnRSZWNvcmRpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RvcFJlY29yZGluZyA9IHRoaXMuc3RvcFJlY29yZGluZy5iaW5kKHRoaXMpXG4gICAgdGhpcy5kaXNjYXJkUmVjb3JkZWRWaWRlbyA9IHRoaXMuZGlzY2FyZFJlY29yZGVkVmlkZW8uYmluZCh0aGlzKVxuICAgIHRoaXMuc3VibWl0ID0gdGhpcy5zdWJtaXQuYmluZCh0aGlzKVxuICAgIHRoaXMub25lVHdvVGhyZWVTbWlsZSA9IHRoaXMub25lVHdvVGhyZWVTbWlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5mb2N1cyA9IHRoaXMuZm9jdXMuYmluZCh0aGlzKVxuICAgIHRoaXMuY2hhbmdlVmlkZW9Tb3VyY2UgPSB0aGlzLmNoYW5nZVZpZGVvU291cmNlLmJpbmQodGhpcylcblxuICAgIHRoaXMud2ViY2FtQWN0aXZlID0gZmFsc2VcblxuICAgIGlmICh0aGlzLm9wdHMuY291bnRkb3duKSB7XG4gICAgICB0aGlzLm9wdHMub25CZWZvcmVTbmFwc2hvdCA9IHRoaXMub25lVHdvVGhyZWVTbWlsZVxuICAgIH1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgaGFzQ2FtZXJhOiBmYWxzZSxcbiAgICAgIGNhbWVyYVJlYWR5OiBmYWxzZSxcbiAgICAgIGNhbWVyYUVycm9yOiBudWxsLFxuICAgICAgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCxcbiAgICAgIHZpZGVvU291cmNlczogW10sXG4gICAgICBjdXJyZW50RGV2aWNlSWQ6IG51bGwsXG4gICAgfSlcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICBzdXBlci5zZXRPcHRpb25zKHtcbiAgICAgIC4uLm5ld09wdHMsXG4gICAgICB2aWRlb0NvbnN0cmFpbnRzOiB7XG4gICAgICAgIC8vIE1heSBiZSB1bmRlZmluZWQgYnV0IC4uLiBoYW5kbGVzIHRoYXRcbiAgICAgICAgLi4udGhpcy5vcHRzLnZpZGVvQ29uc3RyYWludHMsXG4gICAgICAgIC4uLm5ld09wdHM/LnZpZGVvQ29uc3RyYWludHMsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBoYXNDYW1lcmFDaGVjayAoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhRGV2aWNlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZGV2aWNlcyA9PiB7XG4gICAgICByZXR1cm4gZGV2aWNlcy5zb21lKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKVxuICAgIH0pXG4gIH1cblxuICBpc0F1ZGlvT25seSAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cy5tb2Rlcy5sZW5ndGggPT09IDEgJiYgdGhpcy5vcHRzLm1vZGVzWzBdID09PSAnYXVkaW8tb25seSdcbiAgfVxuXG4gIGdldENvbnN0cmFpbnRzIChkZXZpY2VJZCA9IG51bGwpIHtcbiAgICBjb25zdCBhY2NlcHRzQXVkaW8gPSB0aGlzLm9wdHMubW9kZXMuaW5kZXhPZigndmlkZW8tYXVkaW8nKSAhPT0gLTFcbiAgICAgIHx8IHRoaXMub3B0cy5tb2Rlcy5pbmRleE9mKCdhdWRpby1vbmx5JykgIT09IC0xXG4gICAgY29uc3QgYWNjZXB0c1ZpZGVvID0gIXRoaXMuaXNBdWRpb09ubHkoKVxuICAgICAgICAmJiAodGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ3ZpZGVvLWF1ZGlvJykgIT09IC0xXG4gICAgICAgICAgfHwgdGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ3ZpZGVvLW9ubHknKSAhPT0gLTFcbiAgICAgICAgICB8fCB0aGlzLm9wdHMubW9kZXMuaW5kZXhPZigncGljdHVyZScpICE9PSAtMSlcblxuICAgIGNvbnN0IHZpZGVvQ29uc3RyYWludHMgPSB7XG4gICAgICAuLi4odGhpcy5vcHRzLnZpZGVvQ29uc3RyYWludHMgfHwgeyBmYWNpbmdNb2RlOiB0aGlzLm9wdHMuZmFjaW5nTW9kZSB9KSxcbiAgICAgIC8vIGZhY2luZ01vZGUgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGRldmljZUlkLCBhbmQgbm90IG5lZWRlZFxuICAgICAgLy8gd2hlbiBzcGVjaWZpYyBkZXZpY2UgaXMgc2VsZWN0ZWRcbiAgICAgIC4uLihkZXZpY2VJZCA/IHsgZGV2aWNlSWQsIGZhY2luZ01vZGU6IG51bGwgfSA6IHt9KSxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IGFjY2VwdHNBdWRpbyxcbiAgICAgIHZpZGVvOiBhY2NlcHRzVmlkZW8gPyB2aWRlb0NvbnN0cmFpbnRzIDogZmFsc2UsXG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIHN0YXJ0IChvcHRpb25zID0gbnVsbCkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0c1VzZXJNZWRpYSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIGFjY2VzcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuXG4gICAgdGhpcy53ZWJjYW1BY3RpdmUgPSB0cnVlXG5cbiAgICBpZiAodGhpcy5vcHRzLm1pcnJvcikge1xuICAgICAgdGhpcy4jZW5hYmxlTWlycm9yID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5nZXRDb25zdHJhaW50cyhvcHRpb25zICYmIG9wdGlvbnMuZGV2aWNlSWQgPyBvcHRpb25zLmRldmljZUlkIDogbnVsbClcblxuICAgIHRoaXMuaGFzQ2FtZXJhQ2hlY2soKS50aGVuKGhhc0NhbWVyYSA9PiB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgaGFzQ2FtZXJhLFxuICAgICAgfSlcblxuICAgICAgLy8gYXNrIHVzZXIgZm9yIGFjY2VzcyB0byB0aGVpciBjYW1lcmFcbiAgICAgIHJldHVybiB0aGlzLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuXG4gICAgICAgICAgbGV0IGN1cnJlbnREZXZpY2VJZCA9IG51bGxcbiAgICAgICAgICBjb25zdCB0cmFja3MgPSB0aGlzLmlzQXVkaW9Pbmx5KCkgPyBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKSA6IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpXG5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCA9IHRyYWNrc1swXS5nZXRTZXR0aW5ncygpLmRldmljZUlkXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICBpZiAodHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gb3B0aW9ucy5kZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCA9IHRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNvdXJjZXMgbm93LCBzbyB3ZSBjYW4gYWNjZXNzIHRoZSBuYW1lcy5cbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpZGVvU291cmNlcygpXG5cbiAgICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCxcbiAgICAgICAgICAgIGNhbWVyYVJlYWR5OiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgICBjYW1lcmFSZWFkeTogZmFsc2UsXG4gICAgICAgICAgICBjYW1lcmFFcnJvcjogZXJyLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy51cHB5LmluZm8oZXJyLm1lc3NhZ2UsICdlcnJvcicpXG4gICAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0TWVkaWFSZWNvcmRlck9wdGlvbnMgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuXG4gICAgLy8gVHJ5IHRvIHVzZSB0aGUgYG9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZWAgb3Igb25lIG9mIHRoZSBgYWxsb3dlZEZpbGVUeXBlc2AgZm9yIHRoZSByZWNvcmRpbmcuXG4gICAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGl0LCB3ZSdsbCBmYWxsIGJhY2sgdG8gdGhlIGJyb3dzZXIgZGVmYXVsdCBpbnN0ZWFkLlxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGhhdmUgdGhlIGBpc1R5cGVTdXBwb3J0ZWRgIEFQSS5cbiAgICBpZiAoTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHsgcmVzdHJpY3Rpb25zIH0gPSB0aGlzLnVwcHkub3B0c1xuICAgICAgbGV0IHByZWZlcnJlZFZpZGVvTWltZVR5cGVzID0gW11cbiAgICAgIGlmICh0aGlzLm9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZSkge1xuICAgICAgICBwcmVmZXJyZWRWaWRlb01pbWVUeXBlcyA9IFt0aGlzLm9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZV1cbiAgICAgIH0gZWxzZSBpZiAocmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMpIHtcbiAgICAgICAgcHJlZmVycmVkVmlkZW9NaW1lVHlwZXMgPSByZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcy5tYXAodG9NaW1lVHlwZSkuZmlsdGVyKGlzVmlkZW9NaW1lVHlwZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsdGVyU3VwcG9ydGVkVHlwZXMgPSAoY2FuZGlkYXRlVHlwZSkgPT4gTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQoY2FuZGlkYXRlVHlwZSlcbiAgICAgICAgJiYgZ2V0RmlsZVR5cGVFeHRlbnNpb24oY2FuZGlkYXRlVHlwZSlcbiAgICAgIGNvbnN0IGFjY2VwdGFibGVNaW1lVHlwZXMgPSBwcmVmZXJyZWRWaWRlb01pbWVUeXBlcy5maWx0ZXIoZmlsdGVyU3VwcG9ydGVkVHlwZXMpXG5cbiAgICAgIGlmIChhY2NlcHRhYmxlTWltZVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSBhY2NlcHRhYmxlTWltZVR5cGVzWzBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIHN0YXJ0UmVjb3JkaW5nICgpIHtcbiAgICAvLyBvbmx5IHVzZWQgaWYgc3VwcG9ydHNNZWRpYVJlY29yZGVyKCkgcmV0dXJuZWQgdHJ1ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgdGhpcy5yZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMuc3RyZWFtLCB0aGlzLmdldE1lZGlhUmVjb3JkZXJPcHRpb25zKCkpXG4gICAgdGhpcy5yZWNvcmRpbmdDaHVua3MgPSBbXVxuICAgIGxldCBzdG9wcGluZ0JlY2F1c2VPZk1heFNpemUgPSBmYWxzZVxuICAgIHRoaXMucmVjb3JkZXIuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5yZWNvcmRpbmdDaHVua3MucHVzaChldmVudC5kYXRhKVxuXG4gICAgICBjb25zdCB7IHJlc3RyaWN0aW9ucyB9ID0gdGhpcy51cHB5Lm9wdHNcbiAgICAgIGlmICh0aGlzLnJlY29yZGluZ0NodW5rcy5sZW5ndGggPiAxXG4gICAgICAgICAgJiYgcmVzdHJpY3Rpb25zLm1heEZpbGVTaXplICE9IG51bGxcbiAgICAgICAgICAmJiAhc3RvcHBpbmdCZWNhdXNlT2ZNYXhTaXplKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzLnJlZHVjZSgoYWNjLCBjaHVuaykgPT4gYWNjICsgY2h1bmsuc2l6ZSwgMClcbiAgICAgICAgLy8gRXhjbHVkZSB0aGUgaW5pdGlhbCBjaHVuayBmcm9tIHRoZSBhdmVyYWdlIHNpemUgY2FsY3VsYXRpb24gYmVjYXVzZSBpdCBpcyBsaWtlbHkgdG8gYmUgYSB2ZXJ5IHNtYWxsIG91dGxpZXJcbiAgICAgICAgY29uc3QgYXZlcmFnZUNodW5rU2l6ZSA9ICh0b3RhbFNpemUgLSB0aGlzLnJlY29yZGluZ0NodW5rc1swXS5zaXplKSAvICh0aGlzLnJlY29yZGluZ0NodW5rcy5sZW5ndGggLSAxKVxuICAgICAgICBjb25zdCBleHBlY3RlZEVuZENodW5rU2l6ZSA9IGF2ZXJhZ2VDaHVua1NpemUgKiAzXG4gICAgICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgwLCByZXN0cmljdGlvbnMubWF4RmlsZVNpemUgLSBleHBlY3RlZEVuZENodW5rU2l6ZSlcblxuICAgICAgICBpZiAodG90YWxTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICAgIHN0b3BwaW5nQmVjYXVzZU9mTWF4U2l6ZSA9IHRydWVcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyh0aGlzLmkxOG4oJ3JlY29yZGluZ1N0b3BwZWRNYXhTaXplJyksICd3YXJuaW5nJywgNDAwMClcbiAgICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHVzZSBhIFwidGltZSBzbGljZVwiIG9mIDUwMG1zOiBvbmRhdGFhdmFpbGFibGUgd2lsbCBiZSBjYWxsZWQgZWFjaCA1MDBtc1xuICAgIC8vIHNtYWxsZXIgdGltZSBzbGljZXMgbWVhbiB3ZSBjYW4gbW9yZSBhY2N1cmF0ZWx5IGNoZWNrIHRoZSBtYXggZmlsZSBzaXplIHJlc3RyaWN0aW9uXG4gICAgdGhpcy5yZWNvcmRlci5zdGFydCg1MDApXG5cbiAgICBpZiAodGhpcy5vcHRzLnNob3dSZWNvcmRpbmdMZW5ndGgpIHtcbiAgICAgIC8vIFN0YXJ0IHRoZSByZWNvcmRpbmdMZW5ndGhUaW1lciBpZiB3ZSBhcmUgc2hvd2luZyB0aGUgcmVjb3JkaW5nIGxlbmd0aC5cbiAgICAgIHRoaXMucmVjb3JkaW5nTGVuZ3RoVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZWNvcmRpbmdMZW5ndGggPSB0aGlzLmdldFBsdWdpblN0YXRlKCkucmVjb3JkaW5nTGVuZ3RoU2Vjb25kc1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogY3VycmVudFJlY29yZGluZ0xlbmd0aCArIDEgfSlcbiAgICAgIH0sIDEwMDApXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBpc1JlY29yZGluZzogdHJ1ZSxcbiAgICB9KVxuICB9XG5cbiAgc3RvcFJlY29yZGluZyAoKSB7XG4gICAgY29uc3Qgc3RvcHBlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICAgIHRoaXMucmVjb3JkZXIuc3RvcCgpXG5cbiAgICAgIGlmICh0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aCkge1xuICAgICAgICAvLyBTdG9wIHRoZSByZWNvcmRpbmdMZW5ndGhUaW1lciBpZiB3ZSBhcmUgc2hvd2luZyB0aGUgcmVjb3JkaW5nIGxlbmd0aC5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY29yZGluZ0xlbmd0aFRpbWVyKVxuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gc3RvcHBlZC50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc1JlY29yZGluZzogZmFsc2UsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlkZW8oKVxuICAgIH0pLnRoZW4oKGZpbGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBmaWxlXG4gICAgICAgIC8vIGNyZWF0ZSBvYmplY3QgdXJsIGZvciBjYXB0dXJlIHJlc3VsdCBwcmV2aWV3XG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgICAgcmVjb3JkZWRWaWRlbzogVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlLmRhdGEpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLiNlbmFibGVNaXJyb3IgPSBmYWxzZVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIExvZ2dpbmcgdGhlIGVycm9yLCBleGVwdCByZXN0cmljdGlvbnMsIHdoaWNoIGlzIGhhbmRsZWQgaW4gQ29yZVxuICAgICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIGRpc2NhcmRSZWNvcmRlZFZpZGVvICgpIHtcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkZWRWaWRlbzogbnVsbCB9KVxuXG4gICAgaWYgKHRoaXMub3B0cy5taXJyb3IpIHtcbiAgICAgIHRoaXMuI2VuYWJsZU1pcnJvciA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLmNhcHR1cmVkTWVkaWFGaWxlID0gbnVsbFxuICB9XG5cbiAgc3VibWl0ICgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUpIHtcbiAgICAgICAgdGhpcy51cHB5LmFkZEZpbGUodGhpcy5jYXB0dXJlZE1lZGlhRmlsZSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIExvZ2dpbmcgdGhlIGVycm9yLCBleGVwdCByZXN0cmljdGlvbnMsIHdoaWNoIGlzIGhhbmRsZWQgaW4gQ29yZVxuICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVyciwgJ2Vycm9yJylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzdG9wICgpIHtcbiAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdGhpcy5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVxuICAgICAgY29uc3QgdmlkZW9UcmFja3MgPSB0aGlzLnN0cmVhbS5nZXRWaWRlb1RyYWNrcygpXG5cbiAgICAgIGF1ZGlvVHJhY2tzLmNvbmNhdCh2aWRlb1RyYWNrcykuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnN0b3AoKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWNvcmRlcikge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5yZWNvcmRlci5hZGRFdmVudExpc3RlbmVyKCdzdG9wJywgcmVzb2x2ZSwgeyBvbmNlOiB0cnVlIH0pXG4gICAgICAgIHRoaXMucmVjb3JkZXIuc3RvcCgpXG5cbiAgICAgICAgaWYgKHRoaXMub3B0cy5zaG93UmVjb3JkaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY29yZGluZ0xlbmd0aFRpbWVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgIHRoaXMucmVjb3JkZXIgPSBudWxsXG4gICAgdGhpcy53ZWJjYW1BY3RpdmUgPSBmYWxzZVxuICAgIHRoaXMuc3RyZWFtID0gbnVsbFxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICByZWNvcmRlZFZpZGVvOiBudWxsLFxuICAgICAgaXNSZWNvcmRpbmc6IGZhbHNlLFxuICAgICAgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCxcbiAgICB9KVxuICB9XG5cbiAgZ2V0VmlkZW9FbGVtZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudXBweS1XZWJjYW0tdmlkZW8nKVxuICB9XG5cbiAgb25lVHdvVGhyZWVTbWlsZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjb3VudCA9IHRoaXMub3B0cy5jb3VudGRvd25cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICBjb25zdCBjb3VudERvd24gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy53ZWJjYW1BY3RpdmUpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGNvdW50RG93bilcbiAgICAgICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIGlzIG5vdCBhY3RpdmUnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyhgJHtjb3VudH0uLi5gLCAnd2FybmluZycsIDgwMClcbiAgICAgICAgICBjb3VudC0tXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChjb3VudERvd24pXG4gICAgICAgICAgdGhpcy51cHB5LmluZm8odGhpcy5pMThuKCdzbWlsZScpLCAnc3VjY2VzcycsIDE1MDApXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIDE1MDApXG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApXG4gICAgfSlcbiAgfVxuXG4gIHRha2VTbmFwc2hvdCAoKSB7XG4gICAgaWYgKHRoaXMuY2FwdHVyZUluUHJvZ3Jlc3MpIHJldHVyblxuXG4gICAgdGhpcy5jYXB0dXJlSW5Qcm9ncmVzcyA9IHRydWVcblxuICAgIHRoaXMub3B0cy5vbkJlZm9yZVNuYXBzaG90KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBlcnIgPT09ICdvYmplY3QnID8gZXJyLm1lc3NhZ2UgOiBlcnJcbiAgICAgIHRoaXMudXBweS5pbmZvKG1lc3NhZ2UsICdlcnJvcicsIDUwMDApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBvbkJlZm9yZVNuYXBzaG90OiAke21lc3NhZ2V9YCkpXG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbWFnZSgpXG4gICAgfSkudGhlbigodGFnRmlsZSkgPT4ge1xuICAgICAgdGhpcy5jYXB0dXJlSW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnVwcHkuYWRkRmlsZSh0YWdGaWxlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIExvZ2dpbmcgdGhlIGVycm9yLCBleGNlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIGdldEltYWdlICgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMuZ2V0VmlkZW9FbGVtZW50KClcbiAgICBpZiAoIXZpZGVvKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdObyB2aWRlbyBlbGVtZW50IGZvdW5kLCBsaWtlbHkgZHVlIHRvIHRoZSBXZWJjYW0gdGFiIGJlaW5nIGNsb3NlZC4nKSlcbiAgICB9XG5cbiAgICBjb25zdCB3aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGhcbiAgICBjb25zdCBoZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodFxuXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApXG5cbiAgICBjb25zdCB7IHJlc3RyaWN0aW9ucyB9ID0gdGhpcy51cHB5Lm9wdHNcbiAgICBsZXQgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSBbXVxuICAgIGlmICh0aGlzLm9wdHMucHJlZmVycmVkSW1hZ2VNaW1lVHlwZSkge1xuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSBbdGhpcy5vcHRzLnByZWZlcnJlZEltYWdlTWltZVR5cGVdXG4gICAgfSBlbHNlIGlmIChyZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcykge1xuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSByZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcy5tYXAodG9NaW1lVHlwZSkuZmlsdGVyKGlzSW1hZ2VNaW1lVHlwZSlcbiAgICB9XG5cbiAgICBjb25zdCBtaW1lVHlwZSA9IHByZWZlcnJlZEltYWdlTWltZVR5cGVzWzBdIHx8ICdpbWFnZS9qcGVnJ1xuICAgIGNvbnN0IGV4dCA9IGdldEZpbGVUeXBlRXh0ZW5zaW9uKG1pbWVUeXBlKSB8fCAnanBnJ1xuICAgIGNvbnN0IG5hbWUgPSBgY2FtLSR7RGF0ZS5ub3coKX0uJHtleHR9YFxuXG4gICAgcmV0dXJuIGNhbnZhc1RvQmxvYihjYW52YXMsIG1pbWVUeXBlKS50aGVuKChibG9iKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRhdGE6IG5ldyBCbG9iKFtibG9iXSwgeyB0eXBlOiBtaW1lVHlwZSB9KSxcbiAgICAgICAgdHlwZTogbWltZVR5cGUsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldFZpZGVvICgpIHtcbiAgICAvLyBTb21ldGltZXMgaW4gaU9TIFNhZmFyaSwgQmxvYnMgKGVzcGVjaWFsbHkgdGhlIGZpcnN0IEJsb2IgaW4gdGhlIHJlY29yZGluZ0NodW5rcyBBcnJheSlcbiAgICAvLyBoYXZlIGVtcHR5ICd0eXBlJyBhdHRyaWJ1dGVzIChlLmcuICcnKSBzbyB3ZSBuZWVkIHRvIGZpbmQgYSBCbG9iIHRoYXQgaGFzIGEgZGVmaW5lZCAndHlwZSdcbiAgICAvLyBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IE1JTUUgdHlwZS5cbiAgICBjb25zdCBtaW1lVHlwZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzLmZpbmQoYmxvYiA9PiBibG9iLnR5cGU/Lmxlbmd0aCA+IDApLnR5cGVcblxuICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBnZXRGaWxlVHlwZUV4dGVuc2lvbihtaW1lVHlwZSlcblxuICAgIGlmICghZmlsZUV4dGVuc2lvbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IHJldHJpZXZlIHJlY29yZGluZzogVW5zdXBwb3J0ZWQgbWVkaWEgdHlwZSBcIiR7bWltZVR5cGV9XCJgKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gYHdlYmNhbS0ke0RhdGUubm93KCl9LiR7ZmlsZUV4dGVuc2lvbn1gXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKHRoaXMucmVjb3JkaW5nQ2h1bmtzLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gICAgY29uc3QgZmlsZSA9IHtcbiAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgIG5hbWUsXG4gICAgICBkYXRhOiBuZXcgQmxvYihbYmxvYl0sIHsgdHlwZTogbWltZVR5cGUgfSksXG4gICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUpXG4gIH1cblxuICBmb2N1cyAoKSB7XG4gICAgaWYgKCF0aGlzLm9wdHMuY291bnRkb3duKSByZXR1cm5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBweS5pbmZvKHRoaXMuaTE4bignc21pbGUnKSwgJ3N1Y2Nlc3MnLCAxNTAwKVxuICAgIH0sIDEwMDApXG4gIH1cblxuICBjaGFuZ2VWaWRlb1NvdXJjZSAoZGV2aWNlSWQpIHtcbiAgICB0aGlzLnN0b3AoKVxuICAgIHRoaXMuc3RhcnQoeyBkZXZpY2VJZCB9KVxuICB9XG5cbiAgdXBkYXRlVmlkZW9Tb3VyY2VzICgpIHtcbiAgICB0aGlzLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihkZXZpY2VzID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICB2aWRlb1NvdXJjZXM6IGRldmljZXMuZmlsdGVyKChkZXZpY2UpID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpLFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBpZiAoIXRoaXMud2ViY2FtQWN0aXZlKSB7XG4gICAgICB0aGlzLnN0YXJ0KClcbiAgICB9XG5cbiAgICBjb25zdCB3ZWJjYW1TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgaWYgKCF3ZWJjYW1TdGF0ZS5jYW1lcmFSZWFkeSB8fCAhd2ViY2FtU3RhdGUuaGFzQ2FtZXJhKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UGVybWlzc2lvbnNTY3JlZW5cbiAgICAgICAgICBpY29uPXtDYW1lcmFJY29ufVxuICAgICAgICAgIGkxOG49e3RoaXMuaTE4bn1cbiAgICAgICAgICBoYXNDYW1lcmE9e3dlYmNhbVN0YXRlLmhhc0NhbWVyYX1cbiAgICAgICAgLz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENhbWVyYVNjcmVlblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LXByb3BzLW5vLXNwcmVhZGluZ1xuICAgICAgICB7Li4ud2ViY2FtU3RhdGV9XG4gICAgICAgIG9uQ2hhbmdlVmlkZW9Tb3VyY2U9e3RoaXMuY2hhbmdlVmlkZW9Tb3VyY2V9XG4gICAgICAgIG9uU25hcHNob3Q9e3RoaXMudGFrZVNuYXBzaG90fVxuICAgICAgICBvblN0YXJ0UmVjb3JkaW5nPXt0aGlzLnN0YXJ0UmVjb3JkaW5nfVxuICAgICAgICBvblN0b3BSZWNvcmRpbmc9e3RoaXMuc3RvcFJlY29yZGluZ31cbiAgICAgICAgb25EaXNjYXJkUmVjb3JkZWRWaWRlbz17dGhpcy5kaXNjYXJkUmVjb3JkZWRWaWRlb31cbiAgICAgICAgb25TdWJtaXQ9e3RoaXMuc3VibWl0fVxuICAgICAgICBvbkZvY3VzPXt0aGlzLmZvY3VzfVxuICAgICAgICBvblN0b3A9e3RoaXMuc3RvcH1cbiAgICAgICAgaTE4bj17dGhpcy5pMThufVxuICAgICAgICBtb2Rlcz17dGhpcy5vcHRzLm1vZGVzfVxuICAgICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoPXt0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aH1cbiAgICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd249e3RoaXMub3B0cy5zaG93VmlkZW9Tb3VyY2VEcm9wZG93bn1cbiAgICAgICAgc3VwcG9ydHNSZWNvcmRpbmc9e3N1cHBvcnRzTWVkaWFSZWNvcmRlcigpfVxuICAgICAgICByZWNvcmRpbmc9e3dlYmNhbVN0YXRlLmlzUmVjb3JkaW5nfVxuICAgICAgICBtaXJyb3I9e3RoaXMuI2VuYWJsZU1pcnJvcn1cbiAgICAgICAgc3JjPXt0aGlzLnN0cmVhbX1cbiAgICAgIC8+XG4gICAgKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBjYW1lcmFSZWFkeTogZmFsc2UsXG4gICAgICByZWNvcmRpbmdMZW5ndGhTZWNvbmRzOiAwLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWVkaWFEZXZpY2VzKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZpZGVvU291cmNlcygpXG5cbiAgICAgIHRoaXMubWVkaWFEZXZpY2VzLm9uZGV2aWNlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZGVvU291cmNlcygpXG5cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgbGV0IHJlc3RhcnRTdHJlYW0gPSB0cnVlXG5cbiAgICAgICAgICBjb25zdCB7IHZpZGVvU291cmNlcywgY3VycmVudERldmljZUlkIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcblxuICAgICAgICAgIHZpZGVvU291cmNlcy5mb3JFYWNoKCh2aWRlb1NvdXJjZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREZXZpY2VJZCA9PT0gdmlkZW9Tb3VyY2UuZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgcmVzdGFydFN0cmVhbSA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChyZXN0YXJ0U3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgICAgICAgdGhpcy5zdGFydCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnN0b3AoKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvblVubW91bnQgKCkge1xuICAgIHRoaXMuc3RvcCgpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdzOiB7XG4gICAgcGx1Z2luTmFtZUNhbWVyYTogJ0NhbWVyYScsXG4gICAgbm9DYW1lcmFUaXRsZTogJ0NhbWVyYSBOb3QgQXZhaWxhYmxlJyxcbiAgICBub0NhbWVyYURlc2NyaXB0aW9uOiAnSW4gb3JkZXIgdG8gdGFrZSBwaWN0dXJlcyBvciByZWNvcmQgdmlkZW8sIHBsZWFzZSBjb25uZWN0IGEgY2FtZXJhIGRldmljZScsXG4gICAgcmVjb3JkaW5nU3RvcHBlZE1heFNpemU6ICdSZWNvcmRpbmcgc3RvcHBlZCBiZWNhdXNlIHRoZSBmaWxlIHNpemUgaXMgYWJvdXQgdG8gZXhjZWVkIHRoZSBsaW1pdCcsXG4gICAgc3VibWl0UmVjb3JkZWRGaWxlOiAnU3VibWl0IHJlY29yZGVkIGZpbGUnLFxuICAgIGRpc2NhcmRSZWNvcmRlZEZpbGU6ICdEaXNjYXJkIHJlY29yZGVkIGZpbGUnLFxuICAgIC8vIFNob3duIGJlZm9yZSBhIHBpY3R1cmUgaXMgdGFrZW4gd2hlbiB0aGUgYGNvdW50ZG93bmAgb3B0aW9uIGlzIHNldC5cbiAgICBzbWlsZTogJ1NtaWxlIScsXG4gICAgLy8gVXNlZCBhcyB0aGUgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCB0YWtlcyBhIHBpY3R1cmUuXG4gICAgLy8gVGhpcyBpcyBub3QgdmlzaWJseSByZW5kZXJlZCBidXQgaXMgcGlja2VkIHVwIGJ5IHNjcmVlbiByZWFkZXJzLlxuICAgIHRha2VQaWN0dXJlOiAnVGFrZSBhIHBpY3R1cmUnLFxuICAgIC8vIFVzZWQgYXMgdGhlIGxhYmVsIGZvciB0aGUgYnV0dG9uIHRoYXQgc3RhcnRzIGEgdmlkZW8gcmVjb3JkaW5nLlxuICAgIC8vIFRoaXMgaXMgbm90IHZpc2libHkgcmVuZGVyZWQgYnV0IGlzIHBpY2tlZCB1cCBieSBzY3JlZW4gcmVhZGVycy5cbiAgICBzdGFydFJlY29yZGluZzogJ0JlZ2luIHZpZGVvIHJlY29yZGluZycsXG4gICAgLy8gVXNlZCBhcyB0aGUgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBzdG9wcyBhIHZpZGVvIHJlY29yZGluZy5cbiAgICAvLyBUaGlzIGlzIG5vdCB2aXNpYmx5IHJlbmRlcmVkIGJ1dCBpcyBwaWNrZWQgdXAgYnkgc2NyZWVuIHJlYWRlcnMuXG4gICAgc3RvcFJlY29yZGluZzogJ1N0b3AgdmlkZW8gcmVjb3JkaW5nJyxcbiAgICAvLyBVc2VkIGFzIHRoZSBsYWJlbCBmb3IgdGhlIHJlY29yZGluZyBsZW5ndGggY291bnRlci4gU2VlIHRoZSBzaG93UmVjb3JkaW5nTGVuZ3RoIG9wdGlvbi5cbiAgICAvLyBUaGlzIGlzIG5vdCB2aXNpYmx5IHJlbmRlcmVkIGJ1dCBpcyBwaWNrZWQgdXAgYnkgc2NyZWVuIHJlYWRlcnMuXG4gICAgcmVjb3JkaW5nTGVuZ3RoOiAnUmVjb3JkaW5nIGxlbmd0aCAle3JlY29yZGluZ19sZW5ndGh9JyxcbiAgICAvLyBUaXRsZSBvbiB0aGUg4oCcYWxsb3cgYWNjZXNz4oCdIHNjcmVlblxuICAgIGFsbG93QWNjZXNzVGl0bGU6ICdQbGVhc2UgYWxsb3cgYWNjZXNzIHRvIHlvdXIgY2FtZXJhJyxcbiAgICAvLyBEZXNjcmlwdGlvbiBvbiB0aGUg4oCcYWxsb3cgYWNjZXNz4oCdIHNjcmVlblxuICAgIGFsbG93QWNjZXNzRGVzY3JpcHRpb246ICdJbiBvcmRlciB0byB0YWtlIHBpY3R1cmVzIG9yIHJlY29yZCB2aWRlbyB3aXRoIHlvdXIgY2FtZXJhLCBwbGVhc2UgYWxsb3cgY2FtZXJhIGFjY2VzcyBmb3IgdGhpcyBzaXRlLicsXG4gIH0sXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1cHBvcnRzTWVkaWFSZWNvcmRlciAoKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBhdC9jb21wYXQgKi9cbiAgcmV0dXJuIHR5cGVvZiBNZWRpYVJlY29yZGVyID09PSAnZnVuY3Rpb24nICYmICEhTWVkaWFSZWNvcmRlci5wcm90b3R5cGVcbiAgICAmJiB0eXBlb2YgTWVkaWFSZWNvcmRlci5wcm90b3R5cGUuc3RhcnQgPT09ICdmdW5jdGlvbidcbiAgLyogZXNsaW50LWVuYWJsZSBjb21wYXQvY29tcGF0ICovXG59XG4iLCJjb25zdCB7IFVJUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlclZpZXdzIH0gPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IGxvY2FsZSA9IHJlcXVpcmUoJy4vbG9jYWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBab29tIGV4dGVuZHMgVUlQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnWm9vbSdcbiAgICBQcm92aWRlci5pbml0UGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnWm9vbSdcbiAgICB0aGlzLmljb24gPSAoKSA9PiAoXG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIGZpbGw9XCIjMEU3MUVCXCIgLz5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cGF0aCBmaWxsPVwiI2ZmZlwiIGQ9XCJNMjksMzFIMTRjLTEuNjU3LDAtMy0xLjM0My0zLTNWMTdoMTVjMS42NTcsMCwzLDEuMzQzLDMsM1YzMXpcIiBzdHlsZT17eyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTVweCwgLTVweCkgc2NhbGUoMC45KScgfX0gLz5cbiAgICAgICAgICA8cG9seWdvbiBmaWxsPVwiI2ZmZlwiIHBvaW50cz1cIjM3LDMxIDMxLDI3IDMxLDIxIDM3LDE3XCIgc3R5bGU9e3sgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01cHgsIC01cHgpIHNjYWxlKDAuOSknIH19IC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ3pvb20nLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWQsXG4gICAgfSlcblxuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGxvY2FsZVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gICAgdGhpcy50aXRsZSA9IHRoaXMuaTE4bigncGx1Z2luTmFtZVpvb20nKVxuXG4gICAgdGhpcy5vbkZpcnN0UmVuZGVyID0gdGhpcy5vbkZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldyA9IG5ldyBQcm92aWRlclZpZXdzKHRoaXMsIHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcudGVhckRvd24oKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvbkZpcnN0UmVuZGVyICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wcm92aWRlci5mZXRjaFByZUF1dGhUb2tlbigpLFxuICAgICAgdGhpcy52aWV3LmdldEZvbGRlcigpLFxuICAgIF0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdzOiB7XG4gICAgcGx1Z2luTmFtZVpvb206ICdab29tJyxcbiAgfSxcbn1cbiIsImNvbnN0IFVwcHkgPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IERhc2hib2FyZCA9IHJlcXVpcmUoJ0B1cHB5L2Rhc2hib2FyZCcpXG5jb25zdCBHb29nbGVEcml2ZSA9IHJlcXVpcmUoJ0B1cHB5L2dvb2dsZS1kcml2ZScpXG5jb25zdCBEcm9wYm94ID0gcmVxdWlyZSgnQHVwcHkvZHJvcGJveCcpXG5jb25zdCBJbnN0YWdyYW0gPSByZXF1aXJlKCdAdXBweS9pbnN0YWdyYW0nKVxuY29uc3QgRmFjZWJvb2sgPSByZXF1aXJlKCdAdXBweS9mYWNlYm9vaycpXG5jb25zdCBPbmVEcml2ZSA9IHJlcXVpcmUoJ0B1cHB5L29uZWRyaXZlJylcbmNvbnN0IFpvb20gPSByZXF1aXJlKCdAdXBweS96b29tJylcbi8vIGNvbnN0IEJveCA9IHJlcXVpcmUoJ0B1cHB5L2JveCcpXG5jb25zdCBJbWFnZUVkaXRvciA9IHJlcXVpcmUoJ0B1cHB5L2ltYWdlLWVkaXRvcicpXG5jb25zdCBVcmwgPSByZXF1aXJlKCdAdXBweS91cmwnKVxuY29uc3QgV2ViY2FtID0gcmVxdWlyZSgnQHVwcHkvd2ViY2FtJylcbmNvbnN0IFNjcmVlbkNhcHR1cmUgPSByZXF1aXJlKCdAdXBweS9zY3JlZW4tY2FwdHVyZScpXG5jb25zdCBUdXMgPSByZXF1aXJlKCdAdXBweS90dXMnKVxuY29uc3QgRHJvcFRhcmdldCA9IHJlcXVpcmUoJ0B1cHB5L2Ryb3AtdGFyZ2V0JylcbmNvbnN0IEdvbGRlblJldHJpZXZlciA9IHJlcXVpcmUoJ0B1cHB5L2dvbGRlbi1yZXRyaWV2ZXInKVxuY29uc3QgbG9jYWxlTGlzdCA9IHJlcXVpcmUoJy4uL2xvY2FsZV9saXN0Lmpzb24nKVxuXG5jb25zdCBDT01QQU5JT04gPSByZXF1aXJlKCcuLi9lbnYnKVxuXG5jb25zdCBSVExfTE9DQUxFUyA9IFsnYXJfU0EnLCAnZmFfSVInLCAnaGVfSUwnXVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5VcHB5ID09PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuVXBweSA9IHtcbiAgICBsb2NhbGVzOiB7fSxcbiAgfVxufVxuXG5mdW5jdGlvbiB1cHB5SW5pdCAoKSB7XG4gIGlmICh3aW5kb3cudXBweSkge1xuICAgIHdpbmRvdy51cHB5LmNsb3NlKClcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSB3aW5kb3cudXBweU9wdGlvbnNcblxuICBjb25zdCB1cHB5ID0gbmV3IFVwcHkoe1xuICAgIGxvZ2dlcjogVXBweS5kZWJ1Z0xvZ2dlcixcbiAgfSlcblxuICB1cHB5LnVzZShUdXMsIHsgZW5kcG9pbnQ6ICdodHRwczovL3R1c2QudHVzZGVtby5uZXQvZmlsZXMvJyB9KVxuXG4gIHVwcHkub24oJ2NvbXBsZXRlJywgcmVzdWx0ID0+IHtcbiAgICBjb25zb2xlLmxvZygnc3VjY2Vzc2Z1bCBmaWxlczonKVxuICAgIGNvbnNvbGUubG9nKHJlc3VsdC5zdWNjZXNzZnVsKVxuICAgIGNvbnNvbGUubG9nKCdmYWlsZWQgZmlsZXM6JylcbiAgICBjb25zb2xlLmxvZyhyZXN1bHQuZmFpbGVkKVxuICB9KVxuXG4gIHVwcHkudXNlKERhc2hib2FyZCwge1xuICAgIHRyaWdnZXI6ICcuVXBweU1vZGFsT3BlbmVyQnRuJyxcbiAgICB0YXJnZXQ6IG9wdHMuRGFzaGJvYXJkSW5saW5lID8gJy5EYXNoYm9hcmRDb250YWluZXInIDogJ2JvZHknLFxuICAgIGlubGluZTogb3B0cy5EYXNoYm9hcmRJbmxpbmUsXG4gICAgaGVpZ2h0OiA0NzAsXG4gICAgc2hvd1Byb2dyZXNzRGV0YWlsczogdHJ1ZSxcbiAgICBtZXRhRmllbGRzOiBbXG4gICAgICB7IGlkOiAnbmFtZScsIG5hbWU6ICdOYW1lJywgcGxhY2Vob2xkZXI6ICdmaWxlIG5hbWUnIH0sXG4gICAgICB7IGlkOiAnY2FwdGlvbicsIG5hbWU6ICdDYXB0aW9uJywgcGxhY2Vob2xkZXI6ICdhZGQgZGVzY3JpcHRpb24nIH0sXG4gICAgXSxcbiAgfSlcblxuICB3aW5kb3cudXBweSA9IHVwcHlcbn1cblxuZnVuY3Rpb24gdXBweVNldE9wdGlvbnMgKCkge1xuICBjb25zdCBvcHRzID0gd2luZG93LnVwcHlPcHRpb25zXG5cbiAgY29uc3QgZGVmYXVsdE51bGxSZXN0cmljdGlvbnMgPSB7XG4gICAgbWF4RmlsZVNpemU6IG51bGwsXG4gICAgbWluRmlsZVNpemU6IG51bGwsXG4gICAgbWF4TnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICBtaW5OdW1iZXJPZkZpbGVzOiBudWxsLFxuICAgIGFsbG93ZWRGaWxlVHlwZXM6IG51bGwsXG4gIH1cblxuICBjb25zdCByZXN0cmljdGlvbnMgPSB7XG4gICAgbWF4RmlsZVNpemU6IDEwMDAwMDAsXG4gICAgbWF4TnVtYmVyT2ZGaWxlczogMyxcbiAgICBtaW5OdW1iZXJPZkZpbGVzOiAyLFxuICAgIGFsbG93ZWRGaWxlVHlwZXM6IFsnaW1hZ2UvKicsICd2aWRlby8qJ10sXG4gICAgcmVxdWlyZWRNZXRhRmllbGRzOiBbJ2NhcHRpb24nXSxcbiAgfVxuXG4gIHdpbmRvdy51cHB5LnNldE9wdGlvbnMoe1xuICAgIGF1dG9Qcm9jZWVkOiBvcHRzLmF1dG9Qcm9jZWVkLFxuICAgIHJlc3RyaWN0aW9uczogb3B0cy5yZXN0cmljdGlvbnMgPyByZXN0cmljdGlvbnMgOiBkZWZhdWx0TnVsbFJlc3RyaWN0aW9ucyxcbiAgfSlcblxuICB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0Rhc2hib2FyZCcpLnNldE9wdGlvbnMoe1xuICAgIG5vdGU6IG9wdHMucmVzdHJpY3Rpb25zID8gJ0ltYWdlcyBhbmQgdmlkZW8gb25seSwgMuKAkzMgZmlsZXMsIHVwIHRvIDEgTUInIDogJycsXG4gICAgdGhlbWU6IG9wdHMuZGFya01vZGUgPyAnZGFyaycgOiAnbGlnaHQnLFxuICAgIGRpc2FibGVkOiBvcHRzLmRpc2FibGVkLFxuICB9KVxuXG4gIGNvbnN0IGdvb2dsZURyaXZlSW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0dvb2dsZURyaXZlJylcbiAgaWYgKG9wdHMuR29vZ2xlRHJpdmUgJiYgIWdvb2dsZURyaXZlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoR29vZ2xlRHJpdmUsIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogQ09NUEFOSU9OIH0pXG4gIH1cbiAgaWYgKCFvcHRzLkdvb2dsZURyaXZlICYmIGdvb2dsZURyaXZlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oZ29vZ2xlRHJpdmVJbnN0YW5jZSlcbiAgfVxuXG4gIGNvbnN0IGRyb3Bib3hJbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignRHJvcGJveCcpXG4gIGlmIChvcHRzLkRyb3Bib3ggJiYgIWRyb3Bib3hJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShEcm9wYm94LCB7IHRhcmdldDogRGFzaGJvYXJkLCBjb21wYW5pb25Vcmw6IENPTVBBTklPTiB9KVxuICB9XG4gIGlmICghb3B0cy5Ecm9wYm94ICYmIGRyb3Bib3hJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnJlbW92ZVBsdWdpbihkcm9wYm94SW5zdGFuY2UpXG4gIH1cblxuICBjb25zdCBpbnN0YWdyYW1JbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignSW5zdGFncmFtJylcbiAgaWYgKG9wdHMuSW5zdGFncmFtICYmICFpbnN0YWdyYW1JbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShJbnN0YWdyYW0sIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogQ09NUEFOSU9OIH0pXG4gIH1cbiAgaWYgKCFvcHRzLkluc3RhZ3JhbSAmJiBpbnN0YWdyYW1JbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnJlbW92ZVBsdWdpbihpbnN0YWdyYW1JbnN0YW5jZSlcbiAgfVxuXG4gIGNvbnN0IHVybEluc3RhbmNlID0gd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdVcmwnKVxuICBpZiAob3B0cy5VcmwgJiYgIXVybEluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkudXNlKFVybCwgeyB0YXJnZXQ6IERhc2hib2FyZCwgY29tcGFuaW9uVXJsOiBDT01QQU5JT04gfSlcbiAgfVxuICBpZiAoIW9wdHMuVXJsICYmIHVybEluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKHVybEluc3RhbmNlKVxuICB9XG5cbiAgY29uc3QgZmFjZWJvb2tJbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignRmFjZWJvb2snKVxuICBpZiAob3B0cy5GYWNlYm9vayAmJiAhZmFjZWJvb2tJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShGYWNlYm9vaywgeyB0YXJnZXQ6IERhc2hib2FyZCwgY29tcGFuaW9uVXJsOiBDT01QQU5JT04gfSlcbiAgfVxuICBpZiAoIW9wdHMuRmFjZWJvb2sgJiYgZmFjZWJvb2tJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnJlbW92ZVBsdWdpbihmYWNlYm9va0luc3RhbmNlKVxuICB9XG5cbiAgY29uc3Qgb25lRHJpdmVJbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignT25lRHJpdmUnKVxuICBpZiAob3B0cy5PbmVEcml2ZSAmJiAhb25lRHJpdmVJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShPbmVEcml2ZSwgeyB0YXJnZXQ6IERhc2hib2FyZCwgY29tcGFuaW9uVXJsOiBDT01QQU5JT04gfSlcbiAgfVxuICBpZiAoIW9wdHMuT25lRHJpdmUgJiYgb25lRHJpdmVJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnJlbW92ZVBsdWdpbihvbmVEcml2ZUluc3RhbmNlKVxuICB9XG5cbiAgY29uc3Qgem9vbUluc3RhbmNlID0gd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdab29tJylcbiAgaWYgKG9wdHMuWm9vbSAmJiAhem9vbUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkudXNlKFpvb20sIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogJ2h0dHBzOi8vaW50ZW5zZS1tZWFkb3ctNjE4MTMuaGVyb2t1YXBwLmNvbS8nIH0pXG4gIH1cbiAgaWYgKCFvcHRzLlpvb20gJiYgem9vbUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKHpvb21JbnN0YW5jZSlcbiAgfVxuXG4gIC8vICAgY29uc3QgYm94SW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0JveCcpXG4gIC8vICAgaWYgKG9wdHMuQm94ICYmICFib3hJbnN0YW5jZSkge1xuICAvLyAgICAgd2luZG93LnVwcHkudXNlKEJveCwgeyB0YXJnZXQ6IERhc2hib2FyZCwgY29tcGFuaW9uVXJsOiBDT01QQU5JT04gfSlcbiAgLy8gICB9XG4gIC8vICAgaWYgKCFvcHRzLkJveCAmJiBib3hJbnN0YW5jZSkge1xuICAvLyAgICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKGJveEluc3RhbmNlKVxuICAvLyAgIH1cblxuICBjb25zdCB3ZWJjYW1JbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignV2ViY2FtJylcbiAgaWYgKG9wdHMuV2ViY2FtICYmICF3ZWJjYW1JbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShXZWJjYW0sIHtcbiAgICAgIHRhcmdldDogRGFzaGJvYXJkLFxuICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd246IHRydWUsXG4gICAgfSlcbiAgfVxuICBpZiAoIW9wdHMuV2ViY2FtICYmIHdlYmNhbUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKHdlYmNhbUluc3RhbmNlKVxuICB9XG5cbiAgY29uc3Qgc2NyZWVuQ2FwdHVyZUluc3RhbmNlID0gd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdTY3JlZW5DYXB0dXJlJylcbiAgaWYgKG9wdHMuU2NyZWVuQ2FwdHVyZSAmJiAhc2NyZWVuQ2FwdHVyZUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkudXNlKFNjcmVlbkNhcHR1cmUsIHsgdGFyZ2V0OiBEYXNoYm9hcmQgfSlcbiAgfVxuICBpZiAoIW9wdHMuU2NyZWVuQ2FwdHVyZSAmJiBzY3JlZW5DYXB0dXJlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oc2NyZWVuQ2FwdHVyZUluc3RhbmNlKVxuICB9XG5cbiAgY29uc3QgaW1hZ2VFZGl0b3JJbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignSW1hZ2VFZGl0b3InKVxuICBpZiAob3B0cy5pbWFnZUVkaXRvciAmJiAhaW1hZ2VFZGl0b3JJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShJbWFnZUVkaXRvciwgeyB0YXJnZXQ6IERhc2hib2FyZCB9KVxuICB9XG4gIGlmICghb3B0cy5pbWFnZUVkaXRvciAmJiBpbWFnZUVkaXRvckluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKGltYWdlRWRpdG9ySW5zdGFuY2UpXG4gIH1cblxuICBjb25zdCBkcm9wVGFyZ2V0SW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0Ryb3BUYXJnZXQnKVxuICBpZiAob3B0cy5Ecm9wVGFyZ2V0ICYmICFkcm9wVGFyZ2V0SW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoRHJvcFRhcmdldCwgeyB0YXJnZXQ6IGRvY3VtZW50LmJvZHkgfSlcbiAgfVxuICBpZiAoIW9wdHMuRHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0SW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oZHJvcFRhcmdldEluc3RhbmNlKVxuICB9XG5cbiAgY29uc3QgZ29sZGVuUmV0cmlldmVySW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0dvbGRlblJldHJpZXZlcicpXG4gIGlmIChvcHRzLkdvbGRlblJldHJpZXZlciAmJiAhZ29sZGVuUmV0cmlldmVySW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoR29sZGVuUmV0cmlldmVyKVxuICB9XG4gIGlmICghb3B0cy5Hb2xkZW5SZXRyaWV2ZXIgJiYgZ29sZGVuUmV0cmlldmVySW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oZ29sZGVuUmV0cmlldmVySW5zdGFuY2UpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbkxvY2FsZUF2YWlsYWJsZSAobG9jYWxlTmFtZSwgY2FsbGJhY2spIHtcbiAgY29uc3QgaW50ZXJ2YWwgPSAxMDAgLy8gbXNcbiAgY29uc3QgbG9vcCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICBpZiAod2luZG93LlVwcHkgJiYgd2luZG93LlVwcHkubG9jYWxlcyAmJiB3aW5kb3cuVXBweS5sb2NhbGVzW2xvY2FsZU5hbWVdKSB7XG4gICAgICBjbGVhckludGVydmFsKGxvb3ApXG4gICAgICBjYWxsYmFjayh3aW5kb3cuVXBweS5sb2NhbGVzW2xvY2FsZU5hbWVdKVxuICAgIH1cbiAgfSwgaW50ZXJ2YWwpXG59XG5cbmZ1bmN0aW9uIGxvYWRMb2NhbGVGcm9tQ0ROIChsb2NhbGVOYW1lKSB7XG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gIGNvbnN0IGpzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAganMudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gIGpzLnNyYyA9IGBodHRwczovL3JlbGVhc2VzLnRyYW5zbG9hZGl0LmNvbS91cHB5L2xvY2FsZXMvdjIuMC4zLyR7bG9jYWxlTmFtZX0ubWluLmpzYFxuXG4gIGhlYWQuYXBwZW5kQ2hpbGQoanMpXG59XG5cbmZ1bmN0aW9uIHNldExvY2FsZSAobG9jYWxlTmFtZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdy5VcHB5LmxvY2FsZXNbbG9jYWxlTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9hZExvY2FsZUZyb21DRE4obG9jYWxlTmFtZSlcbiAgfVxuICB3aGVuTG9jYWxlQXZhaWxhYmxlKGxvY2FsZU5hbWUsIChsb2NhbGVPYmopID0+IHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBSVExfTE9DQUxFUy5pbmRleE9mKGxvY2FsZU5hbWUpICE9PSAtMVxuICAgICAgPyAncnRsJ1xuICAgICAgOiAnbHRyJ1xuXG4gICAgd2luZG93LnVwcHkuc2V0T3B0aW9ucyh7XG4gICAgICBsb2NhbGU6IGxvY2FsZU9iaixcbiAgICB9KVxuXG4gICAgd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdEYXNoYm9hcmQnKS5zZXRPcHRpb25zKHtcbiAgICAgIGRpcmVjdGlvbixcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBwb3B1bGF0ZUxvY2FsZVNlbGVjdCAoKSB7XG4gIGNvbnN0IGxvY2FsZVNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2NhbGVMaXN0JylcblxuICBPYmplY3Qua2V5cyhsb2NhbGVMaXN0KS5mb3JFYWNoKGxvY2FsZU5hbWUgPT4ge1xuICAgIGlmIChsb2NhbGVOYW1lID09PSAnZW5fVVMnKSByZXR1cm5cbiAgICBsb2NhbGVTZWxlY3QuaW5uZXJIVE1MICs9IGA8b3B0aW9uIHZhbHVlPVwiJHtsb2NhbGVOYW1lfVwiPiR7bG9jYWxlTGlzdFtsb2NhbGVOYW1lXX0g4oCUICgke2xvY2FsZU5hbWV9KTwvb3B0aW9uPmBcbiAgfSlcblxuICBsb2NhbGVTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgbG9jYWxlTmFtZSA9IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgIHNldExvY2FsZShsb2NhbGVOYW1lKVxuICB9KVxufVxuXG53aW5kb3cudXBweVNldE9wdGlvbnMgPSB1cHB5U2V0T3B0aW9uc1xud2luZG93LnVwcHlJbml0ID0gdXBweUluaXRcbndpbmRvdy51cHB5U2V0TG9jYWxlID0gc2V0TG9jYWxlXG5cbnBvcHVsYXRlTG9jYWxlU2VsZWN0KClcbnVwcHlJbml0KClcbnVwcHlTZXRPcHRpb25zKClcbiIsImxldCBjb21wYW5pb25FbmRwb2ludCA9ICdodHRwOi8vbG9jYWxob3N0OjMwMjAnXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbmlmIChsb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ3VwcHkuaW8nIHx8IC8tLXVwcHlcXC5uZXRsaWZ5XFwuYXBwJC8udGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcbiAgY29tcGFuaW9uRW5kcG9pbnQgPSAnLy9jb21wYW5pb24udXBweS5pbydcbn1cblxuY29uc3QgQ09NUEFOSU9OID0gY29tcGFuaW9uRW5kcG9pbnRcbm1vZHVsZS5leHBvcnRzID0gQ09NUEFOSU9OXG4iLCJtb2R1bGUuZXhwb3J0cz17XCJhcl9TQVwiOlwiQXJhYmljIChTYXVkaSBBcmFiaWEpXCIsXCJiZ19CR1wiOlwiQnVsZ2FyaWFuIChCdWxnYXJpYSlcIixcImNzX0NaXCI6XCJDemVjaCAoQ3plY2hpYSlcIixcImRhX0RLXCI6XCJEYW5pc2ggKERlbm1hcmspXCIsXCJkZV9ERVwiOlwiR2VybWFuIChHZXJtYW55KVwiLFwiZWxfR1JcIjpcIkdyZWVrIChHcmVlY2UpXCIsXCJlbl9VU1wiOlwiRW5nbGlzaCAoVW5pdGVkIFN0YXRlcylcIixcImVzX0VTXCI6XCJTcGFuaXNoIChTcGFpbilcIixcImZhX0lSXCI6XCJQZXJzaWFuIChJcmFuKVwiLFwiZmlfRklcIjpcIkZpbm5pc2ggKEZpbmxhbmQpXCIsXCJmcl9GUlwiOlwiRnJlbmNoIChGcmFuY2UpXCIsXCJnbF9FU1wiOlwiR2FsaWNpYW4gKFNwYWluKVwiLFwiaGVfSUxcIjpcIkhlYnJldyAoSXNyYWVsKVwiLFwiaHJfSFJcIjpcIkNyb2F0aWFuIChDcm9hdGlhKVwiLFwiaHVfSFVcIjpcIkh1bmdhcmlhbiAoSHVuZ2FyeSlcIixcImlkX0lEXCI6XCJJbmRvbmVzaWFuIChJbmRvbmVzaWEpXCIsXCJpc19JU1wiOlwiSWNlbGFuZGljIChJY2VsYW5kKVwiLFwiaXRfSVRcIjpcIkl0YWxpYW4gKEl0YWx5KVwiLFwiamFfSlBcIjpcIkphcGFuZXNlIChKYXBhbilcIixcImtvX0tSXCI6XCJLb3JlYW4gKFNvdXRoIEtvcmVhKVwiLFwibmJfTk9cIjpcIk5vcndlZ2lhbiBCb2ttw6VsIChOb3J3YXkpXCIsXCJubF9OTFwiOlwiRHV0Y2ggKE5ldGhlcmxhbmRzKVwiLFwicGxfUExcIjpcIlBvbGlzaCAoUG9sYW5kKVwiLFwicHRfQlJcIjpcIlBvcnR1Z3Vlc2UgKEJyYXppbClcIixcInB0X1BUXCI6XCJQb3J0dWd1ZXNlIChQb3J0dWdhbClcIixcInJvX1JPXCI6XCJSb21hbmlhbiAoUm9tYW5pYSlcIixcInJ1X1JVXCI6XCJSdXNzaWFuIChSdXNzaWEpXCIsXCJza19TS1wiOlwiU2xvdmFrIChTbG92YWtpYSlcIixcInNyX1JTX0N5cmlsbGljXCI6XCJTZXJiaWFuIChTZXJiaWEsIEN5cmlsbGljKVwiLFwic3JfUlNfTGF0aW5cIjpcIlNlcmJpYW4gKFNlcmJpYSwgTGF0aW4pXCIsXCJzdl9TRVwiOlwiU3dlZGlzaCAoU3dlZGVuKVwiLFwidGhfVEhcIjpcIlRoYWkgKFRoYWlsYW5kKVwiLFwidHJfVFJcIjpcIlR1cmtpc2ggKFR1cmtleSlcIixcInVrX1VBXCI6XCJVa3JhaW5pYW4gKFVrcmFpbmUpXCIsXCJ2aV9WTlwiOlwiVmlldG5hbWVzZSAoVmlldG5hbSlcIixcInpoX0NOXCI6XCJDaGluZXNlIChDaGluYSlcIixcInpoX1RXXCI6XCJDaGluZXNlIChUYWl3YW4pXCJ9Il19
